import { A as AstroError, O as LiveContentConfigError, P as AstroUserError, o as objectType, j as dateType, Q as numberType, h as arrayType, s as stringType, R as UnknownContentCollectionError, c as createComponent, S as RenderUndefinedEntryError, u as unescapeHTML, r as renderTemplate, T as escape$2, V as renderUniqueStylesheet, W as renderScriptElement, X as createHeadAndContent, a as renderComponent, K as getDefaultExportFromCjs$1, Y as commonjsGlobal$1, Z as unionType, _ as enumType, i as booleanType, $ as instanceOfType, a0 as recordType, a1 as anyType, a2 as literalType, a3 as ZodIssueCode, a4 as custom, a5 as intersectionType, a6 as optionalType, a7 as preprocessType, a8 as cspAlgorithmSchema, a9 as cspHashSchema, aa as allowedDirectivesSchema, ab as tupleType, ac as nullType, ad as functionType, ae as unknownType, af as red, ag as yellow, ah as cyan } from './astro/server_lQeudqkI.mjs';
import fs__default, { readFileSync, promises } from 'node:fs';
import path$b, { resolve as resolve$2, posix, dirname as dirname$1 } from 'node:path';
import process$1 from 'node:process';
import require$$1$1$1, { fileURLToPath as fileURLToPath$1, URL as URL$3, pathToFileURL as pathToFileURL$1 } from 'node:url';
import { format as format$2, promisify as promisify$4, inspect } from 'node:util';
import require$$0$6, { createRequire as createRequire$2, builtinModules } from 'node:module';
import crypto$2 from 'node:crypto';
import require$$0$4 from 'fs';
import require$$2 from 'os';
import require$$0$2$1, { win32, posix as posix$1, isAbsolute, resolve as resolve$3 } from 'path';
import require$$2$1 from 'child_process';
import require$$3 from 'crypto';
import require$$0$3 from 'tty';
import { createRequire as createRequire$1 } from 'module';
import { exec, execFile } from 'node:child_process';
import require$$1$1, { TextEncoder as TextEncoder$1, TextDecoder as TextDecoder$1 } from 'util';
import require$$4$1$1 from 'net';
import require$$0$7 from 'events';
import require$$0$5, { fileURLToPath as fileURLToPath$2 } from 'url';
import require$$1$2 from 'http';
import require$$0$8 from 'stream';
import os from 'node:os';
import { Buffer as Buffer$1 } from 'node:buffer';
import assert$2 from 'node:assert';
import v8$1 from 'node:v8';
import require$$1$3 from 'https';
import require$$4$2 from 'tls';
import zlib$1 from 'zlib';
import require$$0$9 from 'buffer';
import require$$4$3 from 'assert';
import './remark-excerpt_awIMCM0s.mjs';
import require$$0$a from 'readline';
import { h as sanitize_location, I as IGNORABLE_RUNTIME_WARNINGS, i as is_void, N as NAMESPACE_SVG, j as NAMESPACE_MATHML, k as is_reserved, l as is_rune, m as cannot_be_set_statically, n as can_delegate_event, o as is_svg, p as is_content_editable_binding, q as is_state_creation_rune, P as PROPS_IS_BINDABLE, t as PROPS_IS_IMMUTABLE, u as PROPS_IS_RUNES, v as PROPS_IS_UPDATED, w as PROPS_IS_LAZY_INITIAL, x as is_mathml, y as hash, e as escape_html, B as BLOCK_OPEN_ELSE, z as BLOCK_CLOSE, A as BLOCK_OPEN, E as EMPTY_COMMENT, C as is_load_error_element, D as is_boolean_attribute, F as ELEMENT_IS_NAMESPACED, G as ELEMENT_PRESERVE_ATTRIBUTE_CASE, H as ELEMENT_IS_INPUT, J as is_capture_event, K as is_passive_event, L as is_dom_property, M as normalize_attribute, O as EACH_INDEX_REACTIVE, Q as EACH_ITEM_REACTIVE, R as EACH_ITEM_IMMUTABLE, S as EACH_IS_ANIMATED, T as EACH_IS_CONTROLLED, U as TEMPLATE_USE_SVG, V as TEMPLATE_USE_MATHML, W as TEMPLATE_USE_IMPORT_NODE, X as TEMPLATE_FRAGMENT, Y as TRANSITION_GLOBAL, Z as TRANSITION_IN, _ as TRANSITION_OUT } from './_@astro-renderers_DkFg_9vY.mjs';
import fsp from 'node:fs/promises';
import { performance as performance$1 } from 'node:perf_hooks';
import tailwindPlugin from 'tailwindcss';

/**
 * Base64 Encodes an arraybuffer
 * @param {ArrayBuffer} arraybuffer
 * @returns {string}
 */

/**
 * Decodes a base64 string into an arraybuffer
 * @param {string} string
 * @returns {ArrayBuffer}
 */
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);

  for (let i = 0; i < arraybuffer.byteLength; i++) {
    dv.setUint8(i, binaryString.charCodeAt(i));
  }

  return arraybuffer;
}

const KEY_STRING =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/**
 * Substitute for atob since it's deprecated in node.
 * Does not do any input validation.
 *
 * @see https://github.com/jsdom/abab/blob/master/lib/atob.js
 *
 * @param {string} data
 * @returns {string}
 */
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }

  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;

  for (let i = 0; i < data.length; i++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 0xff0000) >> 16);
      output += String.fromCharCode((buffer & 0xff00) >> 8);
      output += String.fromCharCode(buffer & 0xff);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 0xff00) >> 8);
    output += String.fromCharCode(buffer & 0xff);
  }
  return output;
}

const UNDEFINED = -1;
const HOLE = -2;
const NAN = -3;
const POSITIVE_INFINITY = -4;
const NEGATIVE_INFINITY = -5;
const NEGATIVE_ZERO = -6;

/**
 * Revive a value flattened with `devalue.stringify`
 * @param {number | any[]} parsed
 * @param {Record<string, (value: any) => any>} [revivers]
 */
function unflatten(parsed, revivers) {
	if (typeof parsed === 'number') return hydrate(parsed, true);

	if (!Array.isArray(parsed) || parsed.length === 0) {
		throw new Error('Invalid input');
	}

	const values = /** @type {any[]} */ (parsed);

	const hydrated = Array(values.length);

	/**
	 * @param {number} index
	 * @returns {any}
	 */
	function hydrate(index, standalone = false) {
		if (index === UNDEFINED) return undefined;
		if (index === NAN) return NaN;
		if (index === POSITIVE_INFINITY) return Infinity;
		if (index === NEGATIVE_INFINITY) return -Infinity;
		if (index === NEGATIVE_ZERO) return -0;

		if (standalone || typeof index !== 'number') {
			throw new Error(`Invalid input`);
		}

		if (index in hydrated) return hydrated[index];

		const value = values[index];

		if (!value || typeof value !== 'object') {
			hydrated[index] = value;
		} else if (Array.isArray(value)) {
			if (typeof value[0] === 'string') {
				const type = value[0];

				switch (type) {
					case 'Date':
						hydrated[index] = new Date(value[1]);
						break;

					case 'Set':
						const set = new Set();
						hydrated[index] = set;
						for (let i = 1; i < value.length; i += 1) {
							set.add(hydrate(value[i]));
						}
						break;

					case 'Map':
						const map = new Map();
						hydrated[index] = map;
						for (let i = 1; i < value.length; i += 2) {
							map.set(hydrate(value[i]), hydrate(value[i + 1]));
						}
						break;

					case 'RegExp':
						hydrated[index] = new RegExp(value[1], value[2]);
						break;

					case 'Object':
						hydrated[index] = Object(value[1]);
						break;

					case 'BigInt':
						hydrated[index] = BigInt(value[1]);
						break;

					case 'null':
						const obj = Object.create(null);
						hydrated[index] = obj;
						for (let i = 1; i < value.length; i += 2) {
							obj[value[i]] = hydrate(value[i + 1]);
						}
						break;

					case 'Int8Array':
					case 'Uint8Array':
					case 'Uint8ClampedArray':
					case 'Int16Array':
					case 'Uint16Array':
					case 'Int32Array':
					case 'Uint32Array':
					case 'Float32Array':
					case 'Float64Array':
					case 'BigInt64Array':
					case 'BigUint64Array': {
						const TypedArrayConstructor = globalThis[type];
						const typedArray = new TypedArrayConstructor(hydrate(value[1]));

						hydrated[index] =
							value[2] !== undefined
								? typedArray.subarray(value[2], value[3])
								: typedArray;

						break;
					}

					case 'ArrayBuffer': {
						const base64 = value[1];
						const arraybuffer = decode64(base64);
						hydrated[index] = arraybuffer;
						break;
					}

					case 'Temporal.Duration':
					case 'Temporal.Instant':
					case 'Temporal.PlainDate':
					case 'Temporal.PlainTime':
					case 'Temporal.PlainDateTime':
					case 'Temporal.PlainMonthDay':
					case 'Temporal.PlainYearMonth':
					case 'Temporal.ZonedDateTime': {
						const temporalName = type.slice(9);
						// @ts-expect-error TS doesn't know about Temporal yet
						hydrated[index] = Temporal[temporalName].from(value[1]);
						break;
					}

					case 'URL': {
						const url = new URL(value[1]);
						hydrated[index] = url;
						break;
					}

					case 'URLSearchParams': {
						const url = new URLSearchParams(value[1]);
						hydrated[index] = url;
						break;
					}

					default:
						throw new Error(`Unknown type ${type}`);
				}
			} else {
				const array = new Array(value.length);
				hydrated[index] = array;

				for (let i = 0; i < value.length; i += 1) {
					const n = value[i];
					if (n === HOLE) continue;

					array[i] = hydrate(n);
				}
			}
		} else {
			/** @type {Record<string, any>} */
			const object = {};
			hydrated[index] = object;

			for (const key in value) {
				if (key === '__proto__') {
					throw new Error('Cannot parse an object with a `__proto__` property');
				}

				const n = value[key];
				object[key] = hydrate(n);
			}
		}

		return hydrated[index];
	}

	return hydrate(0);
}

/**
 * Map of elements that have certain elements that are not allowed inside them, in the sense that they will auto-close the parent/ancestor element.
 * Theoretically one could take advantage of it but most of the time it will just result in confusing behavior and break when SSR'd.
 * There are more elements that are invalid inside other elements, but they're not auto-closed and so don't break SSR and are therefore not listed here.
 * @type {Record<string, { direct: string[]} | { descendant: string[]; reset_by?: string[] }>}
 */
const autoclosing_children = {
	// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
	li: { direct: ['li'] },
	// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
	dt: { descendant: ['dt', 'dd'], reset_by: ['dl'] },
	dd: { descendant: ['dt', 'dd'], reset_by: ['dl'] },
	p: {
		descendant: [
			'address',
			'article',
			'aside',
			'blockquote',
			'div',
			'dl',
			'fieldset',
			'footer',
			'form',
			'h1',
			'h2',
			'h3',
			'h4',
			'h5',
			'h6',
			'header',
			'hgroup',
			'hr',
			'main',
			'menu',
			'nav',
			'ol',
			'p',
			'pre',
			'section',
			'table',
			'ul'
		]
	},
	rt: { descendant: ['rt', 'rp'] },
	rp: { descendant: ['rt', 'rp'] },
	optgroup: { descendant: ['optgroup'] },
	option: { descendant: ['option', 'optgroup'] },
	thead: { direct: ['tbody', 'tfoot'] },
	tbody: { direct: ['tbody', 'tfoot'] },
	tfoot: { direct: ['tbody'] },
	tr: { direct: ['tr', 'tbody'] },
	td: { direct: ['td', 'th', 'tr'] },
	th: { direct: ['td', 'th', 'tr'] }
};

/**
 * Returns true if the tag is either the last in the list of siblings and will be autoclosed,
 * or not allowed inside the parent tag such that it will auto-close it. The latter results
 * in the browser repairing the HTML, which will likely result in an error during hydration.
 * @param {string} current
 * @param {string} [next]
 */
function closing_tag_omitted(current, next) {
	const disallowed = autoclosing_children[current];
	if (disallowed) {
		if (
			!next ||
			('direct' in disallowed ? disallowed.direct : disallowed.descendant).includes(next)
		) {
			return true;
		}
	}
	return false;
}

/**
 * Map of elements that have certain elements that are not allowed inside them, in the sense that the browser will somehow repair the HTML.
 * There are more elements that are invalid inside other elements, but they're not repaired and so don't break SSR and are therefore not listed here.
 * @type {Record<string, { direct: string[]} | { descendant: string[]; reset_by?: string[]; only?: string[] } | { only: string[] }>}
 */
const disallowed_children = {
	...autoclosing_children,
	optgroup: { only: ['option', '#text'] },
	// Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
	option: { only: ['#text'] },
	form: { descendant: ['form'] },
	a: { descendant: ['a'] },
	button: { descendant: ['button'] },
	h1: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },
	h2: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },
	h3: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },
	h4: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },
	h5: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },
	h6: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },
	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	select: { only: ['option', 'optgroup', '#text', 'hr', 'script', 'template'] },

	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	// No special behavior since these rules fall back to "in body" mode for
	// all except special table nodes which cause bad parsing behavior anyway.

	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	tr: { only: ['th', 'td', 'style', 'script', 'template'] },
	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	tbody: { only: ['tr', 'style', 'script', 'template'] },
	thead: { only: ['tr', 'style', 'script', 'template'] },
	tfoot: { only: ['tr', 'style', 'script', 'template'] },
	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	colgroup: { only: ['col', 'template'] },
	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	table: {
		only: ['caption', 'colgroup', 'tbody', 'thead', 'tfoot', 'style', 'script', 'template']
	},
	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	head: {
		only: [
			'base',
			'basefont',
			'bgsound',
			'link',
			'meta',
			'title',
			'noscript',
			'noframes',
			'style',
			'script',
			'template'
		]
	},
	// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	html: { only: ['head', 'body', 'frameset'] },
	frameset: { only: ['frame'] },
	'#document': { only: ['html'] }
};

/**
 * Returns an error message if the tag is not allowed inside the ancestor tag (which is grandparent and above) such that it will result
 * in the browser repairing the HTML, which will likely result in an error during hydration.
 * @param {string} child_tag
 * @param {string[]} ancestors All nodes starting with the parent, up until the ancestor, which means two entries minimum
 * @param {string} [child_loc]
 * @param {string} [ancestor_loc]
 * @returns {string | null}
 */
function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) {
	if (child_tag.includes('-')) return null; // custom elements can be anything

	const ancestor_tag = ancestors[ancestors.length - 1];
	const disallowed = disallowed_children[ancestor_tag];
	if (!disallowed) return null;

	if ('reset_by' in disallowed && disallowed.reset_by) {
		for (let i = ancestors.length - 2; i >= 0; i--) {
			const ancestor = ancestors[i];
			if (ancestor.includes('-')) return null; // custom elements can be anything

			// A reset means that forbidden descendants are allowed again
			if (disallowed.reset_by.includes(ancestors[i])) {
				return null;
			}
		}
	}

	if ('descendant' in disallowed && disallowed.descendant.includes(child_tag)) {
		const child = `\`<${child_tag}>\``;
		const ancestor = `\`<${ancestor_tag}>\``;

		return `${child} cannot be a descendant of ${ancestor}`;
	}

	return null;
}

/**
 * Returns an error message if the tag is not allowed inside the parent tag such that it will result
 * in the browser repairing the HTML, which will likely result in an error during hydration.
 * @param {string} child_tag
 * @param {string} parent_tag
 * @param {string} [child_loc]
 * @param {string} [parent_loc]
 * @returns {string | null}
 */
function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) {
	if (child_tag.includes('-') || parent_tag?.includes('-')) return null; // custom elements can be anything

	if (parent_tag === 'template') return null; // no errors or warning should be thrown in immediate children of template tags

	const disallowed = disallowed_children[parent_tag];

	const child = `\`<${child_tag}>\``;
	const parent = `\`<${parent_tag}>\``;

	if (disallowed) {
		if ('direct' in disallowed && disallowed.direct.includes(child_tag)) {
			return `${child} cannot be a direct child of ${parent}`;
		}

		if ('descendant' in disallowed && disallowed.descendant.includes(child_tag)) {
			return `${child} cannot be a child of ${parent}`;
		}

		if ('only' in disallowed && disallowed.only) {
			if (disallowed.only.includes(child_tag)) {
				return null;
			} else {
				return `${child} cannot be a child of ${parent}. \`<${parent_tag}>\` only allows these children: ${disallowed.only.map((d) => `\`<${d}>\``).join(', ')}`;
			}
		}
	}

	// These tags are only valid with a few parents that have special child
	// parsing rules - if we're down here, then none of those matched and
	// so we allow it only if we don't know what the parent is, as all other
	// cases are invalid (and we only get into this function if we know the parent).
	switch (child_tag) {
		case 'body':
		case 'caption':
		case 'col':
		case 'colgroup':
		case 'frameset':
		case 'frame':
		case 'head':
		case 'html':
			return `${child} cannot be a child of ${parent}`;
		case 'thead':
		case 'tbody':
		case 'tfoot':
			return `${child} must be the child of a \`<table>\`, not a ${parent}`;
		case 'td':
		case 'th':
			return `${child} must be the child of a \`<tr>\`, not a ${parent}`;
		case 'tr':
			return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${parent}`;
	}

	return null;
}

var e$1=e=>Object.prototype.toString.call(e),t=e=>ArrayBuffer.isView(e)&&!(e instanceof DataView),o=t=>"[object Date]"===e$1(t),n$1=t=>"[object RegExp]"===e$1(t),r=t=>"[object Error]"===e$1(t),s$1=t=>"[object Boolean]"===e$1(t),l=t=>"[object Number]"===e$1(t),i$3=t=>"[object String]"===e$1(t),c=Array.isArray,u=Object.getOwnPropertyDescriptor,a=Object.prototype.propertyIsEnumerable,f=Object.getOwnPropertySymbols,p$1=Object.prototype.hasOwnProperty,h$1=Object.keys;function d$1(e){const t=h$1(e),o=f(e);for(let n=0;n<o.length;n++)a.call(e,o[n])&&t.push(o[n]);return t}function b(e,t){return !u(e,t)?.writable}function y$1(e,u){if("object"==typeof e&&null!==e){let a;if(c(e))a=[];else if(o(e))a=new Date(e.getTime?e.getTime():e);else if(n$1(e))a=new RegExp(e);else if(r(e))a={message:e.message};else if(s$1(e)||l(e)||i$3(e))a=Object(e);else {if(t(e))return e.slice();a=Object.create(Object.getPrototypeOf(e));}const f=u.includeSymbols?d$1:h$1;for(const t of f(e))a[t]=e[t];return a}return e}var g={includeSymbols:false,immutable:false};function m$1(e,t,o=g){const n=[],r=[];let s=true;const l=o.includeSymbols?d$1:h$1,i=!!o.immutable;return function e(u){const a=i?y$1(u,o):u,f={};let h=true;const d={node:a,node_:u,path:[].concat(n),parent:r[r.length-1],parents:r,key:n[n.length-1],isRoot:0===n.length,level:n.length,circular:void 0,isLeaf:false,notLeaf:true,notRoot:true,isFirst:false,isLast:false,update:function(e,t=false){d.isRoot||(d.parent.node[d.key]=e),d.node=e,t&&(h=false);},delete:function(e){delete d.parent.node[d.key],e&&(h=false);},remove:function(e){c(d.parent.node)?d.parent.node.splice(d.key,1):delete d.parent.node[d.key],e&&(h=false);},keys:null,before:function(e){f.before=e;},after:function(e){f.after=e;},pre:function(e){f.pre=e;},post:function(e){f.post=e;},stop:function(){s=false;},block:function(){h=false;}};if(!s)return d;function g(){if("object"==typeof d.node&&null!==d.node){d.keys&&d.node_===d.node||(d.keys=l(d.node)),d.isLeaf=0===d.keys.length;for(let e=0;e<r.length;e++)if(r[e].node_===u){d.circular=r[e];break}}else d.isLeaf=true,d.keys=null;d.notLeaf=!d.isLeaf,d.notRoot=!d.isRoot;}g();const m=t(d,d.node);if(void 0!==m&&d.update&&d.update(m),f.before&&f.before(d,d.node),!h)return d;if("object"==typeof d.node&&null!==d.node&&!d.circular){r.push(d),g();for(const[t,o]of Object.entries(d.keys??[])){n.push(o),f.pre&&f.pre(d,d.node[o],o);const r=e(d.node[o]);i&&p$1.call(d.node,o)&&!b(d.node,o)&&(d.node[o]=r.node),r.isLast=!!d.keys?.length&&+t==d.keys.length-1,r.isFirst=0==+t,f.post&&f.post(d,r),n.pop();}r.pop();}return f.after&&f.after(d,d.node),d}(e).node}var j=class{#e;#t;constructor(e,t=g){this.#e=e,this.#t=t;}get(e){let t=this.#e;for(let o=0;t&&o<e.length;o++){const n=e[o];if(!p$1.call(t,n)||!this.#t.includeSymbols&&"symbol"==typeof n)return;t=t[n];}return t}has(e){let t=this.#e;for(let o=0;t&&o<e.length;o++){const n=e[o];if(!p$1.call(t,n)||!this.#t.includeSymbols&&"symbol"==typeof n)return  false;t=t[n];}return  true}set(e,t){let o=this.#e,n=0;for(n=0;n<e.length-1;n++){const t=e[n];p$1.call(o,t)||(o[t]={}),o=o[t];}return o[e[n]]=t,t}map(e){return m$1(this.#e,e,{immutable:true,includeSymbols:!!this.#t.includeSymbols})}forEach(e){return this.#e=m$1(this.#e,e,this.#t),this.#e}reduce(e,t){const o=1===arguments.length;let n=o?this.#e:t;return this.forEach(((t,r)=>{t.isRoot&&o||(n=e(t,n,r));})),n}paths(){const e=[];return this.forEach((t=>{e.push(t.path);})),e}nodes(){const e=[];return this.forEach((t=>{e.push(t.node);})),e}clone(){const e=[],o=[],n=this.#t;return t(this.#e)?this.#e.slice():function t(r){for(let t=0;t<e.length;t++)if(e[t]===r)return o[t];if("object"==typeof r&&null!==r){const s=y$1(r,n);e.push(r),o.push(s);const l=n.includeSymbols?d$1:h$1;for(const e of l(r))s[e]=t(r[e]);return e.pop(),o.pop(),s}return r}(this.#e)}};

/*
How it works:
`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
*/

let Node$1 = class Node {
	value;
	next;

	constructor(value) {
		this.value = value;
	}
};

class Queue {
	#head;
	#tail;
	#size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node$1(value);

		if (this.#head) {
			this.#tail.next = node;
			this.#tail = node;
		} else {
			this.#head = node;
			this.#tail = node;
		}

		this.#size++;
	}

	dequeue() {
		const current = this.#head;
		if (!current) {
			return;
		}

		this.#head = this.#head.next;
		this.#size--;

		// Clean up tail reference when queue becomes empty
		if (!this.#head) {
			this.#tail = undefined;
		}

		return current.value;
	}

	peek() {
		if (!this.#head) {
			return;
		}

		return this.#head.value;

		// TODO: Node.js 18.
		// return this.#head?.value;
	}

	clear() {
		this.#head = undefined;
		this.#tail = undefined;
		this.#size = 0;
	}

	get size() {
		return this.#size;
	}

	* [Symbol.iterator]() {
		let current = this.#head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}

	* drain() {
		while (this.#head) {
			yield this.dequeue();
		}
	}
}

function pLimit(concurrency) {
	validateConcurrency(concurrency);

	const queue = new Queue();
	let activeCount = 0;

	const resumeNext = () => {
		if (activeCount < concurrency && queue.size > 0) {
			queue.dequeue()();
			// Since `pendingCount` has been decreased by one, increase `activeCount` by one.
			activeCount++;
		}
	};

	const next = () => {
		activeCount--;

		resumeNext();
	};

	const run = async (function_, resolve, arguments_) => {
		const result = (async () => function_(...arguments_))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (function_, resolve, arguments_) => {
		// Queue `internalResolve` instead of the `run` function
		// to preserve asynchronous context.
		new Promise(internalResolve => {
			queue.enqueue(internalResolve);
		}).then(
			run.bind(undefined, function_, resolve, arguments_),
		);

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// after the `internalResolve` function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency) {
				resumeNext();
			}
		})();
	};

	const generator = (function_, ...arguments_) => new Promise(resolve => {
		enqueue(function_, resolve, arguments_);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount,
		},
		pendingCount: {
			get: () => queue.size,
		},
		clearQueue: {
			value() {
				queue.clear();
			},
		},
		concurrency: {
			get: () => concurrency,

			set(newConcurrency) {
				validateConcurrency(newConcurrency);
				concurrency = newConcurrency;

				queueMicrotask(() => {
					// eslint-disable-next-line no-unmodified-loop-condition
					while (activeCount < concurrency && queue.size > 0) {
						resumeNext();
					}
				});
			},
		},
	});

	return generator;
}

function validateConcurrency(concurrency) {
	if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}
}

function prependForwardSlash(path) {
  return path[0] === "/" ? path : "/" + path;
}
function removeTrailingForwardSlash(path) {
  return path.endsWith("/") ? path.slice(0, path.length - 1) : path;
}
function removeLeadingForwardSlash(path) {
  return path.startsWith("/") ? path.substring(1) : path;
}
function trimSlashes(path) {
  return path.replace(/^\/|\/$/g, "");
}
function isString$1(path) {
  return typeof path === "string" || path instanceof String;
}
function joinPaths(...paths) {
  return paths.filter(isString$1).map((path, i) => {
    if (i === 0) {
      return removeTrailingForwardSlash(path);
    } else if (i === paths.length - 1) {
      return removeLeadingForwardSlash(path);
    } else {
      return trimSlashes(path);
    }
  }).join("/");
}
const URL_PROTOCOL_REGEX = /^(?:(?:http|ftp|https|ws):?\/\/|\/\/)/;
function isRemotePath(src) {
  const decoded = src.replace(/%5C/gi, "\\");
  if (decoded[0] === "\\") {
    return true;
  }
  if (/^(?:http|https|ftp|ws):\\/.test(decoded)) {
    return true;
  }
  return URL_PROTOCOL_REGEX.test(decoded) || decoded.startsWith("data:");
}
function removeBase(path, base) {
  if (path.startsWith(base)) {
    return path.slice(removeTrailingForwardSlash(base).length);
  }
  return path;
}

const CONTENT_IMAGE_FLAG = "astroContentImageFlag";
const IMAGE_IMPORT_PREFIX = "__ASTRO_IMAGE_";
const CONTENT_LAYER_TYPE = "content_layer";
const LIVE_CONTENT_TYPE = "live";

const VALID_INPUT_FORMATS = [
  "jpeg",
  "jpg",
  "png",
  "tiff",
  "webp",
  "gif",
  "svg",
  "avif"
];
const VALID_SUPPORTED_FORMATS = [
  "jpeg",
  "jpg",
  "png",
  "tiff",
  "webp",
  "gif",
  "svg",
  "avif"
];
const DEFAULT_OUTPUT_FORMAT = "webp";
const DEFAULT_HASH_PROPS = [
  "src",
  "width",
  "height",
  "format",
  "quality",
  "fit",
  "position"
];

function imageSrcToImportId(imageSrc, filePath) {
  imageSrc = removeBase(imageSrc, IMAGE_IMPORT_PREFIX);
  if (isRemotePath(imageSrc)) {
    return;
  }
  const ext = imageSrc.split(".").at(-1)?.toLowerCase();
  if (!ext || !VALID_INPUT_FORMATS.includes(ext)) {
    return;
  }
  const params = new URLSearchParams(CONTENT_IMAGE_FLAG);
  if (filePath) {
    params.set("importer", filePath);
  }
  return `${imageSrc}?${params.toString()}`;
}

function getImporterFilename() {
  const stackLine = new Error().stack?.split("\n").find(
    (line) => !line.includes("defineCollection") && !line.includes("defineLiveCollection") && !line.includes("getImporterFilename") && !line.startsWith("Error")
  );
  if (!stackLine) {
    return void 0;
  }
  const match = /\/((?:src|chunks)\/.*?):\d+:\d+/.exec(stackLine);
  return match?.[1] ?? void 0;
}
function defineCollection$1(config) {
  const importerFilename = getImporterFilename();
  if (importerFilename?.includes("live.config")) {
    throw new AstroError({
      ...LiveContentConfigError,
      message: LiveContentConfigError.message(
        "Collections in a live config file must use `defineLiveCollection`.",
        importerFilename
      )
    });
  }
  if ("loader" in config) {
    if (config.type && config.type !== CONTENT_LAYER_TYPE) {
      throw new AstroUserError(
        `Collections that use the Content Layer API must have a \`loader\` defined and no \`type\` set. Check your collection definitions in ${importerFilename ?? "your content config file"}.`
      );
    }
    if (typeof config.loader === "object" && typeof config.loader.load !== "function" && ("loadEntry" in config.loader || "loadCollection" in config.loader)) {
      throw new AstroUserError(
        `Live content collections must be defined in "src/live.config.ts" file. Check your collection definitions in "${importerFilename ?? "your content config file"}" to ensure you are not using a live loader.`
      );
    }
    config.type = CONTENT_LAYER_TYPE;
  }
  if (!config.type) config.type = "content";
  return config;
}

class ImmutableDataStore {
  _collections = /* @__PURE__ */ new Map();
  constructor() {
    this._collections = /* @__PURE__ */ new Map();
  }
  get(collectionName, key) {
    return this._collections.get(collectionName)?.get(String(key));
  }
  entries(collectionName) {
    const collection = this._collections.get(collectionName) ?? /* @__PURE__ */ new Map();
    return [...collection.entries()];
  }
  values(collectionName) {
    const collection = this._collections.get(collectionName) ?? /* @__PURE__ */ new Map();
    return [...collection.values()];
  }
  keys(collectionName) {
    const collection = this._collections.get(collectionName) ?? /* @__PURE__ */ new Map();
    return [...collection.keys()];
  }
  has(collectionName, key) {
    const collection = this._collections.get(collectionName);
    if (collection) {
      return collection.has(String(key));
    }
    return false;
  }
  hasCollection(collectionName) {
    return this._collections.has(collectionName);
  }
  collections() {
    return this._collections;
  }
  /**
   * Attempts to load a DataStore from the virtual module.
   * This only works in Vite.
   */
  static async fromModule() {
    try {
      const data = await import('./_astro_data-layer-content_ChgEie40.mjs');
      if (data.default instanceof Map) {
        return ImmutableDataStore.fromMap(data.default);
      }
      const map = unflatten(data.default);
      return ImmutableDataStore.fromMap(map);
    } catch {
    }
    return new ImmutableDataStore();
  }
  static async fromMap(data) {
    const store = new ImmutableDataStore();
    store._collections = data;
    return store;
  }
}
function dataStoreSingleton() {
  let instance = void 0;
  return {
    get: async () => {
      if (!instance) {
        instance = ImmutableDataStore.fromModule();
      }
      return instance;
    },
    set: (store) => {
      instance = store;
    }
  };
}
const globalDataStore = dataStoreSingleton();

const __vite_import_meta_env__ = {"ASSETS_PREFIX": undefined, "BASE_URL": "/", "DEV": false, "MODE": "production", "PROD": true, "SITE": "https://fuwari.vercel.app/", "SSR": true};
function createCollectionToGlobResultMap({
  globResult,
  contentDir
}) {
  const collectionToGlobResultMap = {};
  for (const key in globResult) {
    const keyRelativeToContentDir = key.replace(new RegExp(`^${contentDir}`), "");
    const segments = keyRelativeToContentDir.split("/");
    if (segments.length <= 1) continue;
    const collection = segments[0];
    collectionToGlobResultMap[collection] ??= {};
    collectionToGlobResultMap[collection][key] = globResult[key];
  }
  return collectionToGlobResultMap;
}
objectType({
  tags: arrayType(stringType()).optional(),
  maxAge: numberType().optional(),
  lastModified: dateType().optional()
});
function createGetCollection({
  contentCollectionToEntryMap,
  dataCollectionToEntryMap,
  getRenderEntryImport,
  cacheEntriesByCollection,
  liveCollections
}) {
  return async function getCollection(collection, filter) {
    if (collection in liveCollections) {
      throw new AstroError({
        ...UnknownContentCollectionError,
        message: `Collection "${collection}" is a live collection. Use getLiveCollection() instead of getCollection().`
      });
    }
    const hasFilter = typeof filter === "function";
    const store = await globalDataStore.get();
    let type;
    if (collection in contentCollectionToEntryMap) {
      type = "content";
    } else if (collection in dataCollectionToEntryMap) {
      type = "data";
    } else if (store.hasCollection(collection)) {
      const { default: imageAssetMap } = await import('./content-assets_DleWbedO.mjs');
      const result = [];
      for (const rawEntry of store.values(collection)) {
        const data = updateImageReferencesInData(rawEntry.data, rawEntry.filePath, imageAssetMap);
        let entry = {
          ...rawEntry,
          data,
          collection
        };
        if (entry.legacyId) {
          entry = emulateLegacyEntry(entry);
        }
        if (hasFilter && !filter(entry)) {
          continue;
        }
        result.push(entry);
      }
      return result;
    } else {
      console.warn(
        `The collection ${JSON.stringify(
          collection
        )} does not exist or is empty. Please check your content config file for errors.`
      );
      return [];
    }
    const lazyImports = Object.values(
      type === "content" ? contentCollectionToEntryMap[collection] : dataCollectionToEntryMap[collection]
    );
    let entries = [];
    if (!Object.assign(__vite_import_meta_env__, {})?.DEV && cacheEntriesByCollection.has(collection)) {
      entries = cacheEntriesByCollection.get(collection);
    } else {
      const limit = pLimit(10);
      entries = await Promise.all(
        lazyImports.map(
          (lazyImport) => limit(async () => {
            const entry = await lazyImport();
            return type === "content" ? {
              id: entry.id,
              slug: entry.slug,
              body: entry.body,
              collection: entry.collection,
              data: entry.data,
              async render() {
                return render({
                  collection: entry.collection,
                  id: entry.id,
                  renderEntryImport: await getRenderEntryImport(collection, entry.slug)
                });
              }
            } : {
              id: entry.id,
              collection: entry.collection,
              data: entry.data
            };
          })
        )
      );
      cacheEntriesByCollection.set(collection, entries);
    }
    if (hasFilter) {
      return entries.filter(filter);
    } else {
      return entries.slice();
    }
  };
}
function emulateLegacyEntry({ legacyId, ...entry }) {
  const legacyEntry = {
    ...entry,
    id: legacyId,
    slug: entry.id
  };
  return {
    ...legacyEntry,
    // Define separately so the render function isn't included in the object passed to `renderEntry()`
    render: () => renderEntry(legacyEntry)
  };
}
function createGetEntry({
  getEntryImport,
  getRenderEntryImport,
  collectionNames,
  liveCollections
}) {
  return async function getEntry(collectionOrLookupObject, lookup) {
    let collection, lookupId;
    if (typeof collectionOrLookupObject === "string") {
      collection = collectionOrLookupObject;
      if (!lookup)
        throw new AstroError({
          ...UnknownContentCollectionError,
          message: "`getEntry()` requires an entry identifier as the second argument."
        });
      lookupId = lookup;
    } else {
      collection = collectionOrLookupObject.collection;
      lookupId = "id" in collectionOrLookupObject ? collectionOrLookupObject.id : collectionOrLookupObject.slug;
    }
    if (collection in liveCollections) {
      throw new AstroError({
        ...UnknownContentCollectionError,
        message: `Collection "${collection}" is a live collection. Use getLiveEntry() instead of getEntry().`
      });
    }
    if (typeof lookupId === "object") {
      throw new AstroError({
        ...UnknownContentCollectionError,
        message: `The entry identifier must be a string. Received object.`
      });
    }
    const store = await globalDataStore.get();
    if (store.hasCollection(collection)) {
      const entry2 = store.get(collection, lookupId);
      if (!entry2) {
        console.warn(`Entry ${collection} → ${lookupId} was not found.`);
        return;
      }
      const { default: imageAssetMap } = await import('./content-assets_DleWbedO.mjs');
      entry2.data = updateImageReferencesInData(entry2.data, entry2.filePath, imageAssetMap);
      if (entry2.legacyId) {
        return emulateLegacyEntry({ ...entry2, collection });
      }
      return {
        ...entry2,
        collection
      };
    }
    if (!collectionNames.has(collection)) {
      console.warn(
        `The collection ${JSON.stringify(collection)} does not exist. Please ensure it is defined in your content config.`
      );
      return void 0;
    }
    const entryImport = await getEntryImport(collection, lookupId);
    if (typeof entryImport !== "function") return void 0;
    const entry = await entryImport();
    if (entry._internal.type === "content") {
      return {
        id: entry.id,
        slug: entry.slug,
        body: entry.body,
        collection: entry.collection,
        data: entry.data,
        async render() {
          return render({
            collection: entry.collection,
            id: entry.id,
            renderEntryImport: await getRenderEntryImport(collection, lookupId)
          });
        }
      };
    } else if (entry._internal.type === "data") {
      return {
        id: entry.id,
        collection: entry.collection,
        data: entry.data
      };
    }
    return void 0;
  };
}
const CONTENT_LAYER_IMAGE_REGEX = /__ASTRO_IMAGE_="([^"]+)"/g;
async function updateImageReferencesInBody(html, fileName) {
  const { default: imageAssetMap } = await import('./content-assets_DleWbedO.mjs');
  const imageObjects = /* @__PURE__ */ new Map();
  const { getImage } = await import('./_astro_assets_SlzzLEF7.mjs').then(n => n._);
  for (const [_full, imagePath] of html.matchAll(CONTENT_LAYER_IMAGE_REGEX)) {
    try {
      const decodedImagePath = JSON.parse(imagePath.replaceAll("&#x22;", '"'));
      let image;
      if (URL.canParse(decodedImagePath.src)) {
        image = await getImage(decodedImagePath);
      } else {
        const id = imageSrcToImportId(decodedImagePath.src, fileName);
        const imported = imageAssetMap.get(id);
        if (!id || imageObjects.has(id) || !imported) {
          continue;
        }
        image = await getImage({ ...decodedImagePath, src: imported });
      }
      imageObjects.set(imagePath, image);
    } catch {
      throw new Error(`Failed to parse image reference: ${imagePath}`);
    }
  }
  return html.replaceAll(CONTENT_LAYER_IMAGE_REGEX, (full, imagePath) => {
    const image = imageObjects.get(imagePath);
    if (!image) {
      return full;
    }
    const { index, ...attributes } = image.attributes;
    return Object.entries({
      ...attributes,
      src: image.src,
      srcset: image.srcSet.attribute,
      // This attribute is used by the toolbar audit
      ...Object.assign(__vite_import_meta_env__, {}).DEV ? { "data-image-component": "true" } : {}
    }).map(([key, value]) => value ? `${key}="${escape$2(value)}"` : "").join(" ");
  });
}
function updateImageReferencesInData(data, fileName, imageAssetMap) {
  return new j(data).map(function(ctx, val) {
    if (typeof val === "string" && val.startsWith(IMAGE_IMPORT_PREFIX)) {
      const src = val.replace(IMAGE_IMPORT_PREFIX, "");
      const id = imageSrcToImportId(src, fileName);
      if (!id) {
        ctx.update(src);
        return;
      }
      const imported = imageAssetMap?.get(id);
      if (imported) {
        ctx.update(imported);
      } else {
        ctx.update(src);
      }
    }
  });
}
async function renderEntry(entry) {
  if (!entry) {
    throw new AstroError(RenderUndefinedEntryError);
  }
  if ("render" in entry && !("legacyId" in entry)) {
    return entry.render();
  }
  if (entry.deferredRender) {
    try {
      const { default: contentModules } = await import('./content-modules_Dz-S_Wwv.mjs');
      const renderEntryImport = contentModules.get(entry.filePath);
      return render({
        collection: "",
        id: entry.id,
        renderEntryImport
      });
    } catch (e) {
      console.error(e);
    }
  }
  const html = entry?.rendered?.metadata?.imagePaths?.length && entry.filePath ? await updateImageReferencesInBody(entry.rendered.html, entry.filePath) : entry?.rendered?.html;
  const Content = createComponent(() => renderTemplate`${unescapeHTML(html)}`);
  return {
    Content,
    headings: entry?.rendered?.metadata?.headings ?? [],
    remarkPluginFrontmatter: entry?.rendered?.metadata?.frontmatter ?? {}
  };
}
async function render({
  collection,
  id,
  renderEntryImport
}) {
  const UnexpectedRenderError = new AstroError({
    ...UnknownContentCollectionError,
    message: `Unexpected error while rendering ${String(collection)} → ${String(id)}.`
  });
  if (typeof renderEntryImport !== "function") throw UnexpectedRenderError;
  const baseMod = await renderEntryImport();
  if (baseMod == null || typeof baseMod !== "object") throw UnexpectedRenderError;
  const { default: defaultMod } = baseMod;
  if (isPropagatedAssetsModule(defaultMod)) {
    const { collectedStyles, collectedLinks, collectedScripts, getMod } = defaultMod;
    if (typeof getMod !== "function") throw UnexpectedRenderError;
    const propagationMod = await getMod();
    if (propagationMod == null || typeof propagationMod !== "object") throw UnexpectedRenderError;
    const Content = createComponent({
      factory(result, baseProps, slots) {
        let styles = "", links = "", scripts = "";
        if (Array.isArray(collectedStyles)) {
          styles = collectedStyles.map((style) => {
            return renderUniqueStylesheet(result, {
              type: "inline",
              content: style
            });
          }).join("");
        }
        if (Array.isArray(collectedLinks)) {
          links = collectedLinks.map((link) => {
            return renderUniqueStylesheet(result, {
              type: "external",
              src: prependForwardSlash(link)
            });
          }).join("");
        }
        if (Array.isArray(collectedScripts)) {
          scripts = collectedScripts.map((script) => renderScriptElement(script)).join("");
        }
        let props = baseProps;
        if (id.endsWith("mdx")) {
          props = {
            components: propagationMod.components ?? {},
            ...baseProps
          };
        }
        return createHeadAndContent(
          unescapeHTML(styles + links + scripts),
          renderTemplate`${renderComponent(
            result,
            "Content",
            propagationMod.Content,
            props,
            slots
          )}`
        );
      },
      propagation: "self"
    });
    return {
      Content,
      headings: propagationMod.getHeadings?.() ?? [],
      remarkPluginFrontmatter: propagationMod.frontmatter ?? {}
    };
  } else if (baseMod.Content && typeof baseMod.Content === "function") {
    return {
      Content: baseMod.Content,
      headings: baseMod.getHeadings?.() ?? [],
      remarkPluginFrontmatter: baseMod.frontmatter ?? {}
    };
  } else {
    throw UnexpectedRenderError;
  }
}
function isPropagatedAssetsModule(module) {
  return typeof module === "object" && module != null && "__astroPropagation" in module;
}
function defineCollection(config) {
  if (config.type === "live") {
    throw new AstroError({
      ...LiveContentConfigError,
      message: LiveContentConfigError.message(
        "Collections with type `live` must be defined in a `src/live.config.ts` file."
      )
    });
  }
  return defineCollection$1(config);
}

// astro-head-inject

const liveCollections = {};

const contentDir = '/src/content/';

const contentEntryGlob = "";
const contentCollectionToEntryMap = createCollectionToGlobResultMap({
	globResult: contentEntryGlob,
	contentDir,
});

const dataEntryGlob = "";
const dataCollectionToEntryMap = createCollectionToGlobResultMap({
	globResult: dataEntryGlob,
	contentDir,
});
const collectionToEntryMap = createCollectionToGlobResultMap({
	globResult: { ...contentEntryGlob, ...dataEntryGlob },
	contentDir,
});

let lookupMap = {};
lookupMap = {};

const collectionNames = new Set(Object.keys(lookupMap));

function createGlobLookup(glob) {
	return async (collection, lookupId) => {
		const filePath = lookupMap[collection]?.entries[lookupId];

		if (!filePath) return undefined;
		return glob[collection][filePath];
	};
}

const renderEntryGlob = "";
const collectionToRenderEntryMap = createCollectionToGlobResultMap({
	globResult: renderEntryGlob,
	contentDir,
});

const cacheEntriesByCollection = new Map();
const getCollection = createGetCollection({
	contentCollectionToEntryMap,
	dataCollectionToEntryMap,
	getRenderEntryImport: createGlobLookup(collectionToRenderEntryMap),
	cacheEntriesByCollection,
	liveCollections,
});

const getEntry = createGetEntry({
	getEntryImport: createGlobLookup(collectionToEntryMap),
	getRenderEntryImport: createGlobLookup(collectionToRenderEntryMap),
	collectionNames,
	liveCollections,
});

var I18nKey = /* @__PURE__ */ ((I18nKey2) => {
  I18nKey2["home"] = "home";
  I18nKey2["about"] = "about";
  I18nKey2["archive"] = "archive";
  I18nKey2["search"] = "search";
  I18nKey2["tags"] = "tags";
  I18nKey2["categories"] = "categories";
  I18nKey2["recentPosts"] = "recentPosts";
  I18nKey2["comments"] = "comments";
  I18nKey2["untitled"] = "untitled";
  I18nKey2["uncategorized"] = "uncategorized";
  I18nKey2["noTags"] = "noTags";
  I18nKey2["wordCount"] = "wordCount";
  I18nKey2["wordsCount"] = "wordsCount";
  I18nKey2["minuteCount"] = "minuteCount";
  I18nKey2["minutesCount"] = "minutesCount";
  I18nKey2["postCount"] = "postCount";
  I18nKey2["postsCount"] = "postsCount";
  I18nKey2["themeColor"] = "themeColor";
  I18nKey2["lightMode"] = "lightMode";
  I18nKey2["darkMode"] = "darkMode";
  I18nKey2["systemMode"] = "systemMode";
  I18nKey2["more"] = "more";
  I18nKey2["author"] = "author";
  I18nKey2["publishedAt"] = "publishedAt";
  I18nKey2["license"] = "license";
  return I18nKey2;
})(I18nKey || {});

const i18nKey = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: I18nKey
}, Symbol.toStringTag, { value: 'Module' }));

var LinkPreset = /* @__PURE__ */ ((LinkPreset2) => {
  LinkPreset2[LinkPreset2["Home"] = 0] = "Home";
  LinkPreset2[LinkPreset2["Archive"] = 1] = "Archive";
  LinkPreset2[LinkPreset2["About"] = 2] = "About";
  return LinkPreset2;
})(LinkPreset || {});

const config$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  LinkPreset
}, Symbol.toStringTag, { value: 'Module' }));

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var native = {};

var hasRequiredNative;

function requireNative () {
	if (hasRequiredNative) return native;
	hasRequiredNative = 1;
	const { existsSync } = fs__default;
	const path = path$b;
	const { platform, arch, report } = process$1;

	const isMusl = () => {
		try {
			return !report.getReport().header.glibcVersionRuntime;
		} catch {
			return false;
		}
	};

	const isMingw32 = () => {
		try {
			return report.getReport().header.osName.startsWith('MINGW32_NT');
		} catch {
			return false;
		}
	};

	const bindingsByPlatformAndArch = {
		android: {
			arm: { base: 'android-arm-eabi' },
			arm64: { base: 'android-arm64' }
		},
		darwin: {
			arm64: { base: 'darwin-arm64' },
			x64: { base: 'darwin-x64' }
		},
		freebsd: {
			arm64: { base: 'freebsd-arm64' },
			x64: { base: 'freebsd-x64' }
		},
		linux: {
			arm: { base: 'linux-arm-gnueabihf', musl: 'linux-arm-musleabihf' },
			arm64: { base: 'linux-arm64-gnu', musl: 'linux-arm64-musl' },
			loong64: { base: 'linux-loong64-gnu', musl: null },
			ppc64: { base: 'linux-ppc64-gnu', musl: null },
			riscv64: { base: 'linux-riscv64-gnu', musl: 'linux-riscv64-musl' },
			s390x: { base: 'linux-s390x-gnu', musl: null },
			x64: { base: 'linux-x64-gnu', musl: 'linux-x64-musl' }
		},
		openharmony: {
			arm64: { base: 'openharmony-arm64' }
		},
		win32: {
			arm64: { base: 'win32-arm64-msvc' },
			ia32: { base: 'win32-ia32-msvc' },
			x64: {
				base: isMingw32() ? 'win32-x64-gnu' : 'win32-x64-msvc'
			}
		}
	};

	const msvcLinkFilenameByArch = {
		arm64: 'vc_redist.arm64.exe',
		ia32: 'vc_redist.x86.exe',
		x64: 'vc_redist.x64.exe'
	};

	const packageBase = getPackageBase();
	const localName = `./rollup.${packageBase}.node`;
	const requireWithFriendlyError = id => {
		try {
			return commonjsRequire(id);
		} catch (error) {
			if (
				platform === 'win32' &&
				error instanceof Error &&
				error.code === 'ERR_DLOPEN_FAILED' &&
				error.message.includes('The specified module could not be found')
			) {
				const msvcDownloadLink = `https://aka.ms/vs/17/release/${msvcLinkFilenameByArch[arch]}`;
				throw new Error(
					`Failed to load module ${id}. ` +
						'Required DLL was not found. ' +
						'This error usually happens when Microsoft Visual C++ Redistributable is not installed. ' +
						`You can download it from ${msvcDownloadLink}`,
					{ cause: error }
				);
			}

			throw new Error(
				`Cannot find module ${id}. ` +
					`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). ` +
					'Please try `npm i` again after removing both package-lock.json and node_modules directory.',
				{ cause: error }
			);
		}
	};

	const { parse, parseAsync, xxhashBase64Url, xxhashBase36, xxhashBase16 } = requireWithFriendlyError(
		existsSync(path.join(__dirname, localName)) ? localName : `@rollup/rollup-${packageBase}`
	);

	function getPackageBase() {
		const imported = bindingsByPlatformAndArch[platform]?.[arch];
		if (!imported) {
			throwUnsupportedError(false);
		}
		if ('musl' in imported && isMusl()) {
			return imported.musl || throwUnsupportedError(true);
		}
		return imported.base;
	}

	function throwUnsupportedError(isMusl) {
		throw new Error(
			`Your current platform "${platform}${isMusl ? ' (musl)' : ''}" and architecture "${arch}" combination is not yet supported by the native Rollup build. Please use the WASM build "@rollup/wasm-node" instead.

The following platform-architecture combinations are supported:
${Object.entries(bindingsByPlatformAndArch)
		.flatMap(([platformName, architectures]) =>
			Object.entries(architectures).flatMap(([architectureName, { musl }]) => {
				const name = `${platformName}-${architectureName}`;
				return musl ? [name, `${name} (musl)`] : [name];
			})
		)
		.join('\n')}

If this is important to you, please consider supporting Rollup to make a native build for your platform and architecture available.`
		);
	}

	native.parse = parse;
	native.parseAsync = parseAsync;
	native.xxhashBase64Url = xxhashBase64Url;
	native.xxhashBase36 = xxhashBase36;
	native.xxhashBase16 = xxhashBase16;
	return native;
}

requireNative();

/*
  @license
	Rollup.js v4.53.3
	Wed, 19 Nov 2025 06:31:27 GMT - commit 998b5950a6ea7cea1a7b994e8dab45472c3cbe7e

	https://github.com/rollup/rollup

	Released under the MIT License.
*/

Object.freeze(Object.create(null));
Object.freeze(new (class extends Set {
    add() {
        throw new Error('Cannot add to empty set');
    }
})());

var utils$1 = {};

var constants$2;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants$2;
	hasRequiredConstants = 1;

	const WIN_SLASH = '\\\\/';
	const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

	/**
	 * Posix glob regex
	 */

	const DOT_LITERAL = '\\.';
	const PLUS_LITERAL = '\\+';
	const QMARK_LITERAL = '\\?';
	const SLASH_LITERAL = '\\/';
	const ONE_CHAR = '(?=.)';
	const QMARK = '[^/]';
	const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
	const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
	const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
	const NO_DOT = `(?!${DOT_LITERAL})`;
	const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
	const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
	const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
	const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
	const STAR = `${QMARK}*?`;
	const SEP = '/';

	const POSIX_CHARS = {
	  DOT_LITERAL,
	  PLUS_LITERAL,
	  QMARK_LITERAL,
	  SLASH_LITERAL,
	  ONE_CHAR,
	  QMARK,
	  END_ANCHOR,
	  DOTS_SLASH,
	  NO_DOT,
	  NO_DOTS,
	  NO_DOT_SLASH,
	  NO_DOTS_SLASH,
	  QMARK_NO_DOT,
	  STAR,
	  START_ANCHOR,
	  SEP
	};

	/**
	 * Windows glob regex
	 */

	const WINDOWS_CHARS = {
	  ...POSIX_CHARS,

	  SLASH_LITERAL: `[${WIN_SLASH}]`,
	  QMARK: WIN_NO_SLASH,
	  STAR: `${WIN_NO_SLASH}*?`,
	  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
	  NO_DOT: `(?!${DOT_LITERAL})`,
	  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
	  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
	  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
	  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
	  SEP: '\\'
	};

	/**
	 * POSIX Bracket Regex
	 */

	const POSIX_REGEX_SOURCE = {
	  alnum: 'a-zA-Z0-9',
	  alpha: 'a-zA-Z',
	  ascii: '\\x00-\\x7F',
	  blank: ' \\t',
	  cntrl: '\\x00-\\x1F\\x7F',
	  digit: '0-9',
	  graph: '\\x21-\\x7E',
	  lower: 'a-z',
	  print: '\\x20-\\x7E ',
	  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
	  space: ' \\t\\r\\n\\v\\f',
	  upper: 'A-Z',
	  word: 'A-Za-z0-9_',
	  xdigit: 'A-Fa-f0-9'
	};

	constants$2 = {
	  MAX_LENGTH: 1024 * 64,
	  POSIX_REGEX_SOURCE,

	  // regular expressions
	  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
	  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
	  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
	  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
	  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
	  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

	  // Replace globs with equivalent patterns to reduce parsing time.
	  REPLACEMENTS: {
	    __proto__: null,
	    '***': '*',
	    '**/**': '**',
	    '**/**/**': '**'
	  },

	  // Digits
	  CHAR_0: 48, /* 0 */
	  CHAR_9: 57, /* 9 */

	  // Alphabet chars.
	  CHAR_UPPERCASE_A: 65, /* A */
	  CHAR_LOWERCASE_A: 97, /* a */
	  CHAR_UPPERCASE_Z: 90, /* Z */
	  CHAR_LOWERCASE_Z: 122, /* z */

	  CHAR_LEFT_PARENTHESES: 40, /* ( */
	  CHAR_RIGHT_PARENTHESES: 41, /* ) */

	  CHAR_ASTERISK: 42, /* * */

	  // Non-alphabetic chars.
	  CHAR_AMPERSAND: 38, /* & */
	  CHAR_AT: 64, /* @ */
	  CHAR_BACKWARD_SLASH: 92, /* \ */
	  CHAR_CARRIAGE_RETURN: 13, /* \r */
	  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
	  CHAR_COLON: 58, /* : */
	  CHAR_COMMA: 44, /* , */
	  CHAR_DOT: 46, /* . */
	  CHAR_DOUBLE_QUOTE: 34, /* " */
	  CHAR_EQUAL: 61, /* = */
	  CHAR_EXCLAMATION_MARK: 33, /* ! */
	  CHAR_FORM_FEED: 12, /* \f */
	  CHAR_FORWARD_SLASH: 47, /* / */
	  CHAR_GRAVE_ACCENT: 96, /* ` */
	  CHAR_HASH: 35, /* # */
	  CHAR_HYPHEN_MINUS: 45, /* - */
	  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
	  CHAR_LEFT_CURLY_BRACE: 123, /* { */
	  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
	  CHAR_LINE_FEED: 10, /* \n */
	  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
	  CHAR_PERCENT: 37, /* % */
	  CHAR_PLUS: 43, /* + */
	  CHAR_QUESTION_MARK: 63, /* ? */
	  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
	  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
	  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
	  CHAR_SEMICOLON: 59, /* ; */
	  CHAR_SINGLE_QUOTE: 39, /* ' */
	  CHAR_SPACE: 32, /*   */
	  CHAR_TAB: 9, /* \t */
	  CHAR_UNDERSCORE: 95, /* _ */
	  CHAR_VERTICAL_LINE: 124, /* | */
	  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

	  /**
	   * Create EXTGLOB_CHARS
	   */

	  extglobChars(chars) {
	    return {
	      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
	      '?': { type: 'qmark', open: '(?:', close: ')?' },
	      '+': { type: 'plus', open: '(?:', close: ')+' },
	      '*': { type: 'star', open: '(?:', close: ')*' },
	      '@': { type: 'at', open: '(?:', close: ')' }
	    };
	  },

	  /**
	   * Create GLOB_CHARS
	   */

	  globChars(win32) {
	    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
	  }
	};
	return constants$2;
}

/*global navigator*/

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	(function (exports$1) {

		const {
		  REGEX_BACKSLASH,
		  REGEX_REMOVE_BACKSLASH,
		  REGEX_SPECIAL_CHARS,
		  REGEX_SPECIAL_CHARS_GLOBAL
		} = /*@__PURE__*/ requireConstants();

		exports$1.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
		exports$1.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
		exports$1.isRegexChar = str => str.length === 1 && exports$1.hasRegexChars(str);
		exports$1.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
		exports$1.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

		exports$1.isWindows = () => {
		  if (typeof navigator !== 'undefined' && navigator.platform) {
		    const platform = navigator.platform.toLowerCase();
		    return platform === 'win32' || platform === 'windows';
		  }

		  if (typeof process !== 'undefined' && process.platform) {
		    return process.platform === 'win32';
		  }

		  return false;
		};

		exports$1.removeBackslashes = str => {
		  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
		    return match === '\\' ? '' : match;
		  });
		};

		exports$1.escapeLast = (input, char, lastIdx) => {
		  const idx = input.lastIndexOf(char, lastIdx);
		  if (idx === -1) return input;
		  if (input[idx - 1] === '\\') return exports$1.escapeLast(input, char, idx - 1);
		  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
		};

		exports$1.removePrefix = (input, state = {}) => {
		  let output = input;
		  if (output.startsWith('./')) {
		    output = output.slice(2);
		    state.prefix = './';
		  }
		  return output;
		};

		exports$1.wrapOutput = (input, state = {}, options = {}) => {
		  const prepend = options.contains ? '' : '^';
		  const append = options.contains ? '' : '$';

		  let output = `${prepend}(?:${input})${append}`;
		  if (state.negated === true) {
		    output = `(?:^(?!${output}).*$)`;
		  }
		  return output;
		};

		exports$1.basename = (path, { windows } = {}) => {
		  const segs = path.split(windows ? /[\\/]/ : '/');
		  const last = segs[segs.length - 1];

		  if (last === '') {
		    return segs[segs.length - 2];
		  }

		  return last;
		}; 
	} (utils$1));
	return utils$1;
}

var scan_1;
var hasRequiredScan;

function requireScan () {
	if (hasRequiredScan) return scan_1;
	hasRequiredScan = 1;

	const utils = /*@__PURE__*/ requireUtils$1();
	const {
	  CHAR_ASTERISK,             /* * */
	  CHAR_AT,                   /* @ */
	  CHAR_BACKWARD_SLASH,       /* \ */
	  CHAR_COMMA,                /* , */
	  CHAR_DOT,                  /* . */
	  CHAR_EXCLAMATION_MARK,     /* ! */
	  CHAR_FORWARD_SLASH,        /* / */
	  CHAR_LEFT_CURLY_BRACE,     /* { */
	  CHAR_LEFT_PARENTHESES,     /* ( */
	  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
	  CHAR_PLUS,                 /* + */
	  CHAR_QUESTION_MARK,        /* ? */
	  CHAR_RIGHT_CURLY_BRACE,    /* } */
	  CHAR_RIGHT_PARENTHESES,    /* ) */
	  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
	} = /*@__PURE__*/ requireConstants();

	const isPathSeparator = code => {
	  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
	};

	const depth = token => {
	  if (token.isPrefix !== true) {
	    token.depth = token.isGlobstar ? Infinity : 1;
	  }
	};

	/**
	 * Quickly scans a glob pattern and returns an object with a handful of
	 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
	 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
	 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
	 *
	 * ```js
	 * const pm = require('picomatch');
	 * console.log(pm.scan('foo/bar/*.js'));
	 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
	 * ```
	 * @param {String} `str`
	 * @param {Object} `options`
	 * @return {Object} Returns an object with tokens and regex source string.
	 * @api public
	 */

	const scan = (input, options) => {
	  const opts = options || {};

	  const length = input.length - 1;
	  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
	  const slashes = [];
	  const tokens = [];
	  const parts = [];

	  let str = input;
	  let index = -1;
	  let start = 0;
	  let lastIndex = 0;
	  let isBrace = false;
	  let isBracket = false;
	  let isGlob = false;
	  let isExtglob = false;
	  let isGlobstar = false;
	  let braceEscaped = false;
	  let backslashes = false;
	  let negated = false;
	  let negatedExtglob = false;
	  let finished = false;
	  let braces = 0;
	  let prev;
	  let code;
	  let token = { value: '', depth: 0, isGlob: false };

	  const eos = () => index >= length;
	  const peek = () => str.charCodeAt(index + 1);
	  const advance = () => {
	    prev = code;
	    return str.charCodeAt(++index);
	  };

	  while (index < length) {
	    code = advance();
	    let next;

	    if (code === CHAR_BACKWARD_SLASH) {
	      backslashes = token.backslashes = true;
	      code = advance();

	      if (code === CHAR_LEFT_CURLY_BRACE) {
	        braceEscaped = true;
	      }
	      continue;
	    }

	    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
	      braces++;

	      while (eos() !== true && (code = advance())) {
	        if (code === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }

	        if (code === CHAR_LEFT_CURLY_BRACE) {
	          braces++;
	          continue;
	        }

	        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;

	          if (scanToEnd === true) {
	            continue;
	          }

	          break;
	        }

	        if (braceEscaped !== true && code === CHAR_COMMA) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;

	          if (scanToEnd === true) {
	            continue;
	          }

	          break;
	        }

	        if (code === CHAR_RIGHT_CURLY_BRACE) {
	          braces--;

	          if (braces === 0) {
	            braceEscaped = false;
	            isBrace = token.isBrace = true;
	            finished = true;
	            break;
	          }
	        }
	      }

	      if (scanToEnd === true) {
	        continue;
	      }

	      break;
	    }

	    if (code === CHAR_FORWARD_SLASH) {
	      slashes.push(index);
	      tokens.push(token);
	      token = { value: '', depth: 0, isGlob: false };

	      if (finished === true) continue;
	      if (prev === CHAR_DOT && index === (start + 1)) {
	        start += 2;
	        continue;
	      }

	      lastIndex = index + 1;
	      continue;
	    }

	    if (opts.noext !== true) {
	      const isExtglobChar = code === CHAR_PLUS
	        || code === CHAR_AT
	        || code === CHAR_ASTERISK
	        || code === CHAR_QUESTION_MARK
	        || code === CHAR_EXCLAMATION_MARK;

	      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
	        isGlob = token.isGlob = true;
	        isExtglob = token.isExtglob = true;
	        finished = true;
	        if (code === CHAR_EXCLAMATION_MARK && index === start) {
	          negatedExtglob = true;
	        }

	        if (scanToEnd === true) {
	          while (eos() !== true && (code = advance())) {
	            if (code === CHAR_BACKWARD_SLASH) {
	              backslashes = token.backslashes = true;
	              code = advance();
	              continue;
	            }

	            if (code === CHAR_RIGHT_PARENTHESES) {
	              isGlob = token.isGlob = true;
	              finished = true;
	              break;
	            }
	          }
	          continue;
	        }
	        break;
	      }
	    }

	    if (code === CHAR_ASTERISK) {
	      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
	      isGlob = token.isGlob = true;
	      finished = true;

	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }

	    if (code === CHAR_QUESTION_MARK) {
	      isGlob = token.isGlob = true;
	      finished = true;

	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }

	    if (code === CHAR_LEFT_SQUARE_BRACKET) {
	      while (eos() !== true && (next = advance())) {
	        if (next === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }

	        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
	          isBracket = token.isBracket = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          break;
	        }
	      }

	      if (scanToEnd === true) {
	        continue;
	      }

	      break;
	    }

	    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
	      negated = token.negated = true;
	      start++;
	      continue;
	    }

	    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
	      isGlob = token.isGlob = true;

	      if (scanToEnd === true) {
	        while (eos() !== true && (code = advance())) {
	          if (code === CHAR_LEFT_PARENTHESES) {
	            backslashes = token.backslashes = true;
	            code = advance();
	            continue;
	          }

	          if (code === CHAR_RIGHT_PARENTHESES) {
	            finished = true;
	            break;
	          }
	        }
	        continue;
	      }
	      break;
	    }

	    if (isGlob === true) {
	      finished = true;

	      if (scanToEnd === true) {
	        continue;
	      }

	      break;
	    }
	  }

	  if (opts.noext === true) {
	    isExtglob = false;
	    isGlob = false;
	  }

	  let base = str;
	  let prefix = '';
	  let glob = '';

	  if (start > 0) {
	    prefix = str.slice(0, start);
	    str = str.slice(start);
	    lastIndex -= start;
	  }

	  if (base && isGlob === true && lastIndex > 0) {
	    base = str.slice(0, lastIndex);
	    glob = str.slice(lastIndex);
	  } else if (isGlob === true) {
	    base = '';
	    glob = str;
	  } else {
	    base = str;
	  }

	  if (base && base !== '' && base !== '/' && base !== str) {
	    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
	      base = base.slice(0, -1);
	    }
	  }

	  if (opts.unescape === true) {
	    if (glob) glob = utils.removeBackslashes(glob);

	    if (base && backslashes === true) {
	      base = utils.removeBackslashes(base);
	    }
	  }

	  const state = {
	    prefix,
	    input,
	    start,
	    base,
	    glob,
	    isBrace,
	    isBracket,
	    isGlob,
	    isExtglob,
	    isGlobstar,
	    negated,
	    negatedExtglob
	  };

	  if (opts.tokens === true) {
	    state.maxDepth = 0;
	    if (!isPathSeparator(code)) {
	      tokens.push(token);
	    }
	    state.tokens = tokens;
	  }

	  if (opts.parts === true || opts.tokens === true) {
	    let prevIndex;

	    for (let idx = 0; idx < slashes.length; idx++) {
	      const n = prevIndex ? prevIndex + 1 : start;
	      const i = slashes[idx];
	      const value = input.slice(n, i);
	      if (opts.tokens) {
	        if (idx === 0 && start !== 0) {
	          tokens[idx].isPrefix = true;
	          tokens[idx].value = prefix;
	        } else {
	          tokens[idx].value = value;
	        }
	        depth(tokens[idx]);
	        state.maxDepth += tokens[idx].depth;
	      }
	      if (idx !== 0 || value !== '') {
	        parts.push(value);
	      }
	      prevIndex = i;
	    }

	    if (prevIndex && prevIndex + 1 < input.length) {
	      const value = input.slice(prevIndex + 1);
	      parts.push(value);

	      if (opts.tokens) {
	        tokens[tokens.length - 1].value = value;
	        depth(tokens[tokens.length - 1]);
	        state.maxDepth += tokens[tokens.length - 1].depth;
	      }
	    }

	    state.slashes = slashes;
	    state.parts = parts;
	  }

	  return state;
	};

	scan_1 = scan;
	return scan_1;
}

var parse_1$3;
var hasRequiredParse$3;

function requireParse$3 () {
	if (hasRequiredParse$3) return parse_1$3;
	hasRequiredParse$3 = 1;

	const constants = /*@__PURE__*/ requireConstants();
	const utils = /*@__PURE__*/ requireUtils$1();

	/**
	 * Constants
	 */

	const {
	  MAX_LENGTH,
	  POSIX_REGEX_SOURCE,
	  REGEX_NON_SPECIAL_CHARS,
	  REGEX_SPECIAL_CHARS_BACKREF,
	  REPLACEMENTS
	} = constants;

	/**
	 * Helpers
	 */

	const expandRange = (args, options) => {
	  if (typeof options.expandRange === 'function') {
	    return options.expandRange(...args, options);
	  }

	  args.sort();
	  const value = `[${args.join('-')}]`;

	  try {
	    /* eslint-disable-next-line no-new */
	    new RegExp(value);
	  } catch (ex) {
	    return args.map(v => utils.escapeRegex(v)).join('..');
	  }

	  return value;
	};

	/**
	 * Create the message for a syntax error
	 */

	const syntaxError = (type, char) => {
	  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
	};

	/**
	 * Parse the given input string.
	 * @param {String} input
	 * @param {Object} options
	 * @return {Object}
	 */

	const parse = (input, options) => {
	  if (typeof input !== 'string') {
	    throw new TypeError('Expected a string');
	  }

	  input = REPLACEMENTS[input] || input;

	  const opts = { ...options };
	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

	  let len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }

	  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
	  const tokens = [bos];

	  const capture = opts.capture ? '' : '?:';

	  // create constants based on platform, for windows or posix
	  const PLATFORM_CHARS = constants.globChars(opts.windows);
	  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

	  const {
	    DOT_LITERAL,
	    PLUS_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOT_SLASH,
	    NO_DOTS_SLASH,
	    QMARK,
	    QMARK_NO_DOT,
	    STAR,
	    START_ANCHOR
	  } = PLATFORM_CHARS;

	  const globstar = opts => {
	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };

	  const nodot = opts.dot ? '' : NO_DOT;
	  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
	  let star = opts.bash === true ? globstar(opts) : STAR;

	  if (opts.capture) {
	    star = `(${star})`;
	  }

	  // minimatch options support
	  if (typeof opts.noext === 'boolean') {
	    opts.noextglob = opts.noext;
	  }

	  const state = {
	    input,
	    index: -1,
	    start: 0,
	    dot: opts.dot === true,
	    consumed: '',
	    output: '',
	    prefix: '',
	    backtrack: false,
	    negated: false,
	    brackets: 0,
	    braces: 0,
	    parens: 0,
	    quotes: 0,
	    globstar: false,
	    tokens
	  };

	  input = utils.removePrefix(input, state);
	  len = input.length;

	  const extglobs = [];
	  const braces = [];
	  const stack = [];
	  let prev = bos;
	  let value;

	  /**
	   * Tokenizing helpers
	   */

	  const eos = () => state.index === len - 1;
	  const peek = state.peek = (n = 1) => input[state.index + n];
	  const advance = state.advance = () => input[++state.index] || '';
	  const remaining = () => input.slice(state.index + 1);
	  const consume = (value = '', num = 0) => {
	    state.consumed += value;
	    state.index += num;
	  };

	  const append = token => {
	    state.output += token.output != null ? token.output : token.value;
	    consume(token.value);
	  };

	  const negate = () => {
	    let count = 1;

	    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
	      advance();
	      state.start++;
	      count++;
	    }

	    if (count % 2 === 0) {
	      return false;
	    }

	    state.negated = true;
	    state.start++;
	    return true;
	  };

	  const increment = type => {
	    state[type]++;
	    stack.push(type);
	  };

	  const decrement = type => {
	    state[type]--;
	    stack.pop();
	  };

	  /**
	   * Push tokens onto the tokens array. This helper speeds up
	   * tokenizing by 1) helping us avoid backtracking as much as possible,
	   * and 2) helping us avoid creating extra tokens when consecutive
	   * characters are plain text. This improves performance and simplifies
	   * lookbehinds.
	   */

	  const push = tok => {
	    if (prev.type === 'globstar') {
	      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
	      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

	      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
	        state.output = state.output.slice(0, -prev.output.length);
	        prev.type = 'star';
	        prev.value = '*';
	        prev.output = star;
	        state.output += prev.output;
	      }
	    }

	    if (extglobs.length && tok.type !== 'paren') {
	      extglobs[extglobs.length - 1].inner += tok.value;
	    }

	    if (tok.value || tok.output) append(tok);
	    if (prev && prev.type === 'text' && tok.type === 'text') {
	      prev.output = (prev.output || prev.value) + tok.value;
	      prev.value += tok.value;
	      return;
	    }

	    tok.prev = prev;
	    tokens.push(tok);
	    prev = tok;
	  };

	  const extglobOpen = (type, value) => {
	    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

	    token.prev = prev;
	    token.parens = state.parens;
	    token.output = state.output;
	    const output = (opts.capture ? '(' : '') + token.open;

	    increment('parens');
	    push({ type, value, output: state.output ? '' : ONE_CHAR });
	    push({ type: 'paren', extglob: true, value: advance(), output });
	    extglobs.push(token);
	  };

	  const extglobClose = token => {
	    let output = token.close + (opts.capture ? ')' : '');
	    let rest;

	    if (token.type === 'negate') {
	      let extglobStar = star;

	      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
	        extglobStar = globstar(opts);
	      }

	      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
	        output = token.close = `)$))${extglobStar}`;
	      }

	      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
	        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
	        // In this case, we need to parse the string and use it in the output of the original pattern.
	        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
	        //
	        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
	        const expression = parse(rest, { ...options, fastpaths: false }).output;

	        output = token.close = `)${expression})${extglobStar})`;
	      }

	      if (token.prev.type === 'bos') {
	        state.negatedExtglob = true;
	      }
	    }

	    push({ type: 'paren', extglob: true, value, output });
	    decrement('parens');
	  };

	  /**
	   * Fast paths
	   */

	  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
	    let backslashes = false;

	    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
	      if (first === '\\') {
	        backslashes = true;
	        return m;
	      }

	      if (first === '?') {
	        if (esc) {
	          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
	        }
	        if (index === 0) {
	          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
	        }
	        return QMARK.repeat(chars.length);
	      }

	      if (first === '.') {
	        return DOT_LITERAL.repeat(chars.length);
	      }

	      if (first === '*') {
	        if (esc) {
	          return esc + first + (rest ? star : '');
	        }
	        return star;
	      }
	      return esc ? m : `\\${m}`;
	    });

	    if (backslashes === true) {
	      if (opts.unescape === true) {
	        output = output.replace(/\\/g, '');
	      } else {
	        output = output.replace(/\\+/g, m => {
	          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
	        });
	      }
	    }

	    if (output === input && opts.contains === true) {
	      state.output = input;
	      return state;
	    }

	    state.output = utils.wrapOutput(output, state, options);
	    return state;
	  }

	  /**
	   * Tokenize input until we reach end-of-string
	   */

	  while (!eos()) {
	    value = advance();

	    if (value === '\u0000') {
	      continue;
	    }

	    /**
	     * Escaped characters
	     */

	    if (value === '\\') {
	      const next = peek();

	      if (next === '/' && opts.bash !== true) {
	        continue;
	      }

	      if (next === '.' || next === ';') {
	        continue;
	      }

	      if (!next) {
	        value += '\\';
	        push({ type: 'text', value });
	        continue;
	      }

	      // collapse slashes to reduce potential for exploits
	      const match = /^\\+/.exec(remaining());
	      let slashes = 0;

	      if (match && match[0].length > 2) {
	        slashes = match[0].length;
	        state.index += slashes;
	        if (slashes % 2 !== 0) {
	          value += '\\';
	        }
	      }

	      if (opts.unescape === true) {
	        value = advance();
	      } else {
	        value += advance();
	      }

	      if (state.brackets === 0) {
	        push({ type: 'text', value });
	        continue;
	      }
	    }

	    /**
	     * If we're inside a regex character class, continue
	     * until we reach the closing bracket.
	     */

	    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
	      if (opts.posix !== false && value === ':') {
	        const inner = prev.value.slice(1);
	        if (inner.includes('[')) {
	          prev.posix = true;

	          if (inner.includes(':')) {
	            const idx = prev.value.lastIndexOf('[');
	            const pre = prev.value.slice(0, idx);
	            const rest = prev.value.slice(idx + 2);
	            const posix = POSIX_REGEX_SOURCE[rest];
	            if (posix) {
	              prev.value = pre + posix;
	              state.backtrack = true;
	              advance();

	              if (!bos.output && tokens.indexOf(prev) === 1) {
	                bos.output = ONE_CHAR;
	              }
	              continue;
	            }
	          }
	        }
	      }

	      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
	        value = `\\${value}`;
	      }

	      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
	        value = `\\${value}`;
	      }

	      if (opts.posix === true && value === '!' && prev.value === '[') {
	        value = '^';
	      }

	      prev.value += value;
	      append({ value });
	      continue;
	    }

	    /**
	     * If we're inside a quoted string, continue
	     * until we reach the closing double quote.
	     */

	    if (state.quotes === 1 && value !== '"') {
	      value = utils.escapeRegex(value);
	      prev.value += value;
	      append({ value });
	      continue;
	    }

	    /**
	     * Double quotes
	     */

	    if (value === '"') {
	      state.quotes = state.quotes === 1 ? 0 : 1;
	      if (opts.keepQuotes === true) {
	        push({ type: 'text', value });
	      }
	      continue;
	    }

	    /**
	     * Parentheses
	     */

	    if (value === '(') {
	      increment('parens');
	      push({ type: 'paren', value });
	      continue;
	    }

	    if (value === ')') {
	      if (state.parens === 0 && opts.strictBrackets === true) {
	        throw new SyntaxError(syntaxError('opening', '('));
	      }

	      const extglob = extglobs[extglobs.length - 1];
	      if (extglob && state.parens === extglob.parens + 1) {
	        extglobClose(extglobs.pop());
	        continue;
	      }

	      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
	      decrement('parens');
	      continue;
	    }

	    /**
	     * Square brackets
	     */

	    if (value === '[') {
	      if (opts.nobracket === true || !remaining().includes(']')) {
	        if (opts.nobracket !== true && opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError('closing', ']'));
	        }

	        value = `\\${value}`;
	      } else {
	        increment('brackets');
	      }

	      push({ type: 'bracket', value });
	      continue;
	    }

	    if (value === ']') {
	      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
	        push({ type: 'text', value, output: `\\${value}` });
	        continue;
	      }

	      if (state.brackets === 0) {
	        if (opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError('opening', '['));
	        }

	        push({ type: 'text', value, output: `\\${value}` });
	        continue;
	      }

	      decrement('brackets');

	      const prevValue = prev.value.slice(1);
	      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
	        value = `/${value}`;
	      }

	      prev.value += value;
	      append({ value });

	      // when literal brackets are explicitly disabled
	      // assume we should match with a regex character class
	      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
	        continue;
	      }

	      const escaped = utils.escapeRegex(prev.value);
	      state.output = state.output.slice(0, -prev.value.length);

	      // when literal brackets are explicitly enabled
	      // assume we should escape the brackets to match literal characters
	      if (opts.literalBrackets === true) {
	        state.output += escaped;
	        prev.value = escaped;
	        continue;
	      }

	      // when the user specifies nothing, try to match both
	      prev.value = `(${capture}${escaped}|${prev.value})`;
	      state.output += prev.value;
	      continue;
	    }

	    /**
	     * Braces
	     */

	    if (value === '{' && opts.nobrace !== true) {
	      increment('braces');

	      const open = {
	        type: 'brace',
	        value,
	        output: '(',
	        outputIndex: state.output.length,
	        tokensIndex: state.tokens.length
	      };

	      braces.push(open);
	      push(open);
	      continue;
	    }

	    if (value === '}') {
	      const brace = braces[braces.length - 1];

	      if (opts.nobrace === true || !brace) {
	        push({ type: 'text', value, output: value });
	        continue;
	      }

	      let output = ')';

	      if (brace.dots === true) {
	        const arr = tokens.slice();
	        const range = [];

	        for (let i = arr.length - 1; i >= 0; i--) {
	          tokens.pop();
	          if (arr[i].type === 'brace') {
	            break;
	          }
	          if (arr[i].type !== 'dots') {
	            range.unshift(arr[i].value);
	          }
	        }

	        output = expandRange(range, opts);
	        state.backtrack = true;
	      }

	      if (brace.comma !== true && brace.dots !== true) {
	        const out = state.output.slice(0, brace.outputIndex);
	        const toks = state.tokens.slice(brace.tokensIndex);
	        brace.value = brace.output = '\\{';
	        value = output = '\\}';
	        state.output = out;
	        for (const t of toks) {
	          state.output += (t.output || t.value);
	        }
	      }

	      push({ type: 'brace', value, output });
	      decrement('braces');
	      braces.pop();
	      continue;
	    }

	    /**
	     * Pipes
	     */

	    if (value === '|') {
	      if (extglobs.length > 0) {
	        extglobs[extglobs.length - 1].conditions++;
	      }
	      push({ type: 'text', value });
	      continue;
	    }

	    /**
	     * Commas
	     */

	    if (value === ',') {
	      let output = value;

	      const brace = braces[braces.length - 1];
	      if (brace && stack[stack.length - 1] === 'braces') {
	        brace.comma = true;
	        output = '|';
	      }

	      push({ type: 'comma', value, output });
	      continue;
	    }

	    /**
	     * Slashes
	     */

	    if (value === '/') {
	      // if the beginning of the glob is "./", advance the start
	      // to the current index, and don't add the "./" characters
	      // to the state. This greatly simplifies lookbehinds when
	      // checking for BOS characters like "!" and "." (not "./")
	      if (prev.type === 'dot' && state.index === state.start + 1) {
	        state.start = state.index + 1;
	        state.consumed = '';
	        state.output = '';
	        tokens.pop();
	        prev = bos; // reset "prev" to the first token
	        continue;
	      }

	      push({ type: 'slash', value, output: SLASH_LITERAL });
	      continue;
	    }

	    /**
	     * Dots
	     */

	    if (value === '.') {
	      if (state.braces > 0 && prev.type === 'dot') {
	        if (prev.value === '.') prev.output = DOT_LITERAL;
	        const brace = braces[braces.length - 1];
	        prev.type = 'dots';
	        prev.output += value;
	        prev.value += value;
	        brace.dots = true;
	        continue;
	      }

	      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
	        push({ type: 'text', value, output: DOT_LITERAL });
	        continue;
	      }

	      push({ type: 'dot', value, output: DOT_LITERAL });
	      continue;
	    }

	    /**
	     * Question marks
	     */

	    if (value === '?') {
	      const isGroup = prev && prev.value === '(';
	      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        extglobOpen('qmark', value);
	        continue;
	      }

	      if (prev && prev.type === 'paren') {
	        const next = peek();
	        let output = value;

	        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
	          output = `\\${value}`;
	        }

	        push({ type: 'text', value, output });
	        continue;
	      }

	      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
	        push({ type: 'qmark', value, output: QMARK_NO_DOT });
	        continue;
	      }

	      push({ type: 'qmark', value, output: QMARK });
	      continue;
	    }

	    /**
	     * Exclamation
	     */

	    if (value === '!') {
	      if (opts.noextglob !== true && peek() === '(') {
	        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
	          extglobOpen('negate', value);
	          continue;
	        }
	      }

	      if (opts.nonegate !== true && state.index === 0) {
	        negate();
	        continue;
	      }
	    }

	    /**
	     * Plus
	     */

	    if (value === '+') {
	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        extglobOpen('plus', value);
	        continue;
	      }

	      if ((prev && prev.value === '(') || opts.regex === false) {
	        push({ type: 'plus', value, output: PLUS_LITERAL });
	        continue;
	      }

	      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
	        push({ type: 'plus', value });
	        continue;
	      }

	      push({ type: 'plus', value: PLUS_LITERAL });
	      continue;
	    }

	    /**
	     * Plain text
	     */

	    if (value === '@') {
	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        push({ type: 'at', extglob: true, value, output: '' });
	        continue;
	      }

	      push({ type: 'text', value });
	      continue;
	    }

	    /**
	     * Plain text
	     */

	    if (value !== '*') {
	      if (value === '$' || value === '^') {
	        value = `\\${value}`;
	      }

	      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
	      if (match) {
	        value += match[0];
	        state.index += match[0].length;
	      }

	      push({ type: 'text', value });
	      continue;
	    }

	    /**
	     * Stars
	     */

	    if (prev && (prev.type === 'globstar' || prev.star === true)) {
	      prev.type = 'star';
	      prev.star = true;
	      prev.value += value;
	      prev.output = star;
	      state.backtrack = true;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }

	    let rest = remaining();
	    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
	      extglobOpen('star', value);
	      continue;
	    }

	    if (prev.type === 'star') {
	      if (opts.noglobstar === true) {
	        consume(value);
	        continue;
	      }

	      const prior = prev.prev;
	      const before = prior.prev;
	      const isStart = prior.type === 'slash' || prior.type === 'bos';
	      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

	      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
	        push({ type: 'star', value, output: '' });
	        continue;
	      }

	      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
	      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
	      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
	        push({ type: 'star', value, output: '' });
	        continue;
	      }

	      // strip consecutive `/**/`
	      while (rest.slice(0, 3) === '/**') {
	        const after = input[state.index + 4];
	        if (after && after !== '/') {
	          break;
	        }
	        rest = rest.slice(3);
	        consume('/**', 3);
	      }

	      if (prior.type === 'bos' && eos()) {
	        prev.type = 'globstar';
	        prev.value += value;
	        prev.output = globstar(opts);
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value);
	        continue;
	      }

	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;

	        prev.type = 'globstar';
	        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
	        prev.value += value;
	        state.globstar = true;
	        state.output += prior.output + prev.output;
	        consume(value);
	        continue;
	      }

	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
	        const end = rest[1] !== void 0 ? '|$' : '';

	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;

	        prev.type = 'globstar';
	        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
	        prev.value += value;

	        state.output += prior.output + prev.output;
	        state.globstar = true;

	        consume(value + advance());

	        push({ type: 'slash', value: '/', output: '' });
	        continue;
	      }

	      if (prior.type === 'bos' && rest[0] === '/') {
	        prev.type = 'globstar';
	        prev.value += value;
	        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value + advance());
	        push({ type: 'slash', value: '/', output: '' });
	        continue;
	      }

	      // remove single star from output
	      state.output = state.output.slice(0, -prev.output.length);

	      // reset previous token to globstar
	      prev.type = 'globstar';
	      prev.output = globstar(opts);
	      prev.value += value;

	      // reset output with globstar
	      state.output += prev.output;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }

	    const token = { type: 'star', value, output: star };

	    if (opts.bash === true) {
	      token.output = '.*?';
	      if (prev.type === 'bos' || prev.type === 'slash') {
	        token.output = nodot + token.output;
	      }
	      push(token);
	      continue;
	    }

	    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
	      token.output = value;
	      push(token);
	      continue;
	    }

	    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
	      if (prev.type === 'dot') {
	        state.output += NO_DOT_SLASH;
	        prev.output += NO_DOT_SLASH;

	      } else if (opts.dot === true) {
	        state.output += NO_DOTS_SLASH;
	        prev.output += NO_DOTS_SLASH;

	      } else {
	        state.output += nodot;
	        prev.output += nodot;
	      }

	      if (peek() !== '*') {
	        state.output += ONE_CHAR;
	        prev.output += ONE_CHAR;
	      }
	    }

	    push(token);
	  }

	  while (state.brackets > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
	    state.output = utils.escapeLast(state.output, '[');
	    decrement('brackets');
	  }

	  while (state.parens > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
	    state.output = utils.escapeLast(state.output, '(');
	    decrement('parens');
	  }

	  while (state.braces > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
	    state.output = utils.escapeLast(state.output, '{');
	    decrement('braces');
	  }

	  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
	    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
	  }

	  // rebuild the output if we had to backtrack at any point
	  if (state.backtrack === true) {
	    state.output = '';

	    for (const token of state.tokens) {
	      state.output += token.output != null ? token.output : token.value;

	      if (token.suffix) {
	        state.output += token.suffix;
	      }
	    }
	  }

	  return state;
	};

	/**
	 * Fast paths for creating regular expressions for common glob patterns.
	 * This can significantly speed up processing and has very little downside
	 * impact when none of the fast paths match.
	 */

	parse.fastpaths = (input, options) => {
	  const opts = { ...options };
	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
	  const len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }

	  input = REPLACEMENTS[input] || input;

	  // create constants based on platform, for windows or posix
	  const {
	    DOT_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOTS,
	    NO_DOTS_SLASH,
	    STAR,
	    START_ANCHOR
	  } = constants.globChars(opts.windows);

	  const nodot = opts.dot ? NO_DOTS : NO_DOT;
	  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
	  const capture = opts.capture ? '' : '?:';
	  const state = { negated: false, prefix: '' };
	  let star = opts.bash === true ? '.*?' : STAR;

	  if (opts.capture) {
	    star = `(${star})`;
	  }

	  const globstar = opts => {
	    if (opts.noglobstar === true) return star;
	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };

	  const create = str => {
	    switch (str) {
	      case '*':
	        return `${nodot}${ONE_CHAR}${star}`;

	      case '.*':
	        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

	      case '*.*':
	        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

	      case '*/*':
	        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

	      case '**':
	        return nodot + globstar(opts);

	      case '**/*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

	      case '**/*.*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

	      case '**/.*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

	      default: {
	        const match = /^(.*?)\.(\w+)$/.exec(str);
	        if (!match) return;

	        const source = create(match[1]);
	        if (!source) return;

	        return source + DOT_LITERAL + match[2];
	      }
	    }
	  };

	  const output = utils.removePrefix(input, state);
	  let source = create(output);

	  if (source && opts.strictSlashes !== true) {
	    source += `${SLASH_LITERAL}?`;
	  }

	  return source;
	};

	parse_1$3 = parse;
	return parse_1$3;
}

var picomatch_1$1;
var hasRequiredPicomatch$1;

function requirePicomatch$1 () {
	if (hasRequiredPicomatch$1) return picomatch_1$1;
	hasRequiredPicomatch$1 = 1;

	const scan = /*@__PURE__*/ requireScan();
	const parse = /*@__PURE__*/ requireParse$3();
	const utils = /*@__PURE__*/ requireUtils$1();
	const constants = /*@__PURE__*/ requireConstants();
	const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

	/**
	 * Creates a matcher function from one or more glob patterns. The
	 * returned function takes a string to match as its first argument,
	 * and returns true if the string is a match. The returned matcher
	 * function also takes a boolean as the second argument that, when true,
	 * returns an object with additional information.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch(glob[, options]);
	 *
	 * const isMatch = picomatch('*.!(*a)');
	 * console.log(isMatch('a.a')); //=> false
	 * console.log(isMatch('a.b')); //=> true
	 * ```
	 * @name picomatch
	 * @param {String|Array} `globs` One or more glob patterns.
	 * @param {Object=} `options`
	 * @return {Function=} Returns a matcher function.
	 * @api public
	 */

	const picomatch = (glob, options, returnState = false) => {
	  if (Array.isArray(glob)) {
	    const fns = glob.map(input => picomatch(input, options, returnState));
	    const arrayMatcher = str => {
	      for (const isMatch of fns) {
	        const state = isMatch(str);
	        if (state) return state;
	      }
	      return false;
	    };
	    return arrayMatcher;
	  }

	  const isState = isObject(glob) && glob.tokens && glob.input;

	  if (glob === '' || (typeof glob !== 'string' && !isState)) {
	    throw new TypeError('Expected pattern to be a non-empty string');
	  }

	  const opts = options || {};
	  const posix = opts.windows;
	  const regex = isState
	    ? picomatch.compileRe(glob, options)
	    : picomatch.makeRe(glob, options, false, true);

	  const state = regex.state;
	  delete regex.state;

	  let isIgnored = () => false;
	  if (opts.ignore) {
	    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
	    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
	  }

	  const matcher = (input, returnObject = false) => {
	    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
	    const result = { glob, state, regex, posix, input, output, match, isMatch };

	    if (typeof opts.onResult === 'function') {
	      opts.onResult(result);
	    }

	    if (isMatch === false) {
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }

	    if (isIgnored(input)) {
	      if (typeof opts.onIgnore === 'function') {
	        opts.onIgnore(result);
	      }
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }

	    if (typeof opts.onMatch === 'function') {
	      opts.onMatch(result);
	    }
	    return returnObject ? result : true;
	  };

	  if (returnState) {
	    matcher.state = state;
	  }

	  return matcher;
	};

	/**
	 * Test `input` with the given `regex`. This is used by the main
	 * `picomatch()` function to test the input string.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.test(input, regex[, options]);
	 *
	 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
	 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
	 * ```
	 * @param {String} `input` String to test.
	 * @param {RegExp} `regex`
	 * @return {Object} Returns an object with matching info.
	 * @api public
	 */

	picomatch.test = (input, regex, options, { glob, posix } = {}) => {
	  if (typeof input !== 'string') {
	    throw new TypeError('Expected input to be a string');
	  }

	  if (input === '') {
	    return { isMatch: false, output: '' };
	  }

	  const opts = options || {};
	  const format = opts.format || (posix ? utils.toPosixSlashes : null);
	  let match = input === glob;
	  let output = (match && format) ? format(input) : input;

	  if (match === false) {
	    output = format ? format(input) : input;
	    match = output === glob;
	  }

	  if (match === false || opts.capture === true) {
	    if (opts.matchBase === true || opts.basename === true) {
	      match = picomatch.matchBase(input, regex, options, posix);
	    } else {
	      match = regex.exec(output);
	    }
	  }

	  return { isMatch: Boolean(match), match, output };
	};

	/**
	 * Match the basename of a filepath.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.matchBase(input, glob[, options]);
	 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
	 * ```
	 * @param {String} `input` String to test.
	 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
	 * @return {Boolean}
	 * @api public
	 */

	picomatch.matchBase = (input, glob, options) => {
	  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
	  return regex.test(utils.basename(input));
	};

	/**
	 * Returns true if **any** of the given glob `patterns` match the specified `string`.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.isMatch(string, patterns[, options]);
	 *
	 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
	 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
	 * ```
	 * @param {String|Array} str The string to test.
	 * @param {String|Array} patterns One or more glob patterns to use for matching.
	 * @param {Object} [options] See available [options](#options).
	 * @return {Boolean} Returns true if any patterns match `str`
	 * @api public
	 */

	picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

	/**
	 * Parse a glob pattern to create the source string for a regular
	 * expression.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * const result = picomatch.parse(pattern[, options]);
	 * ```
	 * @param {String} `pattern`
	 * @param {Object} `options`
	 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
	 * @api public
	 */

	picomatch.parse = (pattern, options) => {
	  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
	  return parse(pattern, { ...options, fastpaths: false });
	};

	/**
	 * Scan a glob pattern to separate the pattern into segments.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.scan(input[, options]);
	 *
	 * const result = picomatch.scan('!./foo/*.js');
	 * console.log(result);
	 * { prefix: '!./',
	 *   input: '!./foo/*.js',
	 *   start: 3,
	 *   base: 'foo',
	 *   glob: '*.js',
	 *   isBrace: false,
	 *   isBracket: false,
	 *   isGlob: true,
	 *   isExtglob: false,
	 *   isGlobstar: false,
	 *   negated: true }
	 * ```
	 * @param {String} `input` Glob pattern to scan.
	 * @param {Object} `options`
	 * @return {Object} Returns an object with
	 * @api public
	 */

	picomatch.scan = (input, options) => scan(input, options);

	/**
	 * Compile a regular expression from the `state` object returned by the
	 * [parse()](#parse) method.
	 *
	 * @param {Object} `state`
	 * @param {Object} `options`
	 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
	 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
	 * @return {RegExp}
	 * @api public
	 */

	picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
	  if (returnOutput === true) {
	    return state.output;
	  }

	  const opts = options || {};
	  const prepend = opts.contains ? '' : '^';
	  const append = opts.contains ? '' : '$';

	  let source = `${prepend}(?:${state.output})${append}`;
	  if (state && state.negated === true) {
	    source = `^(?!${source}).*$`;
	  }

	  const regex = picomatch.toRegex(source, options);
	  if (returnState === true) {
	    regex.state = state;
	  }

	  return regex;
	};

	/**
	 * Create a regular expression from a parsed glob pattern.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * const state = picomatch.parse('*.js');
	 * // picomatch.compileRe(state[, options]);
	 *
	 * console.log(picomatch.compileRe(state));
	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	 * ```
	 * @param {String} `state` The object returned from the `.parse` method.
	 * @param {Object} `options`
	 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
	 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
	 * @return {RegExp} Returns a regex created from the given pattern.
	 * @api public
	 */

	picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
	  if (!input || typeof input !== 'string') {
	    throw new TypeError('Expected a non-empty string');
	  }

	  let parsed = { negated: false, fastpaths: true };

	  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
	    parsed.output = parse.fastpaths(input, options);
	  }

	  if (!parsed.output) {
	    parsed = parse(input, options);
	  }

	  return picomatch.compileRe(parsed, options, returnOutput, returnState);
	};

	/**
	 * Create a regular expression from the given regex source string.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.toRegex(source[, options]);
	 *
	 * const { output } = picomatch.parse('*.js');
	 * console.log(picomatch.toRegex(output));
	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	 * ```
	 * @param {String} `source` Regular expression source string.
	 * @param {Object} `options`
	 * @return {RegExp}
	 * @api public
	 */

	picomatch.toRegex = (source, options) => {
	  try {
	    const opts = options || {};
	    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
	  } catch (err) {
	    if (options && options.debug === true) throw err;
	    return /$^/;
	  }
	};

	/**
	 * Picomatch constants.
	 * @return {Object}
	 */

	picomatch.constants = constants;

	/**
	 * Expose "picomatch"
	 */

	picomatch_1$1 = picomatch;
	return picomatch_1$1;
}

var picomatch_1;
var hasRequiredPicomatch;

function requirePicomatch () {
	if (hasRequiredPicomatch) return picomatch_1;
	hasRequiredPicomatch = 1;

	const pico = /*@__PURE__*/ requirePicomatch$1();
	const utils = /*@__PURE__*/ requireUtils$1();

	function picomatch(glob, options, returnState = false) {
	  // default to os.platform()
	  if (options && (options.windows === null || options.windows === undefined)) {
	    // don't mutate the original options object
	    options = { ...options, windows: utils.isWindows() };
	  }

	  return pico(glob, options, returnState);
	}

	Object.assign(picomatch, pico);
	picomatch_1 = picomatch;
	return picomatch_1;
}

var picomatchExports = /*@__PURE__*/ requirePicomatch();
const pm$1 = /*@__PURE__*/getDefaultExportFromCjs$1(picomatchExports);

var main$1;
var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main$1;
	hasRequiredMain = 1;
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __export = (target, all) => {
	  for (var name in all)
	    __defProp(target, name, { get: all[name], enumerable: true });
	};
	var __copyProps = (to, from, except, desc) => {
	  if (from && typeof from === "object" || typeof from === "function") {
	    for (let key of __getOwnPropNames(from))
	      if (!__hasOwnProp.call(to, key) && key !== except)
	        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
	  }
	  return to;
	};
	var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

	// lib/npm/node.ts
	var node_exports = {};
	__export(node_exports, {
	  analyzeMetafile: () => analyzeMetafile,
	  analyzeMetafileSync: () => analyzeMetafileSync,
	  build: () => build,
	  buildSync: () => buildSync,
	  context: () => context,
	  default: () => node_default,
	  formatMessages: () => formatMessages,
	  formatMessagesSync: () => formatMessagesSync,
	  initialize: () => initialize,
	  stop: () => stop,
	  transform: () => transform,
	  transformSync: () => transformSync,
	  version: () => version
	});
	main$1 = __toCommonJS(node_exports);

	// lib/shared/stdio_protocol.ts
	function encodePacket(packet) {
	  let visit = (value) => {
	    if (value === null) {
	      bb.write8(0);
	    } else if (typeof value === "boolean") {
	      bb.write8(1);
	      bb.write8(+value);
	    } else if (typeof value === "number") {
	      bb.write8(2);
	      bb.write32(value | 0);
	    } else if (typeof value === "string") {
	      bb.write8(3);
	      bb.write(encodeUTF8(value));
	    } else if (value instanceof Uint8Array) {
	      bb.write8(4);
	      bb.write(value);
	    } else if (value instanceof Array) {
	      bb.write8(5);
	      bb.write32(value.length);
	      for (let item of value) {
	        visit(item);
	      }
	    } else {
	      let keys = Object.keys(value);
	      bb.write8(6);
	      bb.write32(keys.length);
	      for (let key of keys) {
	        bb.write(encodeUTF8(key));
	        visit(value[key]);
	      }
	    }
	  };
	  let bb = new ByteBuffer();
	  bb.write32(0);
	  bb.write32(packet.id << 1 | +!packet.isRequest);
	  visit(packet.value);
	  writeUInt32LE(bb.buf, bb.len - 4, 0);
	  return bb.buf.subarray(0, bb.len);
	}
	function decodePacket(bytes) {
	  let visit = () => {
	    switch (bb.read8()) {
	      case 0:
	        return null;
	      case 1:
	        return !!bb.read8();
	      case 2:
	        return bb.read32();
	      case 3:
	        return decodeUTF8(bb.read());
	      case 4:
	        return bb.read();
	      case 5: {
	        let count = bb.read32();
	        let value2 = [];
	        for (let i = 0; i < count; i++) {
	          value2.push(visit());
	        }
	        return value2;
	      }
	      case 6: {
	        let count = bb.read32();
	        let value2 = {};
	        for (let i = 0; i < count; i++) {
	          value2[decodeUTF8(bb.read())] = visit();
	        }
	        return value2;
	      }
	      default:
	        throw new Error("Invalid packet");
	    }
	  };
	  let bb = new ByteBuffer(bytes);
	  let id = bb.read32();
	  let isRequest = (id & 1) === 0;
	  id >>>= 1;
	  let value = visit();
	  if (bb.ptr !== bytes.length) {
	    throw new Error("Invalid packet");
	  }
	  return { id, isRequest, value };
	}
	var ByteBuffer = class {
	  constructor(buf = new Uint8Array(1024)) {
	    this.buf = buf;
	    this.len = 0;
	    this.ptr = 0;
	  }
	  _write(delta) {
	    if (this.len + delta > this.buf.length) {
	      let clone = new Uint8Array((this.len + delta) * 2);
	      clone.set(this.buf);
	      this.buf = clone;
	    }
	    this.len += delta;
	    return this.len - delta;
	  }
	  write8(value) {
	    let offset = this._write(1);
	    this.buf[offset] = value;
	  }
	  write32(value) {
	    let offset = this._write(4);
	    writeUInt32LE(this.buf, value, offset);
	  }
	  write(bytes) {
	    let offset = this._write(4 + bytes.length);
	    writeUInt32LE(this.buf, bytes.length, offset);
	    this.buf.set(bytes, offset + 4);
	  }
	  _read(delta) {
	    if (this.ptr + delta > this.buf.length) {
	      throw new Error("Invalid packet");
	    }
	    this.ptr += delta;
	    return this.ptr - delta;
	  }
	  read8() {
	    return this.buf[this._read(1)];
	  }
	  read32() {
	    return readUInt32LE(this.buf, this._read(4));
	  }
	  read() {
	    let length = this.read32();
	    let bytes = new Uint8Array(length);
	    let ptr = this._read(bytes.length);
	    bytes.set(this.buf.subarray(ptr, ptr + length));
	    return bytes;
	  }
	};
	var encodeUTF8;
	var decodeUTF8;
	var encodeInvariant;
	if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
	  let encoder = new TextEncoder();
	  let decoder = new TextDecoder();
	  encodeUTF8 = (text) => encoder.encode(text);
	  decodeUTF8 = (bytes) => decoder.decode(bytes);
	  encodeInvariant = 'new TextEncoder().encode("")';
	} else if (typeof Buffer !== "undefined") {
	  encodeUTF8 = (text) => Buffer.from(text);
	  decodeUTF8 = (bytes) => {
	    let { buffer, byteOffset, byteLength } = bytes;
	    return Buffer.from(buffer, byteOffset, byteLength).toString();
	  };
	  encodeInvariant = 'Buffer.from("")';
	} else {
	  throw new Error("No UTF-8 codec found");
	}
	if (!(encodeUTF8("") instanceof Uint8Array))
	  throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
	function readUInt32LE(buffer, offset) {
	  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
	}
	function writeUInt32LE(buffer, value, offset) {
	  buffer[offset++] = value;
	  buffer[offset++] = value >> 8;
	  buffer[offset++] = value >> 16;
	  buffer[offset++] = value >> 24;
	}

	// lib/shared/common.ts
	var quote = JSON.stringify;
	var buildLogLevelDefault = "warning";
	var transformLogLevelDefault = "silent";
	function validateAndJoinStringArray(values, what) {
	  const toJoin = [];
	  for (const value of values) {
	    validateStringValue(value, what);
	    if (value.indexOf(",") >= 0) throw new Error(`Invalid ${what}: ${value}`);
	    toJoin.push(value);
	  }
	  return toJoin.join(",");
	}
	var canBeAnything = () => null;
	var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
	var mustBeString = (value) => typeof value === "string" ? null : "a string";
	var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
	var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
	var mustBeValidPortNumber = (value) => typeof value === "number" && value === (value | 0) && value >= 0 && value <= 65535 ? null : "a valid port number";
	var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
	var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
	var mustBeArrayOfStrings = (value) => Array.isArray(value) && value.every((x) => typeof x === "string") ? null : "an array of strings";
	var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
	var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
	var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
	var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
	var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
	var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
	var mustBeStringOrArrayOfStrings = (value) => typeof value === "string" || Array.isArray(value) && value.every((x) => typeof x === "string") ? null : "a string or an array of strings";
	var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
	var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
	function getFlag(object, keys, key, mustBeFn) {
	  let value = object[key];
	  keys[key + ""] = true;
	  if (value === void 0) return void 0;
	  let mustBe = mustBeFn(value);
	  if (mustBe !== null) throw new Error(`${quote(key)} must be ${mustBe}`);
	  return value;
	}
	function checkForInvalidFlags(object, keys, where) {
	  for (let key in object) {
	    if (!(key in keys)) {
	      throw new Error(`Invalid option ${where}: ${quote(key)}`);
	    }
	  }
	}
	function validateInitializeOptions(options) {
	  let keys = /* @__PURE__ */ Object.create(null);
	  let wasmURL = getFlag(options, keys, "wasmURL", mustBeStringOrURL);
	  let wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
	  let worker = getFlag(options, keys, "worker", mustBeBoolean);
	  checkForInvalidFlags(options, keys, "in initialize() call");
	  return {
	    wasmURL,
	    wasmModule,
	    worker
	  };
	}
	function validateMangleCache(mangleCache) {
	  let validated;
	  if (mangleCache !== void 0) {
	    validated = /* @__PURE__ */ Object.create(null);
	    for (let key in mangleCache) {
	      let value = mangleCache[key];
	      if (typeof value === "string" || value === false) {
	        validated[key] = value;
	      } else {
	        throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
	      }
	    }
	  }
	  return validated;
	}
	function pushLogFlags(flags, options, keys, isTTY2, logLevelDefault) {
	  let color = getFlag(options, keys, "color", mustBeBoolean);
	  let logLevel = getFlag(options, keys, "logLevel", mustBeString);
	  let logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
	  if (color !== void 0) flags.push(`--color=${color}`);
	  else if (isTTY2) flags.push(`--color=true`);
	  flags.push(`--log-level=${logLevel || logLevelDefault}`);
	  flags.push(`--log-limit=${logLimit || 0}`);
	}
	function validateStringValue(value, what, key) {
	  if (typeof value !== "string") {
	    throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
	  }
	  return value;
	}
	function pushCommonFlags(flags, options, keys) {
	  let legalComments = getFlag(options, keys, "legalComments", mustBeString);
	  let sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
	  let sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
	  let target = getFlag(options, keys, "target", mustBeStringOrArrayOfStrings);
	  let format = getFlag(options, keys, "format", mustBeString);
	  let globalName = getFlag(options, keys, "globalName", mustBeString);
	  let mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
	  let reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
	  let mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
	  let minify = getFlag(options, keys, "minify", mustBeBoolean);
	  let minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
	  let minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
	  let minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
	  let lineLimit = getFlag(options, keys, "lineLimit", mustBeInteger);
	  let drop = getFlag(options, keys, "drop", mustBeArrayOfStrings);
	  let dropLabels = getFlag(options, keys, "dropLabels", mustBeArrayOfStrings);
	  let charset = getFlag(options, keys, "charset", mustBeString);
	  let treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
	  let ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
	  let jsx = getFlag(options, keys, "jsx", mustBeString);
	  let jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
	  let jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
	  let jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
	  let jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
	  let jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
	  let define = getFlag(options, keys, "define", mustBeObject);
	  let logOverride = getFlag(options, keys, "logOverride", mustBeObject);
	  let supported = getFlag(options, keys, "supported", mustBeObject);
	  let pure = getFlag(options, keys, "pure", mustBeArrayOfStrings);
	  let keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
	  let platform = getFlag(options, keys, "platform", mustBeString);
	  let tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
	  let absPaths = getFlag(options, keys, "absPaths", mustBeArrayOfStrings);
	  if (legalComments) flags.push(`--legal-comments=${legalComments}`);
	  if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);
	  if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);
	  if (target) flags.push(`--target=${validateAndJoinStringArray(Array.isArray(target) ? target : [target], "target")}`);
	  if (format) flags.push(`--format=${format}`);
	  if (globalName) flags.push(`--global-name=${globalName}`);
	  if (platform) flags.push(`--platform=${platform}`);
	  if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
	  if (minify) flags.push("--minify");
	  if (minifySyntax) flags.push("--minify-syntax");
	  if (minifyWhitespace) flags.push("--minify-whitespace");
	  if (minifyIdentifiers) flags.push("--minify-identifiers");
	  if (lineLimit) flags.push(`--line-limit=${lineLimit}`);
	  if (charset) flags.push(`--charset=${charset}`);
	  if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);
	  if (ignoreAnnotations) flags.push(`--ignore-annotations`);
	  if (drop) for (let what of drop) flags.push(`--drop:${validateStringValue(what, "drop")}`);
	  if (dropLabels) flags.push(`--drop-labels=${validateAndJoinStringArray(dropLabels, "drop label")}`);
	  if (absPaths) flags.push(`--abs-paths=${validateAndJoinStringArray(absPaths, "abs paths")}`);
	  if (mangleProps) flags.push(`--mangle-props=${jsRegExpToGoRegExp(mangleProps)}`);
	  if (reserveProps) flags.push(`--reserve-props=${jsRegExpToGoRegExp(reserveProps)}`);
	  if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);
	  if (jsx) flags.push(`--jsx=${jsx}`);
	  if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);
	  if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);
	  if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);
	  if (jsxDev) flags.push(`--jsx-dev`);
	  if (jsxSideEffects) flags.push(`--jsx-side-effects`);
	  if (define) {
	    for (let key in define) {
	      if (key.indexOf("=") >= 0) throw new Error(`Invalid define: ${key}`);
	      flags.push(`--define:${key}=${validateStringValue(define[key], "define", key)}`);
	    }
	  }
	  if (logOverride) {
	    for (let key in logOverride) {
	      if (key.indexOf("=") >= 0) throw new Error(`Invalid log override: ${key}`);
	      flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
	    }
	  }
	  if (supported) {
	    for (let key in supported) {
	      if (key.indexOf("=") >= 0) throw new Error(`Invalid supported: ${key}`);
	      const value = supported[key];
	      if (typeof value !== "boolean") throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
	      flags.push(`--supported:${key}=${value}`);
	    }
	  }
	  if (pure) for (let fn of pure) flags.push(`--pure:${validateStringValue(fn, "pure")}`);
	  if (keepNames) flags.push(`--keep-names`);
	}
	function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
	  var _a2;
	  let flags = [];
	  let entries = [];
	  let keys = /* @__PURE__ */ Object.create(null);
	  let stdinContents = null;
	  let stdinResolveDir = null;
	  pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
	  pushCommonFlags(flags, options, keys);
	  let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
	  let bundle = getFlag(options, keys, "bundle", mustBeBoolean);
	  let splitting = getFlag(options, keys, "splitting", mustBeBoolean);
	  let preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
	  let metafile = getFlag(options, keys, "metafile", mustBeBoolean);
	  let outfile = getFlag(options, keys, "outfile", mustBeString);
	  let outdir = getFlag(options, keys, "outdir", mustBeString);
	  let outbase = getFlag(options, keys, "outbase", mustBeString);
	  let tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
	  let resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArrayOfStrings);
	  let nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArrayOfStrings);
	  let mainFields = getFlag(options, keys, "mainFields", mustBeArrayOfStrings);
	  let conditions = getFlag(options, keys, "conditions", mustBeArrayOfStrings);
	  let external = getFlag(options, keys, "external", mustBeArrayOfStrings);
	  let packages = getFlag(options, keys, "packages", mustBeString);
	  let alias = getFlag(options, keys, "alias", mustBeObject);
	  let loader = getFlag(options, keys, "loader", mustBeObject);
	  let outExtension = getFlag(options, keys, "outExtension", mustBeObject);
	  let publicPath = getFlag(options, keys, "publicPath", mustBeString);
	  let entryNames = getFlag(options, keys, "entryNames", mustBeString);
	  let chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
	  let assetNames = getFlag(options, keys, "assetNames", mustBeString);
	  let inject = getFlag(options, keys, "inject", mustBeArrayOfStrings);
	  let banner = getFlag(options, keys, "banner", mustBeObject);
	  let footer = getFlag(options, keys, "footer", mustBeObject);
	  let entryPoints = getFlag(options, keys, "entryPoints", mustBeEntryPoints);
	  let absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
	  let stdin = getFlag(options, keys, "stdin", mustBeObject);
	  let write = (_a2 = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
	  let allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
	  let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
	  keys.plugins = true;
	  checkForInvalidFlags(options, keys, `in ${callName}() call`);
	  if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
	  if (bundle) flags.push("--bundle");
	  if (allowOverwrite) flags.push("--allow-overwrite");
	  if (splitting) flags.push("--splitting");
	  if (preserveSymlinks) flags.push("--preserve-symlinks");
	  if (metafile) flags.push(`--metafile`);
	  if (outfile) flags.push(`--outfile=${outfile}`);
	  if (outdir) flags.push(`--outdir=${outdir}`);
	  if (outbase) flags.push(`--outbase=${outbase}`);
	  if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);
	  if (packages) flags.push(`--packages=${packages}`);
	  if (resolveExtensions) flags.push(`--resolve-extensions=${validateAndJoinStringArray(resolveExtensions, "resolve extension")}`);
	  if (publicPath) flags.push(`--public-path=${publicPath}`);
	  if (entryNames) flags.push(`--entry-names=${entryNames}`);
	  if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);
	  if (assetNames) flags.push(`--asset-names=${assetNames}`);
	  if (mainFields) flags.push(`--main-fields=${validateAndJoinStringArray(mainFields, "main field")}`);
	  if (conditions) flags.push(`--conditions=${validateAndJoinStringArray(conditions, "condition")}`);
	  if (external) for (let name of external) flags.push(`--external:${validateStringValue(name, "external")}`);
	  if (alias) {
	    for (let old in alias) {
	      if (old.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${old}`);
	      flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
	    }
	  }
	  if (banner) {
	    for (let type in banner) {
	      if (type.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${type}`);
	      flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
	    }
	  }
	  if (footer) {
	    for (let type in footer) {
	      if (type.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${type}`);
	      flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
	    }
	  }
	  if (inject) for (let path3 of inject) flags.push(`--inject:${validateStringValue(path3, "inject")}`);
	  if (loader) {
	    for (let ext in loader) {
	      if (ext.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${ext}`);
	      flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
	    }
	  }
	  if (outExtension) {
	    for (let ext in outExtension) {
	      if (ext.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${ext}`);
	      flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
	    }
	  }
	  if (entryPoints) {
	    if (Array.isArray(entryPoints)) {
	      for (let i = 0, n = entryPoints.length; i < n; i++) {
	        let entryPoint = entryPoints[i];
	        if (typeof entryPoint === "object" && entryPoint !== null) {
	          let entryPointKeys = /* @__PURE__ */ Object.create(null);
	          let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
	          let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
	          checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
	          if (input === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
	          if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
	          entries.push([output, input]);
	        } else {
	          entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
	        }
	      }
	    } else {
	      for (let key in entryPoints) {
	        entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
	      }
	    }
	  }
	  if (stdin) {
	    let stdinKeys = /* @__PURE__ */ Object.create(null);
	    let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
	    let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
	    let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
	    let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
	    checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
	    if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
	    if (loader2) flags.push(`--loader=${loader2}`);
	    if (resolveDir) stdinResolveDir = resolveDir;
	    if (typeof contents === "string") stdinContents = encodeUTF8(contents);
	    else if (contents instanceof Uint8Array) stdinContents = contents;
	  }
	  let nodePaths = [];
	  if (nodePathsInput) {
	    for (let value of nodePathsInput) {
	      value += "";
	      nodePaths.push(value);
	    }
	  }
	  return {
	    entries,
	    flags,
	    write,
	    stdinContents,
	    stdinResolveDir,
	    absWorkingDir,
	    nodePaths,
	    mangleCache: validateMangleCache(mangleCache)
	  };
	}
	function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
	  let flags = [];
	  let keys = /* @__PURE__ */ Object.create(null);
	  pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
	  pushCommonFlags(flags, options, keys);
	  let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
	  let sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
	  let loader = getFlag(options, keys, "loader", mustBeString);
	  let banner = getFlag(options, keys, "banner", mustBeString);
	  let footer = getFlag(options, keys, "footer", mustBeString);
	  let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
	  checkForInvalidFlags(options, keys, `in ${callName}() call`);
	  if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
	  if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
	  if (loader) flags.push(`--loader=${loader}`);
	  if (banner) flags.push(`--banner=${banner}`);
	  if (footer) flags.push(`--footer=${footer}`);
	  return {
	    flags,
	    mangleCache: validateMangleCache(mangleCache)
	  };
	}
	function createChannel(streamIn) {
	  const requestCallbacksByKey = {};
	  const closeData = { didClose: false, reason: "" };
	  let responseCallbacks = {};
	  let nextRequestID = 0;
	  let nextBuildKey = 0;
	  let stdout = new Uint8Array(16 * 1024);
	  let stdoutUsed = 0;
	  let readFromStdout = (chunk) => {
	    let limit = stdoutUsed + chunk.length;
	    if (limit > stdout.length) {
	      let swap = new Uint8Array(limit * 2);
	      swap.set(stdout);
	      stdout = swap;
	    }
	    stdout.set(chunk, stdoutUsed);
	    stdoutUsed += chunk.length;
	    let offset = 0;
	    while (offset + 4 <= stdoutUsed) {
	      let length = readUInt32LE(stdout, offset);
	      if (offset + 4 + length > stdoutUsed) {
	        break;
	      }
	      offset += 4;
	      handleIncomingPacket(stdout.subarray(offset, offset + length));
	      offset += length;
	    }
	    if (offset > 0) {
	      stdout.copyWithin(0, offset, stdoutUsed);
	      stdoutUsed -= offset;
	    }
	  };
	  let afterClose = (error) => {
	    closeData.didClose = true;
	    if (error) closeData.reason = ": " + (error.message || error);
	    const text = "The service was stopped" + closeData.reason;
	    for (let id in responseCallbacks) {
	      responseCallbacks[id](text, null);
	    }
	    responseCallbacks = {};
	  };
	  let sendRequest = (refs, value, callback) => {
	    if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
	    let id = nextRequestID++;
	    responseCallbacks[id] = (error, response) => {
	      try {
	        callback(error, response);
	      } finally {
	        if (refs) refs.unref();
	      }
	    };
	    if (refs) refs.ref();
	    streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
	  };
	  let sendResponse = (id, value) => {
	    if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
	    streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
	  };
	  let handleRequest = async (id, request) => {
	    try {
	      if (request.command === "ping") {
	        sendResponse(id, {});
	        return;
	      }
	      if (typeof request.key === "number") {
	        const requestCallbacks = requestCallbacksByKey[request.key];
	        if (!requestCallbacks) {
	          return;
	        }
	        const callback = requestCallbacks[request.command];
	        if (callback) {
	          await callback(id, request);
	          return;
	        }
	      }
	      throw new Error(`Invalid command: ` + request.command);
	    } catch (e) {
	      const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
	      try {
	        sendResponse(id, { errors });
	      } catch {
	      }
	    }
	  };
	  let isFirstPacket = true;
	  let handleIncomingPacket = (bytes) => {
	    if (isFirstPacket) {
	      isFirstPacket = false;
	      let binaryVersion = String.fromCharCode(...bytes);
	      if (binaryVersion !== "0.25.12") {
	        throw new Error(`Cannot start service: Host version "${"0.25.12"}" does not match binary version ${quote(binaryVersion)}`);
	      }
	      return;
	    }
	    let packet = decodePacket(bytes);
	    if (packet.isRequest) {
	      handleRequest(packet.id, packet.value);
	    } else {
	      let callback = responseCallbacks[packet.id];
	      delete responseCallbacks[packet.id];
	      if (packet.value.error) callback(packet.value.error, {});
	      else callback(null, packet.value);
	    }
	  };
	  let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
	    let refCount = 0;
	    const buildKey = nextBuildKey++;
	    const requestCallbacks = {};
	    const buildRefs = {
	      ref() {
	        if (++refCount === 1) {
	          if (refs) refs.ref();
	        }
	      },
	      unref() {
	        if (--refCount === 0) {
	          delete requestCallbacksByKey[buildKey];
	          if (refs) refs.unref();
	        }
	      }
	    };
	    requestCallbacksByKey[buildKey] = requestCallbacks;
	    buildRefs.ref();
	    buildOrContextImpl(
	      callName,
	      buildKey,
	      sendRequest,
	      sendResponse,
	      buildRefs,
	      streamIn,
	      requestCallbacks,
	      options,
	      isTTY2,
	      defaultWD2,
	      (err, res) => {
	        try {
	          callback(err, res);
	        } finally {
	          buildRefs.unref();
	        }
	      }
	    );
	  };
	  let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs3, callback }) => {
	    const details = createObjectStash();
	    let start = (inputPath) => {
	      try {
	        if (typeof input !== "string" && !(input instanceof Uint8Array))
	          throw new Error('The input to "transform" must be a string or a Uint8Array');
	        let {
	          flags,
	          mangleCache
	        } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
	        let request = {
	          command: "transform",
	          flags,
	          inputFS: inputPath !== null,
	          input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
	        };
	        if (mangleCache) request.mangleCache = mangleCache;
	        sendRequest(refs, request, (error, response) => {
	          if (error) return callback(new Error(error), null);
	          let errors = replaceDetailsInMessages(response.errors, details);
	          let warnings = replaceDetailsInMessages(response.warnings, details);
	          let outstanding = 1;
	          let next = () => {
	            if (--outstanding === 0) {
	              let result = {
	                warnings,
	                code: response.code,
	                map: response.map,
	                mangleCache: void 0,
	                legalComments: void 0
	              };
	              if ("legalComments" in response) result.legalComments = response == null ? void 0 : response.legalComments;
	              if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;
	              callback(null, result);
	            }
	          };
	          if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
	          if (response.codeFS) {
	            outstanding++;
	            fs3.readFile(response.code, (err, contents) => {
	              if (err !== null) {
	                callback(err, null);
	              } else {
	                response.code = contents;
	                next();
	              }
	            });
	          }
	          if (response.mapFS) {
	            outstanding++;
	            fs3.readFile(response.map, (err, contents) => {
	              if (err !== null) {
	                callback(err, null);
	              } else {
	                response.map = contents;
	                next();
	              }
	            });
	          }
	          next();
	        });
	      } catch (e) {
	        let flags = [];
	        try {
	          pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
	        } catch {
	        }
	        const error = extractErrorMessageV8(e, streamIn, details, void 0, "");
	        sendRequest(refs, { command: "error", flags, error }, () => {
	          error.detail = details.load(error.detail);
	          callback(failureErrorWithLog("Transform failed", [error], []), null);
	        });
	      }
	    };
	    if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
	      let next = start;
	      start = () => fs3.writeFile(input, next);
	    }
	    start(null);
	  };
	  let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
	    if (!options) throw new Error(`Missing second argument in ${callName}() call`);
	    let keys = {};
	    let kind = getFlag(options, keys, "kind", mustBeString);
	    let color = getFlag(options, keys, "color", mustBeBoolean);
	    let terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
	    checkForInvalidFlags(options, keys, `in ${callName}() call`);
	    if (kind === void 0) throw new Error(`Missing "kind" in ${callName}() call`);
	    if (kind !== "error" && kind !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
	    let request = {
	      command: "format-msgs",
	      messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
	      isWarning: kind === "warning"
	    };
	    if (color !== void 0) request.color = color;
	    if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;
	    sendRequest(refs, request, (error, response) => {
	      if (error) return callback(new Error(error), null);
	      callback(null, response.messages);
	    });
	  };
	  let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
	    if (options === void 0) options = {};
	    let keys = {};
	    let color = getFlag(options, keys, "color", mustBeBoolean);
	    let verbose = getFlag(options, keys, "verbose", mustBeBoolean);
	    checkForInvalidFlags(options, keys, `in ${callName}() call`);
	    let request = {
	      command: "analyze-metafile",
	      metafile
	    };
	    if (color !== void 0) request.color = color;
	    if (verbose !== void 0) request.verbose = verbose;
	    sendRequest(refs, request, (error, response) => {
	      if (error) return callback(new Error(error), null);
	      callback(null, response.result);
	    });
	  };
	  return {
	    readFromStdout,
	    afterClose,
	    service: {
	      buildOrContext,
	      transform: transform2,
	      formatMessages: formatMessages2,
	      analyzeMetafile: analyzeMetafile2
	    }
	  };
	}
	function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
	  const details = createObjectStash();
	  const isContext = callName === "context";
	  const handleError = (e, pluginName) => {
	    const flags = [];
	    try {
	      pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
	    } catch {
	    }
	    const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
	    sendRequest(refs, { command: "error", flags, error: message }, () => {
	      message.detail = details.load(message.detail);
	      callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
	    });
	  };
	  let plugins;
	  if (typeof options === "object") {
	    const value = options.plugins;
	    if (value !== void 0) {
	      if (!Array.isArray(value)) return handleError(new Error(`"plugins" must be an array`), "");
	      plugins = value;
	    }
	  }
	  if (plugins && plugins.length > 0) {
	    if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
	    handlePlugins(
	      buildKey,
	      sendRequest,
	      sendResponse,
	      refs,
	      streamIn,
	      requestCallbacks,
	      options,
	      plugins,
	      details
	    ).then(
	      (result) => {
	        if (!result.ok) return handleError(result.error, result.pluginName);
	        try {
	          buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
	        } catch (e) {
	          handleError(e, "");
	        }
	      },
	      (e) => handleError(e, "")
	    );
	    return;
	  }
	  try {
	    buildOrContextContinue(null, (result, done) => done([], []), () => {
	    });
	  } catch (e) {
	    handleError(e, "");
	  }
	  function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
	    const writeDefault = streamIn.hasFS;
	    const {
	      entries,
	      flags,
	      write,
	      stdinContents,
	      stdinResolveDir,
	      absWorkingDir,
	      nodePaths,
	      mangleCache
	    } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
	    if (write && !streamIn.hasFS) throw new Error(`The "write" option is unavailable in this environment`);
	    const request = {
	      command: "build",
	      key: buildKey,
	      entries,
	      flags,
	      write,
	      stdinContents,
	      stdinResolveDir,
	      absWorkingDir: absWorkingDir || defaultWD2,
	      nodePaths,
	      context: isContext
	    };
	    if (requestPlugins) request.plugins = requestPlugins;
	    if (mangleCache) request.mangleCache = mangleCache;
	    const buildResponseToResult = (response, callback2) => {
	      const result = {
	        errors: replaceDetailsInMessages(response.errors, details),
	        warnings: replaceDetailsInMessages(response.warnings, details),
	        outputFiles: void 0,
	        metafile: void 0,
	        mangleCache: void 0
	      };
	      const originalErrors = result.errors.slice();
	      const originalWarnings = result.warnings.slice();
	      if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);
	      if (response.metafile) result.metafile = JSON.parse(response.metafile);
	      if (response.mangleCache) result.mangleCache = response.mangleCache;
	      if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
	      runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
	        if (originalErrors.length > 0 || onEndErrors.length > 0) {
	          const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
	          return callback2(error, null, onEndErrors, onEndWarnings);
	        }
	        callback2(null, result, onEndErrors, onEndWarnings);
	      });
	    };
	    let latestResultPromise;
	    let provideLatestResult;
	    if (isContext)
	      requestCallbacks["on-end"] = (id, request2) => new Promise((resolve) => {
	        buildResponseToResult(request2, (err, result, onEndErrors, onEndWarnings) => {
	          const response = {
	            errors: onEndErrors,
	            warnings: onEndWarnings
	          };
	          if (provideLatestResult) provideLatestResult(err, result);
	          latestResultPromise = void 0;
	          provideLatestResult = void 0;
	          sendResponse(id, response);
	          resolve();
	        });
	      });
	    sendRequest(refs, request, (error, response) => {
	      if (error) return callback(new Error(error), null);
	      if (!isContext) {
	        return buildResponseToResult(response, (err, res) => {
	          scheduleOnDisposeCallbacks();
	          return callback(err, res);
	        });
	      }
	      if (response.errors.length > 0) {
	        return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
	      }
	      let didDispose = false;
	      const result = {
	        rebuild: () => {
	          if (!latestResultPromise) latestResultPromise = new Promise((resolve, reject) => {
	            let settlePromise;
	            provideLatestResult = (err, result2) => {
	              if (!settlePromise) settlePromise = () => err ? reject(err) : resolve(result2);
	            };
	            const triggerAnotherBuild = () => {
	              const request2 = {
	                command: "rebuild",
	                key: buildKey
	              };
	              sendRequest(refs, request2, (error2, response2) => {
	                if (error2) {
	                  reject(new Error(error2));
	                } else if (settlePromise) {
	                  settlePromise();
	                } else {
	                  triggerAnotherBuild();
	                }
	              });
	            };
	            triggerAnotherBuild();
	          });
	          return latestResultPromise;
	        },
	        watch: (options2 = {}) => new Promise((resolve, reject) => {
	          if (!streamIn.hasFS) throw new Error(`Cannot use the "watch" API in this environment`);
	          const keys = {};
	          const delay = getFlag(options2, keys, "delay", mustBeInteger);
	          checkForInvalidFlags(options2, keys, `in watch() call`);
	          const request2 = {
	            command: "watch",
	            key: buildKey
	          };
	          if (delay) request2.delay = delay;
	          sendRequest(refs, request2, (error2) => {
	            if (error2) reject(new Error(error2));
	            else resolve(void 0);
	          });
	        }),
	        serve: (options2 = {}) => new Promise((resolve, reject) => {
	          if (!streamIn.hasFS) throw new Error(`Cannot use the "serve" API in this environment`);
	          const keys = {};
	          const port = getFlag(options2, keys, "port", mustBeValidPortNumber);
	          const host = getFlag(options2, keys, "host", mustBeString);
	          const servedir = getFlag(options2, keys, "servedir", mustBeString);
	          const keyfile = getFlag(options2, keys, "keyfile", mustBeString);
	          const certfile = getFlag(options2, keys, "certfile", mustBeString);
	          const fallback = getFlag(options2, keys, "fallback", mustBeString);
	          const cors = getFlag(options2, keys, "cors", mustBeObject);
	          const onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
	          checkForInvalidFlags(options2, keys, `in serve() call`);
	          const request2 = {
	            command: "serve",
	            key: buildKey,
	            onRequest: !!onRequest
	          };
	          if (port !== void 0) request2.port = port;
	          if (host !== void 0) request2.host = host;
	          if (servedir !== void 0) request2.servedir = servedir;
	          if (keyfile !== void 0) request2.keyfile = keyfile;
	          if (certfile !== void 0) request2.certfile = certfile;
	          if (fallback !== void 0) request2.fallback = fallback;
	          if (cors) {
	            const corsKeys = {};
	            const origin = getFlag(cors, corsKeys, "origin", mustBeStringOrArrayOfStrings);
	            checkForInvalidFlags(cors, corsKeys, `on "cors" object`);
	            if (Array.isArray(origin)) request2.corsOrigin = origin;
	            else if (origin !== void 0) request2.corsOrigin = [origin];
	          }
	          sendRequest(refs, request2, (error2, response2) => {
	            if (error2) return reject(new Error(error2));
	            if (onRequest) {
	              requestCallbacks["serve-request"] = (id, request3) => {
	                onRequest(request3.args);
	                sendResponse(id, {});
	              };
	            }
	            resolve(response2);
	          });
	        }),
	        cancel: () => new Promise((resolve) => {
	          if (didDispose) return resolve();
	          const request2 = {
	            command: "cancel",
	            key: buildKey
	          };
	          sendRequest(refs, request2, () => {
	            resolve();
	          });
	        }),
	        dispose: () => new Promise((resolve) => {
	          if (didDispose) return resolve();
	          didDispose = true;
	          const request2 = {
	            command: "dispose",
	            key: buildKey
	          };
	          sendRequest(refs, request2, () => {
	            resolve();
	            scheduleOnDisposeCallbacks();
	            refs.unref();
	          });
	        })
	      };
	      refs.ref();
	      callback(null, result);
	    });
	  }
	}
	var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
	  let onStartCallbacks = [];
	  let onEndCallbacks = [];
	  let onResolveCallbacks = {};
	  let onLoadCallbacks = {};
	  let onDisposeCallbacks = [];
	  let nextCallbackID = 0;
	  let i = 0;
	  let requestPlugins = [];
	  let isSetupDone = false;
	  plugins = [...plugins];
	  for (let item of plugins) {
	    let keys = {};
	    if (typeof item !== "object") throw new Error(`Plugin at index ${i} must be an object`);
	    const name = getFlag(item, keys, "name", mustBeString);
	    if (typeof name !== "string" || name === "") throw new Error(`Plugin at index ${i} is missing a name`);
	    try {
	      let setup = getFlag(item, keys, "setup", mustBeFunction);
	      if (typeof setup !== "function") throw new Error(`Plugin is missing a setup function`);
	      checkForInvalidFlags(item, keys, `on plugin ${quote(name)}`);
	      let plugin = {
	        name,
	        onStart: false,
	        onEnd: false,
	        onResolve: [],
	        onLoad: []
	      };
	      i++;
	      let resolve = (path3, options = {}) => {
	        if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
	        if (typeof path3 !== "string") throw new Error(`The path to resolve must be a string`);
	        let keys2 = /* @__PURE__ */ Object.create(null);
	        let pluginName = getFlag(options, keys2, "pluginName", mustBeString);
	        let importer = getFlag(options, keys2, "importer", mustBeString);
	        let namespace = getFlag(options, keys2, "namespace", mustBeString);
	        let resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
	        let kind = getFlag(options, keys2, "kind", mustBeString);
	        let pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
	        let importAttributes = getFlag(options, keys2, "with", mustBeObject);
	        checkForInvalidFlags(options, keys2, "in resolve() call");
	        return new Promise((resolve2, reject) => {
	          const request = {
	            command: "resolve",
	            path: path3,
	            key: buildKey,
	            pluginName: name
	          };
	          if (pluginName != null) request.pluginName = pluginName;
	          if (importer != null) request.importer = importer;
	          if (namespace != null) request.namespace = namespace;
	          if (resolveDir != null) request.resolveDir = resolveDir;
	          if (kind != null) request.kind = kind;
	          else throw new Error(`Must specify "kind" when calling "resolve"`);
	          if (pluginData != null) request.pluginData = details.store(pluginData);
	          if (importAttributes != null) request.with = sanitizeStringMap(importAttributes, "with");
	          sendRequest(refs, request, (error, response) => {
	            if (error !== null) reject(new Error(error));
	            else resolve2({
	              errors: replaceDetailsInMessages(response.errors, details),
	              warnings: replaceDetailsInMessages(response.warnings, details),
	              path: response.path,
	              external: response.external,
	              sideEffects: response.sideEffects,
	              namespace: response.namespace,
	              suffix: response.suffix,
	              pluginData: details.load(response.pluginData)
	            });
	          });
	        });
	      };
	      let promise = setup({
	        initialOptions,
	        resolve,
	        onStart(callback) {
	          let registeredText = `This error came from the "onStart" callback registered here:`;
	          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
	          onStartCallbacks.push({ name, callback, note: registeredNote });
	          plugin.onStart = true;
	        },
	        onEnd(callback) {
	          let registeredText = `This error came from the "onEnd" callback registered here:`;
	          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
	          onEndCallbacks.push({ name, callback, note: registeredNote });
	          plugin.onEnd = true;
	        },
	        onResolve(options, callback) {
	          let registeredText = `This error came from the "onResolve" callback registered here:`;
	          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
	          let keys2 = {};
	          let filter = getFlag(options, keys2, "filter", mustBeRegExp);
	          let namespace = getFlag(options, keys2, "namespace", mustBeString);
	          checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${quote(name)}`);
	          if (filter == null) throw new Error(`onResolve() call is missing a filter`);
	          let id = nextCallbackID++;
	          onResolveCallbacks[id] = { name, callback, note: registeredNote };
	          plugin.onResolve.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
	        },
	        onLoad(options, callback) {
	          let registeredText = `This error came from the "onLoad" callback registered here:`;
	          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
	          let keys2 = {};
	          let filter = getFlag(options, keys2, "filter", mustBeRegExp);
	          let namespace = getFlag(options, keys2, "namespace", mustBeString);
	          checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${quote(name)}`);
	          if (filter == null) throw new Error(`onLoad() call is missing a filter`);
	          let id = nextCallbackID++;
	          onLoadCallbacks[id] = { name, callback, note: registeredNote };
	          plugin.onLoad.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
	        },
	        onDispose(callback) {
	          onDisposeCallbacks.push(callback);
	        },
	        esbuild: streamIn.esbuild
	      });
	      if (promise) await promise;
	      requestPlugins.push(plugin);
	    } catch (e) {
	      return { ok: false, error: e, pluginName: name };
	    }
	  }
	  requestCallbacks["on-start"] = async (id, request) => {
	    details.clear();
	    let response = { errors: [], warnings: [] };
	    await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
	      try {
	        let result = await callback();
	        if (result != null) {
	          if (typeof result !== "object") throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
	          let keys = {};
	          let errors = getFlag(result, keys, "errors", mustBeArray);
	          let warnings = getFlag(result, keys, "warnings", mustBeArray);
	          checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name)}`);
	          if (errors != null) response.errors.push(...sanitizeMessages(errors, "errors", details, name, void 0));
	          if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
	        }
	      } catch (e) {
	        response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
	      }
	    }));
	    sendResponse(id, response);
	  };
	  requestCallbacks["on-resolve"] = async (id, request) => {
	    let response = {}, name = "", callback, note;
	    for (let id2 of request.ids) {
	      try {
	        ({ name, callback, note } = onResolveCallbacks[id2]);
	        let result = await callback({
	          path: request.path,
	          importer: request.importer,
	          namespace: request.namespace,
	          resolveDir: request.resolveDir,
	          kind: request.kind,
	          pluginData: details.load(request.pluginData),
	          with: request.with
	        });
	        if (result != null) {
	          if (typeof result !== "object") throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
	          let keys = {};
	          let pluginName = getFlag(result, keys, "pluginName", mustBeString);
	          let path3 = getFlag(result, keys, "path", mustBeString);
	          let namespace = getFlag(result, keys, "namespace", mustBeString);
	          let suffix = getFlag(result, keys, "suffix", mustBeString);
	          let external = getFlag(result, keys, "external", mustBeBoolean);
	          let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
	          let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
	          let errors = getFlag(result, keys, "errors", mustBeArray);
	          let warnings = getFlag(result, keys, "warnings", mustBeArray);
	          let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
	          let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
	          checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name)}`);
	          response.id = id2;
	          if (pluginName != null) response.pluginName = pluginName;
	          if (path3 != null) response.path = path3;
	          if (namespace != null) response.namespace = namespace;
	          if (suffix != null) response.suffix = suffix;
	          if (external != null) response.external = external;
	          if (sideEffects != null) response.sideEffects = sideEffects;
	          if (pluginData != null) response.pluginData = details.store(pluginData);
	          if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
	          if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
	          if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
	          if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
	          break;
	        }
	      } catch (e) {
	        response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
	        break;
	      }
	    }
	    sendResponse(id, response);
	  };
	  requestCallbacks["on-load"] = async (id, request) => {
	    let response = {}, name = "", callback, note;
	    for (let id2 of request.ids) {
	      try {
	        ({ name, callback, note } = onLoadCallbacks[id2]);
	        let result = await callback({
	          path: request.path,
	          namespace: request.namespace,
	          suffix: request.suffix,
	          pluginData: details.load(request.pluginData),
	          with: request.with
	        });
	        if (result != null) {
	          if (typeof result !== "object") throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
	          let keys = {};
	          let pluginName = getFlag(result, keys, "pluginName", mustBeString);
	          let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
	          let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
	          let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
	          let loader = getFlag(result, keys, "loader", mustBeString);
	          let errors = getFlag(result, keys, "errors", mustBeArray);
	          let warnings = getFlag(result, keys, "warnings", mustBeArray);
	          let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
	          let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
	          checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name)}`);
	          response.id = id2;
	          if (pluginName != null) response.pluginName = pluginName;
	          if (contents instanceof Uint8Array) response.contents = contents;
	          else if (contents != null) response.contents = encodeUTF8(contents);
	          if (resolveDir != null) response.resolveDir = resolveDir;
	          if (pluginData != null) response.pluginData = details.store(pluginData);
	          if (loader != null) response.loader = loader;
	          if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
	          if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
	          if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
	          if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
	          break;
	        }
	      } catch (e) {
	        response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
	        break;
	      }
	    }
	    sendResponse(id, response);
	  };
	  let runOnEndCallbacks = (result, done) => done([], []);
	  if (onEndCallbacks.length > 0) {
	    runOnEndCallbacks = (result, done) => {
	      (async () => {
	        const onEndErrors = [];
	        const onEndWarnings = [];
	        for (const { name, callback, note } of onEndCallbacks) {
	          let newErrors;
	          let newWarnings;
	          try {
	            const value = await callback(result);
	            if (value != null) {
	              if (typeof value !== "object") throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
	              let keys = {};
	              let errors = getFlag(value, keys, "errors", mustBeArray);
	              let warnings = getFlag(value, keys, "warnings", mustBeArray);
	              checkForInvalidFlags(value, keys, `from onEnd() callback in plugin ${quote(name)}`);
	              if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
	              if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
	            }
	          } catch (e) {
	            newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
	          }
	          if (newErrors) {
	            onEndErrors.push(...newErrors);
	            try {
	              result.errors.push(...newErrors);
	            } catch {
	            }
	          }
	          if (newWarnings) {
	            onEndWarnings.push(...newWarnings);
	            try {
	              result.warnings.push(...newWarnings);
	            } catch {
	            }
	          }
	        }
	        done(onEndErrors, onEndWarnings);
	      })();
	    };
	  }
	  let scheduleOnDisposeCallbacks = () => {
	    for (const cb of onDisposeCallbacks) {
	      setTimeout(() => cb(), 0);
	    }
	  };
	  isSetupDone = true;
	  return {
	    ok: true,
	    requestPlugins,
	    runOnEndCallbacks,
	    scheduleOnDisposeCallbacks
	  };
	};
	function createObjectStash() {
	  const map = /* @__PURE__ */ new Map();
	  let nextID = 0;
	  return {
	    clear() {
	      map.clear();
	    },
	    load(id) {
	      return map.get(id);
	    },
	    store(value) {
	      if (value === void 0) return -1;
	      const id = nextID++;
	      map.set(id, value);
	      return id;
	    }
	  };
	}
	function extractCallerV8(e, streamIn, ident) {
	  let note;
	  let tried = false;
	  return () => {
	    if (tried) return note;
	    tried = true;
	    try {
	      let lines = (e.stack + "").split("\n");
	      lines.splice(1, 1);
	      let location = parseStackLinesV8(streamIn, lines, ident);
	      if (location) {
	        note = { text: e.message, location };
	        return note;
	      }
	    } catch {
	    }
	  };
	}
	function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
	  let text = "Internal error";
	  let location = null;
	  try {
	    text = (e && e.message || e) + "";
	  } catch {
	  }
	  try {
	    location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
	  } catch {
	  }
	  return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
	}
	function parseStackLinesV8(streamIn, lines, ident) {
	  let at = "    at ";
	  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
	    for (let i = 1; i < lines.length; i++) {
	      let line = lines[i];
	      if (!line.startsWith(at)) continue;
	      line = line.slice(at.length);
	      while (true) {
	        let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
	        if (match) {
	          line = match[1];
	          continue;
	        }
	        match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
	        if (match) {
	          line = match[1];
	          continue;
	        }
	        match = /^(\S+):(\d+):(\d+)$/.exec(line);
	        if (match) {
	          let contents;
	          try {
	            contents = streamIn.readFileSync(match[1], "utf8");
	          } catch {
	            break;
	          }
	          let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
	          let column = +match[3] - 1;
	          let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
	          return {
	            file: match[1],
	            namespace: "file",
	            line: +match[2],
	            column: encodeUTF8(lineText.slice(0, column)).length,
	            length: encodeUTF8(lineText.slice(column, column + length)).length,
	            lineText: lineText + "\n" + lines.slice(1).join("\n"),
	            suggestion: ""
	          };
	        }
	        break;
	      }
	    }
	  }
	  return null;
	}
	function failureErrorWithLog(text, errors, warnings) {
	  let limit = 5;
	  text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
	    if (i === limit) return "\n...";
	    if (!e.location) return `
error: ${e.text}`;
	    let { file, line, column } = e.location;
	    let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
	    return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
	  }).join("");
	  let error = new Error(text);
	  for (const [key, value] of [["errors", errors], ["warnings", warnings]]) {
	    Object.defineProperty(error, key, {
	      configurable: true,
	      enumerable: true,
	      get: () => value,
	      set: (value2) => Object.defineProperty(error, key, {
	        configurable: true,
	        enumerable: true,
	        value: value2
	      })
	    });
	  }
	  return error;
	}
	function replaceDetailsInMessages(messages, stash) {
	  for (const message of messages) {
	    message.detail = stash.load(message.detail);
	  }
	  return messages;
	}
	function sanitizeLocation(location, where, terminalWidth) {
	  if (location == null) return null;
	  let keys = {};
	  let file = getFlag(location, keys, "file", mustBeString);
	  let namespace = getFlag(location, keys, "namespace", mustBeString);
	  let line = getFlag(location, keys, "line", mustBeInteger);
	  let column = getFlag(location, keys, "column", mustBeInteger);
	  let length = getFlag(location, keys, "length", mustBeInteger);
	  let lineText = getFlag(location, keys, "lineText", mustBeString);
	  let suggestion = getFlag(location, keys, "suggestion", mustBeString);
	  checkForInvalidFlags(location, keys, where);
	  if (lineText) {
	    const relevantASCII = lineText.slice(
	      0,
	      (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
	    );
	    if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
	      lineText = relevantASCII;
	    }
	  }
	  return {
	    file: file || "",
	    namespace: namespace || "",
	    line: line || 0,
	    column: column || 0,
	    length: length || 0,
	    lineText: lineText || "",
	    suggestion: suggestion || ""
	  };
	}
	function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
	  let messagesClone = [];
	  let index = 0;
	  for (const message of messages) {
	    let keys = {};
	    let id = getFlag(message, keys, "id", mustBeString);
	    let pluginName = getFlag(message, keys, "pluginName", mustBeString);
	    let text = getFlag(message, keys, "text", mustBeString);
	    let location = getFlag(message, keys, "location", mustBeObjectOrNull);
	    let notes = getFlag(message, keys, "notes", mustBeArray);
	    let detail = getFlag(message, keys, "detail", canBeAnything);
	    let where = `in element ${index} of "${property}"`;
	    checkForInvalidFlags(message, keys, where);
	    let notesClone = [];
	    if (notes) {
	      for (const note of notes) {
	        let noteKeys = {};
	        let noteText = getFlag(note, noteKeys, "text", mustBeString);
	        let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
	        checkForInvalidFlags(note, noteKeys, where);
	        notesClone.push({
	          text: noteText || "",
	          location: sanitizeLocation(noteLocation, where, terminalWidth)
	        });
	      }
	    }
	    messagesClone.push({
	      id: id || "",
	      pluginName: pluginName || fallbackPluginName,
	      text: text || "",
	      location: sanitizeLocation(location, where, terminalWidth),
	      notes: notesClone,
	      detail: stash ? stash.store(detail) : -1
	    });
	    index++;
	  }
	  return messagesClone;
	}
	function sanitizeStringArray(values, property) {
	  const result = [];
	  for (const value of values) {
	    if (typeof value !== "string") throw new Error(`${quote(property)} must be an array of strings`);
	    result.push(value);
	  }
	  return result;
	}
	function sanitizeStringMap(map, property) {
	  const result = /* @__PURE__ */ Object.create(null);
	  for (const key in map) {
	    const value = map[key];
	    if (typeof value !== "string") throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
	    result[key] = value;
	  }
	  return result;
	}
	function convertOutputFiles({ path: path3, contents, hash }) {
	  let text = null;
	  return {
	    path: path3,
	    contents,
	    hash,
	    get text() {
	      const binary = this.contents;
	      if (text === null || binary !== contents) {
	        contents = binary;
	        text = decodeUTF8(binary);
	      }
	      return text;
	    }
	  };
	}
	function jsRegExpToGoRegExp(regexp) {
	  let result = regexp.source;
	  if (regexp.flags) result = `(?${regexp.flags})${result}`;
	  return result;
	}

	// lib/npm/node-platform.ts
	var fs = require$$0$4;
	var os = require$$2;
	var path = require$$0$2$1;
	var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
	var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
	var packageDarwin_arm64 = "@esbuild/darwin-arm64";
	var packageDarwin_x64 = "@esbuild/darwin-x64";
	var knownWindowsPackages = {
	  "win32 arm64 LE": "@esbuild/win32-arm64",
	  "win32 ia32 LE": "@esbuild/win32-ia32",
	  "win32 x64 LE": "@esbuild/win32-x64"
	};
	var knownUnixlikePackages = {
	  "aix ppc64 BE": "@esbuild/aix-ppc64",
	  "android arm64 LE": "@esbuild/android-arm64",
	  "darwin arm64 LE": "@esbuild/darwin-arm64",
	  "darwin x64 LE": "@esbuild/darwin-x64",
	  "freebsd arm64 LE": "@esbuild/freebsd-arm64",
	  "freebsd x64 LE": "@esbuild/freebsd-x64",
	  "linux arm LE": "@esbuild/linux-arm",
	  "linux arm64 LE": "@esbuild/linux-arm64",
	  "linux ia32 LE": "@esbuild/linux-ia32",
	  "linux mips64el LE": "@esbuild/linux-mips64el",
	  "linux ppc64 LE": "@esbuild/linux-ppc64",
	  "linux riscv64 LE": "@esbuild/linux-riscv64",
	  "linux s390x BE": "@esbuild/linux-s390x",
	  "linux x64 LE": "@esbuild/linux-x64",
	  "linux loong64 LE": "@esbuild/linux-loong64",
	  "netbsd arm64 LE": "@esbuild/netbsd-arm64",
	  "netbsd x64 LE": "@esbuild/netbsd-x64",
	  "openbsd arm64 LE": "@esbuild/openbsd-arm64",
	  "openbsd x64 LE": "@esbuild/openbsd-x64",
	  "sunos x64 LE": "@esbuild/sunos-x64"
	};
	var knownWebAssemblyFallbackPackages = {
	  "android arm LE": "@esbuild/android-arm",
	  "android x64 LE": "@esbuild/android-x64",
	  "openharmony arm64 LE": "@esbuild/openharmony-arm64"
	};
	function pkgAndSubpathForCurrentPlatform() {
	  let pkg;
	  let subpath;
	  let isWASM = false;
	  let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
	  if (platformKey in knownWindowsPackages) {
	    pkg = knownWindowsPackages[platformKey];
	    subpath = "esbuild.exe";
	  } else if (platformKey in knownUnixlikePackages) {
	    pkg = knownUnixlikePackages[platformKey];
	    subpath = "bin/esbuild";
	  } else if (platformKey in knownWebAssemblyFallbackPackages) {
	    pkg = knownWebAssemblyFallbackPackages[platformKey];
	    subpath = "bin/esbuild";
	    isWASM = true;
	  } else {
	    throw new Error(`Unsupported platform: ${platformKey}`);
	  }
	  return { pkg, subpath, isWASM };
	}
	function pkgForSomeOtherPlatform() {
	  const libMainJS = require.resolve("esbuild");
	  const nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));
	  if (path.basename(nodeModulesDirectory) === "node_modules") {
	    for (const unixKey in knownUnixlikePackages) {
	      try {
	        const pkg = knownUnixlikePackages[unixKey];
	        if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
	      } catch {
	      }
	    }
	    for (const windowsKey in knownWindowsPackages) {
	      try {
	        const pkg = knownWindowsPackages[windowsKey];
	        if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
	      } catch {
	      }
	    }
	  }
	  return null;
	}
	function downloadedBinPath(pkg, subpath) {
	  const esbuildLibDir = path.dirname(require.resolve("esbuild"));
	  return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
	}
	function generateBinPath() {
	  if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
	    if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
	      console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
	    } else {
	      return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
	    }
	  }
	  const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
	  let binPath;
	  try {
	    binPath = require.resolve(`${pkg}/${subpath}`);
	  } catch (e) {
	    binPath = downloadedBinPath(pkg, subpath);
	    if (!fs.existsSync(binPath)) {
	      try {
	        require.resolve(pkg);
	      } catch {
	        const otherPkg = pkgForSomeOtherPlatform();
	        if (otherPkg) {
	          let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
	          if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
	            suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
	          }
	          throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
	        }
	        throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
	      }
	      throw e;
	    }
	  }
	  if (/\.zip\//.test(binPath)) {
	    let pnpapi;
	    try {
	      pnpapi = require("pnpapi");
	    } catch (e) {
	    }
	    if (pnpapi) {
	      const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
	      const binTargetPath = path.join(
	        root,
	        "node_modules",
	        ".cache",
	        "esbuild",
	        `pnpapi-${pkg.replace("/", "-")}-${"0.25.12"}-${path.basename(subpath)}`
	      );
	      if (!fs.existsSync(binTargetPath)) {
	        fs.mkdirSync(path.dirname(binTargetPath), { recursive: true });
	        fs.copyFileSync(binPath, binTargetPath);
	        fs.chmodSync(binTargetPath, 493);
	      }
	      return { binPath: binTargetPath, isWASM };
	    }
	  }
	  return { binPath, isWASM };
	}

	// lib/npm/node.ts
	var child_process = require$$2$1;
	var crypto = require$$3;
	var path2 = require$$0$2$1;
	var fs2 = require$$0$4;
	var os2 = require$$2;
	var tty = require$$0$3;
	var worker_threads;
	if (process.env.ESBUILD_WORKER_THREADS !== "0") {
	  try {
	    worker_threads = require("worker_threads");
	  } catch {
	  }
	  let [major, minor] = process.versions.node.split(".");
	  if (
	    // <v12.17.0 does not work
	    +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
	  ) {
	    worker_threads = void 0;
	  }
	}
	var _a;
	var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.25.12";
	var esbuildCommandAndArgs = () => {
	  if ((!ESBUILD_BINARY_PATH || false) && (path2.basename(__filename) !== "main.js" || path2.basename(__dirname) !== "lib")) {
	    throw new Error(
	      `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

	More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
	    );
	  }
	  {
	    const { binPath, isWASM } = generateBinPath();
	    if (isWASM) {
	      return ["node", [binPath]];
	    } else {
	      return [binPath, []];
	    }
	  }
	};
	var isTTY = () => tty.isatty(2);
	var fsSync = {
	  readFile(tempFile, callback) {
	    try {
	      let contents = fs2.readFileSync(tempFile, "utf8");
	      try {
	        fs2.unlinkSync(tempFile);
	      } catch {
	      }
	      callback(null, contents);
	    } catch (err) {
	      callback(err, null);
	    }
	  },
	  writeFile(contents, callback) {
	    try {
	      let tempFile = randomFileName();
	      fs2.writeFileSync(tempFile, contents);
	      callback(tempFile);
	    } catch {
	      callback(null);
	    }
	  }
	};
	var fsAsync = {
	  readFile(tempFile, callback) {
	    try {
	      fs2.readFile(tempFile, "utf8", (err, contents) => {
	        try {
	          fs2.unlink(tempFile, () => callback(err, contents));
	        } catch {
	          callback(err, contents);
	        }
	      });
	    } catch (err) {
	      callback(err, null);
	    }
	  },
	  writeFile(contents, callback) {
	    try {
	      let tempFile = randomFileName();
	      fs2.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
	    } catch {
	      callback(null);
	    }
	  }
	};
	var version = "0.25.12";
	var build = (options) => ensureServiceIsRunning().build(options);
	var context = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
	var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
	var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
	var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
	var buildSync = (options) => {
	  if (worker_threads && !isInternalWorkerThread) {
	    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
	    return workerThreadService.buildSync(options);
	  }
	  let result;
	  runServiceSync((service) => service.buildOrContext({
	    callName: "buildSync",
	    refs: null,
	    options,
	    isTTY: isTTY(),
	    defaultWD,
	    callback: (err, res) => {
	      if (err) throw err;
	      result = res;
	    }
	  }));
	  return result;
	};
	var transformSync = (input, options) => {
	  if (worker_threads && !isInternalWorkerThread) {
	    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
	    return workerThreadService.transformSync(input, options);
	  }
	  let result;
	  runServiceSync((service) => service.transform({
	    callName: "transformSync",
	    refs: null,
	    input,
	    options: options || {},
	    isTTY: isTTY(),
	    fs: fsSync,
	    callback: (err, res) => {
	      if (err) throw err;
	      result = res;
	    }
	  }));
	  return result;
	};
	var formatMessagesSync = (messages, options) => {
	  if (worker_threads && !isInternalWorkerThread) {
	    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
	    return workerThreadService.formatMessagesSync(messages, options);
	  }
	  let result;
	  runServiceSync((service) => service.formatMessages({
	    callName: "formatMessagesSync",
	    refs: null,
	    messages,
	    options,
	    callback: (err, res) => {
	      if (err) throw err;
	      result = res;
	    }
	  }));
	  return result;
	};
	var analyzeMetafileSync = (metafile, options) => {
	  if (worker_threads && !isInternalWorkerThread) {
	    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
	    return workerThreadService.analyzeMetafileSync(metafile, options);
	  }
	  let result;
	  runServiceSync((service) => service.analyzeMetafile({
	    callName: "analyzeMetafileSync",
	    refs: null,
	    metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
	    options,
	    callback: (err, res) => {
	      if (err) throw err;
	      result = res;
	    }
	  }));
	  return result;
	};
	var stop = () => {
	  if (stopService) stopService();
	  if (workerThreadService) workerThreadService.stop();
	  return Promise.resolve();
	};
	var initializeWasCalled = false;
	var initialize = (options) => {
	  options = validateInitializeOptions(options || {});
	  if (options.wasmURL) throw new Error(`The "wasmURL" option only works in the browser`);
	  if (options.wasmModule) throw new Error(`The "wasmModule" option only works in the browser`);
	  if (options.worker) throw new Error(`The "worker" option only works in the browser`);
	  if (initializeWasCalled) throw new Error('Cannot call "initialize" more than once');
	  ensureServiceIsRunning();
	  initializeWasCalled = true;
	  return Promise.resolve();
	};
	var defaultWD = process.cwd();
	var longLivedService;
	var stopService;
	var ensureServiceIsRunning = () => {
	  if (longLivedService) return longLivedService;
	  let [command, args] = esbuildCommandAndArgs();
	  let child = child_process.spawn(command, args.concat(`--service=${"0.25.12"}`, "--ping"), {
	    windowsHide: true,
	    stdio: ["pipe", "pipe", "inherit"],
	    cwd: defaultWD
	  });
	  let { readFromStdout, afterClose, service } = createChannel({
	    writeToStdin(bytes) {
	      child.stdin.write(bytes, (err) => {
	        if (err) afterClose(err);
	      });
	    },
	    readFileSync: fs2.readFileSync,
	    isSync: false,
	    hasFS: true,
	    esbuild: node_exports
	  });
	  child.stdin.on("error", afterClose);
	  child.on("error", afterClose);
	  const stdin = child.stdin;
	  const stdout = child.stdout;
	  stdout.on("data", readFromStdout);
	  stdout.on("end", afterClose);
	  stopService = () => {
	    stdin.destroy();
	    stdout.destroy();
	    child.kill();
	    initializeWasCalled = false;
	    longLivedService = void 0;
	    stopService = void 0;
	  };
	  let refCount = 0;
	  child.unref();
	  if (stdin.unref) {
	    stdin.unref();
	  }
	  if (stdout.unref) {
	    stdout.unref();
	  }
	  const refs = {
	    ref() {
	      if (++refCount === 1) child.ref();
	    },
	    unref() {
	      if (--refCount === 0) child.unref();
	    }
	  };
	  longLivedService = {
	    build: (options) => new Promise((resolve, reject) => {
	      service.buildOrContext({
	        callName: "build",
	        refs,
	        options,
	        isTTY: isTTY(),
	        defaultWD,
	        callback: (err, res) => err ? reject(err) : resolve(res)
	      });
	    }),
	    context: (options) => new Promise((resolve, reject) => service.buildOrContext({
	      callName: "context",
	      refs,
	      options,
	      isTTY: isTTY(),
	      defaultWD,
	      callback: (err, res) => err ? reject(err) : resolve(res)
	    })),
	    transform: (input, options) => new Promise((resolve, reject) => service.transform({
	      callName: "transform",
	      refs,
	      input,
	      options: options || {},
	      isTTY: isTTY(),
	      fs: fsAsync,
	      callback: (err, res) => err ? reject(err) : resolve(res)
	    })),
	    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({
	      callName: "formatMessages",
	      refs,
	      messages,
	      options,
	      callback: (err, res) => err ? reject(err) : resolve(res)
	    })),
	    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({
	      callName: "analyzeMetafile",
	      refs,
	      metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
	      options,
	      callback: (err, res) => err ? reject(err) : resolve(res)
	    }))
	  };
	  return longLivedService;
	};
	var runServiceSync = (callback) => {
	  let [command, args] = esbuildCommandAndArgs();
	  let stdin = new Uint8Array();
	  let { readFromStdout, afterClose, service } = createChannel({
	    writeToStdin(bytes) {
	      if (stdin.length !== 0) throw new Error("Must run at most one command");
	      stdin = bytes;
	    },
	    isSync: true,
	    hasFS: true,
	    esbuild: node_exports
	  });
	  callback(service);
	  let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.25.12"}`), {
	    cwd: defaultWD,
	    windowsHide: true,
	    input: stdin,
	    // We don't know how large the output could be. If it's too large, the
	    // command will fail with ENOBUFS. Reserve 16mb for now since that feels
	    // like it should be enough. Also allow overriding this with an environment
	    // variable.
	    maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
	  });
	  readFromStdout(stdout);
	  afterClose(null);
	};
	var randomFileName = () => {
	  return path2.join(os2.tmpdir(), `esbuild-${crypto.randomBytes(32).toString("hex")}`);
	};
	var workerThreadService = null;
	var startWorkerThreadService = (worker_threads2) => {
	  let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
	  let worker = new worker_threads2.Worker(__filename, {
	    workerData: { workerPort, defaultWD, esbuildVersion: "0.25.12" },
	    transferList: [workerPort],
	    // From node's documentation: https://nodejs.org/api/worker_threads.html
	    //
	    //   Take care when launching worker threads from preload scripts (scripts loaded
	    //   and run using the `-r` command line flag). Unless the `execArgv` option is
	    //   explicitly set, new Worker threads automatically inherit the command line flags
	    //   from the running process and will preload the same preload scripts as the main
	    //   thread. If the preload script unconditionally launches a worker thread, every
	    //   thread spawned will spawn another until the application crashes.
	    //
	    execArgv: []
	  });
	  let nextID = 0;
	  let fakeBuildError = (text) => {
	    let error = new Error(`Build failed with 1 error:
error: ${text}`);
	    let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
	    error.errors = errors;
	    error.warnings = [];
	    return error;
	  };
	  let validateBuildSyncOptions = (options) => {
	    if (!options) return;
	    let plugins = options.plugins;
	    if (plugins && plugins.length > 0) throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
	  };
	  let applyProperties = (object, properties) => {
	    for (let key in properties) {
	      object[key] = properties[key];
	    }
	  };
	  let runCallSync = (command, args) => {
	    let id = nextID++;
	    let sharedBuffer = new SharedArrayBuffer(8);
	    let sharedBufferView = new Int32Array(sharedBuffer);
	    let msg = { sharedBuffer, id, command, args };
	    worker.postMessage(msg);
	    let status = Atomics.wait(sharedBufferView, 0, 0);
	    if (status !== "ok" && status !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + status);
	    let { message: { id: id2, resolve, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
	    if (id !== id2) throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
	    if (reject) {
	      applyProperties(reject, properties);
	      throw reject;
	    }
	    return resolve;
	  };
	  worker.unref();
	  return {
	    buildSync(options) {
	      validateBuildSyncOptions(options);
	      return runCallSync("build", [options]);
	    },
	    transformSync(input, options) {
	      return runCallSync("transform", [input, options]);
	    },
	    formatMessagesSync(messages, options) {
	      return runCallSync("formatMessages", [messages, options]);
	    },
	    analyzeMetafileSync(metafile, options) {
	      return runCallSync("analyzeMetafile", [metafile, options]);
	    },
	    stop() {
	      worker.terminate();
	      workerThreadService = null;
	    }
	  };
	};
	var startSyncServiceWorker = () => {
	  let workerPort = worker_threads.workerData.workerPort;
	  let parentPort = worker_threads.parentPort;
	  let extractProperties = (object) => {
	    let properties = {};
	    if (object && typeof object === "object") {
	      for (let key in object) {
	        properties[key] = object[key];
	      }
	    }
	    return properties;
	  };
	  try {
	    let service = ensureServiceIsRunning();
	    defaultWD = worker_threads.workerData.defaultWD;
	    parentPort.on("message", (msg) => {
	      (async () => {
	        let { sharedBuffer, id, command, args } = msg;
	        let sharedBufferView = new Int32Array(sharedBuffer);
	        try {
	          switch (command) {
	            case "build":
	              workerPort.postMessage({ id, resolve: await service.build(args[0]) });
	              break;
	            case "transform":
	              workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
	              break;
	            case "formatMessages":
	              workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
	              break;
	            case "analyzeMetafile":
	              workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
	              break;
	            default:
	              throw new Error(`Invalid command: ${command}`);
	          }
	        } catch (reject) {
	          workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
	        }
	        Atomics.add(sharedBufferView, 0, 1);
	        Atomics.notify(sharedBufferView, 0, Infinity);
	      })();
	    });
	  } catch (reject) {
	    parentPort.on("message", (msg) => {
	      let { sharedBuffer, id } = msg;
	      let sharedBufferView = new Int32Array(sharedBuffer);
	      workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
	      Atomics.add(sharedBufferView, 0, 1);
	      Atomics.notify(sharedBufferView, 0, Infinity);
	    });
	  }
	};
	if (isInternalWorkerThread) {
	  startSyncServiceWorker();
	}
	var node_default = node_exports;
	return main$1;
}

requireMain();

const { version: version$3 } = JSON.parse(
  readFileSync(new URL("../../package.json", import.meta.url)).toString()
);
const DEFAULT_MAIN_FIELDS = [
  "browser",
  "module",
  "jsnext:main",
  // moment still uses this...
  "jsnext"
];
const DEFAULT_CLIENT_MAIN_FIELDS = Object.freeze(DEFAULT_MAIN_FIELDS);
const DEFAULT_SERVER_MAIN_FIELDS = Object.freeze(
  DEFAULT_MAIN_FIELDS.filter((f) => f !== "browser")
);
const DEV_PROD_CONDITION = `development|production`;
const DEFAULT_CONDITIONS = ["module", "browser", "node", DEV_PROD_CONDITION];
const DEFAULT_CLIENT_CONDITIONS = Object.freeze(
  DEFAULT_CONDITIONS.filter((c) => c !== "node")
);
const DEFAULT_SERVER_CONDITIONS = Object.freeze(
  DEFAULT_CONDITIONS.filter((c) => c !== "browser")
);
const FS_PREFIX = `/@fs/`;
const VITE_PACKAGE_DIR = resolve$2(
  // import.meta.url is `dist/node/constants.js` after bundle
  fileURLToPath$1(import.meta.url),
  "../../.."
);
const CLIENT_ENTRY = resolve$2(VITE_PACKAGE_DIR, "dist/client/client.mjs");
const ENV_ENTRY = resolve$2(VITE_PACKAGE_DIR, "dist/client/env.mjs");
const CLIENT_DIR = path$b.dirname(CLIENT_ENTRY);

//#region rolldown:runtime
var __require$1 = /* @__PURE__ */ createRequire$1(import.meta.url);

//#endregion
//#region src/builder/index.ts
let pm = null;
/* c8 ignore next 6 */
try {
	__require$1.resolve("picomatch");
	pm = __require$1("picomatch");
} catch {}

typeof process < "u" && process.platform === "win32";
const chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar$2 = new Uint8Array(64), charToInt$2 = new Uint8Array(128);
for (let i = 0; i < chars$2.length; i++) {
  const c = chars$2.charCodeAt(i);
  intToChar$2[i] = c, charToInt$2[c] = i;
}

const __require = createRequire$2(import.meta.url);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var picocolors$1 = { exports: {} };
let p = process || {}, argv = p.argv || [], env$1 = p.env || {};
let isColorSupported = !(!!env$1.NO_COLOR || argv.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI);
let formatter = (open2, close2, replace = open2) => (input) => {
  let string = "" + input, index2 = string.indexOf(close2, open2.length);
  return ~index2 ? open2 + replaceClose(string, close2, replace, index2) + close2 : open2 + string + close2;
};
let replaceClose = (string, close2, replace, index2) => {
  let result = "", cursor = 0;
  do {
    result += string.substring(cursor, index2) + replace;
    cursor = index2 + close2.length;
    index2 = string.indexOf(close2, cursor);
  } while (~index2);
  return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported) => {
  let f2 = enabled ? formatter : () => String;
  return {
    isColorSupported: enabled,
    reset: f2("\x1B[0m", "\x1B[0m"),
    bold: f2("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
    dim: f2("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
    italic: f2("\x1B[3m", "\x1B[23m"),
    underline: f2("\x1B[4m", "\x1B[24m"),
    inverse: f2("\x1B[7m", "\x1B[27m"),
    hidden: f2("\x1B[8m", "\x1B[28m"),
    strikethrough: f2("\x1B[9m", "\x1B[29m"),
    black: f2("\x1B[30m", "\x1B[39m"),
    red: f2("\x1B[31m", "\x1B[39m"),
    green: f2("\x1B[32m", "\x1B[39m"),
    yellow: f2("\x1B[33m", "\x1B[39m"),
    blue: f2("\x1B[34m", "\x1B[39m"),
    magenta: f2("\x1B[35m", "\x1B[39m"),
    cyan: f2("\x1B[36m", "\x1B[39m"),
    white: f2("\x1B[37m", "\x1B[39m"),
    gray: f2("\x1B[90m", "\x1B[39m"),
    bgBlack: f2("\x1B[40m", "\x1B[49m"),
    bgRed: f2("\x1B[41m", "\x1B[49m"),
    bgGreen: f2("\x1B[42m", "\x1B[49m"),
    bgYellow: f2("\x1B[43m", "\x1B[49m"),
    bgBlue: f2("\x1B[44m", "\x1B[49m"),
    bgMagenta: f2("\x1B[45m", "\x1B[49m"),
    bgCyan: f2("\x1B[46m", "\x1B[49m"),
    bgWhite: f2("\x1B[47m", "\x1B[49m"),
    blackBright: f2("\x1B[90m", "\x1B[39m"),
    redBright: f2("\x1B[91m", "\x1B[39m"),
    greenBright: f2("\x1B[92m", "\x1B[39m"),
    yellowBright: f2("\x1B[93m", "\x1B[39m"),
    blueBright: f2("\x1B[94m", "\x1B[39m"),
    magentaBright: f2("\x1B[95m", "\x1B[39m"),
    cyanBright: f2("\x1B[96m", "\x1B[39m"),
    whiteBright: f2("\x1B[97m", "\x1B[39m"),
    bgBlackBright: f2("\x1B[100m", "\x1B[49m"),
    bgRedBright: f2("\x1B[101m", "\x1B[49m"),
    bgGreenBright: f2("\x1B[102m", "\x1B[49m"),
    bgYellowBright: f2("\x1B[103m", "\x1B[49m"),
    bgBlueBright: f2("\x1B[104m", "\x1B[49m"),
    bgMagentaBright: f2("\x1B[105m", "\x1B[49m"),
    bgCyanBright: f2("\x1B[106m", "\x1B[49m"),
    bgWhiteBright: f2("\x1B[107m", "\x1B[49m")
  };
};
picocolors$1.exports = createColors();
picocolors$1.exports.createColors = createColors;
var picocolorsExports = picocolors$1.exports;
var colors$1 = /* @__PURE__ */ getDefaultExportFromCjs(picocolorsExports);
const isWindows$3 = typeof process !== "undefined" && process.platform === "win32";
const windowsSlashRE = /\\/g;
function slash$1(p2) {
  return p2.replace(windowsSlashRE, "/");
}
function isArray$1(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray$1(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
const normalizePathRegExp = new RegExp(`\\${win32.sep}`, "g");
const normalizePath$5 = function normalizePath(filename) {
  return filename.replace(normalizePathRegExp, posix$1.sep);
};
function getMatcherString$1(id, resolutionBase) {
  if (resolutionBase === false || isAbsolute(id) || id.startsWith("**")) {
    return normalizePath$5(id);
  }
  const basePath = normalizePath$5(resolve$3(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return posix$1.join(basePath, normalizePath$5(id));
}
const createFilter$2 = function createFilter(include, exclude, options2) {
  const resolutionBase = options2 && options2.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : {
    test: (what) => {
      const pattern = getMatcherString$1(id, resolutionBase);
      const fn = pm$1(pattern, { dot: true });
      const result = fn(what);
      return result;
    }
  };
  const includeMatchers = ensureArray(include).map(getMatcher);
  const excludeMatchers = ensureArray(exclude).map(getMatcher);
  if (!includeMatchers.length && !excludeMatchers.length)
    return (id) => typeof id === "string" && !id.includes("\0");
  return function result(id) {
    if (typeof id !== "string")
      return false;
    if (id.includes("\0"))
      return false;
    const pathId = normalizePath$5(id);
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if (matcher instanceof RegExp) {
        matcher.lastIndex = 0;
      }
      if (matcher.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if (matcher instanceof RegExp) {
        matcher.lastIndex = 0;
      }
      if (matcher.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
const reservedWords$2 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
const builtins$1 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
const forbiddenIdentifiers$1 = new Set(`${reservedWords$2} ${builtins$1}`.split(" "));
forbiddenIdentifiers$1.add("");
const chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar$1 = new Uint8Array(64);
const charToInt$1 = new Uint8Array(128);
for (let i = 0; i < chars$1.length; i++) {
  const c = chars$1.charCodeAt(i);
  intToChar$1[i] = c;
  charToInt$1[c] = i;
}
var node$1$1 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1) return ms$1;
  hasRequiredMs$1 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w = d2 * 7;
  var y2 = d2 * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse3(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse3(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common$4;
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$4;
  hasRequiredCommon$1 = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy2;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index2];
            match = formatter2.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$4 = setup;
  return common$4;
}
(function(module, exports$1) {
  const tty = require$$0$3;
  const util2 = require$$1$1;
  exports$1.init = init2;
  exports$1.log = log;
  exports$1.formatArgs = formatArgs;
  exports$1.save = save;
  exports$1.load = load2;
  exports$1.useColors = useColors;
  exports$1.destroy = util2.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  exports$1.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require("supports-color");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports$1.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {
  }
  exports$1.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports$1.inspectOpts.hideDate) {
      return "";
    }
    return (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util2.formatWithOptions(exports$1.inspectOpts, ...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init2(debug2) {
    debug2.inspectOpts = {};
    const keys = Object.keys(exports$1.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug2.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
    }
  }
  module.exports = requireCommon$1()(exports$1);
  const { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
})(node$1$1, node$1$1.exports);
var nodeExports$1 = node$1$1.exports;
var debug$j = /* @__PURE__ */ getDefaultExportFromCjs(nodeExports$1);
let pnp$1;
if (process.versions.pnp) {
  try {
    pnp$1 = createRequire$2(import.meta.url)("pnpapi");
  } catch {
  }
}
function resolvePackageData(pkgName, basedir, preserveSymlinks = false, packageCache) {
  if (pnp$1) {
    const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks);
    try {
      const pkg = pnp$1.resolveToUnqualified(pkgName, basedir, {
        considerBuiltins: false
      });
      if (!pkg) return null;
      const pkgData = loadPackageData(path$b.join(pkg, "package.json"));
      packageCache?.set(cacheKey, pkgData);
      return pkgData;
    } catch {
      return null;
    }
  }
  const originalBasedir = basedir;
  while (basedir) {
    const pkg = path$b.join(basedir, "node_modules", pkgName, "package.json");
    try {
      if (fs__default.existsSync(pkg)) {
        const pkgPath = preserveSymlinks ? pkg : safeRealpathSync(pkg);
        const pkgData = loadPackageData(pkgPath);
        if (packageCache) ;
        return pkgData;
      }
    } catch {
    }
    const nextBasedir = path$b.dirname(basedir);
    if (nextBasedir === basedir) break;
    basedir = nextBasedir;
  }
  return null;
}
function loadPackageData(pkgPath) {
  const data = JSON.parse(stripBomTag(fs__default.readFileSync(pkgPath, "utf-8")));
  const pkgDir = normalizePath$3(path$b.dirname(pkgPath));
  const { sideEffects } = data;
  let hasSideEffects;
  if (typeof sideEffects === "boolean") {
    hasSideEffects = () => sideEffects;
  } else if (Array.isArray(sideEffects)) {
    if (sideEffects.length <= 0) {
      hasSideEffects = () => false;
    } else {
      const finalPackageSideEffects = sideEffects.map((sideEffect) => {
        if (sideEffect.includes("/")) {
          return sideEffect;
        }
        return `**/${sideEffect}`;
      });
      hasSideEffects = createFilter$1(finalPackageSideEffects, null, {
        resolve: pkgDir
      });
    }
  } else {
    hasSideEffects = () => null;
  }
  const resolvedCache = {};
  const pkg = {
    dir: pkgDir,
    data,
    hasSideEffects,
    setResolvedCache(key, entry, options2) {
      resolvedCache[getResolveCacheKey(key, options2)] = entry;
    },
    getResolvedCache(key, options2) {
      return resolvedCache[getResolveCacheKey(key, options2)];
    }
  };
  return pkg;
}
function getResolveCacheKey(key, options2) {
  return [
    key,
    options2.isRequire ? "1" : "0",
    options2.conditions.join("_"),
    options2.extensions.join("_"),
    options2.mainFields.join("_")
  ].join("|");
}
function setRpdCache(packageCache, pkgData, pkgName, basedir, originalBasedir, preserveSymlinks) {
  packageCache.set(getRpdCacheKey(pkgName, basedir, preserveSymlinks), pkgData);
  traverseBetweenDirs(originalBasedir, basedir, (dir) => {
    packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData);
  });
}
function getRpdCacheKey(pkgName, basedir, preserveSymlinks) {
  return `rpd_${pkgName}_${basedir}_${preserveSymlinks}`;
}
function traverseBetweenDirs(longerDir, shorterDir, cb) {
  while (longerDir !== shorterDir) {
    cb(longerDir);
    longerDir = path$b.dirname(longerDir);
  }
}
const createFilter$1 = createFilter$2;
const NODE_BUILTIN_NAMESPACE = "node:";
const NPM_BUILTIN_NAMESPACE = "npm:";
const BUN_BUILTIN_NAMESPACE = "bun:";
const nodeBuiltins = builtinModules.filter((id) => !id.includes(":"));
[
  ...nodeBuiltins,
  new RegExp(`^${NODE_BUILTIN_NAMESPACE}`),
  new RegExp(`^${NPM_BUILTIN_NAMESPACE}`),
  new RegExp(`^${BUN_BUILTIN_NAMESPACE}`)
];
createRequire$2(import.meta.url);
const _dirname = path$b.dirname(fileURLToPath$1(import.meta.url));
resolvePackageData("rollup", _dirname, true)?.data.version ?? "";
const filter$1 = process.env.VITE_DEBUG_FILTER;
const DEBUG = process.env.DEBUG;
function createDebugger$1(namespace, options2 = {}) {
  const log = debug$j(namespace);
  const { onlyWhenFocused, depth } = options2;
  if (depth && log.inspectOpts && log.inspectOpts.depth == null) {
    log.inspectOpts.depth = options2.depth;
  }
  let enabled = log.enabled;
  if (enabled && onlyWhenFocused) {
    const ns = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
    enabled = !!DEBUG?.includes(ns);
  }
  if (enabled) {
    return (...args) => {
      if (!filter$1 || args.some((a) => a?.includes?.(filter$1))) {
        log(...args);
      }
    };
  }
}
function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith("client.mjs")) {
    throw new Error(
      `cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`
    );
  }
  if (!fs__default.existsSync(CLIENT_ENTRY)) {
    throw new Error(
      "cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY
    );
  }
  return fs__default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
(
  // eslint-disable-next-line n/no-unsupported-features/node-builtins
  URL$3.canParse ?? // URL.canParse is supported from Node.js 18.17.0+, 20.0.0+
  ((path2, base) => {
    try {
      new URL$3(path2, base);
      return true;
    } catch {
      return false;
    }
  })
);
testCaseInsensitiveFS();
function normalizePath$3(id) {
  return path$b.posix.normalize(isWindows$3 ? slash$1(id) : id);
}
function tryStatSync(file) {
  try {
    return fs__default.statSync(file, { throwIfNoEntry: false });
  } catch {
  }
}
let safeRealpathSync = isWindows$3 ? windowsSafeRealPathSync : fs__default.realpathSync.native;
const windowsNetworkMap = /* @__PURE__ */ new Map();
function windowsMappedRealpathSync(path2) {
  const realPath = fs__default.realpathSync.native(path2);
  if (realPath.startsWith("\\\\")) {
    for (const [network, volume] of windowsNetworkMap) {
      if (realPath.startsWith(network)) return realPath.replace(network, volume);
    }
  }
  return realPath;
}
const parseNetUseRE = /^\w* +(\w:) +([^ ]+)\s/;
let firstSafeRealPathSyncRun = false;
function windowsSafeRealPathSync(path2) {
  if (!firstSafeRealPathSyncRun) {
    optimizeSafeRealPathSync();
    firstSafeRealPathSyncRun = true;
  }
  return fs__default.realpathSync(path2);
}
function optimizeSafeRealPathSync() {
  const nodeVersion = process.versions.node.split(".").map(Number);
  if (nodeVersion[0] < 18 || nodeVersion[0] === 18 && nodeVersion[1] < 10) {
    safeRealpathSync = fs__default.realpathSync;
    return;
  }
  try {
    fs__default.realpathSync.native(path$b.resolve("./"));
  } catch (error2) {
    if (error2.message.includes("EISDIR: illegal operation on a directory")) {
      safeRealpathSync = fs__default.realpathSync;
      return;
    }
  }
  exec("net use", (error2, stdout) => {
    if (error2) return;
    const lines = stdout.split("\n");
    for (const line of lines) {
      const m2 = parseNetUseRE.exec(line);
      if (m2) windowsNetworkMap.set(m2[2], m2[1]);
    }
    if (windowsNetworkMap.size === 0) {
      safeRealpathSync = fs__default.realpathSync.native;
    } else {
      safeRealpathSync = windowsMappedRealpathSync;
    }
  });
}
function arraify$2(target) {
  return Array.isArray(target) ? target : [target];
}
(
  // eslint-disable-next-line n/no-unsupported-features/node-builtins -- crypto.hash is supported in Node 21.7.0+, 20.12.0+
  crypto$2.hash ?? ((algorithm, data, outputEncoding) => crypto$2.createHash(algorithm).update(data).digest(outputEncoding))
);
function stripBomTag(content) {
  if (content.charCodeAt(0) === 65279) {
    return content.slice(1);
  }
  return content;
}
[
  { name: "Assets", color: colors$1.green },
  { name: "CSS", color: colors$1.magenta },
  { name: "JS", color: colors$1.cyan }
];
new RegExp("\\" + path$b.posix.sep, "g");
new RegExp("\\" + path$b.sep, "g");
const TS_EXTENSIONS$1 = [".ts", ".tsx", ".mts", ".cts"];
const JS_EXTENSIONS$1 = [".js", ".jsx", ".mjs", ".cjs"];
const TSJS_EXTENSIONS$1 = TS_EXTENSIONS$1.concat(JS_EXTENSIONS$1);
`\\.(?:${TS_EXTENSIONS$1.map((ext) => ext.substring(1)).join("|")})`;
`\\.(?:${TSJS_EXTENSIONS$1.map((ext) => ext.substring(1)).join(
  "|"
)})`;
path$b.posix.sep === path$b.sep;
createDebugger$1("vite:esbuild");
Buffer$1.from("version https://git-lfs.github.com");
var ImportType;
!(function(A2) {
  A2[A2.Static = 1] = "Static", A2[A2.Dynamic = 2] = "Dynamic", A2[A2.ImportMeta = 3] = "ImportMeta", A2[A2.StaticSourcePhase = 4] = "StaticSourcePhase", A2[A2.DynamicSourcePhase = 5] = "DynamicSourcePhase";
})(ImportType || (ImportType = {}));
1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
const E = () => {
  return A2 = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKm0EwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQvcCAEGf0EAIQBBAEEAKAKwCiIBQQxqIgI2ArAKQQEQKSEDQQAoArAKIQQCQAJAAkACQAJAAkACQAJAIANBLkcNAEEAIARBAmo2ArAKAkBBARApIgNB8wBGDQAgA0HtAEcNB0EAKAKwCiIDQQJqQZwIQQYQLw0HAkBBACgCnAoiBBAqDQAgBC8BAEEuRg0ICyABIAEgA0EIakEAKALUCRABDwtBACgCsAoiA0ECakGiCEEKEC8NBgJAQQAoApwKIgQQKg0AIAQvAQBBLkYNBwsgA0EMaiEDDAELIANB8wBHDQEgBCACTQ0BQQYhAEEAIQIgBEECakGiCEEKEC8NAiAEQQxqIQMCQCAELwEMIgVBd2oiBEEXSw0AQQEgBHRBn4CABHENAQsgBUGgAUcNAgtBACADNgKwCkEBIQBBARApIQMLAkACQAJAAkAgA0H7AEYNACADQShHDQFBACgCpApBAC8BmAoiA0EDdGoiBEEAKAKwCjYCBEEAIANBAWo7AZgKIARBBTYCAEEAKAKcCi8BAEEuRg0HQQBBACgCsAoiBEECajYCsApBARApIQMgAUEAKAKwCkEAIAQQAQJAAkAgAA0AQQAoAvAJIQQMAQtBACgC8AkiBEEFNgIcC0EAQQAvAZYKIgBBAWo7AZYKQQAoAqgKIABBAnRqIAQ2AgACQCADQSJGDQAgA0EnRg0AQQBBACgCsApBfmo2ArAKDwsgAxAaQQBBACgCsApBAmoiAzYCsAoCQAJAAkBBARApQVdqDgQBAgIAAgtBAEEAKAKwCkECajYCsApBARApGkEAKALwCSIEIAM2AgQgBEEBOgAYIARBACgCsAoiAzYCEEEAIANBfmo2ArAKDwtBACgC8AkiBCADNgIEIARBAToAGEEAQQAvAZgKQX9qOwGYCiAEQQAoArAKQQJqNgIMQQBBAC8BlgpBf2o7AZYKDwtBAEEAKAKwCkF+ajYCsAoPCyAADQJBACgCsAohA0EALwGYCg0BA0ACQAJAAkAgA0EAKAK0Ck8NAEEBECkiA0EiRg0BIANBJ0YNASADQf0ARw0CQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0JC0EAIANBCGo2ArAKAkBBARApIgNBIkYNACADQSdHDQkLIAEgA0EAECsPCyADEBoLQQBBACgCsApBAmoiAzYCsAoMAAsLIAANAUEGIQBBACECAkAgA0FZag4EBAMDBAALIANBIkYNAwwCC0EAIANBfmo2ArAKDwtBDCEAQQEhAgtBACgCsAoiAyABIABBAXRqRw0AQQAgA0F+ajYCsAoPC0EALwGYCg0CQQAoArAKIQNBACgCtAohAANAIAMgAE8NAQJAAkAgAy8BACIEQSdGDQAgBEEiRw0BCyABIAQgAhArDwtBACADQQJqIgM2ArAKDAALCxAlCw8LQQBBACgCsApBfmo2ArAKC0cBA39BACgCsApBAmohAEEAKAK0CiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2ArAKC5gBAQN/QQBBACgCsAoiAUECajYCsAogAUEGaiEBQQAoArQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2ArAKDAELIAFBfmohAQtBACABNgKwCg8LIAFBAmohAQwACwuIAQEEf0EAKAKwCiEBQQAoArQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKwChAlDwtBACABNgKwCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQaYJQQUQHQ0AIABBlghBAxAdDQAgAEGwCUECEB0hAQsgAQtGAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC3AkiBUkNACAAIAEgAhAvDQACQCAAIAVHDQBBAQ8LIAQQJiEDCyADC4MBAQJ/QQEhAQJAAkACQAJAAkACQCAALwEAIgJBRWoOBAUEBAEACwJAIAJBm39qDgQDBAQCAAsgAkEpRg0EIAJB+QBHDQMgAEF+akG8CUEGEB0PCyAAQX5qLwEAQT1GDwsgAEF+akG0CUEEEB0PCyAAQX5qQcgJQQMQHQ8LQQAhAQsgAQu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQcoIQQIQHQ8LIABBfGpBzghBAxAdDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAnDwsgAEF6akHjABAnDwsgAEF8akHUCEEEEB0PCyAAQXxqQdwIQQYQHQ8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB6AhBBhAdDwsgAEF4akH0CEECEB0PCyAAQX5qQfgIQQQQHQ8LQQEhASAAQX5qIgBB6QAQJw0EIABBgAlBBRAdDwsgAEF+akHkABAnDwsgAEF+akGKCUEHEB0PCyAAQX5qQZgJQQQQHQ8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAnDwsgAEF8akGgCUEDEB0hAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAocSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akH4CEEEEB0PCyAAQX5qLwEAQfUARw0AIABBfGpB3AhBBhAdIQELIAEL3gEBBH9BACgCsAohAEEAKAK0CiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2ArAKQQBBAC8BmAoiAkEBajsBmApBACgCpAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCsApBAEEALwGYCkF/aiIAOwGYCkEAKAKkCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2ArAKCxAlCwtwAQJ/AkACQANAQQBBACgCsAoiAEECaiIBNgKwCiAAQQAoArQKTw0BAkACQAJAIAEvAQAiAUGlf2oOAgECAAsCQCABQXZqDgQEAwMEAAsgAUEvRw0CDAQLEC4aDAELQQAgAEEEajYCsAoMAAsLECULCzUBAX9BAEEBOgD8CUEAKAKwCiEAQQBBACgCtApBAmo2ArAKQQAgAEEAKALcCWtBAXU2ApAKC0MBAn9BASEBAkAgAC8BACICQXdqQf//A3FBBUkNACACQYABckGgAUYNAEEAIQEgAhAoRQ0AIAJBLkcgABAqcg8LIAELPQECf0EAIQICQEEAKALcCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAECAhAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKwCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQGAwCCyAAEBkMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACECFFDQMMAQsgAkGgAUcNAgtBAEEAKAKwCiIDQQJqIgE2ArAKIANBACgCtApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELnAQBAX8CQCABQSJGDQAgAUEnRg0AECUPC0EAKAKwCiEDIAEQGiAAIANBAmpBACgCsApBACgC0AkQAQJAIAJFDQBBACgC8AlBBDYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQAMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhACABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIABBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiAiEAA0BBACAAQQJqNgKwCgJAAkACQEEBECkiAEEiRg0AIABBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQAMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSEADAELIAAQLCEACwJAIABBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAEEiRg0AIABBJ0YNAEEAIAE2ArAKDwsgABAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAEEsRg0AIABB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiEADAELC0EAKALwCSIBIAI2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(A2, "base64") : Uint8Array.from(atob(A2), ((A3) => A3.charCodeAt(0)));
  var A2;
};
WebAssembly.compile(E()).then(WebAssembly.instantiate).then((({ exports: A2 }) => {
}));
var convertSourceMap$1 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "commentRegex", {
    get: function getCommentRegex() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }
  });
  Object.defineProperty(exports$1, "mapFileCommentRegex", {
    get: function getMapFileCommentRegex() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }
  });
  var decodeBase64;
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      decodeBase64 = decodeBase64WithBufferFrom;
    } else {
      decodeBase64 = decodeBase64WithNewBuffer;
    }
  } else {
    decodeBase64 = decodeBase64WithAtob;
  }
  function decodeBase64WithBufferFrom(base64) {
    return Buffer.from(base64, "base64").toString();
  }
  function decodeBase64WithNewBuffer(base64) {
    if (typeof value === "number") {
      throw new TypeError("The value to decode must not be of type number.");
    }
    return new Buffer(base64, "base64").toString();
  }
  function decodeBase64WithAtob(base64) {
    return decodeURIComponent(escape(atob(base64)));
  }
  function stripComment(sm) {
    return sm.split(",").pop();
  }
  function readFromFileMap(sm, read) {
    var r2 = exports$1.mapFileCommentRegex.exec(sm);
    var filename = r2[1] || r2[2];
    try {
      var sm = read(filename);
      if (sm != null && typeof sm.catch === "function") {
        return sm.catch(throwError);
      } else {
        return sm;
      }
    } catch (e2) {
      throwError(e2);
    }
    function throwError(e2) {
      throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e2.stack);
    }
  }
  function Converter(sm, opts) {
    opts = opts || {};
    if (opts.hasComment) {
      sm = stripComment(sm);
    }
    if (opts.encoding === "base64") {
      sm = decodeBase64(sm);
    } else if (opts.encoding === "uri") {
      sm = decodeURIComponent(sm);
    }
    if (opts.isJSON || opts.encoding) {
      sm = JSON.parse(sm);
    }
    this.sourcemap = sm;
  }
  Converter.prototype.toJSON = function(space) {
    return JSON.stringify(this.sourcemap, null, space);
  };
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
    } else {
      Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
    }
  } else {
    Converter.prototype.toBase64 = encodeBase64WithBtoa;
  }
  function encodeBase64WithBufferFrom() {
    var json = this.toJSON();
    return Buffer.from(json, "utf8").toString("base64");
  }
  function encodeBase64WithNewBuffer() {
    var json = this.toJSON();
    if (typeof json === "number") {
      throw new TypeError("The json to encode must not be of type number.");
    }
    return new Buffer(json, "utf8").toString("base64");
  }
  function encodeBase64WithBtoa() {
    var json = this.toJSON();
    return btoa(unescape(encodeURIComponent(json)));
  }
  Converter.prototype.toURI = function() {
    var json = this.toJSON();
    return encodeURIComponent(json);
  };
  Converter.prototype.toComment = function(options2) {
    var encoding, content, data;
    if (options2 != null && options2.encoding === "uri") {
      encoding = "";
      content = this.toURI();
    } else {
      encoding = ";base64";
      content = this.toBase64();
    }
    data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
    return options2 != null && options2.multiline ? "/*# " + data + " */" : "//# " + data;
  };
  Converter.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Converter.prototype.addProperty = function(key, value2) {
    if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(key, value2);
  };
  Converter.prototype.setProperty = function(key, value2) {
    this.sourcemap[key] = value2;
    return this;
  };
  Converter.prototype.getProperty = function(key) {
    return this.sourcemap[key];
  };
  exports$1.fromObject = function(obj) {
    return new Converter(obj);
  };
  exports$1.fromJSON = function(json) {
    return new Converter(json, { isJSON: true });
  };
  exports$1.fromURI = function(uri) {
    return new Converter(uri, { encoding: "uri" });
  };
  exports$1.fromBase64 = function(base64) {
    return new Converter(base64, { encoding: "base64" });
  };
  exports$1.fromComment = function(comment) {
    var m2, encoding;
    comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
    m2 = exports$1.commentRegex.exec(comment);
    encoding = m2 && m2[4] || "uri";
    return new Converter(comment, { encoding, hasComment: true });
  };
  function makeConverter(sm) {
    return new Converter(sm, { isJSON: true });
  }
  exports$1.fromMapFileComment = function(comment, read) {
    if (typeof read === "string") {
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
      );
    }
    var sm = readFromFileMap(comment, read);
    if (sm != null && typeof sm.then === "function") {
      return sm.then(makeConverter);
    } else {
      return makeConverter(sm);
    }
  };
  exports$1.fromSource = function(content) {
    var m2 = content.match(exports$1.commentRegex);
    return m2 ? exports$1.fromComment(m2.pop()) : null;
  };
  exports$1.fromMapFileSource = function(content, read) {
    if (typeof read === "string") {
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
      );
    }
    var m2 = content.match(exports$1.mapFileCommentRegex);
    return m2 ? exports$1.fromMapFileComment(m2.pop(), read) : null;
  };
  exports$1.removeComments = function(src2) {
    return src2.replace(exports$1.commentRegex, "");
  };
  exports$1.removeMapFileComments = function(src2) {
    return src2.replace(exports$1.mapFileCommentRegex, "");
  };
  exports$1.generateMapFileComment = function(file, options2) {
    var data = "sourceMappingURL=" + file;
    return options2 && options2.multiline ? "/*# " + data + " */" : "//# " + data;
  };
})(convertSourceMap$1);
createDebugger$1("vite:sourcemap", {
  onlyWhenFocused: true
});
const fs$7 = require$$0$4;
fs$7.promises.readFile;
typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
const { createRequire } = require$$0$6;
const { fileURLToPath, pathToFileURL } = require$$1$1$1;
const { resolve: resolve$1 } = path$b;
new Set(builtinModules);
const own$1 = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
const kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
const messages = /* @__PURE__ */ new Map();
const nodeInternalPrefix = "__node_internal_";
let userStackTraceLimit;
createError(
  "ERR_INVALID_ARG_TYPE",
  /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */
  (name, expected, actual) => {
    assert$2(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name.endsWith(" argument")) {
      message += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type} `;
    }
    message += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value2 of expected) {
      assert$2(
        typeof value2 === "string",
        "All expected entries have to be of type string"
      );
      if (kTypes.has(value2)) {
        types.push(value2.toLowerCase());
      } else if (classRegExp.exec(value2) === null) {
        assert$2(
          value2 !== "object",
          'The value "object" should be written as "Object"'
        );
        other.push(value2);
      } else {
        instances.push(value2);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
        types,
        "or"
      )}`;
      if (instances.length > 0 || other.length > 0) message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0) message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0].toLowerCase() !== other[0]) message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  },
  TypeError
);
createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  },
  TypeError
);
createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path2, base, message) => {
    return `Invalid package config ${path2}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
createError(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} packagePath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (packagePath, key, target, isImport = false, base = void 0) => {
    const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      assert$2(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
createError(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {boolean} [exactUrl]
   */
  (path2, base, exactUrl = false) => {
    return `Cannot find ${exactUrl ? "module" : "package"} '${path2}' imported from ${base}`;
  },
  Error
);
createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
  },
  TypeError
);
createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */
  (packagePath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);
createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
createError(
  "ERR_UNSUPPORTED_RESOLVE_REQUEST",
  'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
  TypeError
);
createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} extension
   * @param {string} path
   */
  (extension2, path2) => {
    return `Unknown file extension "${extension2}" for ${path2}`;
  },
  TypeError
);
createError(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name, value2, reason = "is invalid") => {
    let inspected = inspect(value2);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
function createError(sym, value2, constructor) {
  messages.set(sym, value2);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error2 = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error2);
    Object.defineProperties(error2, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error2);
    error2.code = key;
    return error2;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8$1.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error2) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error2);
    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
    return error2;
  }
);
function getMessage(key, parameters, self2) {
  const message = messages.get(key);
  assert$2(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    assert$2(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  assert$2(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(format$2, null, parameters);
}
function determineSpecificType(value2) {
  if (value2 === null || value2 === void 0) {
    return String(value2);
  }
  if (typeof value2 === "function" && value2.name) {
    return `function ${value2.name}`;
  }
  if (typeof value2 === "object") {
    if (value2.constructor && value2.constructor.name) {
      return `an instance of ${value2.constructor.name}`;
    }
    return `${inspect(value2, { depth: -1 })}`;
  }
  let inspected = inspect(value2, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value2} (${inspected})`;
}
[
  colors$1.blue,
  colors$1.magenta,
  colors$1.green,
  colors$1.gray
];
var LineTerminatorSequence;
LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
RegExp(LineTerminatorSequence.source);
const { basename, dirname, relative } = posix;
createDebugger$1("vite:deps");
createDebugger$1("vite:deps");
const lockfileFormats = [
  {
    path: "node_modules/.package-lock.json",
    checkPatchesDir: "patches",
    manager: "npm"
  },
  {
    // Yarn non-PnP
    path: "node_modules/.yarn-state.yml",
    checkPatchesDir: false,
    manager: "yarn"
  },
  {
    // Yarn v3+ PnP
    path: ".pnp.cjs",
    checkPatchesDir: ".yarn/patches",
    manager: "yarn"
  },
  {
    // Yarn v2 PnP
    path: ".pnp.js",
    checkPatchesDir: ".yarn/patches",
    manager: "yarn"
  },
  {
    // yarn 1
    path: "node_modules/.yarn-integrity",
    checkPatchesDir: "patches",
    manager: "yarn"
  },
  {
    path: "node_modules/.pnpm/lock.yaml",
    // Included in lockfile
    checkPatchesDir: false,
    manager: "pnpm"
  },
  {
    path: "bun.lock",
    checkPatchesDir: "patches",
    manager: "bun"
  },
  {
    path: "bun.lockb",
    checkPatchesDir: "patches",
    manager: "bun"
  }
].sort((_, { manager }) => {
  return process.env.npm_config_user_agent?.startsWith(manager) ? 1 : -1;
});
lockfileFormats.map((l) => l.path);
const GRACEFUL_RENAME_TIMEOUT = 5e3;
promisify$4(function gracefulRename(from, to, cb) {
  const start = Date.now();
  let backoff = 0;
  fs__default.rename(from, to, function CB(er) {
    if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_RENAME_TIMEOUT) {
      setTimeout(function() {
        fs__default.stat(to, function(stater, _st) {
          if (stater && stater.code === "ENOENT") fs__default.rename(from, to, CB);
          else CB(er);
        });
      }, backoff);
      if (backoff < 100) backoff += 10;
      return;
    }
    cb(er);
  });
});
createDebugger$1("vite:external");
normalizePath$3(CLIENT_ENTRY);
normalizePath$3(ENV_ENTRY);
createDebugger$1("vite:resolve-details", {
  onlyWhenFocused: true
});
createDebugger$1("vite:optimize-deps");
var main = { exports: {} };
var version$1 = "16.5.0";
var require$$4$1 = {
  version: version$1
};
const fs$6 = require$$0$4;
const path$8 = require$$0$2$1;
const os$1 = require$$2;
const crypto$1 = require$$3;
const packageJson = require$$4$1;
const version$2 = packageJson.version;
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse$c(src2) {
  const obj = {};
  let lines = src2.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    let value2 = match[2] || "";
    value2 = value2.trim();
    const maybeQuote = value2[0];
    value2 = value2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value2 = value2.replace(/\\n/g, "\n");
      value2 = value2.replace(/\\r/g, "\r");
    }
    obj[key] = value2;
  }
  return obj;
}
function _parseVault(options2) {
  const vaultPath = _vaultPath(options2);
  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err2 = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err2.code = "MISSING_DATA";
    throw err2;
  }
  const keys = _dotenvKey(options2).split(",");
  const length = keys.length;
  let decrypted;
  for (let i = 0; i < length; i++) {
    try {
      const key = keys[i].trim();
      const attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error2) {
      if (i + 1 >= length) {
        throw error2;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _warn(message) {
  console.log(`[dotenv@${version$2}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version$2}][DEBUG] ${message}`);
}
function _dotenvKey(options2) {
  if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
    return options2.DOTENV_KEY;
  }
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error2) {
    if (error2.code === "ERR_INVALID_URL") {
      const err2 = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err2.code = "INVALID_DOTENV_KEY";
      throw err2;
    }
    throw error2;
  }
  const key = uri.password;
  if (!key) {
    const err2 = new Error("INVALID_DOTENV_KEY: Missing key part");
    err2.code = "INVALID_DOTENV_KEY";
    throw err2;
  }
  const environment = uri.searchParams.get("environment");
  if (!environment) {
    const err2 = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err2.code = "INVALID_DOTENV_KEY";
    throw err2;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err2 = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err2.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err2;
  }
  return { ciphertext, key };
}
function _vaultPath(options2) {
  let possibleVaultPath = null;
  if (options2 && options2.path && options2.path.length > 0) {
    if (Array.isArray(options2.path)) {
      for (const filepath of options2.path) {
        if (fs$6.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
    }
  } else {
    possibleVaultPath = path$8.resolve(process.cwd(), ".env.vault");
  }
  if (fs$6.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path$8.join(os$1.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options2) {
  const debug2 = Boolean(options2 && options2.debug);
  if (debug2) {
    _debug("Loading env from encrypted .env.vault");
  }
  const parsed = DotenvModule._parseVault(options2);
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options2);
  return { parsed };
}
function configDotenv(options2) {
  const dotenvPath = path$8.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug2 = Boolean(options2 && options2.debug);
  if (options2 && options2.encoding) {
    encoding = options2.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options2 && options2.path) {
    if (!Array.isArray(options2.path)) {
      optionPaths = [_resolveHome(options2.path)];
    } else {
      optionPaths = [];
      for (const filepath of options2.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path2 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs$6.readFileSync(path2, { encoding }));
      DotenvModule.populate(parsedAll, parsed, options2);
    } catch (e2) {
      if (debug2) {
        _debug(`Failed to load ${path2} ${e2.message}`);
      }
      lastError = e2;
    }
  }
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsedAll, options2);
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config$2(options2) {
  if (_dotenvKey(options2).length === 0) {
    return DotenvModule.configDotenv(options2);
  }
  const vaultPath = _vaultPath(options2);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options2);
  }
  return DotenvModule._configVault(options2);
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error2) {
    const isRange = error2 instanceof RangeError;
    const invalidKeyLength = error2.message === "Invalid key length";
    const decryptionFailed = error2.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err2 = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err2.code = "INVALID_DOTENV_KEY";
      throw err2;
    } else if (decryptionFailed) {
      const err2 = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err2.code = "DECRYPTION_FAILED";
      throw err2;
    } else {
      throw error2;
    }
  }
}
function populate(processEnv, parsed, options2 = {}) {
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  if (typeof parsed !== "object") {
    const err2 = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err2.code = "OBJECT_REQUIRED";
    throw err2;
  }
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config: config$2,
  decrypt,
  parse: parse$c,
  populate
};
main.exports.configDotenv = DotenvModule.configDotenv;
main.exports._configVault = DotenvModule._configVault;
main.exports._parseVault = DotenvModule._parseVault;
main.exports.config = DotenvModule.config;
main.exports.decrypt = DotenvModule.decrypt;
var parse_1$2 = main.exports.parse = DotenvModule.parse;
main.exports.populate = DotenvModule.populate;
main.exports = DotenvModule;
function _resolveEscapeSequences(value2) {
  return value2.replace(/\\\$/g, "$");
}
function expandValue(value2, processEnv, runningParsed) {
  const env2 = { ...runningParsed, ...processEnv };
  const regex = /(?<!\\)\${([^{}]+)}|(?<!\\)\$([A-Za-z_][A-Za-z0-9_]*)/g;
  let result = value2;
  let match;
  const seen2 = /* @__PURE__ */ new Set();
  while ((match = regex.exec(result)) !== null) {
    seen2.add(result);
    const [template, bracedExpression, unbracedExpression] = match;
    const expression = bracedExpression || unbracedExpression;
    const opRegex = /(:\+|\+|:-|-)/;
    const opMatch = expression.match(opRegex);
    const splitter = opMatch ? opMatch[0] : null;
    const r2 = expression.split(splitter);
    let defaultValue;
    let value3;
    const key = r2.shift();
    if ([":+", "+"].includes(splitter)) {
      defaultValue = env2[key] ? r2.join(splitter) : "";
      value3 = null;
    } else {
      defaultValue = r2.join(splitter);
      value3 = env2[key];
    }
    if (value3) {
      if (seen2.has(value3)) {
        result = result.replace(template, defaultValue);
      } else {
        result = result.replace(template, value3);
      }
    } else {
      result = result.replace(template, defaultValue);
    }
    if (result === runningParsed[key]) {
      break;
    }
    regex.lastIndex = 0;
  }
  return result;
}
function expand$2(options2) {
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  for (const key in options2.parsed) {
    let value2 = options2.parsed[key];
    if (processEnv[key] && processEnv[key] !== value2) {
      value2 = processEnv[key];
    } else {
      value2 = expandValue(value2, processEnv, options2.parsed);
    }
    options2.parsed[key] = _resolveEscapeSequences(value2);
  }
  for (const processKey in options2.parsed) {
    processEnv[processKey] = options2.parsed[processKey];
  }
  return options2;
}
var expand_1$1 = expand$2;
const debug$b = createDebugger$1("vite:env");
function getEnvFilesForMode(mode2, envDir) {
  if (envDir !== false) {
    return [
      /** default file */
      `.env`,
      /** local file */
      `.env.local`,
      /** mode file */
      `.env.${mode2}`,
      /** mode local file */
      `.env.${mode2}.local`
    ].map((file) => normalizePath$3(path$b.join(envDir, file)));
  }
  return [];
}
function loadEnv(mode2, envDir, prefixes = "VITE_") {
  const start = performance.now();
  const getTime = () => `${(performance.now() - start).toFixed(2)}ms`;
  if (mode2 === "local") {
    throw new Error(
      `"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`
    );
  }
  prefixes = arraify$2(prefixes);
  const env2 = {};
  const envFiles = getEnvFilesForMode(mode2, envDir);
  debug$b?.(`loading env files: %O`, envFiles);
  const parsed = Object.fromEntries(
    envFiles.flatMap((filePath) => {
      if (!tryStatSync(filePath)?.isFile()) return [];
      return Object.entries(parse_1$2(fs__default.readFileSync(filePath)));
    })
  );
  debug$b?.(`env files loaded in ${getTime()}`);
  if (parsed.NODE_ENV && process.env.VITE_USER_NODE_ENV === void 0) {
    process.env.VITE_USER_NODE_ENV = parsed.NODE_ENV;
  }
  if (parsed.BROWSER && process.env.BROWSER === void 0) {
    process.env.BROWSER = parsed.BROWSER;
  }
  if (parsed.BROWSER_ARGS && process.env.BROWSER_ARGS === void 0) {
    process.env.BROWSER_ARGS = parsed.BROWSER_ARGS;
  }
  const processEnv = { ...process.env };
  expand_1$1({ parsed, processEnv });
  for (const [key, value2] of Object.entries(parsed)) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env2[key] = value2;
    }
  }
  for (const key in process.env) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env2[key] = process.env[key];
    }
  }
  debug$b?.(`using resolved env: %O`, env2);
  return env2;
}
var node$3 = { exports: {} };
var debug$a = { exports: {} };
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;
var ms$2 = function(val, options2) {
  options2 = options2 || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse$b(val);
  } else if (type === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$b(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n2 = parseFloat(match[1]);
  var type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n2 * y;
    case "days":
    case "day":
    case "d":
      return n2 * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n2 * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n2 * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n2 * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n2;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  if (ms2 >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (ms2 >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (ms2 >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (ms2 >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  return plural(ms2, d, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s, "second") || ms2 + " ms";
}
function plural(ms2, n2, name) {
  if (ms2 < n2) {
    return;
  }
  if (ms2 < n2 * 1.5) {
    return Math.floor(ms2 / n2) + " " + name;
  }
  return Math.ceil(ms2 / n2) + " " + name + "s";
}
(function(module, exports$1) {
  exports$1 = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports$1.coerce = coerce;
  exports$1.disable = disable;
  exports$1.enable = enable;
  exports$1.enabled = enabled;
  exports$1.humanize = ms$2;
  exports$1.names = [];
  exports$1.skips = [];
  exports$1.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash2 = 0, i;
    for (i in namespace) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
      hash2 |= 0;
    }
    return exports$1.colors[Math.abs(hash2) % exports$1.colors.length];
  }
  function createDebug(namespace) {
    function debug2() {
      if (!debug2.enabled) return;
      var self2 = debug2;
      var curr = +/* @__PURE__ */ new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports$1.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
        if (match === "%%") return match;
        index2++;
        var formatter2 = exports$1.formatters[format2];
        if ("function" === typeof formatter2) {
          var val = args[index2];
          match = formatter2.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      exports$1.formatArgs.call(self2, args);
      var logFn = debug2.log || exports$1.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.enabled = exports$1.enabled(namespace);
    debug2.useColors = exports$1.useColors();
    debug2.color = selectColor(namespace);
    if ("function" === typeof exports$1.init) {
      exports$1.init(debug2);
    }
    return debug2;
  }
  function enable(namespaces) {
    exports$1.save(namespaces);
    exports$1.names = [];
    exports$1.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i]) continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports$1.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports$1.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports$1.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports$1.skips.length; i < len; i++) {
      if (exports$1.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports$1.names.length; i < len; i++) {
      if (exports$1.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
})(debug$a, debug$a.exports);
var debugExports = debug$a.exports;
(function(module, exports$1) {
  var tty = require$$0$3;
  var util2 = require$$1$1;
  exports$1 = module.exports = debugExports;
  exports$1.init = init2;
  exports$1.log = log;
  exports$1.formatArgs = formatArgs;
  exports$1.save = save;
  exports$1.load = load2;
  exports$1.useColors = useColors;
  exports$1.colors = [6, 2, 3, 4, 5, 1];
  exports$1.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
    else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
    else if (val === "null") val = null;
    else val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (1 !== fd && 2 !== fd) {
    util2.deprecate(function() {
    }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(fd);
  }
  exports$1.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports$1.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
  function formatArgs(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push("\x1B[3" + c + "m+" + exports$1.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
    }
  }
  function log() {
    return stream3.write(util2.format.apply(util2, arguments) + "\n");
  }
  function save(namespaces) {
    if (null == namespaces) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream4;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream4 = new tty.WriteStream(fd2);
        stream4._type = "tty";
        if (stream4._handle && stream4._handle.unref) {
          stream4._handle.unref();
        }
        break;
      case "FILE":
        var fs2 = require$$0$4;
        stream4 = new fs2.SyncWriteStream(fd2, { autoClose: false });
        stream4._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net2 = require$$4$1$1;
        stream4 = new net2.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream4.readable = false;
        stream4.read = null;
        stream4._type = "pipe";
        if (stream4._handle && stream4._handle.unref) {
          stream4._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream4.fd = fd2;
    stream4._isStdio = true;
    return stream4;
  }
  function init2(debug2) {
    debug2.inspectOpts = {};
    var keys = Object.keys(exports$1.inspectOpts);
    for (var i = 0; i < keys.length; i++) {
      debug2.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
    }
  }
  exports$1.enable(load2());
})(node$3, node$3.exports);
var nodeExports = node$3.exports;
var onFinished$2 = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst = first$1;
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee = arr[0];
    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);
      ee.on(event, fn);
      cleanups.push({
        ee,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i2 = 0; i2 < cleanups.length; i2++) {
      x = cleanups[i2];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err2 = event === "error" ? arg1 : null;
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    done(err2, ee, event, args);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
onFinished$2.exports = onFinished$1;
onFinished$2.exports.isFinished = isFinished$1;
var first = eeFirst;
var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function onFinished$1(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$2(listener2, null, msg);
    return msg;
  }
  attachListener(msg, listener2);
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error2) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error2);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished) return;
    if (eeMsg !== eeSocket) return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err2) {
    if (msg.__onFinished === listener2) msg.__onFinished = null;
    if (!listener2.queue) return;
    var queue = listener2.queue;
    listener2.queue = null;
    for (var i = 0; i < queue.length; i++) {
      queue[i](err2, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;
  if (typeof assignSocket !== "function") return;
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
var onFinishedExports = onFinished$2.exports;
var parseurl$1 = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var url$3 = require$$0$5;
var parse$a = url$3.parse;
var Url = url$3.Url;
parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str) {
  if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
    return parse$a(str);
  }
  var pathname = str;
  var query = null;
  var search = null;
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 63:
        if (search === null) {
          pathname = str.substring(0, i);
          query = str.substring(i + 1);
          search = str.substring(i);
        }
        break;
      case 9:
      /* \t */
      case 10:
      /* \n */
      case 12:
      /* \f */
      case 13:
      /* \r */
      case 32:
      /*    */
      case 35:
      /* #  */
      case 160:
      case 65279:
        return parse$a(str);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str;
  url2.href = str;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
var require$$0$1 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "(Unused)",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes$2 = require$$0$1;
status.STATUS_CODES = codes$2;
status.codes = populateStatusesMap(status, codes$2);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function populateStatusesMap(statuses2, codes2) {
  var arr = [];
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status2 = Number(code);
    statuses2[status2] = message;
    statuses2[message] = status2;
    statuses2[message.toLowerCase()] = status2;
    arr.push(status2);
  });
  return arr;
}
function status(code) {
  if (typeof code === "number") {
    if (!status[code]) throw new Error("invalid status code: " + code);
    return code;
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n2 = parseInt(code, 10);
  if (!isNaN(n2)) {
    if (!status[n2]) throw new Error("invalid status code: " + n2);
    return n2;
  }
  n2 = status[code.toLowerCase()];
  if (!n2) throw new Error('invalid status message: "' + code + '"');
  return n2;
}
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
nodeExports("finalhandler");
var onFinished = onFinishedExports;
typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
onFinished.isFinished;
var utilsMerge = { exports: {} };
(function(module, exports$1) {
  module.exports = function(a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  };
})(utilsMerge);
/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
nodeExports("connect:dispatcher");
require$$0$7.EventEmitter;
process.env.NODE_ENV || "development";
typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err2) {
    return false;
  }
}
shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty$1.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
var vary$1 = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
vary$1.exports = vary;
vary$1.exports.append = append$1;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append$1(header, field) {
  if (typeof header !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$9(String(field)) : field;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header === "*") {
    return header;
  }
  var val = header;
  var vals = parse$9(header.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse$9(header) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(header.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(header.substring(start, end));
  return list;
}
function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res.getHeader("Vary") || "";
  var header = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append$1(header, field)) {
    res.setHeader("Vary", val);
  }
}
const fs$5 = require$$0$4;
const { Readable } = require$$0$8;
const sysPath$3 = require$$0$2$1;
const { promisify: promisify$3 } = require$$1$1;
const picomatch$1 = pm$1;
const readdir$1 = promisify$3(fs$5.readdir);
const stat$3 = promisify$3(fs$5.stat);
const lstat$2 = promisify$3(fs$5.lstat);
const realpath$1 = promisify$3(fs$5.realpath);
const BANG$2 = "!";
const RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
const NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
const FILE_TYPE = "files";
const DIR_TYPE = "directories";
const FILE_DIR_TYPE = "files_directories";
const EVERYTHING_TYPE = "all";
const ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
const isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
const [maj, min] = process.versions.node.split(".").slice(0, 2).map((n2) => Number.parseInt(n2, 10));
const wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
const normalizeFilter$1 = (filter2) => {
  if (filter2 === void 0) return;
  if (typeof filter2 === "function") return filter2;
  if (typeof filter2 === "string") {
    const glob2 = picomatch$1(filter2.trim());
    return (entry) => glob2(entry.basename);
  }
  if (Array.isArray(filter2)) {
    const positive = [];
    const negative = [];
    for (const item of filter2) {
      const trimmed = item.trim();
      if (trimmed.charAt(0) === BANG$2) {
        negative.push(picomatch$1(trimmed.slice(1)));
      } else {
        positive.push(picomatch$1(trimmed));
      }
    }
    if (negative.length > 0) {
      if (positive.length > 0) {
        return (entry) => positive.some((f2) => f2(entry.basename)) && !negative.some((f2) => f2(entry.basename));
      }
      return (entry) => !negative.some((f2) => f2(entry.basename));
    }
    return (entry) => positive.some((f2) => f2(entry.basename));
  }
};
class ReaddirpStream extends Readable {
  static get defaultOptions() {
    return {
      root: ".",
      /* eslint-disable no-unused-vars */
      fileFilter: (path2) => true,
      directoryFilter: (path2) => true,
      /* eslint-enable no-unused-vars */
      type: FILE_TYPE,
      lstat: false,
      depth: 2147483648,
      alwaysStat: false
    };
  }
  constructor(options2 = {}) {
    super({
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options2.highWaterMark || 4096
    });
    const opts = { ...ReaddirpStream.defaultOptions, ...options2 };
    const { root, type } = opts;
    this._fileFilter = normalizeFilter$1(opts.fileFilter);
    this._directoryFilter = normalizeFilter$1(opts.directoryFilter);
    const statMethod = opts.lstat ? lstat$2 : stat$3;
    if (wantBigintFsStats) {
      this._stat = (path2) => statMethod(path2, { bigint: true });
    } else {
      this._stat = statMethod;
    }
    this._maxDepth = opts.depth;
    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsEverything = type === EVERYTHING_TYPE;
    this._root = sysPath$3.resolve(root);
    this._isDirent = "Dirent" in fs$5 && !opts.alwaysStat;
    this._statsProp = this._isDirent ? "dirent" : "stats";
    this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
    this.parents = [this._exploreDir(root, 1)];
    this.reading = false;
    this.parent = void 0;
  }
  async _read(batch) {
    if (this.reading) return;
    this.reading = true;
    try {
      while (!this.destroyed && batch > 0) {
        const { path: path2, depth, files = [] } = this.parent || {};
        if (files.length > 0) {
          const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path2));
          for (const entry of await Promise.all(slice)) {
            if (this.destroyed) return;
            const entryType = await this._getEntryType(entry);
            if (entryType === "directory" && this._directoryFilter(entry)) {
              if (depth <= this._maxDepth) {
                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
              }
              if (this._wantsDir) {
                this.push(entry);
                batch--;
              }
            } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
              if (this._wantsFile) {
                this.push(entry);
                batch--;
              }
            }
          }
        } else {
          const parent = this.parents.pop();
          if (!parent) {
            this.push(null);
            break;
          }
          this.parent = await parent;
          if (this.destroyed) return;
        }
      }
    } catch (error2) {
      this.destroy(error2);
    } finally {
      this.reading = false;
    }
  }
  async _exploreDir(path2, depth) {
    let files;
    try {
      files = await readdir$1(path2, this._rdOptions);
    } catch (error2) {
      this._onError(error2);
    }
    return { files, depth, path: path2 };
  }
  async _formatEntry(dirent, path2) {
    let entry;
    try {
      const basename2 = this._isDirent ? dirent.name : dirent;
      const fullPath = sysPath$3.resolve(sysPath$3.join(path2, basename2));
      entry = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename: basename2 };
      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
    } catch (err2) {
      this._onError(err2);
    }
    return entry;
  }
  _onError(err2) {
    if (isNormalFlowError(err2) && !this.destroyed) {
      this.emit("warn", err2);
    } else {
      this.destroy(err2);
    }
  }
  async _getEntryType(entry) {
    const stats = entry && entry[this._statsProp];
    if (!stats) {
      return;
    }
    if (stats.isFile()) {
      return "file";
    }
    if (stats.isDirectory()) {
      return "directory";
    }
    if (stats && stats.isSymbolicLink()) {
      const full = entry.fullPath;
      try {
        const entryRealPath = await realpath$1(full);
        const entryRealPathStats = await lstat$2(entryRealPath);
        if (entryRealPathStats.isFile()) {
          return "file";
        }
        if (entryRealPathStats.isDirectory()) {
          const len = entryRealPath.length;
          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
            const recursiveError = new Error(
              `Circular symlink detected: "${full}" points to "${entryRealPath}"`
            );
            recursiveError.code = RECURSIVE_ERROR_CODE;
            return this._onError(recursiveError);
          }
          return "directory";
        }
      } catch (error2) {
        this._onError(error2);
      }
    }
  }
  _includeAsFile(entry) {
    const stats = entry && entry[this._statsProp];
    return stats && this._wantsEverything && !stats.isDirectory();
  }
}
const readdirp$1 = (root, options2 = {}) => {
  let type = options2.entryType || options2.type;
  if (type === "both") type = FILE_DIR_TYPE;
  if (type) options2.type = type;
  if (!root) {
    throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
  } else if (typeof root !== "string") {
    throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
  }
  options2.root = root;
  return new ReaddirpStream(options2);
};
const readdirpPromise = (root, options2 = {}) => {
  return new Promise((resolve2, reject) => {
    const files = [];
    readdirp$1(root, options2).on("data", (entry) => files.push(entry)).on("end", () => resolve2(files)).on("error", (error2) => reject(error2));
  });
};
readdirp$1.promise = readdirpPromise;
readdirp$1.ReaddirpStream = ReaddirpStream;
readdirp$1.default = readdirp$1;
var anymatch$2 = { exports: {} };
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var normalizePath$2 = function(path2, stripTrailing) {
  if (typeof path2 !== "string") {
    throw new TypeError("expected path to be a string");
  }
  if (path2 === "\\" || path2 === "/") return "/";
  var len = path2.length;
  if (len <= 1) return path2;
  var prefix = "";
  if (len > 4 && path2[3] === "\\") {
    var ch = path2[2];
    if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
      path2 = path2.slice(2);
      prefix = "//";
    }
  }
  var segs = path2.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === "") {
    segs.pop();
  }
  return prefix + segs.join("/");
};
var anymatch_1 = anymatch$2.exports;
Object.defineProperty(anymatch_1, "__esModule", { value: true });
const picomatch = pm$1;
const normalizePath$1 = normalizePath$2;
const BANG$1 = "!";
const DEFAULT_OPTIONS = { returnIndex: false };
const arrify$1 = (item) => Array.isArray(item) ? item : [item];
const createPattern = (matcher, options2) => {
  if (typeof matcher === "function") {
    return matcher;
  }
  if (typeof matcher === "string") {
    const glob2 = picomatch(matcher, options2);
    return (string) => matcher === string || glob2(string);
  }
  if (matcher instanceof RegExp) {
    return (string) => matcher.test(string);
  }
  return (string) => false;
};
const matchPatterns = (patterns, negPatterns, args, returnIndex) => {
  const isList = Array.isArray(args);
  const _path = isList ? args[0] : args;
  if (!isList && typeof _path !== "string") {
    throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
  }
  const path2 = normalizePath$1(_path, false);
  for (let index2 = 0; index2 < negPatterns.length; index2++) {
    const nglob = negPatterns[index2];
    if (nglob(path2)) {
      return returnIndex ? -1 : false;
    }
  }
  const applied = isList && [path2].concat(args.slice(1));
  for (let index2 = 0; index2 < patterns.length; index2++) {
    const pattern = patterns[index2];
    if (isList ? pattern(...applied) : pattern(path2)) {
      return returnIndex ? index2 : true;
    }
  }
  return returnIndex ? -1 : false;
};
const anymatch$1 = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
  if (matchers == null) {
    throw new TypeError("anymatch: specify first argument");
  }
  const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
  const returnIndex = opts.returnIndex || false;
  const mtchers = arrify$1(matchers);
  const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
  const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher) => createPattern(matcher, opts));
  if (testString == null) {
    return (testString2, ri = false) => {
      const returnIndex2 = typeof ri === "boolean" ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
    };
  }
  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};
anymatch$1.default = anymatch$1;
anymatch$2.exports = anymatch$1;
var anymatchExports = anymatch$2.exports;
require$$0$2$1.posix.dirname;
require$$2.platform() === "win32";
var utils$3 = {};
(function(exports$1) {
  exports$1.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports$1.find = (node2, type) => node2.nodes.find((node3) => node3.type === type);
  exports$1.exceedsLimit = (min2, max, step = 1, limit) => {
    if (limit === false) return false;
    if (!exports$1.isInteger(min2) || !exports$1.isInteger(max)) return false;
    return (Number(max) - Number(min2)) / Number(step) >= limit;
  };
  exports$1.escapeNode = (block, n2 = 0, type) => {
    const node2 = block.nodes[n2];
    if (!node2) return;
    if (type && node2.type === type || node2.type === "open" || node2.type === "close") {
      if (node2.escaped !== true) {
        node2.value = "\\" + node2.value;
        node2.escaped = true;
      }
    }
  };
  exports$1.encloseBrace = (node2) => {
    if (node2.type !== "brace") return false;
    if (node2.commas >> 0 + node2.ranges >> 0 === 0) {
      node2.invalid = true;
      return true;
    }
    return false;
  };
  exports$1.isInvalidBrace = (block) => {
    if (block.type !== "brace") return false;
    if (block.invalid === true || block.dollar) return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports$1.isOpenOrClose = (node2) => {
    if (node2.type === "open" || node2.type === "close") {
      return true;
    }
    return node2.open === true || node2.close === true;
  };
  exports$1.reduce = (nodes) => nodes.reduce((acc, node2) => {
    if (node2.type === "text") acc.push(node2.value);
    if (node2.type === "range") node2.type = "text";
    return acc;
  }, []);
  exports$1.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0; i < arr.length; i++) {
        const ele = arr[i];
        if (Array.isArray(ele)) {
          flat(ele);
          continue;
        }
        if (ele !== void 0) {
          result.push(ele);
        }
      }
      return result;
    };
    flat(args);
    return result;
  };
})(utils$3);
var require$$0$2 = [
  "3dm",
  "3ds",
  "3g2",
  "3gp",
  "7z",
  "a",
  "aac",
  "adp",
  "afdesign",
  "afphoto",
  "afpub",
  "ai",
  "aif",
  "aiff",
  "alz",
  "ape",
  "apk",
  "appimage",
  "ar",
  "arj",
  "asf",
  "au",
  "avi",
  "bak",
  "baml",
  "bh",
  "bin",
  "bk",
  "bmp",
  "btif",
  "bz2",
  "bzip2",
  "cab",
  "caf",
  "cgm",
  "class",
  "cmx",
  "cpio",
  "cr2",
  "cur",
  "dat",
  "dcm",
  "deb",
  "dex",
  "djvu",
  "dll",
  "dmg",
  "dng",
  "doc",
  "docm",
  "docx",
  "dot",
  "dotm",
  "dra",
  "DS_Store",
  "dsk",
  "dts",
  "dtshd",
  "dvb",
  "dwg",
  "dxf",
  "ecelp4800",
  "ecelp7470",
  "ecelp9600",
  "egg",
  "eol",
  "eot",
  "epub",
  "exe",
  "f4v",
  "fbs",
  "fh",
  "fla",
  "flac",
  "flatpak",
  "fli",
  "flv",
  "fpx",
  "fst",
  "fvt",
  "g3",
  "gh",
  "gif",
  "graffle",
  "gz",
  "gzip",
  "h261",
  "h263",
  "h264",
  "icns",
  "ico",
  "ief",
  "img",
  "ipa",
  "iso",
  "jar",
  "jpeg",
  "jpg",
  "jpgv",
  "jpm",
  "jxr",
  "key",
  "ktx",
  "lha",
  "lib",
  "lvp",
  "lz",
  "lzh",
  "lzma",
  "lzo",
  "m3u",
  "m4a",
  "m4v",
  "mar",
  "mdi",
  "mht",
  "mid",
  "midi",
  "mj2",
  "mka",
  "mkv",
  "mmr",
  "mng",
  "mobi",
  "mov",
  "movie",
  "mp3",
  "mp4",
  "mp4a",
  "mpeg",
  "mpg",
  "mpga",
  "mxu",
  "nef",
  "npx",
  "numbers",
  "nupkg",
  "o",
  "odp",
  "ods",
  "odt",
  "oga",
  "ogg",
  "ogv",
  "otf",
  "ott",
  "pages",
  "pbm",
  "pcx",
  "pdb",
  "pdf",
  "pea",
  "pgm",
  "pic",
  "png",
  "pnm",
  "pot",
  "potm",
  "potx",
  "ppa",
  "ppam",
  "ppm",
  "pps",
  "ppsm",
  "ppsx",
  "ppt",
  "pptm",
  "pptx",
  "psd",
  "pya",
  "pyc",
  "pyo",
  "pyv",
  "qt",
  "rar",
  "ras",
  "raw",
  "resources",
  "rgb",
  "rip",
  "rlc",
  "rmf",
  "rmvb",
  "rpm",
  "rtf",
  "rz",
  "s3m",
  "s7z",
  "scpt",
  "sgi",
  "shar",
  "snap",
  "sil",
  "sketch",
  "slk",
  "smv",
  "snk",
  "so",
  "stl",
  "suo",
  "sub",
  "swf",
  "tar",
  "tbz",
  "tbz2",
  "tga",
  "tgz",
  "thmx",
  "tif",
  "tiff",
  "tlz",
  "ttc",
  "ttf",
  "txz",
  "udf",
  "uvh",
  "uvi",
  "uvm",
  "uvp",
  "uvs",
  "uvu",
  "viv",
  "vob",
  "war",
  "wav",
  "wax",
  "wbmp",
  "wdp",
  "weba",
  "webm",
  "webp",
  "whl",
  "wim",
  "wm",
  "wma",
  "wmv",
  "wmx",
  "woff",
  "woff2",
  "wrm",
  "wvx",
  "xbm",
  "xif",
  "xla",
  "xlam",
  "xls",
  "xlsb",
  "xlsm",
  "xlsx",
  "xlt",
  "xltm",
  "xltx",
  "xm",
  "xmind",
  "xpi",
  "xpm",
  "xwd",
  "xz",
  "z",
  "zip",
  "zipx"
];
var binaryExtensions$1 = require$$0$2;
const binaryExtensions = binaryExtensions$1;
new Set(binaryExtensions);
var constants$1 = {};
(function(exports$1) {
  const { sep: sep2 } = require$$0$2$1;
  const { platform: platform2 } = process;
  const os2 = require$$2;
  exports$1.EV_ALL = "all";
  exports$1.EV_READY = "ready";
  exports$1.EV_ADD = "add";
  exports$1.EV_CHANGE = "change";
  exports$1.EV_ADD_DIR = "addDir";
  exports$1.EV_UNLINK = "unlink";
  exports$1.EV_UNLINK_DIR = "unlinkDir";
  exports$1.EV_RAW = "raw";
  exports$1.EV_ERROR = "error";
  exports$1.STR_DATA = "data";
  exports$1.STR_END = "end";
  exports$1.STR_CLOSE = "close";
  exports$1.FSEVENT_CREATED = "created";
  exports$1.FSEVENT_MODIFIED = "modified";
  exports$1.FSEVENT_DELETED = "deleted";
  exports$1.FSEVENT_MOVED = "moved";
  exports$1.FSEVENT_CLONED = "cloned";
  exports$1.FSEVENT_UNKNOWN = "unknown";
  exports$1.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
  exports$1.FSEVENT_TYPE_FILE = "file";
  exports$1.FSEVENT_TYPE_DIRECTORY = "directory";
  exports$1.FSEVENT_TYPE_SYMLINK = "symlink";
  exports$1.KEY_LISTENERS = "listeners";
  exports$1.KEY_ERR = "errHandlers";
  exports$1.KEY_RAW = "rawEmitters";
  exports$1.HANDLER_KEYS = [exports$1.KEY_LISTENERS, exports$1.KEY_ERR, exports$1.KEY_RAW];
  exports$1.DOT_SLASH = `.${sep2}`;
  exports$1.BACK_SLASH_RE = /\\/g;
  exports$1.DOUBLE_SLASH_RE = /\/\//;
  exports$1.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
  exports$1.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
  exports$1.REPLACER_RE = /^\.[/\\]/;
  exports$1.SLASH = "/";
  exports$1.SLASH_SLASH = "//";
  exports$1.BRACE_START = "{";
  exports$1.BANG = "!";
  exports$1.ONE_DOT = ".";
  exports$1.TWO_DOTS = "..";
  exports$1.STAR = "*";
  exports$1.GLOBSTAR = "**";
  exports$1.ROOT_GLOBSTAR = "/**/*";
  exports$1.SLASH_GLOBSTAR = "/**";
  exports$1.DIR_SUFFIX = "Dir";
  exports$1.ANYMATCH_OPTS = { dot: true };
  exports$1.STRING_TYPE = "string";
  exports$1.FUNCTION_TYPE = "function";
  exports$1.EMPTY_STR = "";
  exports$1.EMPTY_FN = () => {
  };
  exports$1.IDENTITY_FN = (val) => val;
  exports$1.isWindows = platform2 === "win32";
  exports$1.isMacos = platform2 === "darwin";
  exports$1.isLinux = platform2 === "linux";
  exports$1.isIBMi = os2.type() === "OS400";
})(constants$1);
const fs$4 = require$$0$4;
const { promisify: promisify$2 } = require$$1$1;
const {
  isWindows: isWindows$2,
  isLinux,
  EMPTY_FN: EMPTY_FN$2,
  EMPTY_STR: EMPTY_STR$1,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE: EV_CHANGE$2,
  EV_ADD: EV_ADD$2,
  EV_ADD_DIR: EV_ADD_DIR$2,
  EV_ERROR: EV_ERROR$2,
  STR_DATA: STR_DATA$1,
  STR_END: STR_END$2,
  BRACE_START: BRACE_START$1,
  STAR
} = constants$1;
promisify$2(fs$4.open);
promisify$2(fs$4.stat);
promisify$2(fs$4.lstat);
promisify$2(fs$4.close);
promisify$2(fs$4.realpath);
var fseventsHandler = { exports: {} };
const fs$3 = require$$0$4;
const sysPath$1 = require$$0$2$1;
const { promisify: promisify$1 } = require$$1$1;
let fsevents;
try {
  fsevents = __require("fsevents");
} catch (error2) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error2);
}
if (fsevents) {
  const mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    const maj2 = Number.parseInt(mtch[1], 10);
    const min2 = Number.parseInt(mtch[2], 10);
    if (maj2 === 8 && min2 < 16) {
      fsevents = void 0;
    }
  }
}
const {
  EV_ADD: EV_ADD$1,
  EV_CHANGE: EV_CHANGE$1,
  EV_ADD_DIR: EV_ADD_DIR$1,
  EV_UNLINK: EV_UNLINK$1,
  EV_ERROR: EV_ERROR$1,
  STR_DATA,
  STR_END: STR_END$1,
  FSEVENT_CREATED,
  FSEVENT_MODIFIED,
  FSEVENT_DELETED,
  FSEVENT_MOVED,
  // FSEVENT_CLONED,
  FSEVENT_UNKNOWN,
  FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
  FSEVENT_TYPE_FILE,
  FSEVENT_TYPE_DIRECTORY,
  FSEVENT_TYPE_SYMLINK,
  ROOT_GLOBSTAR,
  DIR_SUFFIX,
  DOT_SLASH,
  FUNCTION_TYPE: FUNCTION_TYPE$1,
  EMPTY_FN: EMPTY_FN$1,
  IDENTITY_FN
} = constants$1;
const Depth = (value2) => isNaN(value2) ? {} : { depth: value2 };
const stat$1 = promisify$1(fs$3.stat);
const lstat = promisify$1(fs$3.lstat);
const realpath = promisify$1(fs$3.realpath);
const statMethods = { stat: stat$1, lstat };
const FSEventsWatchers = /* @__PURE__ */ new Map();
const consolidateThreshhold = 10;
const wrongEventFlags = /* @__PURE__ */ new Set([
  69888,
  70400,
  71424,
  72704,
  73472,
  131328,
  131840,
  262912
]);
const createFSEventsInstance = (path2, callback) => {
  const stop = fsevents.watch(path2, callback);
  return { stop };
};
function setFSEventsListener(path2, realPath, listener2, rawEmitter) {
  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
  const parentPath = sysPath$1.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }
  const resolvedPath = sysPath$1.resolve(path2);
  const hasSymlink = resolvedPath !== realPath;
  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener2(fullPath, flags, info);
  };
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }
  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: /* @__PURE__ */ new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size) return;
        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach((list) => {
          list(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }
  return () => {
    const lst = cont.listeners;
    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(() => {
        cont.rawEmitter = cont.watcher = void 0;
        Object.freeze(cont);
      });
    }
  };
}
const couldConsolidate = (path2) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path2) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }
  return false;
};
const canUse = () => fsevents && FSEventsWatchers.size < 128;
const calcDepth = (path2, root) => {
  let i = 0;
  while (!path2.indexOf(root) && (path2 = sysPath$1.dirname(path2)) !== root) i++;
  return i;
};
const sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
let FsEventsHandler$1 = class FsEventsHandler {
  /**
   * @param {import('../index').FSWatcher} fsw
   */
  constructor(fsw) {
    this.fsw = fsw;
  }
  checkIgnored(path2, stats) {
    const ipaths = this.fsw._ignoredPaths;
    if (this.fsw._isIgnored(path2, stats)) {
      ipaths.add(path2);
      if (stats && stats.isDirectory()) {
        ipaths.add(path2 + ROOT_GLOBSTAR);
      }
      return true;
    }
    ipaths.delete(path2);
    ipaths.delete(path2 + ROOT_GLOBSTAR);
  }
  addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
    this.handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
  }
  async checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
    try {
      const stats = await stat$1(path2);
      if (this.fsw.closed) return;
      if (sameTypes(info, stats)) {
        this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
      } else {
        this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    } catch (error2) {
      if (error2.code === "EACCES") {
        this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
      } else {
        this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }
  }
  handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
    if (this.fsw.closed || this.checkIgnored(path2)) return;
    if (event === EV_UNLINK$1) {
      const isDirectory2 = info.type === FSEVENT_TYPE_DIRECTORY;
      if (isDirectory2 || watchedDir.has(item)) {
        this.fsw._remove(parent, item, isDirectory2);
      }
    } else {
      if (event === EV_ADD$1) {
        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path2);
        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
          const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
          return this._addToFsEvents(path2, false, true, curDepth);
        }
        this.fsw._getWatchedDir(parent).add(item);
      }
      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
      this.fsw._emit(eventName, path2);
      if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path2, false, true);
    }
  }
  /**
   * Handle symlinks encountered during directory scan
   * @param {String} watchPath  - file/dir path to be watched with fsevents
   * @param {String} realPath   - real path (in case of symlinks)
   * @param {Function} transform  - path transformer
   * @param {Function} globFilter - path filter in case a glob pattern was provided
   * @returns {Function} closer for the watcher instance
  */
  _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
    const opts = this.fsw.options;
    const watchCallback = async (fullPath, flags, info) => {
      if (this.fsw.closed || this.fsw._isIgnored(fullPath)) return;
      if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth) return;
      const path2 = transform2(sysPath$1.join(
        watchPath,
        sysPath$1.relative(watchPath, fullPath)
      ));
      if (globFilter && !globFilter(path2)) return;
      const parent = sysPath$1.dirname(path2);
      const item = sysPath$1.basename(path2);
      const watchedDir = this.fsw._getWatchedDir(
        info.type === FSEVENT_TYPE_DIRECTORY ? path2 : parent
      );
      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
        if (typeof opts.ignored === FUNCTION_TYPE$1) {
          let stats;
          try {
            stats = await stat$1(path2);
          } catch (error2) {
          }
          if (this.fsw.closed) return;
          if (this.checkIgnored(path2, stats)) return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } else {
          this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } else {
        switch (info.event) {
          case FSEVENT_CREATED:
          case FSEVENT_MODIFIED:
            return this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          case FSEVENT_DELETED:
          case FSEVENT_MOVED:
            return this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      }
    };
    const closer = setFSEventsListener(
      watchPath,
      realPath,
      watchCallback,
      this.fsw._emitRaw
    );
    this.fsw._emitReady();
    return closer;
  }
  /**
   * Handle symlinks encountered during directory scan
   * @param {String} linkPath path to symlink
   * @param {String} fullPath absolute path to the symlink
   * @param {Function} transform pre-existing path transformer
   * @param {Number} curDepth level of subdirectories traversed to where symlink is
   * @returns {Promise<void>}
   */
  async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;
    this.fsw._symlinkPaths.set(fullPath, true);
    this.fsw._incrReadyCount();
    try {
      const linkTarget = await realpath(linkPath);
      if (this.fsw.closed) return;
      if (this.fsw._isIgnored(linkTarget)) {
        return this.fsw._emitReady();
      }
      this.fsw._incrReadyCount();
      this._addToFsEvents(linkTarget || linkPath, (path2) => {
        let aliasedPath = linkPath;
        if (linkTarget && linkTarget !== DOT_SLASH) {
          aliasedPath = path2.replace(linkTarget, linkPath);
        } else if (path2 !== DOT_SLASH) {
          aliasedPath = sysPath$1.join(linkPath, path2);
        }
        return transform2(aliasedPath);
      }, false, curDepth);
    } catch (error2) {
      if (this.fsw._handleError(error2)) {
        return this.fsw._emitReady();
      }
    }
  }
  /**
   *
   * @param {Path} newPath
   * @param {fs.Stats} stats
   */
  emitAdd(newPath, stats, processPath, opts, forceAdd) {
    const pp = processPath(newPath);
    const isDir = stats.isDirectory();
    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));
    const base = sysPath$1.basename(pp);
    if (isDir) this.fsw._getWatchedDir(pp);
    if (dirObj.has(base)) return;
    dirObj.add(base);
    if (!opts.ignoreInitial || forceAdd === true) {
      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);
    }
  }
  initWatch(realPath, path2, wh, processPath) {
    if (this.fsw.closed) return;
    const closer = this._watchWithFsEvents(
      wh.watchPath,
      sysPath$1.resolve(realPath || wh.watchPath),
      processPath,
      wh.globFilter
    );
    this.fsw._addPathCloser(path2, closer);
  }
  /**
   * Handle added path with fsevents
   * @param {String} path file/dir path or glob pattern
   * @param {Function|Boolean=} transform converts working path to what the user expects
   * @param {Boolean=} forceAdd ensure add is emitted
   * @param {Number=} priorDepth Level of subdirectories already traversed.
   * @returns {Promise<void>}
   */
  async _addToFsEvents(path2, transform2, forceAdd, priorDepth) {
    if (this.fsw.closed) {
      return;
    }
    const opts = this.fsw.options;
    const processPath = typeof transform2 === FUNCTION_TYPE$1 ? transform2 : IDENTITY_FN;
    const wh = this.fsw._getWatchHelpers(path2);
    try {
      const stats = await statMethods[wh.statMethod](wh.watchPath);
      if (this.fsw.closed) return;
      if (this.fsw._isIgnored(wh.watchPath, stats)) {
        throw null;
      }
      if (stats.isDirectory()) {
        if (!wh.globFilter) this.emitAdd(processPath(path2), stats, processPath, opts, forceAdd);
        if (priorDepth && priorDepth > opts.depth) return;
        this.fsw._readdirp(wh.watchPath, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry),
          ...Depth(opts.depth - (priorDepth || 0))
        }).on(STR_DATA, (entry) => {
          if (this.fsw.closed) {
            return;
          }
          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
          const joinedPath = sysPath$1.join(wh.watchPath, entry.path);
          const { fullPath } = entry;
          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
            const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;
            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
          } else {
            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
          }
        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
          this.fsw._emitReady();
        });
      } else {
        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
        this.fsw._emitReady();
      }
    } catch (error2) {
      if (!error2 || this.fsw._handleError(error2)) {
        this.fsw._emitReady();
        this.fsw._emitReady();
      }
    }
    if (opts.persistent && forceAdd !== true) {
      if (typeof transform2 === FUNCTION_TYPE$1) {
        this.initWatch(void 0, path2, wh, processPath);
      } else {
        let realPath;
        try {
          realPath = await realpath(wh.watchPath);
        } catch (e2) {
        }
        this.initWatch(realPath, path2, wh, processPath);
      }
    }
  }
};
fseventsHandler.exports = FsEventsHandler$1;
fseventsHandler.exports.canUse = canUse;
const { EventEmitter: EventEmitter$2 } = require$$0$7;
const fs$2 = require$$0$4;
const { promisify } = require$$1$1;
anymatchExports.default;
const {
  EV_ALL,
  EV_READY,
  EV_ADD,
  EV_CHANGE,
  EV_UNLINK,
  EV_ADD_DIR,
  EV_UNLINK_DIR,
  EV_RAW,
  EV_ERROR,
  STR_CLOSE,
  STR_END,
  BACK_SLASH_RE,
  DOUBLE_SLASH_RE,
  SLASH_OR_BACK_SLASH_RE,
  DOT_RE,
  REPLACER_RE,
  SLASH,
  SLASH_SLASH,
  BRACE_START,
  BANG,
  ONE_DOT,
  TWO_DOTS,
  GLOBSTAR,
  SLASH_GLOBSTAR,
  ANYMATCH_OPTS,
  STRING_TYPE,
  FUNCTION_TYPE,
  EMPTY_STR,
  EMPTY_FN,
  isWindows: isWindows$1,
  isMacos,
  isIBMi
} = constants$1;
promisify(fs$2.stat);
promisify(fs$2.readdir);
var TOKEN = "";
var mult = 4294967296;
for (var i$2 = 0; i$2 < 4; i$2++) {
  TOKEN += (mult * Math.random()).toString(16);
}
let isDockerCached$1;
function hasDockerEnv$1() {
  try {
    fs__default.statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
function hasDockerCGroup$1() {
  try {
    return fs__default.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
function isDocker$1() {
  if (isDockerCached$1 === void 0) {
    isDockerCached$1 = hasDockerEnv$1() || hasDockerCGroup$1();
  }
  return isDockerCached$1;
}
let cachedResult$1;
const hasContainerEnv$1 = () => {
  try {
    fs__default.statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
function isInsideContainer$1() {
  if (cachedResult$1 === void 0) {
    cachedResult$1 = hasContainerEnv$1() || isDocker$1();
  }
  return cachedResult$1;
}
const isWsl$1 = () => {
  if (process$1.platform !== "linux") {
    return false;
  }
  if (os.release().toLowerCase().includes("microsoft")) {
    if (isInsideContainer$1()) {
      return false;
    }
    return true;
  }
  try {
    return fs__default.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isInsideContainer$1() : false;
  } catch {
    return false;
  }
};
var isWsl$1$1 = process$1.env.__IS_WSL_TEST__ ? isWsl$1 : isWsl$1();
function defineLazyProperty(object, propertyName, valueGetter) {
  const define = (value2) => Object.defineProperty(object, propertyName, { value: value2, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = valueGetter();
      define(result);
      return result;
    },
    set(value2) {
      define(value2);
    }
  });
  return object;
}
promisify$4(execFile);
promisify$4(execFile);
promisify$4(execFile);
promisify$4(execFile);
const __dirname$2 = path$b.dirname(fileURLToPath$1(import.meta.url));
path$b.join(__dirname$2, "xdg-open");
const { platform, arch } = process$1;
function detectArchBinary(binary) {
  if (typeof binary === "string" || Array.isArray(binary)) {
    return binary;
  }
  const { [arch]: archBinary } = binary;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && isWsl$1$1) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
const apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  linux: ["google-chrome", "google-chrome-stable", "chromium"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
defineLazyProperty(apps, "browser", () => "browser");
defineLazyProperty(apps, "browserPrivate", () => "browserPrivate");
var crossSpawn = { exports: {} };
var windows;
var hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows) return windows;
  hasRequiredWindows = 1;
  windows = isexe2;
  isexe2.sync = sync2;
  var fs2 = require$$0$4;
  function checkPathExt(path2, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p2 = pathext[i].toLowerCase();
      if (p2 && path2.substr(-p2.length).toLowerCase() === p2) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path2, options2) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path2, options2);
  }
  function isexe2(path2, options2, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path2, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), path2, options2);
  }
  return windows;
}
var mode;
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  mode = isexe2;
  isexe2.sync = sync2;
  var fs2 = require$$0$4;
  function isexe2(path2, options2, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), options2);
  }
  function checkStat(stat2, options2) {
    return stat2.isFile() && checkMode(stat2, options2);
  }
  function checkMode(stat2, options2) {
    var mod = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
    var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o2 = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o2 || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var core$1;
if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
  core$1 = requireWindows();
} else {
  core$1 = requireMode();
}
var isexe_1 = isexe$1;
isexe$1.sync = sync$1;
function isexe$1(path2, options2, cb) {
  if (typeof options2 === "function") {
    cb = options2;
    options2 = {};
  }
  if (!cb) {
    if (typeof Promise !== "function") {
      throw new TypeError("callback not provided");
    }
    return new Promise(function(resolve2, reject) {
      isexe$1(path2, options2 || {}, function(er, is) {
        if (er) {
          reject(er);
        } else {
          resolve2(is);
        }
      });
    });
  }
  core$1(path2, options2 || {}, function(er, is) {
    if (er) {
      if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}
function sync$1(path2, options2) {
  try {
    return core$1.sync(path2, options2 || {});
  } catch (er) {
    if (options2 && options2.ignoreErrors || er.code === "EACCES") {
      return false;
    } else {
      throw er;
    }
  }
}
const isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
const path$2 = require$$0$2$1;
const COLON = isWindows ? ";" : ":";
const isexe = isexe_1;
const getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON;
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
    // windows always checks the cwd first
    ...isWindows ? [process.cwd()] : [],
    ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
    "").split(colon)
  ];
  const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
  const pathExt = isWindows ? pathExtExe.split(colon) : [""];
  if (isWindows) {
    if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
      pathExt.unshift("");
  }
  return {
    pathEnv,
    pathExt,
    pathExtExe
  };
};
const which$1 = (cmd, opt, cb) => {
  if (typeof opt === "function") {
    cb = opt;
    opt = {};
  }
  if (!opt)
    opt = {};
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found2 = [];
  const step = (i) => new Promise((resolve2, reject) => {
    if (i === pathEnv.length)
      return opt.all && found2.length ? resolve2(found2) : reject(getNotFoundError(cmd));
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = path$2.join(pathPart, cmd);
    const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    resolve2(subStep(p2, i, 0));
  });
  const subStep = (p2, i, ii) => new Promise((resolve2, reject) => {
    if (ii === pathExt.length)
      return resolve2(step(i + 1));
    const ext = pathExt[ii];
    isexe(p2 + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found2.push(p2 + ext);
        else
          return resolve2(p2 + ext);
      }
      return resolve2(subStep(p2, i, ii + 1));
    });
  });
  return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
};
const whichSync = (cmd, opt) => {
  opt = opt || {};
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found2 = [];
  for (let i = 0; i < pathEnv.length; i++) {
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = path$2.join(pathPart, cmd);
    const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    for (let j = 0; j < pathExt.length; j++) {
      const cur = p2 + pathExt[j];
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe });
        if (is) {
          if (opt.all)
            found2.push(cur);
          else
            return cur;
        }
      } catch (ex) {
      }
    }
  }
  if (opt.all && found2.length)
    return found2;
  if (opt.nothrow)
    return null;
  throw getNotFoundError(cmd);
};
var which_1 = which$1;
which$1.sync = whichSync;
var pathKey$1 = { exports: {} };
const pathKey = (options2 = {}) => {
  const environment = options2.env || process.env;
  const platform2 = options2.platform || process.platform;
  if (platform2 !== "win32") {
    return "PATH";
  }
  return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
};
pathKey$1.exports = pathKey;
pathKey$1.exports.default = pathKey;
var pathKeyExports = pathKey$1.exports;
const path$1 = require$$0$2$1;
const which = which_1;
const getPathKey = pathKeyExports;
function resolveCommandAttempt(parsed, withoutPathExt) {
  const env2 = parsed.options.env || process.env;
  const cwd = process.cwd();
  const hasCustomCwd = parsed.options.cwd != null;
  const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
  if (shouldSwitchCwd) {
    try {
      process.chdir(parsed.options.cwd);
    } catch (err2) {
    }
  }
  let resolved;
  try {
    resolved = which.sync(parsed.command, {
      path: env2[getPathKey({ env: env2 })],
      pathExt: withoutPathExt ? path$1.delimiter : void 0
    });
  } catch (e2) {
  } finally {
    if (shouldSwitchCwd) {
      process.chdir(cwd);
    }
  }
  if (resolved) {
    resolved = path$1.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
  }
  return resolved;
}
function resolveCommand$1(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
var resolveCommand_1 = resolveCommand$1;
var _escape = {};
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function escapeCommand(arg) {
  arg = arg.replace(metaCharsRegExp, "^$1");
  return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
  arg = `${arg}`;
  arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
  arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
  arg = `"${arg}"`;
  arg = arg.replace(metaCharsRegExp, "^$1");
  if (doubleEscapeMetaChars) {
    arg = arg.replace(metaCharsRegExp, "^$1");
  }
  return arg;
}
_escape.command = escapeCommand;
_escape.argument = escapeArgument;
var shebangRegex$1 = /^#!(.*)/;
const shebangRegex = shebangRegex$1;
var shebangCommand$1 = (string = "") => {
  const match = string.match(shebangRegex);
  if (!match) {
    return null;
  }
  const [path2, argument] = match[0].replace(/#! ?/, "").split(" ");
  const binary = path2.split("/").pop();
  if (binary === "env") {
    return argument;
  }
  return argument ? `${binary} ${argument}` : binary;
};
const fs = require$$0$4;
const shebangCommand = shebangCommand$1;
function readShebang$1(command) {
  const size = 150;
  const buffer = Buffer.alloc(size);
  let fd;
  try {
    fd = fs.openSync(command, "r");
    fs.readSync(fd, buffer, 0, size, 0);
    fs.closeSync(fd);
  } catch (e2) {
  }
  return shebangCommand(buffer.toString());
}
var readShebang_1 = readShebang$1;
const path = require$$0$2$1;
const resolveCommand = resolveCommand_1;
const escape$1 = _escape;
const readShebang = readShebang_1;
const isWin$1 = process.platform === "win32";
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  const shebang = parsed.file && readShebang(parsed.file);
  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }
  return parsed.file;
}
function parseNonShell(parsed) {
  if (!isWin$1) {
    return parsed;
  }
  const commandFile = detectShebang(parsed);
  const needsShell = !isExecutableRegExp.test(commandFile);
  if (parsed.options.forceShell || needsShell) {
    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
    parsed.command = path.normalize(parsed.command);
    parsed.command = escape$1.command(parsed.command);
    parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
    parsed.command = process.env.comspec || "cmd.exe";
    parsed.options.windowsVerbatimArguments = true;
  }
  return parsed;
}
function parse$5$1(command, args, options2) {
  if (args && !Array.isArray(args)) {
    options2 = args;
    args = null;
  }
  args = args ? args.slice(0) : [];
  options2 = Object.assign({}, options2);
  const parsed = {
    command,
    args,
    options: options2,
    file: void 0,
    original: {
      command,
      args
    }
  };
  return options2.shell ? parsed : parseNonShell(parsed);
}
var parse_1$1 = parse$5$1;
const isWin = process.platform === "win32";
function notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}
function hookChildProcess(cp2, parsed) {
  if (!isWin) {
    return;
  }
  const originalEmit = cp2.emit;
  cp2.emit = function(name, arg1) {
    if (name === "exit") {
      const err2 = verifyENOENT(arg1, parsed);
      if (err2) {
        return originalEmit.call(cp2, "error", err2);
      }
    }
    return originalEmit.apply(cp2, arguments);
  };
}
function verifyENOENT(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawn");
  }
  return null;
}
function verifyENOENTSync(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawnSync");
  }
  return null;
}
var enoent$1 = {
  hookChildProcess,
  verifyENOENT,
  verifyENOENTSync,
  notFoundError
};
const cp = require$$2$1;
const parse$4$1 = parse_1$1;
const enoent = enoent$1;
function spawn(command, args, options2) {
  const parsed = parse$4$1(command, args, options2);
  const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
  enoent.hookChildProcess(spawned, parsed);
  return spawned;
}
function spawnSync(command, args, options2) {
  const parsed = parse$4$1(command, args, options2);
  const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
  result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
  return result;
}
crossSpawn.exports = spawn;
crossSpawn.exports.spawn = spawn;
crossSpawn.exports.sync = spawnSync;
crossSpawn.exports._parse = parse$4$1;
crossSpawn.exports._enoent = enoent;
var bufferUtil$1 = { exports: {} };
const BINARY_TYPES$2 = ["nodebuffer", "arraybuffer", "fragments"];
const hasBlob$1 = typeof Blob !== "undefined";
if (hasBlob$1) BINARY_TYPES$2.push("blob");
var constants = {
  BINARY_TYPES: BINARY_TYPES$2,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
  hasBlob: hasBlob$1,
  kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
  kListener: Symbol("kListener"),
  kStatusCode: Symbol("status-code"),
  kWebSocket: Symbol("websocket"),
  NOOP: () => {
  }
};
const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;
const FastBuffer$2 = Buffer[Symbol.species];
function concat$1(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER$3;
  if (list.length === 1) return list[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset2 = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset2);
    offset2 += buf.length;
  }
  if (offset2 < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset2);
  }
  return target;
}
function _mask(source, mask, output, offset2, length) {
  for (let i = 0; i < length; i++) {
    output[offset2 + i] = source[i] ^ mask[i & 3];
  }
}
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}
function toArrayBuffer$1(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}
function toBuffer$2(data) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data)) return data;
  let buf;
  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer$2.readOnly = false;
  }
  return buf;
}
bufferUtil$1.exports = {
  concat: concat$1,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$1,
  toBuffer: toBuffer$2,
  unmask: _unmask
};
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil2 = require("bufferutil");
    bufferUtil$1.exports.mask = function(source, mask, output, offset2, length) {
      if (length < 48) _mask(source, mask, output, offset2, length);
      else bufferUtil2.mask(source, mask, output, offset2, length);
    };
    bufferUtil$1.exports.unmask = function(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil2.unmask(buffer, mask);
    };
  } catch (e2) {
  }
}
var bufferUtilExports = bufferUtil$1.exports;
const kDone = Symbol("kDone");
const kRun = Symbol("kRun");
let Limiter$1 = class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }
  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }
  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;
    if (this.jobs.length) {
      const job = this.jobs.shift();
      this.pending++;
      job(this[kDone]);
    }
  }
};
var limiter = Limiter$1;
const zlib = zlib$1;
const bufferUtil = bufferUtilExports;
const Limiter2 = limiter;
const { kStatusCode: kStatusCode$2 } = constants;
const FastBuffer$1 = Buffer[Symbol.species];
const TRAILER = Buffer.from([0, 0, 255, 255]);
const kPerMessageDeflate = Symbol("permessage-deflate");
const kTotalLength = Symbol("total-length");
const kCallback = Symbol("callback");
const kBuffers = Symbol("buffers");
const kError$1 = Symbol("error");
let zlibLimiter;
let PerMessageDeflate$4 = class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options2, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options2 || {};
    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;
    this.params = null;
    if (!zlibLimiter) {
      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter2(concurrency);
    }
  }
  /**
   * @type {String}
   */
  static get extensionName() {
    return "permessage-deflate";
  }
  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};
    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }
    return params;
  }
  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);
    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
    return this.params;
  }
  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }
    if (this._deflate) {
      const callback = this._deflate[kCallback];
      this._deflate.close();
      this._deflate = null;
      if (callback) {
        callback(
          new Error(
            "The deflate stream was closed while data was being processed"
          )
        );
      }
    }
  }
  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
        return false;
      }
      return true;
    });
    if (!accepted) {
      throw new Error("None of the extension offers can be accepted");
    }
    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === "number") {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === "number") {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
      delete accepted.client_max_window_bits;
    }
    return accepted;
  }
  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];
    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }
    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === "number") {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }
    return params;
  }
  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value2 = params[key];
        if (value2.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }
        value2 = value2[0];
        if (key === "client_max_window_bits") {
          if (value2 !== true) {
            const num = +value2;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value2}`
              );
            }
            value2 = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value2}`
            );
          }
        } else if (key === "server_max_window_bits") {
          const num = +value2;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value2}`
            );
          }
          value2 = num;
        } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
          if (value2 !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value2}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }
        params[key] = value2;
      });
    });
    return configurations;
  }
  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err2, result) => {
        done();
        callback(err2, result);
      });
    });
  }
  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err2, result) => {
        done();
        callback(err2, result);
      });
    });
  }
  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? "client" : "server";
    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on("error", inflateOnError);
      this._inflate.on("data", inflateOnData);
    }
    this._inflate[kCallback] = callback;
    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);
    this._inflate.flush(() => {
      const err2 = this._inflate[kError$1];
      if (err2) {
        this._inflate.close();
        this._inflate = null;
        callback(err2);
        return;
      }
      const data2 = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );
      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }
      callback(null, data2);
    });
  }
  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? "server" : "client";
    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      this._deflate.on("data", deflateOnData);
    }
    this._deflate[kCallback] = callback;
    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        return;
      }
      let data2 = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );
      if (fin) {
        data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);
      }
      this._deflate[kCallback] = null;
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }
      callback(null, data2);
    });
  }
};
var permessageDeflate = PerMessageDeflate$4;
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
}
function inflateOnError(err2) {
  this[kPerMessageDeflate]._inflate = null;
  err2[kStatusCode$2] = 1007;
  this[kCallback](err2);
}
var validation = { exports: {} };
const { isUtf8 } = require$$0$9;
const { hasBlob } = constants;
const tokenChars$2 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  // 80 - 95
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0
  // 112 - 127
];
function isValidStatusCode$2(code) {
  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
}
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;
  while (i < len) {
    if ((buf[i] & 128) === 0) {
      i++;
    } else if ((buf[i] & 224) === 192) {
      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
        return false;
      }
      i += 2;
    } else if ((buf[i] & 240) === 224) {
      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
      buf[i] === 237 && (buf[i + 1] & 224) === 160) {
        return false;
      }
      i += 3;
    } else if ((buf[i] & 248) === 240) {
      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
        return false;
      }
      i += 4;
    } else {
      return false;
    }
  }
  return true;
}
function isBlob$2(value2) {
  return hasBlob && typeof value2 === "object" && typeof value2.arrayBuffer === "function" && typeof value2.type === "string" && typeof value2.stream === "function" && (value2[Symbol.toStringTag] === "Blob" || value2[Symbol.toStringTag] === "File");
}
validation.exports = {
  isBlob: isBlob$2,
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$2
};
if (isUtf8) {
  validation.exports.isValidUTF8 = function(buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF82 = require("utf-8-validate");
    validation.exports.isValidUTF8 = function(buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);
    };
  } catch (e2) {
  }
}
var validationExports = validation.exports;
const { Writable: Writable$1 } = require$$0$8;
const PerMessageDeflate$3 = permessageDeflate;
const {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$3
} = constants;
const { concat, toArrayBuffer, unmask } = bufferUtilExports;
const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;
const FastBuffer = Buffer[Symbol.species];
const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;
let Receiver$1 = class Receiver extends Writable$1 {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options2 = {}) {
    super();
    this._allowSynchronousEvents = options2.allowSynchronousEvents !== void 0 ? options2.allowSynchronousEvents : true;
    this._binaryType = options2.binaryType || BINARY_TYPES$1[0];
    this._extensions = options2.extensions || {};
    this._isServer = !!options2.isServer;
    this._maxPayload = options2.maxPayload | 0;
    this._skipUTF8Validation = !!options2.skipUTF8Validation;
    this[kWebSocket$3] = void 0;
    this._bufferedBytes = 0;
    this._buffers = [];
    this._compressed = false;
    this._payloadLength = 0;
    this._mask = void 0;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;
    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];
    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 8 && this._state == GET_INFO) return cb();
    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }
  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n2) {
    this._bufferedBytes -= n2;
    if (n2 === this._buffers[0].length) return this._buffers.shift();
    if (n2 < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n2,
        buf.length - n2
      );
      return new FastBuffer(buf.buffer, buf.byteOffset, n2);
    }
    const dst = Buffer.allocUnsafe(n2);
    do {
      const buf = this._buffers[0];
      const offset2 = dst.length - n2;
      if (n2 >= buf.length) {
        dst.set(this._buffers.shift(), offset2);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset2);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n2,
          buf.length - n2
        );
      }
      n2 -= buf.length;
    } while (n2 > 0);
    return dst;
  }
  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;
    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);
    if (!this._errored) cb();
  }
  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    const buf = this.consume(2);
    if ((buf[0] & 48) !== 0) {
      const error2 = this.createError(
        RangeError,
        "RSV2 and RSV3 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_2_3"
      );
      cb(error2);
      return;
    }
    const compressed = (buf[0] & 64) === 64;
    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
      const error2 = this.createError(
        RangeError,
        "RSV1 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_1"
      );
      cb(error2);
      return;
    }
    this._fin = (buf[0] & 128) === 128;
    this._opcode = buf[0] & 15;
    this._payloadLength = buf[1] & 127;
    if (this._opcode === 0) {
      if (compressed) {
        const error2 = this.createError(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
        cb(error2);
        return;
      }
      if (!this._fragmented) {
        const error2 = this.createError(
          RangeError,
          "invalid opcode 0",
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
        cb(error2);
        return;
      }
      this._opcode = this._fragmented;
    } else if (this._opcode === 1 || this._opcode === 2) {
      if (this._fragmented) {
        const error2 = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
        cb(error2);
        return;
      }
      this._compressed = compressed;
    } else if (this._opcode > 7 && this._opcode < 11) {
      if (!this._fin) {
        const error2 = this.createError(
          RangeError,
          "FIN must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_FIN"
        );
        cb(error2);
        return;
      }
      if (compressed) {
        const error2 = this.createError(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
        cb(error2);
        return;
      }
      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
        const error2 = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
        cb(error2);
        return;
      }
    } else {
      const error2 = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        "WS_ERR_INVALID_OPCODE"
      );
      cb(error2);
      return;
    }
    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 128) === 128;
    if (this._isServer) {
      if (!this._masked) {
        const error2 = this.createError(
          RangeError,
          "MASK must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_MASK"
        );
        cb(error2);
        return;
      }
    } else if (this._masked) {
      const error2 = this.createError(
        RangeError,
        "MASK must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_MASK"
      );
      cb(error2);
      return;
    }
    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }
  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }
  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }
    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error2 = this.createError(
        RangeError,
        "Unsupported WebSocket frame: payload length > 2^53 - 1",
        false,
        1009,
        "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
      );
      cb(error2);
      return;
    }
    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }
  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 8) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error2 = this.createError(
          RangeError,
          "Max payload size exceeded",
          false,
          1009,
          "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
        );
        cb(error2);
        return;
      }
    }
    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }
  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }
    this._mask = this.consume(4);
    this._state = GET_DATA;
  }
  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER$2;
    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }
      data = this.consume(this._payloadLength);
      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
        unmask(data, this._mask);
      }
    }
    if (this._opcode > 7) {
      this.controlMessage(data, cb);
      return;
    }
    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }
    if (data.length) {
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }
    this.dataMessage(cb);
  }
  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
    perMessageDeflate.decompress(data, this._fin, (err2, buf) => {
      if (err2) return cb(err2);
      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error2 = this.createError(
            RangeError,
            "Max payload size exceeded",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
          );
          cb(error2);
          return;
        }
        this._fragments.push(buf);
      }
      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }
  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }
    const messageLength = this._messageLength;
    const fragments = this._fragments;
    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];
    if (this._opcode === 2) {
      let data;
      if (this._binaryType === "nodebuffer") {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === "arraybuffer") {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === "blob") {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }
      if (this._allowSynchronousEvents) {
        this.emit("message", data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit("message", data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);
      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error2 = this.createError(
          Error,
          "invalid UTF-8 sequence",
          true,
          1007,
          "WS_ERR_INVALID_UTF8"
        );
        cb(error2);
        return;
      }
      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit("message", buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit("message", buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }
  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 8) {
      if (data.length === 0) {
        this._loop = false;
        this.emit("conclude", 1005, EMPTY_BUFFER$2);
        this.end();
      } else {
        const code = data.readUInt16BE(0);
        if (!isValidStatusCode$1(code)) {
          const error2 = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            "WS_ERR_INVALID_CLOSE_CODE"
          );
          cb(error2);
          return;
        }
        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error2 = this.createError(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
          cb(error2);
          return;
        }
        this._loop = false;
        this.emit("conclude", code, buf);
        this.end();
      }
      this._state = GET_INFO;
      return;
    }
    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 9 ? "ping" : "pong", data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }
  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;
    const err2 = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );
    Error.captureStackTrace(err2, this.createError);
    err2.code = errorCode;
    err2[kStatusCode$1] = statusCode;
    return err2;
  }
};
var receiver = Receiver$1;
const { randomFillSync } = require$$3;
const PerMessageDeflate$2 = permessageDeflate;
const { EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$2 } = constants;
const { isBlob: isBlob$1, isValidStatusCode } = validationExports;
const { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;
const kByteLength = Symbol("kByteLength");
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;
const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;
let Sender$1 = class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions2, generateMask) {
    this._extensions = extensions2 || {};
    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }
    this._socket = socket;
    this._firstFragment = true;
    this._compress = false;
    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP$2;
    this[kWebSocket$2] = void 0;
  }
  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options2) {
    let mask;
    let merge2 = false;
    let offset2 = 2;
    let skipMasking = false;
    if (options2.mask) {
      mask = options2.maskBuffer || maskBuffer;
      if (options2.generateMask) {
        options2.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          if (randomPool === void 0) {
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }
          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }
        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }
      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset2 = 6;
    }
    let dataLength;
    if (typeof data === "string") {
      if ((!options2.mask || skipMasking) && options2[kByteLength] !== void 0) {
        dataLength = options2[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge2 = options2.mask && options2.readOnly && !skipMasking;
    }
    let payloadLength = dataLength;
    if (dataLength >= 65536) {
      offset2 += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset2 += 2;
      payloadLength = 126;
    }
    const target = Buffer.allocUnsafe(merge2 ? dataLength + offset2 : offset2);
    target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
    if (options2.rsv1) target[0] |= 64;
    target[1] = payloadLength;
    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }
    if (!options2.mask) return [target, data];
    target[1] |= 128;
    target[offset2 - 4] = mask[0];
    target[offset2 - 3] = mask[1];
    target[offset2 - 2] = mask[2];
    target[offset2 - 1] = mask[3];
    if (skipMasking) return [target, data];
    if (merge2) {
      applyMask(data, mask, target, offset2, dataLength);
      return [target];
    }
    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }
  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;
    if (code === void 0) {
      buf = EMPTY_BUFFER$1;
    } else if (typeof code !== "number" || !isValidStatusCode(code)) {
      throw new TypeError("First argument must be a valid error code number");
    } else if (data === void 0 || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);
      if (length > 123) {
        throw new RangeError("The message must not be greater than 123 bytes");
      }
      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      if (typeof data === "string") {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }
    const options2 = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 8,
      readOnly: false,
      rsv1: false
    };
    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options2, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options2), cb);
    }
  }
  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;
    if (typeof data === "string") {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob$1(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options2 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 9,
      readOnly,
      rsv1: false
    };
    if (isBlob$1(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options2, cb]);
      } else {
        this.getBlobData(data, false, options2, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options2, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options2), cb);
    }
  }
  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;
    if (typeof data === "string") {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob$1(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options2 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 10,
      readOnly,
      rsv1: false
    };
    if (isBlob$1(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options2, cb]);
      } else {
        this.getBlobData(data, false, options2, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options2, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options2), cb);
    }
  }
  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options2, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    let opcode = options2.binary ? 2 : 1;
    let rsv1 = options2.compress;
    let byteLength;
    let readOnly;
    if (typeof data === "string") {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob$1(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }
    if (options2.fin) this._firstFragment = true;
    const opts = {
      [kByteLength]: byteLength,
      fin: options2.fin,
      generateMask: this._generateMask,
      mask: options2.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };
    if (isBlob$1(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }
  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options2, cb) {
    this._bufferedBytes += options2[kByteLength];
    this._state = GET_BLOB_DATA;
    blob.arrayBuffer().then((arrayBuffer) => {
      if (this._socket.destroyed) {
        const err2 = new Error(
          "The socket was closed while the blob was being read"
        );
        process.nextTick(callCallbacks, this, err2, cb);
        return;
      }
      this._bufferedBytes -= options2[kByteLength];
      const data = toBuffer$1(arrayBuffer);
      if (!compress) {
        this._state = DEFAULT;
        this.sendFrame(Sender.frame(data, options2), cb);
        this.dequeue();
      } else {
        this.dispatch(data, compress, options2, cb);
      }
    }).catch((err2) => {
      process.nextTick(onError, this, err2, cb);
    });
  }
  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options2, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options2), cb);
      return;
    }
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    this._bufferedBytes += options2[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options2.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err2 = new Error(
          "The socket was closed while data was being compressed"
        );
        callCallbacks(this, err2, cb);
        return;
      }
      this._bufferedBytes -= options2[kByteLength];
      this._state = DEFAULT;
      options2.readOnly = false;
      this.sendFrame(Sender.frame(buf, options2), cb);
      this.dequeue();
    });
  }
  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();
      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }
  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }
  /**
   * Sends a frame.
   *
   * @param {(Buffer | String)[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
};
var sender = Sender$1;
function callCallbacks(sender2, err2, cb) {
  if (typeof cb === "function") cb(err2);
  for (let i = 0; i < sender2._queue.length; i++) {
    const params = sender2._queue[i];
    const callback = params[params.length - 1];
    if (typeof callback === "function") callback(err2);
  }
}
function onError(sender2, err2, cb) {
  callCallbacks(sender2, err2, cb);
  sender2.onerror(err2);
}
const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;
const kCode = Symbol("kCode");
const kData = Symbol("kData");
const kError = Symbol("kError");
const kMessage = Symbol("kMessage");
const kReason = Symbol("kReason");
const kTarget = Symbol("kTarget");
const kType = Symbol("kType");
const kWasClean = Symbol("kWasClean");
let Event$1 = class Event2 {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }
  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }
  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
};
Object.defineProperty(Event$1.prototype, "target", { enumerable: true });
Object.defineProperty(Event$1.prototype, "type", { enumerable: true });
class CloseEvent extends Event$1 {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options2 = {}) {
    super(type);
    this[kCode] = options2.code === void 0 ? 0 : options2.code;
    this[kReason] = options2.reason === void 0 ? "" : options2.reason;
    this[kWasClean] = options2.wasClean === void 0 ? false : options2.wasClean;
  }
  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }
  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }
  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}
Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
class ErrorEvent extends Event$1 {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options2 = {}) {
    super(type);
    this[kError] = options2.error === void 0 ? null : options2.error;
    this[kMessage] = options2.message === void 0 ? "" : options2.message;
  }
  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }
  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}
Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
class MessageEvent extends Event$1 {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options2 = {}) {
    super(type);
    this[kData] = options2.data === void 0 ? null : options2.data;
  }
  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}
Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options2 = {}) {
    for (const listener2 of this.listeners(type)) {
      if (!options2[kForOnEventAttribute$1] && listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
        return;
      }
    }
    let wrapper;
    if (type === "message") {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent("message", {
          data: isBinary ? data : data.toString()
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "close") {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent("close", {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "error") {
      wrapper = function onError2(error2) {
        const event = new ErrorEvent("error", {
          error: error2,
          message: error2.message
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "open") {
      wrapper = function onOpen() {
        const event = new Event$1("open");
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }
    wrapper[kForOnEventAttribute$1] = !!options2[kForOnEventAttribute$1];
    wrapper[kListener$1] = handler;
    if (options2.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },
  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener2 of this.listeners(type)) {
      if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
        this.removeListener(type, listener2);
        break;
      }
    }
  }
};
var eventTarget = {
  EventTarget
};
function callListener(listener2, thisArg, event) {
  if (typeof listener2 === "object" && listener2.handleEvent) {
    listener2.handleEvent.call(listener2, event);
  } else {
    listener2.call(thisArg, event);
  }
}
const { tokenChars: tokenChars$1 } = validationExports;
function push(dest, name, elem) {
  if (dest[name] === void 0) dest[name] = [elem];
  else dest[name].push(elem);
}
function parse$3$1(header) {
  const offers = /* @__PURE__ */ Object.create(null);
  let params = /* @__PURE__ */ Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;
  for (; i < header.length; i++) {
    code = header.charCodeAt(i);
    if (extensionName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 44) {
          push(offers, name, params);
          params = /* @__PURE__ */ Object.create(null);
        } else {
          extensionName = name;
        }
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 32 || code === 9) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        start = end = -1;
      } else if (code === 61 && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 34 && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 32 || code === 9)) {
        if (end === -1) end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1) end = i;
        let value2 = header.slice(start, end);
        if (mustUnescape) {
          value2 = value2.replace(/\\/g, "");
          mustUnescape = false;
        }
        push(params, paramName, value2);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        paramName = void 0;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }
  if (start === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === void 0) {
    push(offers, token, params);
  } else {
    if (paramName === void 0) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ""));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }
  return offers;
}
function format$1(extensions2) {
  return Object.keys(extensions2).map((extension2) => {
    let configurations = extensions2[extension2];
    if (!Array.isArray(configurations)) configurations = [configurations];
    return configurations.map((params) => {
      return [extension2].concat(
        Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values)) values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })
      ).join("; ");
    }).join(", ");
  }).join(", ");
}
var extension$1 = { format: format$1, parse: parse$3$1 };
const EventEmitter$1 = require$$0$7;
const https$2 = require$$1$3;
const http$3 = require$$1$2;
const net = require$$4$1$1;
const tls = require$$4$2;
const { randomBytes, createHash: createHash$1 } = require$$3;
const { URL: URL$2 } = require$$0$5;
const PerMessageDeflate$1 = permessageDeflate;
const Receiver2 = receiver;
const Sender2 = sender;
const { isBlob } = validationExports;
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID: GUID$1,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket: kWebSocket$1,
  NOOP: NOOP$1
} = constants;
const {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget;
const { format, parse: parse$2$1 } = extension$1;
const { toBuffer } = bufferUtilExports;
const closeTimeout = 30 * 1e3;
const kAborted = Symbol("kAborted");
const protocolVersions = [8, 13];
const readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
let WebSocket$1 = class WebSocket extends EventEmitter$1 {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options2) {
    super();
    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = "";
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;
      if (protocols === void 0) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === "object" && protocols !== null) {
          options2 = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }
      initAsClient(this, address, protocols, options2);
    } else {
      this._autoPong = options2.autoPong;
      this._isServer = true;
    }
  }
  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }
  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;
    this._binaryType = type;
    if (this._receiver) this._receiver._binaryType = type;
  }
  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;
    return this._socket._writableState.length + this._sender._bufferedBytes;
  }
  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }
  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }
  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }
  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }
  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }
  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options2) {
    const receiver2 = new Receiver2({
      allowSynchronousEvents: options2.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options2.maxPayload,
      skipUTF8Validation: options2.skipUTF8Validation
    });
    const sender2 = new Sender2(socket, this._extensions, options2.generateMask);
    this._receiver = receiver2;
    this._sender = sender2;
    this._socket = socket;
    receiver2[kWebSocket$1] = this;
    sender2[kWebSocket$1] = this;
    socket[kWebSocket$1] = this;
    receiver2.on("conclude", receiverOnConclude);
    receiver2.on("drain", receiverOnDrain);
    receiver2.on("error", receiverOnError);
    receiver2.on("message", receiverOnMessage);
    receiver2.on("ping", receiverOnPing);
    receiver2.on("pong", receiverOnPong);
    sender2.onerror = senderOnError;
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();
    if (head.length > 0) socket.unshift(head);
    socket.on("close", socketOnClose);
    socket.on("data", socketOnData);
    socket.on("end", socketOnEnd);
    socket.on("error", socketOnError$1);
    this._readyState = WebSocket.OPEN;
    this.emit("open");
  }
  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
      return;
    }
    if (this._extensions[PerMessageDeflate$1.extensionName]) {
      this._extensions[PerMessageDeflate$1.extensionName].cleanup();
    }
    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit("close", this._closeCode, this._closeMessage);
  }
  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      abortHandshake$1(this, this._req, msg);
      return;
    }
    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
        this._socket.end();
      }
      return;
    }
    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err2) => {
      if (err2) return;
      this._closeFrameSent = true;
      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
        this._socket.end();
      }
    });
    setCloseTimer(this);
  }
  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
      return;
    }
    this._paused = true;
    this._socket.pause();
  }
  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data === "function") {
      cb = data;
      data = mask = void 0;
    } else if (typeof mask === "function") {
      cb = mask;
      mask = void 0;
    }
    if (typeof data === "number") data = data.toString();
    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }
    if (mask === void 0) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }
  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data === "function") {
      cb = data;
      data = mask = void 0;
    } else if (typeof mask === "function") {
      cb = mask;
      mask = void 0;
    }
    if (typeof data === "number") data = data.toString();
    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }
    if (mask === void 0) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }
  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
      return;
    }
    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }
  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options2, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof options2 === "function") {
      cb = options2;
      options2 = {};
    }
    if (typeof data === "number") data = data.toString();
    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }
    const opts = {
      binary: typeof data !== "string",
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options2
    };
    if (!this._extensions[PerMessageDeflate$1.extensionName]) {
      opts.compress = false;
    }
    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }
  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      abortHandshake$1(this, this._req, msg);
      return;
    }
    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
};
Object.defineProperty(WebSocket$1, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1.prototype, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "isPaused",
  "protocol",
  "readyState",
  "url"
].forEach((property) => {
  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
});
["open", "error", "close", "message"].forEach((method) => {
  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute]) return listener2[kListener];
      }
      return null;
    },
    set(handler) {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute]) {
          this.removeListener(method, listener2);
          break;
        }
      }
      if (typeof handler !== "function") return;
      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});
WebSocket$1.prototype.addEventListener = addEventListener;
WebSocket$1.prototype.removeEventListener = removeEventListener;
var websocket = WebSocket$1;
function initAsClient(websocket2, address, protocols, options2) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options2,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  websocket2._autoPong = opts.autoPong;
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  }
  let parsedUrl;
  if (address instanceof URL$2) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e2) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }
  if (parsedUrl.protocol === "http:") {
    parsedUrl.protocol = "ws:";
  } else if (parsedUrl.protocol === "https:") {
    parsedUrl.protocol = "wss:";
  }
  websocket2._url = parsedUrl.href;
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err2 = new SyntaxError(invalidUrlMessage);
    if (websocket2._redirects === 0) {
      throw err2;
    } else {
      emitErrorAndClose(websocket2, err2);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString("base64");
  const request = isSecure ? https$2.request : http$3.request;
  const protocolSet = /* @__PURE__ */ new Set();
  let perMessageDeflate;
  opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers["Sec-WebSocket-Extensions"] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      }
      protocolSet.add(protocol);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req2;
  if (opts.followRedirects) {
    if (websocket2._redirects === 0) {
      websocket2._originalIpc = isIpcUrl;
      websocket2._originalSecure = isSecure;
      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options2 && options2.headers;
      options2 = { ...options2, headers: {} };
      if (headers) {
        for (const [key2, value2] of Object.entries(headers)) {
          options2.headers[key2.toLowerCase()] = value2;
        }
      }
    } else if (websocket2.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
      if (!isSameHost || websocket2._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost) delete opts.headers.host;
        opts.auth = void 0;
      }
    }
    if (opts.auth && !options2.headers.authorization) {
      options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req2 = websocket2._req = request(opts);
    if (websocket2._redirects) {
      websocket2.emit("redirect", websocket2.url, req2);
    }
  } else {
    req2 = websocket2._req = request(opts);
  }
  if (opts.timeout) {
    req2.on("timeout", () => {
      abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
    });
  }
  req2.on("error", (err2) => {
    if (req2 === null || req2[kAborted]) return;
    req2 = websocket2._req = null;
    emitErrorAndClose(websocket2, err2);
  });
  req2.on("response", (res) => {
    const location2 = res.headers.location;
    const statusCode = res.statusCode;
    if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket2._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
        return;
      }
      req2.abort();
      let addr;
      try {
        addr = new URL$2(location2, address);
      } catch (e2) {
        const err2 = new SyntaxError(`Invalid URL: ${location2}`);
        emitErrorAndClose(websocket2, err2);
        return;
      }
      initAsClient(websocket2, addr, protocols, options2);
    } else if (!websocket2.emit("unexpected-response", req2, res)) {
      abortHandshake$1(
        websocket2,
        req2,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });
  req2.on("upgrade", (res, socket, head) => {
    websocket2.emit("upgrade", res);
    if (websocket2.readyState !== WebSocket$1.CONNECTING) return;
    req2 = websocket2._req = null;
    const upgrade = res.headers.upgrade;
    if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(websocket2, socket, "Invalid Upgrade header");
      return;
    }
    const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
    if (res.headers["sec-websocket-accept"] !== digest) {
      abortHandshake$1(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== void 0) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake$1(websocket2, socket, protError);
      return;
    }
    if (serverProt) websocket2._protocol = serverProt;
    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== void 0) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      let extensions2;
      try {
        extensions2 = parse$2$1(secWebSocketExtensions);
      } catch (err2) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      const extensionNames = Object.keys(extensions2);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions2[PerMessageDeflate$1.extensionName]);
      } catch (err2) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
    }
    websocket2.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  if (opts.finishRequest) {
    opts.finishRequest(req2, websocket2);
  } else {
    req2.end();
  }
}
function emitErrorAndClose(websocket2, err2) {
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._errorEmitted = true;
  websocket2.emit("error", err2);
  websocket2.emitClose();
}
function netConnect(options2) {
  options2.path = options2.socketPath;
  return net.connect(options2);
}
function tlsConnect(options2) {
  options2.path = void 0;
  if (!options2.servername && options2.servername !== "") {
    options2.servername = net.isIP(options2.host) ? "" : options2.host;
  }
  return tls.connect(options2);
}
function abortHandshake$1(websocket2, stream3, message) {
  websocket2._readyState = WebSocket$1.CLOSING;
  const err2 = new Error(message);
  Error.captureStackTrace(err2, abortHandshake$1);
  if (stream3.setHeader) {
    stream3[kAborted] = true;
    stream3.abort();
    if (stream3.socket && !stream3.socket.destroyed) {
      stream3.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket2, err2);
  } else {
    stream3.destroy(err2);
    stream3.once("error", websocket2.emit.bind(websocket2, "error"));
    stream3.once("close", websocket2.emitClose.bind(websocket2));
  }
}
function sendAfterClose(websocket2, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;
    if (websocket2._socket) websocket2._sender._bufferedBytes += length;
    else websocket2._bufferedAmount += length;
  }
  if (cb) {
    const err2 = new Error(
      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`
    );
    process.nextTick(cb, err2);
  }
}
function receiverOnConclude(code, reason) {
  const websocket2 = this[kWebSocket$1];
  websocket2._closeFrameReceived = true;
  websocket2._closeMessage = reason;
  websocket2._closeCode = code;
  if (websocket2._socket[kWebSocket$1] === void 0) return;
  websocket2._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket2._socket);
  if (code === 1005) websocket2.close();
  else websocket2.close(code, reason);
}
function receiverOnDrain() {
  const websocket2 = this[kWebSocket$1];
  if (!websocket2.isPaused) websocket2._socket.resume();
}
function receiverOnError(err2) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._socket[kWebSocket$1] !== void 0) {
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    websocket2.close(err2[kStatusCode]);
  }
  if (!websocket2._errorEmitted) {
    websocket2._errorEmitted = true;
    websocket2.emit("error", err2);
  }
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(data, isBinary) {
  this[kWebSocket$1].emit("message", data, isBinary);
}
function receiverOnPing(data) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._autoPong) websocket2.pong(data, !this._isServer, NOOP$1);
  websocket2.emit("ping", data);
}
function receiverOnPong(data) {
  this[kWebSocket$1].emit("pong", data);
}
function resume(stream3) {
  stream3.resume();
}
function senderOnError(err2) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2.readyState === WebSocket$1.CLOSED) return;
  if (websocket2.readyState === WebSocket$1.OPEN) {
    websocket2._readyState = WebSocket$1.CLOSING;
    setCloseTimer(websocket2);
  }
  this._socket.end();
  if (!websocket2._errorEmitted) {
    websocket2._errorEmitted = true;
    websocket2.emit("error", err2);
  }
}
function setCloseTimer(websocket2) {
  websocket2._closeTimer = setTimeout(
    websocket2._socket.destroy.bind(websocket2._socket),
    closeTimeout
  );
}
function socketOnClose() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket2._readyState = WebSocket$1.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
    websocket2._receiver.write(chunk);
  }
  websocket2._receiver.end();
  this[kWebSocket$1] = void 0;
  clearTimeout(websocket2._closeTimer);
  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
    websocket2.emitClose();
  } else {
    websocket2._receiver.on("error", receiverOnFinish);
    websocket2._receiver.on("finish", receiverOnFinish);
  }
}
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}
function socketOnEnd() {
  const websocket2 = this[kWebSocket$1];
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._receiver.end();
  this.end();
}
function socketOnError$1() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1);
  this.on("error", NOOP$1);
  if (websocket2) {
    websocket2._readyState = WebSocket$1.CLOSING;
    this.destroy();
  }
}
const { tokenChars } = validationExports;
function parse$1$1(header) {
  const protocols = /* @__PURE__ */ new Set();
  let start = -1;
  let end = -1;
  let i = 0;
  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);
    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (i !== 0 && (code === 32 || code === 9)) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 44) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
      if (end === -1) end = i;
      const protocol2 = header.slice(start, end);
      if (protocols.has(protocol2)) {
        throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
      }
      protocols.add(protocol2);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }
  if (start === -1 || end !== -1) {
    throw new SyntaxError("Unexpected end of input");
  }
  const protocol = header.slice(start, i);
  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }
  protocols.add(protocol);
  return protocols;
}
var subprotocol$1 = { parse: parse$1$1 };
const EventEmitter = require$$0$7;
const http$2 = require$$1$2;
const { createHash } = require$$3;
const extension = extension$1;
const PerMessageDeflate2 = permessageDeflate;
const subprotocol = subprotocol$1;
const WebSocket2 = websocket;
const { GUID, kWebSocket } = constants;
const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options2, callback) {
    super();
    options2 = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null,
      // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket: WebSocket2,
      ...options2
    };
    if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options must be specified'
      );
    }
    if (options2.port != null) {
      this._server = http$2.createServer((req2, res) => {
        const body = http$2.STATUS_CODES[426];
        res.writeHead(426, {
          "Content-Length": body.length,
          "Content-Type": "text/plain"
        });
        res.end(body);
      });
      this._server.listen(
        options2.port,
        options2.host,
        options2.backlog,
        callback
      );
    } else if (options2.server) {
      this._server = options2.server;
    }
    if (this._server) {
      const emitConnection = this.emit.bind(this, "connection");
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, "listening"),
        error: this.emit.bind(this, "error"),
        upgrade: (req2, socket, head) => {
          this.handleUpgrade(req2, socket, head, emitConnection);
        }
      });
    }
    if (options2.perMessageDeflate === true) options2.perMessageDeflate = {};
    if (options2.clientTracking) {
      this.clients = /* @__PURE__ */ new Set();
      this._shouldEmitClose = false;
    }
    this.options = options2;
    this._state = RUNNING;
  }
  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }
    if (!this._server) return null;
    return this._server.address();
  }
  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once("close", () => {
          cb(new Error("The server is not running"));
        });
      }
      process.nextTick(emitClose, this);
      return;
    }
    if (cb) this.once("close", cb);
    if (this._state === CLOSING) return;
    this._state = CLOSING;
    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }
      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;
      this._removeListeners();
      this._removeListeners = this._server = null;
      server.close(() => {
        emitClose(this);
      });
    }
  }
  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req2) {
    if (this.options.path) {
      const index2 = req2.url.indexOf("?");
      const pathname = index2 !== -1 ? req2.url.slice(0, index2) : req2.url;
      if (pathname !== this.options.path) return false;
    }
    return true;
  }
  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req2, socket, head, cb) {
    socket.on("error", socketOnError);
    const key = req2.headers["sec-websocket-key"];
    const upgrade = req2.headers.upgrade;
    const version2 = +req2.headers["sec-websocket-version"];
    if (req2.method !== "GET") {
      const message = "Invalid HTTP method";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 405, message);
      return;
    }
    if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
      const message = "Invalid Upgrade header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (key === void 0 || !keyRegex.test(key)) {
      const message = "Missing or invalid Sec-WebSocket-Key header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (version2 !== 8 && version2 !== 13) {
      const message = "Missing or invalid Sec-WebSocket-Version header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (!this.shouldHandle(req2)) {
      abortHandshake(socket, 400);
      return;
    }
    const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
    let protocols = /* @__PURE__ */ new Set();
    if (secWebSocketProtocol !== void 0) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err2) {
        const message = "Invalid Sec-WebSocket-Protocol header";
        abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
        return;
      }
    }
    const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
    const extensions2 = {};
    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
      const perMessageDeflate = new PerMessageDeflate2(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );
      try {
        const offers = extension.parse(secWebSocketExtensions);
        if (offers[PerMessageDeflate2.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);
          extensions2[PerMessageDeflate2.extensionName] = perMessageDeflate;
        }
      } catch (err2) {
        const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
        abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
        return;
      }
    }
    if (this.options.verifyClient) {
      const info = {
        origin: req2.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
        secure: !!(req2.socket.authorized || req2.socket.encrypted),
        req: req2
      };
      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }
          this.completeUpgrade(
            extensions2,
            key,
            protocols,
            req2,
            socket,
            head,
            cb
          );
        });
        return;
      }
      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }
    this.completeUpgrade(extensions2, key, protocols, req2, socket, head, cb);
  }
  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions2, key, protocols, req2, socket, head, cb) {
    if (!socket.readable || !socket.writable) return socket.destroy();
    if (socket[kWebSocket]) {
      throw new Error(
        "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
      );
    }
    if (this._state > RUNNING) return abortHandshake(socket, 503);
    const digest = createHash("sha1").update(key + GUID).digest("base64");
    const headers = [
      "HTTP/1.1 101 Switching Protocols",
      "Upgrade: websocket",
      "Connection: Upgrade",
      `Sec-WebSocket-Accept: ${digest}`
    ];
    const ws = new this.options.WebSocket(null, void 0, this.options);
    if (protocols.size) {
      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }
    if (extensions2[PerMessageDeflate2.extensionName]) {
      const params = extensions2[PerMessageDeflate2.extensionName].params;
      const value2 = extension.format({
        [PerMessageDeflate2.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value2}`);
      ws._extensions = extensions2;
    }
    this.emit("headers", headers, req2);
    socket.write(headers.concat("\r\n").join("\r\n"));
    socket.removeListener("error", socketOnError);
    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });
    if (this.clients) {
      this.clients.add(ws);
      ws.on("close", () => {
        this.clients.delete(ws);
        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }
    cb(ws, req2);
  }
}
var websocketServer = WebSocketServer;
function addListeners(server, map2) {
  for (const event of Object.keys(map2)) server.on(event, map2[event]);
  return function removeListeners() {
    for (const event of Object.keys(map2)) {
      server.removeListener(event, map2[event]);
    }
  };
}
function emitClose(server) {
  server._state = CLOSED;
  server.emit("close");
}
function socketOnError() {
  this.destroy();
}
function abortHandshake(socket, code, message, headers) {
  message = message || http$2.STATUS_CODES[code];
  headers = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(message),
    ...headers
  };
  socket.once("finish", socket.destroy);
  socket.end(
    `HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message
  );
}
function abortHandshakeOrEmitwsClientError(server, req2, socket, code, message) {
  if (server.listenerCount("wsClientError")) {
    const err2 = new Error(message);
    Error.captureStackTrace(err2, abortHandshakeOrEmitwsClientError);
    server.emit("wsClientError", err2, socket, req2);
  } else {
    abortHandshake(socket, code, message);
  }
}
var WebSocketServerRaw_ = /* @__PURE__ */ getDefaultExportFromCjs(websocketServer);
process.versions.bun ? (
  // @ts-expect-error: Bun defines `import.meta.require`
  import.meta.require("ws").WebSocketServer
) : WebSocketServerRaw_;
var httpProxy$3 = { exports: {} };
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener2 = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener2, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener2);
    else emitter._events[evt] = [emitter._events[evt], listener2];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events2, name;
    if (this._eventsCount === 0) return names;
    for (name in events2 = this._events) {
      if (has.call(events2, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events2.push(listeners[i]);
        }
      }
      if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var common$3 = {};
var requiresPort = function required(port, protocol) {
  protocol = protocol.split(":")[0];
  port = +port;
  if (!port) return false;
  switch (protocol) {
    case "http":
    case "ws":
      return port !== 80;
    case "https":
    case "wss":
      return port !== 443;
    case "ftp":
      return port !== 21;
    case "gopher":
      return port !== 70;
    case "file":
      return false;
  }
  return port !== 0;
};
(function(exports$1) {
  var common2 = exports$1, url2 = require$$0$5, required2 = requiresPort;
  var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
  common2.isSSL = isSSL;
  common2.setupOutgoing = function(outgoing, options2, req2, forward) {
    outgoing.port = options2[forward || "target"].port || (isSSL.test(options2[forward || "target"].protocol) ? 443 : 80);
    [
      "host",
      "hostname",
      "socketPath",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "secureProtocol"
    ].forEach(
      function(e2) {
        outgoing[e2] = options2[forward || "target"][e2];
      }
    );
    outgoing.method = options2.method || req2.method;
    outgoing.headers = Object.assign({}, req2.headers);
    if (options2.headers) {
      Object.assign(outgoing.headers, options2.headers);
    }
    if (options2.auth) {
      outgoing.auth = options2.auth;
    }
    if (options2.ca) {
      outgoing.ca = options2.ca;
    }
    if (isSSL.test(options2[forward || "target"].protocol)) {
      outgoing.rejectUnauthorized = typeof options2.secure === "undefined" ? true : options2.secure;
    }
    outgoing.agent = options2.agent || false;
    outgoing.localAddress = options2.localAddress;
    if (!outgoing.agent) {
      outgoing.headers = outgoing.headers || {};
      if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
        outgoing.headers.connection = "close";
      }
    }
    var target = options2[forward || "target"];
    var targetPath = target && options2.prependPath !== false ? target.path || "" : "";
    var outgoingPath = !options2.toProxy ? url2.parse(req2.url).path || "" : req2.url;
    outgoingPath = !options2.ignorePath ? outgoingPath : "";
    outgoing.path = common2.urlJoin(targetPath, outgoingPath);
    if (options2.changeOrigin) {
      outgoing.headers.host = required2(outgoing.port, options2[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
    }
    return outgoing;
  };
  common2.setupSocket = function(socket) {
    socket.setTimeout(0);
    socket.setNoDelay(true);
    socket.setKeepAlive(true, 0);
    return socket;
  };
  common2.getPort = function(req2) {
    var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
    return res ? res[1] : common2.hasEncryptedConnection(req2) ? "443" : "80";
  };
  common2.hasEncryptedConnection = function(req2) {
    return Boolean(req2.connection.encrypted || req2.connection.pair);
  };
  common2.urlJoin = function() {
    var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
    args[lastIndex] = lastSegs.shift();
    retSegs = [
      args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
    ];
    retSegs.push.apply(retSegs, lastSegs);
    return retSegs.join("?");
  };
  common2.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property) {
    if (Array.isArray(header)) {
      return header.map(function(headerElement) {
        return rewriteCookieProperty(headerElement, config2, property);
      });
    }
    return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match, prefix, previousValue) {
      var newValue;
      if (previousValue in config2) {
        newValue = config2[previousValue];
      } else if ("*" in config2) {
        newValue = config2["*"];
      } else {
        return match;
      }
      if (newValue) {
        return prefix + newValue;
      } else {
        return "";
      }
    });
  };
  function hasPort(host) {
    return !!~host.indexOf(":");
  }
})(common$3);
var url$1 = require$$0$5, common$2 = common$3;
var redirectRegex = /^201|30(1|2|7|8)$/;
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
var webOutgoing = {
  // <--
  /**
   * If is a HTTP 1.0 request, remove chunk headers
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  removeChunked: function removeChunked(req2, res, proxyRes) {
    if (req2.httpVersion === "1.0") {
      delete proxyRes.headers["transfer-encoding"];
    }
  },
  /**
   * If is a HTTP 1.0 request, set the correct connection header
   * or if connection header not present, then use `keep-alive`
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  setConnection: function setConnection(req2, res, proxyRes) {
    if (req2.httpVersion === "1.0") {
      proxyRes.headers.connection = req2.headers.connection || "close";
    } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
      proxyRes.headers.connection = req2.headers.connection || "keep-alive";
    }
  },
  setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options2) {
    if ((options2.hostRewrite || options2.autoRewrite || options2.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
      var target = url$1.parse(options2.target);
      var u = url$1.parse(proxyRes.headers["location"]);
      if (target.host != u.host) {
        return;
      }
      if (options2.hostRewrite) {
        u.host = options2.hostRewrite;
      } else if (options2.autoRewrite) {
        u.host = req2.headers["host"];
      }
      if (options2.protocolRewrite) {
        u.protocol = options2.protocolRewrite;
      }
      proxyRes.headers["location"] = u.format();
    }
  },
  /**
   * Copy headers from proxyResponse to response
   * set each header in response object.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain
   *
   * @api private
   */
  writeHeaders: function writeHeaders(req2, res, proxyRes, options2) {
    var rewriteCookieDomainConfig = options2.cookieDomainRewrite, rewriteCookiePathConfig = options2.cookiePathRewrite, preserveHeaderKeyCase = options2.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key2, header) {
      if (header == void 0) return;
      if (rewriteCookieDomainConfig && key2.toLowerCase() === "set-cookie") {
        header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
      }
      if (rewriteCookiePathConfig && key2.toLowerCase() === "set-cookie") {
        header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
      }
      res.setHeader(String(key2).trim(), header);
    };
    if (typeof rewriteCookieDomainConfig === "string") {
      rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
    }
    if (typeof rewriteCookiePathConfig === "string") {
      rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
    }
    if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
      rawHeaderKeyMap = {};
      for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {
        var key = proxyRes.rawHeaders[i];
        rawHeaderKeyMap[key.toLowerCase()] = key;
      }
    }
    Object.keys(proxyRes.headers).forEach(function(key2) {
      var header = proxyRes.headers[key2];
      if (preserveHeaderKeyCase && rawHeaderKeyMap) {
        key2 = rawHeaderKeyMap[key2] || key2;
      }
      setHeader(key2, header);
    });
  },
  /**
   * Set the statusCode from the proxyResponse
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
    if (proxyRes.statusMessage) {
      res.statusCode = proxyRes.statusCode;
      res.statusMessage = proxyRes.statusMessage;
    } else {
      res.statusCode = proxyRes.statusCode;
    }
  }
};
var followRedirects$1 = { exports: {} };
var debug$7;
var debug_1 = function() {
  if (!debug$7) {
    try {
      debug$7 = nodeExports$1("follow-redirects");
    } catch (error2) {
    }
    if (typeof debug$7 !== "function") {
      debug$7 = function() {
      };
    }
  }
  debug$7.apply(null, arguments);
};
var url$2 = require$$0$5;
var URL$1 = url$2.URL;
var http$1 = require$$1$2;
var https$1 = require$$1$3;
var Writable = require$$0$8.Writable;
var assert$1 = require$$4$3;
var debug$6 = debug_1;
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
})();
var useNativeURL = false;
try {
  assert$1(new URL$1(""));
} catch (error2) {
  useNativeURL = error2.code === "ERR_INVALID_URL";
}
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
];
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
var destroy = Writable.prototype.destroy || noop$1;
function RedirectableRequest(options2, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options2);
  this._options = options2;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
    try {
      self2._processResponse(response);
    } catch (cause) {
      self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
    }
  };
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error2) {
  destroyRequest(this._currentRequest, error2);
  destroy.call(this, error2);
  return this;
};
RedirectableRequest.prototype.write = function(data, encoding, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data, encoding });
    this._currentRequest.write(data, encoding, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data, encoding, callback) {
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  } else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self2 = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function() {
      self2._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name, value2) {
  this._options.headers[name] = value2;
  this._currentRequest.setHeader(name, value2);
};
RedirectableRequest.prototype.removeHeader = function(name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self2 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
    }
    self2._timeout = setTimeout(function() {
      self2.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }
  function clearTimer() {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
      self2._timeout = null;
    }
    self2.removeListener("abort", clearTimer);
    self2.removeListener("error", clearTimer);
    self2.removeListener("response", clearTimer);
    self2.removeListener("close", clearTimer);
    if (callback) {
      self2.removeListener("timeout", callback);
    }
    if (!self2.socket) {
      self2._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a, b) {
    return this._currentRequest[method](a, b);
  };
});
["aborted", "connection", "socket"].forEach(function(property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function() {
      return this._currentRequest[property];
    }
  });
});
RedirectableRequest.prototype._sanitizeOptions = function(options2) {
  if (!options2.headers) {
    options2.headers = {};
  }
  if (options2.host) {
    if (!options2.hostname) {
      options2.hostname = options2.host;
    }
    delete options2.host;
  }
  if (!options2.pathname && options2.path) {
    var searchPos = options2.path.indexOf("?");
    if (searchPos < 0) {
      options2.pathname = options2.path;
    } else {
      options2.pathname = options2.path.substring(0, searchPos);
      options2.search = options2.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }
  this._currentUrl = /^\//.test(this._options.path) ? url$2.format(this._options) : (
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path
  );
  if (this._isRedirect) {
    var i = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request === self2._currentRequest) {
        if (error2) {
          self2.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer = buffers[i++];
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        } else if (self2._ended) {
          request.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response) {
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode
    });
  }
  var location2 = response.headers.location;
  if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);
    this._requestBodyBuffers = [];
    return;
  }
  destroyRequest(this._currentRequest);
  response.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource […]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) […]
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = parseUrl$1(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url$2.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl = resolveUrl(location2, currentUrl);
  debug$6("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);
  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function wrap$2(protocols) {
  var exports$1 = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports$1[scheme] = Object.create(nativeProtocol);
    function request(input, options2, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString(input)) {
        input = spreadUrlObject(parseUrl$1(input));
      } else {
        callback = options2;
        options2 = validateUrl(input);
        input = { protocol };
      }
      if (isFunction(options2)) {
        callback = options2;
        options2 = null;
      }
      options2 = Object.assign({
        maxRedirects: exports$1.maxRedirects,
        maxBodyLength: exports$1.maxBodyLength
      }, input, options2);
      options2.nativeProtocols = nativeProtocols;
      if (!isString(options2.host) && !isString(options2.hostname)) {
        options2.hostname = "::1";
      }
      assert$1.equal(options2.protocol, protocol, "protocol mismatch");
      debug$6("options", options2);
      return new RedirectableRequest(options2, callback);
    }
    function get2(input, options2, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options2, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get2, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports$1;
}
function noop$1() {
}
function parseUrl$1(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url$2.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative2, base) {
  return useNativeURL ? new URL$1(relative2, base) : parseUrl$1(url$2.resolve(base, relative2));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
  return spread;
}
function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
  function CustomError(properties) {
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false
    }
  });
  return CustomError;
}
function destroyRequest(request, error2) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop$1);
  request.destroy(error2);
}
function isSubdomain(subdomain, domain) {
  assert$1(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value2) {
  return typeof value2 === "string" || value2 instanceof String;
}
function isFunction(value2) {
  return typeof value2 === "function";
}
function isBuffer(value2) {
  return typeof value2 === "object" && "length" in value2;
}
function isURL(value2) {
  return URL$1 && value2 instanceof URL$1;
}
followRedirects$1.exports = wrap$2({ http: http$1, https: https$1 });
followRedirects$1.exports.wrap = wrap$2;
var followRedirectsExports = followRedirects$1.exports;
var httpNative = require$$1$2, httpsNative = require$$1$3, web_o = webOutgoing, common$1$1 = common$3, followRedirects = followRedirectsExports;
web_o = Object.keys(web_o).map(function(pass) {
  return web_o[pass];
});
var nativeAgents = { http: httpNative, https: httpsNative };
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
var webIncoming = {
  /**
   * Sets `content-length` to '0' if request is of DELETE type.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  deleteLength: function deleteLength(req2, res, options2) {
    if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
      req2.headers["content-length"] = "0";
      delete req2.headers["transfer-encoding"];
    }
  },
  /**
   * Sets timeout in request socket if it was specified in options.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  timeout: function timeout(req2, res, options2) {
    if (options2.timeout) {
      req2.socket.setTimeout(options2.timeout);
    }
  },
  /**
   * Sets `x-forwarded-*` headers if specified in config.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  XHeaders: function XHeaders(req2, res, options2) {
    if (!options2.xfwd) return;
    var encrypted = req2.isSpdy || common$1$1.hasEncryptedConnection(req2);
    var values = {
      for: req2.connection.remoteAddress || req2.socket.remoteAddress,
      port: common$1$1.getPort(req2),
      proto: encrypted ? "https" : "http"
    };
    ["for", "port", "proto"].forEach(function(header) {
      req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
    });
    req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
  },
  /**
   * Does the actual proxying. If `forward` is enabled fires up
   * a ForwardStream, same happens for ProxyStream. The request
   * just dies otherwise.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  stream: function stream(req2, res, options2, _, server, clb) {
    server.emit("start", req2, res, options2.target || options2.forward);
    var agents = options2.followRedirects ? followRedirects : nativeAgents;
    var http2 = agents.http;
    var https2 = agents.https;
    if (options2.forward) {
      var forwardReq = (options2.forward.protocol === "https:" ? https2 : http2).request(
        common$1$1.setupOutgoing(options2.ssl || {}, options2, req2, "forward")
      );
      var forwardError = createErrorHandler(forwardReq, options2.forward);
      req2.on("error", forwardError);
      forwardReq.on("error", forwardError);
      (options2.buffer || req2).pipe(forwardReq);
      if (!options2.target) {
        return res.end();
      }
    }
    var proxyReq = (options2.target.protocol === "https:" ? https2 : http2).request(
      common$1$1.setupOutgoing(options2.ssl || {}, options2, req2)
    );
    proxyReq.on("socket", function(socket) {
      if (server && !proxyReq.getHeader("expect")) {
        server.emit("proxyReq", proxyReq, req2, res, options2);
      }
    });
    if (options2.proxyTimeout) {
      proxyReq.setTimeout(options2.proxyTimeout, function() {
        proxyReq.abort();
      });
    }
    req2.on("aborted", function() {
      proxyReq.abort();
    });
    var proxyError = createErrorHandler(proxyReq, options2.target);
    req2.on("error", proxyError);
    proxyReq.on("error", proxyError);
    function createErrorHandler(proxyReq2, url2) {
      return function proxyError2(err2) {
        if (req2.socket.destroyed && err2.code === "ECONNRESET") {
          server.emit("econnreset", err2, req2, res, url2);
          return proxyReq2.abort();
        }
        if (clb) {
          clb(err2, req2, res, url2);
        } else {
          server.emit("error", err2, req2, res, url2);
        }
      };
    }
    (options2.buffer || req2).pipe(proxyReq);
    proxyReq.on("response", function(proxyRes) {
      if (server) {
        server.emit("proxyRes", proxyRes, req2, res);
      }
      if (!res.headersSent && !options2.selfHandleResponse) {
        for (var i = 0; i < web_o.length; i++) {
          if (web_o[i](req2, res, proxyRes, options2)) {
            break;
          }
        }
      }
      if (!res.finished) {
        proxyRes.on("end", function() {
          if (server) server.emit("end", req2, res, proxyRes);
        });
        if (!options2.selfHandleResponse) proxyRes.pipe(res);
      } else {
        if (server) server.emit("end", req2, res, proxyRes);
      }
    });
  }
};
var http = require$$1$2, https = require$$1$3, common$5 = common$3;
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, socket, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
var wsIncoming = {
  /**
   * WebSocket requests must have the `GET` method and
   * the `upgrade:websocket` header
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   *
   * @api private
   */
  checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
    if (req2.method !== "GET" || !req2.headers.upgrade) {
      socket.destroy();
      return true;
    }
    if (req2.headers.upgrade.toLowerCase() !== "websocket") {
      socket.destroy();
      return true;
    }
  },
  /**
   * Sets `x-forwarded-*` headers if specified in config.
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  XHeaders: function XHeaders2(req2, socket, options2) {
    if (!options2.xfwd) return;
    var values = {
      for: req2.connection.remoteAddress || req2.socket.remoteAddress,
      port: common$5.getPort(req2),
      proto: common$5.hasEncryptedConnection(req2) ? "wss" : "ws"
    };
    ["for", "port", "proto"].forEach(function(header) {
      req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
    });
  },
  /**
   * Does the actual proxying. Make the request and upgrade it
   * send the Switching Protocols request and pipe the sockets.
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  stream: function stream2(req2, socket, options2, head, server, clb) {
    var createHttpHeader = function(line, headers) {
      return Object.keys(headers).reduce(function(head2, key) {
        var value2 = headers[key];
        if (!Array.isArray(value2)) {
          head2.push(key + ": " + value2);
          return head2;
        }
        for (var i = 0; i < value2.length; i++) {
          head2.push(key + ": " + value2[i]);
        }
        return head2;
      }, [line]).join("\r\n") + "\r\n\r\n";
    };
    common$5.setupSocket(socket);
    if (head && head.length) socket.unshift(head);
    var proxyReq = (common$5.isSSL.test(options2.target.protocol) ? https : http).request(
      common$5.setupOutgoing(options2.ssl || {}, options2, req2)
    );
    if (server) {
      server.emit("proxyReqWs", proxyReq, req2, socket, options2, head);
    }
    proxyReq.on("error", onOutgoingError);
    proxyReq.on("response", function(res) {
      if (!res.upgrade) {
        socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
        res.pipe(socket);
      }
    });
    proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
      proxySocket.on("error", onOutgoingError);
      proxySocket.on("end", function() {
        server.emit("close", proxyRes, proxySocket, proxyHead);
      });
      socket.on("error", function() {
        proxySocket.end();
      });
      common$5.setupSocket(proxySocket);
      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);
      socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
      proxySocket.pipe(socket).pipe(proxySocket);
      server.emit("open", proxySocket);
      server.emit("proxySocket", proxySocket);
    });
    return proxyReq.end();
    function onOutgoingError(err2) {
      if (clb) {
        clb(err2, req2, socket);
      } else {
        server.emit("error", err2, req2, socket);
      }
      socket.end();
    }
  }
};
(function(module) {
  var httpProxy2 = module.exports, parse_url = require$$0$5.parse, EE3 = eventemitter3Exports, http2 = require$$1$2, https2 = require$$1$3, web = webIncoming, ws = wsIncoming;
  httpProxy2.Server = ProxyServer2;
  function createRightProxy(type) {
    return function(options2) {
      return function(req2, res) {
        var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
        if (typeof args[cntr] === "function") {
          cbl = args[cntr];
          cntr--;
        }
        var requestOptions = options2;
        if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
          requestOptions = Object.assign({}, options2);
          Object.assign(requestOptions, args[cntr]);
          cntr--;
        }
        if (args[cntr] instanceof Buffer) {
          head = args[cntr];
        }
        ["target", "forward"].forEach(function(e2) {
          if (typeof requestOptions[e2] === "string")
            requestOptions[e2] = parse_url(requestOptions[e2]);
        });
        if (!requestOptions.target && !requestOptions.forward) {
          return this.emit("error", new Error("Must provide a proper URL as target"));
        }
        for (var i = 0; i < passes.length; i++) {
          if (passes[i](req2, res, requestOptions, head, this, cbl)) {
            break;
          }
        }
      };
    };
  }
  httpProxy2.createRightProxy = createRightProxy;
  function ProxyServer2(options2) {
    EE3.call(this);
    options2 = options2 || {};
    options2.prependPath = options2.prependPath === false ? false : true;
    this.web = this.proxyRequest = createRightProxy("web")(options2);
    this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options2);
    this.options = options2;
    this.webPasses = Object.keys(web).map(function(pass) {
      return web[pass];
    });
    this.wsPasses = Object.keys(ws).map(function(pass) {
      return ws[pass];
    });
    this.on("error", this.onError, this);
  }
  require$$1$1.inherits(ProxyServer2, EE3);
  ProxyServer2.prototype.onError = function(err2) {
    if (this.listeners("error").length === 1) {
      throw err2;
    }
  };
  ProxyServer2.prototype.listen = function(port, hostname) {
    var self2 = this, closure = function(req2, res) {
      self2.web(req2, res);
    };
    this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
    if (this.options.ws) {
      this._server.on("upgrade", function(req2, socket, head) {
        self2.ws(req2, socket, head);
      });
    }
    this._server.listen(port, hostname);
    return this;
  };
  ProxyServer2.prototype.close = function(callback) {
    var self2 = this;
    if (this._server) {
      this._server.close(done);
    }
    function done() {
      self2._server = null;
      if (callback) {
        callback.apply(null, arguments);
      }
    }
  };
  ProxyServer2.prototype.before = function(type, passName, callback) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
    passes.forEach(function(v, idx) {
      if (v.name === passName) i = idx;
    });
    if (i === false) throw new Error("No such pass");
    passes.splice(i, 0, callback);
  };
  ProxyServer2.prototype.after = function(type, passName, callback) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
    passes.forEach(function(v, idx) {
      if (v.name === passName) i = idx;
    });
    if (i === false) throw new Error("No such pass");
    passes.splice(i++, 0, callback);
  };
})(httpProxy$3);
var httpProxyExports = httpProxy$3.exports;
var ProxyServer = httpProxyExports.Server;
function createProxyServer(options2) {
  return new ProxyServer(options2);
}
ProxyServer.createProxyServer = createProxyServer;
ProxyServer.createServer = createProxyServer;
ProxyServer.createProxy = createProxyServer;
createDebugger$1("vite:proxy");
createDebugger$1("vite:html-fallback");
require$$0$4.Stats;
createDebugger$1("vite:send", {
  onlyWhenFocused: true
});
createDebugger$1("vite:load");
createDebugger$1("vite:transform");
createDebugger$1("vite:cache");
const moduleScriptRE = /[ \t]*<script[^>]*type\s*=\s*(?:"module"|'module'|module)[^>]*>/i;
const modulePreloadLinkRE = /[ \t]*<link[^>]*rel\s*=\s*(?:"modulepreload"|'modulepreload'|modulepreload)[\s\S]*?\/>/i;
new RegExp(
  [moduleScriptRE, modulePreloadLinkRE].map((r2) => r2.source).join("|"),
  "i"
);
createDebugger$1("vite:cache");
createDebugger$1("vite:time");
createDebugger$1("vite:hmr");
normalizePath$3(CLIENT_DIR);
createDebugger$1("vite:import-analysis");
normalizePath$3(CLIENT_DIR);
normalizePath$3(CLIENT_ENTRY);
normalizePath$3(ENV_ENTRY);
const wasmHelper = async (opts = {}, url2) => {
  let result;
  if (url2.startsWith("data:")) {
    const urlContent = url2.replace(/^data:.*?base64,/, "");
    let bytes;
    if (typeof Buffer === "function" && typeof Buffer.from === "function") {
      bytes = Buffer.from(urlContent, "base64");
    } else if (typeof atob === "function") {
      const binaryString = atob(urlContent);
      bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
    } else {
      throw new Error(
        "Failed to decode base64-encoded data URL, Buffer and atob are not supported"
      );
    }
    result = await WebAssembly.instantiate(bytes, opts);
  } else {
    const response = await fetch(url2);
    const contentType = response.headers.get("Content-Type") || "";
    if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
      result = await WebAssembly.instantiateStreaming(response, opts);
    } else {
      const buffer = await response.arrayBuffer();
      result = await WebAssembly.instantiate(buffer, opts);
    }
  }
  return result.instance;
};
wasmHelper.toString();
process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
createDebugger$1("vite:sourcemap-combine", {
  onlyWhenFocused: true
});
createDebugger$1("vite:resolve");
createDebugger$1("vite:plugin-resolve", {
  onlyWhenFocused: "vite:plugin"
});
createDebugger$1("vite:plugin-transform", {
  onlyWhenFocused: "vite:plugin"
});
createDebugger$1(
  "vite:plugin-container-context"
);
new TextDecoder();
createDebugger$1("vite:deps");
createDebugger$1("vite:config", { depth: 10 });
promisify$4(fs__default.realpath);
[
  {
    find: /^\/?@vite\/env/,
    replacement: path$b.posix.join(FS_PREFIX, normalizePath$3(ENV_ENTRY))
  },
  {
    find: /^\/?@vite\/client/,
    replacement: path$b.posix.join(FS_PREFIX, normalizePath$3(CLIENT_ENTRY))
  }
];
createRequire$2(import.meta.url);

var commonAncestorPath_1;
var hasRequiredCommonAncestorPath;

function requireCommonAncestorPath () {
	if (hasRequiredCommonAncestorPath) return commonAncestorPath_1;
	hasRequiredCommonAncestorPath = 1;
	const {parse, sep, normalize: norm} = require$$0$2$1;

	function* commonArrayMembers (a, b) {
	  const [l, s] = a.length > b.length ? [a, b] : [b, a];
	  for (const x of s) {
	    if (x === l.shift())
	      yield x;
	    else
	      break
	  }
	}

	const commonAncestorPath = (a, b) => a === b ? a
	  : parse(a).root !== parse(b).root ? null
	  : [...commonArrayMembers(norm(a).split(sep), norm(b).split(sep))].join(sep);

	commonAncestorPath_1 = (...paths) => paths.reduce(commonAncestorPath);
	return commonAncestorPath_1;
}

requireCommonAncestorPath();

const defaultExcludeLanguages = ["math"];

var prism = {exports: {}};

var hasRequiredPrism;

function requirePrism () {
	if (hasRequiredPrism) return prism.exports;
	hasRequiredPrism = 1;
	(function (module) {
		/* **********************************************
		     Begin prism-core.js
		********************************************** */

		/// <reference lib="WebWorker"/>

		var _self = (typeof window !== 'undefined')
			? window   // if in browser
			: (
				(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
					? self // if in worker
					: {}   // if in node js
			);

		/**
		 * Prism: Lightweight, robust, elegant syntax highlighting
		 *
		 * @license MIT <https://opensource.org/licenses/MIT>
		 * @author Lea Verou <https://lea.verou.me>
		 * @namespace
		 * @public
		 */
		var Prism = (function (_self) {

			// Private helper vars
			var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
			var uniqueId = 0;

			// The grammar object for plaintext
			var plainTextGrammar = {};


			var _ = {
				/**
				 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
				 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
				 * additional languages or plugins yourself.
				 *
				 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
				 *
				 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
				 * empty Prism object into the global scope before loading the Prism script like this:
				 *
				 * ```js
				 * window.Prism = window.Prism || {};
				 * Prism.manual = true;
				 * // add a new <script> to load Prism's script
				 * ```
				 *
				 * @default false
				 * @type {boolean}
				 * @memberof Prism
				 * @public
				 */
				manual: _self.Prism && _self.Prism.manual,
				/**
				 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
				 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
				 * own worker, you don't want it to do this.
				 *
				 * By setting this value to `true`, Prism will not add its own listeners to the worker.
				 *
				 * You obviously have to change this value before Prism executes. To do this, you can add an
				 * empty Prism object into the global scope before loading the Prism script like this:
				 *
				 * ```js
				 * window.Prism = window.Prism || {};
				 * Prism.disableWorkerMessageHandler = true;
				 * // Load Prism's script
				 * ```
				 *
				 * @default false
				 * @type {boolean}
				 * @memberof Prism
				 * @public
				 */
				disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

				/**
				 * A namespace for utility methods.
				 *
				 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
				 * change or disappear at any time.
				 *
				 * @namespace
				 * @memberof Prism
				 */
				util: {
					encode: function encode(tokens) {
						if (tokens instanceof Token) {
							return new Token(tokens.type, encode(tokens.content), tokens.alias);
						} else if (Array.isArray(tokens)) {
							return tokens.map(encode);
						} else {
							return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
						}
					},

					/**
					 * Returns the name of the type of the given value.
					 *
					 * @param {any} o
					 * @returns {string}
					 * @example
					 * type(null)      === 'Null'
					 * type(undefined) === 'Undefined'
					 * type(123)       === 'Number'
					 * type('foo')     === 'String'
					 * type(true)      === 'Boolean'
					 * type([1, 2])    === 'Array'
					 * type({})        === 'Object'
					 * type(String)    === 'Function'
					 * type(/abc+/)    === 'RegExp'
					 */
					type: function (o) {
						return Object.prototype.toString.call(o).slice(8, -1);
					},

					/**
					 * Returns a unique number for the given object. Later calls will still return the same number.
					 *
					 * @param {Object} obj
					 * @returns {number}
					 */
					objId: function (obj) {
						if (!obj['__id']) {
							Object.defineProperty(obj, '__id', { value: ++uniqueId });
						}
						return obj['__id'];
					},

					/**
					 * Creates a deep clone of the given object.
					 *
					 * The main intended use of this function is to clone language definitions.
					 *
					 * @param {T} o
					 * @param {Record<number, any>} [visited]
					 * @returns {T}
					 * @template T
					 */
					clone: function deepClone(o, visited) {
						visited = visited || {};

						var clone; var id;
						switch (_.util.type(o)) {
							case 'Object':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone = /** @type {Record<string, any>} */ ({});
								visited[id] = clone;

								for (var key in o) {
									if (o.hasOwnProperty(key)) {
										clone[key] = deepClone(o[key], visited);
									}
								}

								return /** @type {any} */ (clone);

							case 'Array':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone = [];
								visited[id] = clone;

								(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
									clone[i] = deepClone(v, visited);
								});

								return /** @type {any} */ (clone);

							default:
								return o;
						}
					},

					/**
					 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
					 *
					 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
					 *
					 * @param {Element} element
					 * @returns {string}
					 */
					getLanguage: function (element) {
						while (element) {
							var m = lang.exec(element.className);
							if (m) {
								return m[1].toLowerCase();
							}
							element = element.parentElement;
						}
						return 'none';
					},

					/**
					 * Sets the Prism `language-xxxx` class of the given element.
					 *
					 * @param {Element} element
					 * @param {string} language
					 * @returns {void}
					 */
					setLanguage: function (element, language) {
						// remove all `language-xxxx` classes
						// (this might leave behind a leading space)
						element.className = element.className.replace(RegExp(lang, 'gi'), '');

						// add the new `language-xxxx` class
						// (using `classList` will automatically clean up spaces for us)
						element.classList.add('language-' + language);
					},

					/**
					 * Returns the script element that is currently executing.
					 *
					 * This does __not__ work for line script element.
					 *
					 * @returns {HTMLScriptElement | null}
					 */
					currentScript: function () {
						if (typeof document === 'undefined') {
							return null;
						}
						if (document.currentScript && document.currentScript.tagName === 'SCRIPT' && 1 < 2 /* hack to trip TS' flow analysis */) {
							return /** @type {any} */ (document.currentScript);
						}

						// IE11 workaround
						// we'll get the src of the current script by parsing IE11's error stack trace
						// this will not work for inline scripts

						try {
							throw new Error();
						} catch (err) {
							// Get file src url from stack. Specifically works with the format of stack traces in IE.
							// A stack will look like this:
							//
							// Error
							//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
							//    at Global code (http://localhost/components/prism-core.js:606:1)

							var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
							if (src) {
								var scripts = document.getElementsByTagName('script');
								for (var i in scripts) {
									if (scripts[i].src == src) {
										return scripts[i];
									}
								}
							}
							return null;
						}
					},

					/**
					 * Returns whether a given class is active for `element`.
					 *
					 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
					 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
					 * given class is just the given class with a `no-` prefix.
					 *
					 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
					 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
					 * ancestors have the given class or the negated version of it, then the default activation will be returned.
					 *
					 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
					 * version of it, the class is considered active.
					 *
					 * @param {Element} element
					 * @param {string} className
					 * @param {boolean} [defaultActivation=false]
					 * @returns {boolean}
					 */
					isActive: function (element, className, defaultActivation) {
						var no = 'no-' + className;

						while (element) {
							var classList = element.classList;
							if (classList.contains(className)) {
								return true;
							}
							if (classList.contains(no)) {
								return false;
							}
							element = element.parentElement;
						}
						return !!defaultActivation;
					}
				},

				/**
				 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
				 *
				 * @namespace
				 * @memberof Prism
				 * @public
				 */
				languages: {
					/**
					 * The grammar for plain, unformatted text.
					 */
					plain: plainTextGrammar,
					plaintext: plainTextGrammar,
					text: plainTextGrammar,
					txt: plainTextGrammar,

					/**
					 * Creates a deep copy of the language with the given id and appends the given tokens.
					 *
					 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
					 * will be overwritten at its original position.
					 *
					 * ## Best practices
					 *
					 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
					 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
					 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
					 *
					 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
					 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
					 *
					 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
					 * @param {Grammar} redef The new tokens to append.
					 * @returns {Grammar} The new language created.
					 * @public
					 * @example
					 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
					 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
					 *     // at its original position
					 *     'comment': { ... },
					 *     // CSS doesn't have a 'color' token, so this token will be appended
					 *     'color': /\b(?:red|green|blue)\b/
					 * });
					 */
					extend: function (id, redef) {
						var lang = _.util.clone(_.languages[id]);

						for (var key in redef) {
							lang[key] = redef[key];
						}

						return lang;
					},

					/**
					 * Inserts tokens _before_ another token in a language definition or any other grammar.
					 *
					 * ## Usage
					 *
					 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
					 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
					 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
					 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
					 * this:
					 *
					 * ```js
					 * Prism.languages.markup.style = {
					 *     // token
					 * };
					 * ```
					 *
					 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
					 * before existing tokens. For the CSS example above, you would use it like this:
					 *
					 * ```js
					 * Prism.languages.insertBefore('markup', 'cdata', {
					 *     'style': {
					 *         // token
					 *     }
					 * });
					 * ```
					 *
					 * ## Special cases
					 *
					 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
					 * will be ignored.
					 *
					 * This behavior can be used to insert tokens after `before`:
					 *
					 * ```js
					 * Prism.languages.insertBefore('markup', 'comment', {
					 *     'comment': Prism.languages.markup.comment,
					 *     // tokens after 'comment'
					 * });
					 * ```
					 *
					 * ## Limitations
					 *
					 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
					 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
					 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
					 * deleting properties which is necessary to insert at arbitrary positions.
					 *
					 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
					 * Instead, it will create a new object and replace all references to the target object with the new one. This
					 * can be done without temporarily deleting properties, so the iteration order is well-defined.
					 *
					 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
					 * you hold the target object in a variable, then the value of the variable will not change.
					 *
					 * ```js
					 * var oldMarkup = Prism.languages.markup;
					 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
					 *
					 * assert(oldMarkup !== Prism.languages.markup);
					 * assert(newMarkup === Prism.languages.markup);
					 * ```
					 *
					 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
					 * object to be modified.
					 * @param {string} before The key to insert before.
					 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
					 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
					 * object to be modified.
					 *
					 * Defaults to `Prism.languages`.
					 * @returns {Grammar} The new grammar object.
					 * @public
					 */
					insertBefore: function (inside, before, insert, root) {
						root = root || /** @type {any} */ (_.languages);
						var grammar = root[inside];
						/** @type {Grammar} */
						var ret = {};

						for (var token in grammar) {
							if (grammar.hasOwnProperty(token)) {

								if (token == before) {
									for (var newToken in insert) {
										if (insert.hasOwnProperty(newToken)) {
											ret[newToken] = insert[newToken];
										}
									}
								}

								// Do not insert token which also occur in insert. See #1525
								if (!insert.hasOwnProperty(token)) {
									ret[token] = grammar[token];
								}
							}
						}

						var old = root[inside];
						root[inside] = ret;

						// Update references in other language definitions
						_.languages.DFS(_.languages, function (key, value) {
							if (value === old && key != inside) {
								this[key] = ret;
							}
						});

						return ret;
					},

					// Traverse a language definition with Depth First Search
					DFS: function DFS(o, callback, type, visited) {
						visited = visited || {};

						var objId = _.util.objId;

						for (var i in o) {
							if (o.hasOwnProperty(i)) {
								callback.call(o, i, o[i], type || i);

								var property = o[i];
								var propertyType = _.util.type(property);

								if (propertyType === 'Object' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, null, visited);
								} else if (propertyType === 'Array' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, i, visited);
								}
							}
						}
					}
				},

				plugins: {},

				/**
				 * This is the most high-level function in Prism’s API.
				 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
				 * each one of them.
				 *
				 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
				 *
				 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
				 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
				 * @memberof Prism
				 * @public
				 */
				highlightAll: function (async, callback) {
					_.highlightAllUnder(document, async, callback);
				},

				/**
				 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
				 * {@link Prism.highlightElement} on each one of them.
				 *
				 * The following hooks will be run:
				 * 1. `before-highlightall`
				 * 2. `before-all-elements-highlight`
				 * 3. All hooks of {@link Prism.highlightElement} for each element.
				 *
				 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
				 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
				 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
				 * @memberof Prism
				 * @public
				 */
				highlightAllUnder: function (container, async, callback) {
					var env = {
						callback: callback,
						container: container,
						selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
					};

					_.hooks.run('before-highlightall', env);

					env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

					_.hooks.run('before-all-elements-highlight', env);

					for (var i = 0, element; (element = env.elements[i++]);) {
						_.highlightElement(element, async === true, env.callback);
					}
				},

				/**
				 * Highlights the code inside a single element.
				 *
				 * The following hooks will be run:
				 * 1. `before-sanity-check`
				 * 2. `before-highlight`
				 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
				 * 4. `before-insert`
				 * 5. `after-highlight`
				 * 6. `complete`
				 *
				 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
				 * the element's language.
				 *
				 * @param {Element} element The element containing the code.
				 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
				 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
				 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
				 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
				 *
				 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
				 * asynchronous highlighting to work. You can build your own bundle on the
				 * [Download page](https://prismjs.com/download.html).
				 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
				 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
				 * @memberof Prism
				 * @public
				 */
				highlightElement: function (element, async, callback) {
					// Find language
					var language = _.util.getLanguage(element);
					var grammar = _.languages[language];

					// Set language on the element, if not present
					_.util.setLanguage(element, language);

					// Set language on the parent, for styling
					var parent = element.parentElement;
					if (parent && parent.nodeName.toLowerCase() === 'pre') {
						_.util.setLanguage(parent, language);
					}

					var code = element.textContent;

					var env = {
						element: element,
						language: language,
						grammar: grammar,
						code: code
					};

					function insertHighlightedCode(highlightedCode) {
						env.highlightedCode = highlightedCode;

						_.hooks.run('before-insert', env);

						env.element.innerHTML = env.highlightedCode;

						_.hooks.run('after-highlight', env);
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
					}

					_.hooks.run('before-sanity-check', env);

					// plugins may change/add the parent/element
					parent = env.element.parentElement;
					if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
						parent.setAttribute('tabindex', '0');
					}

					if (!env.code) {
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
						return;
					}

					_.hooks.run('before-highlight', env);

					if (!env.grammar) {
						insertHighlightedCode(_.util.encode(env.code));
						return;
					}

					if (async && _self.Worker) {
						var worker = new Worker(_.filename);

						worker.onmessage = function (evt) {
							insertHighlightedCode(evt.data);
						};

						worker.postMessage(JSON.stringify({
							language: env.language,
							code: env.code,
							immediateClose: true
						}));
					} else {
						insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
					}
				},

				/**
				 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
				 * and the language definitions to use, and returns a string with the HTML produced.
				 *
				 * The following hooks will be run:
				 * 1. `before-tokenize`
				 * 2. `after-tokenize`
				 * 3. `wrap`: On each {@link Token}.
				 *
				 * @param {string} text A string with the code to be highlighted.
				 * @param {Grammar} grammar An object containing the tokens to use.
				 *
				 * Usually a language definition like `Prism.languages.markup`.
				 * @param {string} language The name of the language definition passed to `grammar`.
				 * @returns {string} The highlighted HTML.
				 * @memberof Prism
				 * @public
				 * @example
				 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
				 */
				highlight: function (text, grammar, language) {
					var env = {
						code: text,
						grammar: grammar,
						language: language
					};
					_.hooks.run('before-tokenize', env);
					if (!env.grammar) {
						throw new Error('The language "' + env.language + '" has no grammar.');
					}
					env.tokens = _.tokenize(env.code, env.grammar);
					_.hooks.run('after-tokenize', env);
					return Token.stringify(_.util.encode(env.tokens), env.language);
				},

				/**
				 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
				 * and the language definitions to use, and returns an array with the tokenized code.
				 *
				 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
				 *
				 * This method could be useful in other contexts as well, as a very crude parser.
				 *
				 * @param {string} text A string with the code to be highlighted.
				 * @param {Grammar} grammar An object containing the tokens to use.
				 *
				 * Usually a language definition like `Prism.languages.markup`.
				 * @returns {TokenStream} An array of strings and tokens, a token stream.
				 * @memberof Prism
				 * @public
				 * @example
				 * let code = `var foo = 0;`;
				 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
				 * tokens.forEach(token => {
				 *     if (token instanceof Prism.Token && token.type === 'number') {
				 *         console.log(`Found numeric literal: ${token.content}`);
				 *     }
				 * });
				 */
				tokenize: function (text, grammar) {
					var rest = grammar.rest;
					if (rest) {
						for (var token in rest) {
							grammar[token] = rest[token];
						}

						delete grammar.rest;
					}

					var tokenList = new LinkedList();
					addAfter(tokenList, tokenList.head, text);

					matchGrammar(text, tokenList, grammar, tokenList.head, 0);

					return toArray(tokenList);
				},

				/**
				 * @namespace
				 * @memberof Prism
				 * @public
				 */
				hooks: {
					all: {},

					/**
					 * Adds the given callback to the list of callbacks for the given hook.
					 *
					 * The callback will be invoked when the hook it is registered for is run.
					 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
					 *
					 * One callback function can be registered to multiple hooks and the same hook multiple times.
					 *
					 * @param {string} name The name of the hook.
					 * @param {HookCallback} callback The callback function which is given environment variables.
					 * @public
					 */
					add: function (name, callback) {
						var hooks = _.hooks.all;

						hooks[name] = hooks[name] || [];

						hooks[name].push(callback);
					},

					/**
					 * Runs a hook invoking all registered callbacks with the given environment variables.
					 *
					 * Callbacks will be invoked synchronously and in the order in which they were registered.
					 *
					 * @param {string} name The name of the hook.
					 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
					 * @public
					 */
					run: function (name, env) {
						var callbacks = _.hooks.all[name];

						if (!callbacks || !callbacks.length) {
							return;
						}

						for (var i = 0, callback; (callback = callbacks[i++]);) {
							callback(env);
						}
					}
				},

				Token: Token
			};
			_self.Prism = _;


			// Typescript note:
			// The following can be used to import the Token type in JSDoc:
			//
			//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

			/**
			 * Creates a new token.
			 *
			 * @param {string} type See {@link Token#type type}
			 * @param {string | TokenStream} content See {@link Token#content content}
			 * @param {string|string[]} [alias] The alias(es) of the token.
			 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
			 * @class
			 * @global
			 * @public
			 */
			function Token(type, content, alias, matchedStr) {
				/**
				 * The type of the token.
				 *
				 * This is usually the key of a pattern in a {@link Grammar}.
				 *
				 * @type {string}
				 * @see GrammarToken
				 * @public
				 */
				this.type = type;
				/**
				 * The strings or tokens contained by this token.
				 *
				 * This will be a token stream if the pattern matched also defined an `inside` grammar.
				 *
				 * @type {string | TokenStream}
				 * @public
				 */
				this.content = content;
				/**
				 * The alias(es) of the token.
				 *
				 * @type {string|string[]}
				 * @see GrammarToken
				 * @public
				 */
				this.alias = alias;
				// Copy of the full string this token was created from
				this.length = (matchedStr || '').length | 0;
			}

			/**
			 * A token stream is an array of strings and {@link Token Token} objects.
			 *
			 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
			 * them.
			 *
			 * 1. No adjacent strings.
			 * 2. No empty strings.
			 *
			 *    The only exception here is the token stream that only contains the empty string and nothing else.
			 *
			 * @typedef {Array<string | Token>} TokenStream
			 * @global
			 * @public
			 */

			/**
			 * Converts the given token or token stream to an HTML representation.
			 *
			 * The following hooks will be run:
			 * 1. `wrap`: On each {@link Token}.
			 *
			 * @param {string | Token | TokenStream} o The token or token stream to be converted.
			 * @param {string} language The name of current language.
			 * @returns {string} The HTML representation of the token or token stream.
			 * @memberof Token
			 * @static
			 */
			Token.stringify = function stringify(o, language) {
				if (typeof o == 'string') {
					return o;
				}
				if (Array.isArray(o)) {
					var s = '';
					o.forEach(function (e) {
						s += stringify(e, language);
					});
					return s;
				}

				var env = {
					type: o.type,
					content: stringify(o.content, language),
					tag: 'span',
					classes: ['token', o.type],
					attributes: {},
					language: language
				};

				var aliases = o.alias;
				if (aliases) {
					if (Array.isArray(aliases)) {
						Array.prototype.push.apply(env.classes, aliases);
					} else {
						env.classes.push(aliases);
					}
				}

				_.hooks.run('wrap', env);

				var attributes = '';
				for (var name in env.attributes) {
					attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
				}

				return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
			};

			/**
			 * @param {RegExp} pattern
			 * @param {number} pos
			 * @param {string} text
			 * @param {boolean} lookbehind
			 * @returns {RegExpExecArray | null}
			 */
			function matchPattern(pattern, pos, text, lookbehind) {
				pattern.lastIndex = pos;
				var match = pattern.exec(text);
				if (match && lookbehind && match[1]) {
					// change the match to remove the text matched by the Prism lookbehind group
					var lookbehindLength = match[1].length;
					match.index += lookbehindLength;
					match[0] = match[0].slice(lookbehindLength);
				}
				return match;
			}

			/**
			 * @param {string} text
			 * @param {LinkedList<string | Token>} tokenList
			 * @param {any} grammar
			 * @param {LinkedListNode<string | Token>} startNode
			 * @param {number} startPos
			 * @param {RematchOptions} [rematch]
			 * @returns {void}
			 * @private
			 *
			 * @typedef RematchOptions
			 * @property {string} cause
			 * @property {number} reach
			 */
			function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
				for (var token in grammar) {
					if (!grammar.hasOwnProperty(token) || !grammar[token]) {
						continue;
					}

					var patterns = grammar[token];
					patterns = Array.isArray(patterns) ? patterns : [patterns];

					for (var j = 0; j < patterns.length; ++j) {
						if (rematch && rematch.cause == token + ',' + j) {
							return;
						}

						var patternObj = patterns[j];
						var inside = patternObj.inside;
						var lookbehind = !!patternObj.lookbehind;
						var greedy = !!patternObj.greedy;
						var alias = patternObj.alias;

						if (greedy && !patternObj.pattern.global) {
							// Without the global flag, lastIndex won't work
							var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
							patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
						}

						/** @type {RegExp} */
						var pattern = patternObj.pattern || patternObj;

						for ( // iterate the token list and keep track of the current token/string position
							var currentNode = startNode.next, pos = startPos;
							currentNode !== tokenList.tail;
							pos += currentNode.value.length, currentNode = currentNode.next
						) {

							if (rematch && pos >= rematch.reach) {
								break;
							}

							var str = currentNode.value;

							if (tokenList.length > text.length) {
								// Something went terribly wrong, ABORT, ABORT!
								return;
							}

							if (str instanceof Token) {
								continue;
							}

							var removeCount = 1; // this is the to parameter of removeBetween
							var match;

							if (greedy) {
								match = matchPattern(pattern, pos, text, lookbehind);
								if (!match || match.index >= text.length) {
									break;
								}

								var from = match.index;
								var to = match.index + match[0].length;
								var p = pos;

								// find the node that contains the match
								p += currentNode.value.length;
								while (from >= p) {
									currentNode = currentNode.next;
									p += currentNode.value.length;
								}
								// adjust pos (and p)
								p -= currentNode.value.length;
								pos = p;

								// the current node is a Token, then the match starts inside another Token, which is invalid
								if (currentNode.value instanceof Token) {
									continue;
								}

								// find the last node which is affected by this match
								for (
									var k = currentNode;
									k !== tokenList.tail && (p < to || typeof k.value === 'string');
									k = k.next
								) {
									removeCount++;
									p += k.value.length;
								}
								removeCount--;

								// replace with the new match
								str = text.slice(pos, p);
								match.index -= pos;
							} else {
								match = matchPattern(pattern, 0, str, lookbehind);
								if (!match) {
									continue;
								}
							}

							// eslint-disable-next-line no-redeclare
							var from = match.index;
							var matchStr = match[0];
							var before = str.slice(0, from);
							var after = str.slice(from + matchStr.length);

							var reach = pos + str.length;
							if (rematch && reach > rematch.reach) {
								rematch.reach = reach;
							}

							var removeFrom = currentNode.prev;

							if (before) {
								removeFrom = addAfter(tokenList, removeFrom, before);
								pos += before.length;
							}

							removeRange(tokenList, removeFrom, removeCount);

							var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
							currentNode = addAfter(tokenList, removeFrom, wrapped);

							if (after) {
								addAfter(tokenList, currentNode, after);
							}

							if (removeCount > 1) {
								// at least one Token object was removed, so we have to do some rematching
								// this can only happen if the current pattern is greedy

								/** @type {RematchOptions} */
								var nestedRematch = {
									cause: token + ',' + j,
									reach: reach
								};
								matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

								// the reach might have been extended because of the rematching
								if (rematch && nestedRematch.reach > rematch.reach) {
									rematch.reach = nestedRematch.reach;
								}
							}
						}
					}
				}
			}

			/**
			 * @typedef LinkedListNode
			 * @property {T} value
			 * @property {LinkedListNode<T> | null} prev The previous node.
			 * @property {LinkedListNode<T> | null} next The next node.
			 * @template T
			 * @private
			 */

			/**
			 * @template T
			 * @private
			 */
			function LinkedList() {
				/** @type {LinkedListNode<T>} */
				var head = { value: null, prev: null, next: null };
				/** @type {LinkedListNode<T>} */
				var tail = { value: null, prev: head, next: null };
				head.next = tail;

				/** @type {LinkedListNode<T>} */
				this.head = head;
				/** @type {LinkedListNode<T>} */
				this.tail = tail;
				this.length = 0;
			}

			/**
			 * Adds a new node with the given value to the list.
			 *
			 * @param {LinkedList<T>} list
			 * @param {LinkedListNode<T>} node
			 * @param {T} value
			 * @returns {LinkedListNode<T>} The added node.
			 * @template T
			 */
			function addAfter(list, node, value) {
				// assumes that node != list.tail && values.length >= 0
				var next = node.next;

				var newNode = { value: value, prev: node, next: next };
				node.next = newNode;
				next.prev = newNode;
				list.length++;

				return newNode;
			}
			/**
			 * Removes `count` nodes after the given node. The given node will not be removed.
			 *
			 * @param {LinkedList<T>} list
			 * @param {LinkedListNode<T>} node
			 * @param {number} count
			 * @template T
			 */
			function removeRange(list, node, count) {
				var next = node.next;
				for (var i = 0; i < count && next !== list.tail; i++) {
					next = next.next;
				}
				node.next = next;
				next.prev = node;
				list.length -= i;
			}
			/**
			 * @param {LinkedList<T>} list
			 * @returns {T[]}
			 * @template T
			 */
			function toArray(list) {
				var array = [];
				var node = list.head.next;
				while (node !== list.tail) {
					array.push(node.value);
					node = node.next;
				}
				return array;
			}


			if (!_self.document) {
				if (!_self.addEventListener) {
					// in Node.js
					return _;
				}

				if (!_.disableWorkerMessageHandler) {
					// In worker
					_self.addEventListener('message', function (evt) {
						var message = JSON.parse(evt.data);
						var lang = message.language;
						var code = message.code;
						var immediateClose = message.immediateClose;

						_self.postMessage(_.highlight(code, _.languages[lang], lang));
						if (immediateClose) {
							_self.close();
						}
					}, false);
				}

				return _;
			}

			// Get current script and highlight
			var script = _.util.currentScript();

			if (script) {
				_.filename = script.src;

				if (script.hasAttribute('data-manual')) {
					_.manual = true;
				}
			}

			function highlightAutomaticallyCallback() {
				if (!_.manual) {
					_.highlightAll();
				}
			}

			if (!_.manual) {
				// If the document state is "loading", then we'll use DOMContentLoaded.
				// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
				// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
				// might take longer one animation frame to execute which can create a race condition where only some plugins have
				// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
				// See https://github.com/PrismJS/prism/issues/2102
				var readyState = document.readyState;
				if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
					document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
				} else {
					if (window.requestAnimationFrame) {
						window.requestAnimationFrame(highlightAutomaticallyCallback);
					} else {
						window.setTimeout(highlightAutomaticallyCallback, 16);
					}
				}
			}

			return _;

		}(_self));

		if (module.exports) {
			module.exports = Prism;
		}

		// hack for components to work correctly in node.js
		if (typeof commonjsGlobal$1 !== 'undefined') {
			commonjsGlobal$1.Prism = Prism;
		}

		// some additional documentation/types

		/**
		 * The expansion of a simple `RegExp` literal to support additional properties.
		 *
		 * @typedef GrammarToken
		 * @property {RegExp} pattern The regular expression of the token.
		 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
		 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
		 * @property {boolean} [greedy=false] Whether the token is greedy.
		 * @property {string|string[]} [alias] An optional alias or list of aliases.
		 * @property {Grammar} [inside] The nested grammar of this token.
		 *
		 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
		 *
		 * This can be used to make nested and even recursive language definitions.
		 *
		 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
		 * each another.
		 * @global
		 * @public
		 */

		/**
		 * @typedef Grammar
		 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
		 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
		 * @global
		 * @public
		 */

		/**
		 * A function which will invoked after an element was successfully highlighted.
		 *
		 * @callback HighlightCallback
		 * @param {Element} element The element successfully highlighted.
		 * @returns {void}
		 * @global
		 * @public
		 */

		/**
		 * @callback HookCallback
		 * @param {Object<string, any>} env The environment variables of the hook.
		 * @returns {void}
		 * @global
		 * @public
		 */


		/* **********************************************
		     Begin prism-markup.js
		********************************************** */

		Prism.languages.markup = {
			'comment': {
				pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
				greedy: true
			},
			'prolog': {
				pattern: /<\?[\s\S]+?\?>/,
				greedy: true
			},
			'doctype': {
				// https://www.w3.org/TR/xml/#NT-doctypedecl
				pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
				greedy: true,
				inside: {
					'internal-subset': {
						pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
						lookbehind: true,
						greedy: true,
						inside: null // see below
					},
					'string': {
						pattern: /"[^"]*"|'[^']*'/,
						greedy: true
					},
					'punctuation': /^<!|>$|[[\]]/,
					'doctype-tag': /^DOCTYPE/i,
					'name': /[^\s<>'"]+/
				}
			},
			'cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				greedy: true
			},
			'tag': {
				pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
				greedy: true,
				inside: {
					'tag': {
						pattern: /^<\/?[^\s>\/]+/,
						inside: {
							'punctuation': /^<\/?/,
							'namespace': /^[^\s>\/:]+:/
						}
					},
					'special-attr': [],
					'attr-value': {
						pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
						inside: {
							'punctuation': [
								{
									pattern: /^=/,
									alias: 'attr-equals'
								},
								{
									pattern: /^(\s*)["']|["']$/,
									lookbehind: true
								}
							]
						}
					},
					'punctuation': /\/?>/,
					'attr-name': {
						pattern: /[^\s>\/]+/,
						inside: {
							'namespace': /^[^\s>\/:]+:/
						}
					}

				}
			},
			'entity': [
				{
					pattern: /&[\da-z]{1,8};/i,
					alias: 'named-entity'
				},
				/&#x?[\da-f]{1,8};/i
			]
		};

		Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
			Prism.languages.markup['entity'];
		Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

		// Plugin to make entity title show the real entity, idea by Roman Komarov
		Prism.hooks.add('wrap', function (env) {

			if (env.type === 'entity') {
				env.attributes['title'] = env.content.replace(/&amp;/, '&');
			}
		});

		Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
			/**
			 * Adds an inlined language to markup.
			 *
			 * An example of an inlined language is CSS with `<style>` tags.
			 *
			 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
			 * case insensitive.
			 * @param {string} lang The language key.
			 * @example
			 * addInlined('style', 'css');
			 */
			value: function addInlined(tagName, lang) {
				var includedCdataInside = {};
				includedCdataInside['language-' + lang] = {
					pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
					lookbehind: true,
					inside: Prism.languages[lang]
				};
				includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

				var inside = {
					'included-cdata': {
						pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
						inside: includedCdataInside
					}
				};
				inside['language-' + lang] = {
					pattern: /[\s\S]+/,
					inside: Prism.languages[lang]
				};

				var def = {};
				def[tagName] = {
					pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
					lookbehind: true,
					greedy: true,
					inside: inside
				};

				Prism.languages.insertBefore('markup', 'cdata', def);
			}
		});
		Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
			/**
			 * Adds an pattern to highlight languages embedded in HTML attributes.
			 *
			 * An example of an inlined language is CSS with `style` attributes.
			 *
			 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
			 * case insensitive.
			 * @param {string} lang The language key.
			 * @example
			 * addAttribute('style', 'css');
			 */
			value: function (attrName, lang) {
				Prism.languages.markup.tag.inside['special-attr'].push({
					pattern: RegExp(
						/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
						'i'
					),
					lookbehind: true,
					inside: {
						'attr-name': /^[^\s=]+/,
						'attr-value': {
							pattern: /=[\s\S]+/,
							inside: {
								'value': {
									pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
									lookbehind: true,
									alias: [lang, 'language-' + lang],
									inside: Prism.languages[lang]
								},
								'punctuation': [
									{
										pattern: /^=/,
										alias: 'attr-equals'
									},
									/"|'/
								]
							}
						}
					}
				});
			}
		});

		Prism.languages.html = Prism.languages.markup;
		Prism.languages.mathml = Prism.languages.markup;
		Prism.languages.svg = Prism.languages.markup;

		Prism.languages.xml = Prism.languages.extend('markup', {});
		Prism.languages.ssml = Prism.languages.xml;
		Prism.languages.atom = Prism.languages.xml;
		Prism.languages.rss = Prism.languages.xml;


		/* **********************************************
		     Begin prism-css.js
		********************************************** */

		(function (Prism) {

			var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

			Prism.languages.css = {
				'comment': /\/\*[\s\S]*?\*\//,
				'atrule': {
					pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
					inside: {
						'rule': /^@[\w-]+/,
						'selector-function-argument': {
							pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
							lookbehind: true,
							alias: 'selector'
						},
						'keyword': {
							pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
							lookbehind: true
						}
						// See rest below
					}
				},
				'url': {
					// https://drafts.csswg.org/css-values-3/#urls
					pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
					greedy: true,
					inside: {
						'function': /^url/i,
						'punctuation': /^\(|\)$/,
						'string': {
							pattern: RegExp('^' + string.source + '$'),
							alias: 'url'
						}
					}
				},
				'selector': {
					pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
					lookbehind: true
				},
				'string': {
					pattern: string,
					greedy: true
				},
				'property': {
					pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
					lookbehind: true
				},
				'important': /!important\b/i,
				'function': {
					pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
					lookbehind: true
				},
				'punctuation': /[(){};:,]/
			};

			Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

			var markup = Prism.languages.markup;
			if (markup) {
				markup.tag.addInlined('style', 'css');
				markup.tag.addAttribute('style', 'css');
			}

		}(Prism));


		/* **********************************************
		     Begin prism-clike.js
		********************************************** */

		Prism.languages.clike = {
			'comment': [
				{
					pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
					lookbehind: true,
					greedy: true
				},
				{
					pattern: /(^|[^\\:])\/\/.*/,
					lookbehind: true,
					greedy: true
				}
			],
			'string': {
				pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
				greedy: true
			},
			'class-name': {
				pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
				lookbehind: true,
				inside: {
					'punctuation': /[.\\]/
				}
			},
			'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
			'boolean': /\b(?:false|true)\b/,
			'function': /\b\w+(?=\()/,
			'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
			'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
			'punctuation': /[{}[\];(),.:]/
		};


		/* **********************************************
		     Begin prism-javascript.js
		********************************************** */

		Prism.languages.javascript = Prism.languages.extend('clike', {
			'class-name': [
				Prism.languages.clike['class-name'],
				{
					pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
					lookbehind: true
				}
			],
			'keyword': [
				{
					pattern: /((?:^|\})\s*)catch\b/,
					lookbehind: true
				},
				{
					pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
					lookbehind: true
				},
			],
			// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
			'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
			'number': {
				pattern: RegExp(
					/(^|[^\w$])/.source +
					'(?:' +
					(
						// constant
						/NaN|Infinity/.source +
						'|' +
						// binary integer
						/0[bB][01]+(?:_[01]+)*n?/.source +
						'|' +
						// octal integer
						/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
						'|' +
						// hexadecimal integer
						/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
						'|' +
						// decimal bigint
						/\d+(?:_\d+)*n/.source +
						'|' +
						// decimal number (integer or float) but no bigint
						/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
					) +
					')' +
					/(?![\w$])/.source
				),
				lookbehind: true
			},
			'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
		});

		Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

		Prism.languages.insertBefore('javascript', 'keyword', {
			'regex': {
				pattern: RegExp(
					// lookbehind
					// eslint-disable-next-line regexp/no-dupe-characters-character-class
					/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
					// Regex pattern:
					// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
					// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
					// with the only syntax, so we have to define 2 different regex patterns.
					/\//.source +
					'(?:' +
					/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
					'|' +
					// `v` flag syntax. This supports 3 levels of nested character classes.
					/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
					')' +
					// lookahead
					/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
				),
				lookbehind: true,
				greedy: true,
				inside: {
					'regex-source': {
						pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
						lookbehind: true,
						alias: 'language-regex',
						inside: Prism.languages.regex
					},
					'regex-delimiter': /^\/|\/$/,
					'regex-flags': /^[a-z]+$/,
				}
			},
			// This must be declared before keyword because we use "function" inside the look-forward
			'function-variable': {
				pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
				alias: 'function'
			},
			'parameter': [
				{
					pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
					lookbehind: true,
					inside: Prism.languages.javascript
				},
				{
					pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
					lookbehind: true,
					inside: Prism.languages.javascript
				},
				{
					pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
					lookbehind: true,
					inside: Prism.languages.javascript
				},
				{
					pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
					lookbehind: true,
					inside: Prism.languages.javascript
				}
			],
			'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
		});

		Prism.languages.insertBefore('javascript', 'string', {
			'hashbang': {
				pattern: /^#!.*/,
				greedy: true,
				alias: 'comment'
			},
			'template-string': {
				pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
				greedy: true,
				inside: {
					'template-punctuation': {
						pattern: /^`|`$/,
						alias: 'string'
					},
					'interpolation': {
						pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
						lookbehind: true,
						inside: {
							'interpolation-punctuation': {
								pattern: /^\$\{|\}$/,
								alias: 'punctuation'
							},
							rest: Prism.languages.javascript
						}
					},
					'string': /[\s\S]+/
				}
			},
			'string-property': {
				pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
				lookbehind: true,
				greedy: true,
				alias: 'property'
			}
		});

		Prism.languages.insertBefore('javascript', 'operator', {
			'literal-property': {
				pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
				lookbehind: true,
				alias: 'property'
			},
		});

		if (Prism.languages.markup) {
			Prism.languages.markup.tag.addInlined('script', 'javascript');

			// add attribute support for all DOM events.
			// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
			Prism.languages.markup.tag.addAttribute(
				/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
				'javascript'
			);
		}

		Prism.languages.js = Prism.languages.javascript;


		/* **********************************************
		     Begin prism-file-highlight.js
		********************************************** */

		(function () {

			if (typeof Prism === 'undefined' || typeof document === 'undefined') {
				return;
			}

			// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
			if (!Element.prototype.matches) {
				Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
			}

			var LOADING_MESSAGE = 'Loading…';
			var FAILURE_MESSAGE = function (status, message) {
				return '✖ Error ' + status + ' while fetching file: ' + message;
			};
			var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

			var EXTENSIONS = {
				'js': 'javascript',
				'py': 'python',
				'rb': 'ruby',
				'ps1': 'powershell',
				'psm1': 'powershell',
				'sh': 'bash',
				'bat': 'batch',
				'h': 'c',
				'tex': 'latex'
			};

			var STATUS_ATTR = 'data-src-status';
			var STATUS_LOADING = 'loading';
			var STATUS_LOADED = 'loaded';
			var STATUS_FAILED = 'failed';

			var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
				+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

			/**
			 * Loads the given file.
			 *
			 * @param {string} src The URL or path of the source file to load.
			 * @param {(result: string) => void} success
			 * @param {(reason: string) => void} error
			 */
			function loadFile(src, success, error) {
				var xhr = new XMLHttpRequest();
				xhr.open('GET', src, true);
				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {
						if (xhr.status < 400 && xhr.responseText) {
							success(xhr.responseText);
						} else {
							if (xhr.status >= 400) {
								error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
							} else {
								error(FAILURE_EMPTY_MESSAGE);
							}
						}
					}
				};
				xhr.send(null);
			}

			/**
			 * Parses the given range.
			 *
			 * This returns a range with inclusive ends.
			 *
			 * @param {string | null | undefined} range
			 * @returns {[number, number | undefined] | undefined}
			 */
			function parseRange(range) {
				var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
				if (m) {
					var start = Number(m[1]);
					var comma = m[2];
					var end = m[3];

					if (!comma) {
						return [start, start];
					}
					if (!end) {
						return [start, undefined];
					}
					return [start, Number(end)];
				}
				return undefined;
			}

			Prism.hooks.add('before-highlightall', function (env) {
				env.selector += ', ' + SELECTOR;
			});

			Prism.hooks.add('before-sanity-check', function (env) {
				var pre = /** @type {HTMLPreElement} */ (env.element);
				if (pre.matches(SELECTOR)) {
					env.code = ''; // fast-path the whole thing and go to complete

					pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

					// add code element with loading message
					var code = pre.appendChild(document.createElement('CODE'));
					code.textContent = LOADING_MESSAGE;

					var src = pre.getAttribute('data-src');

					var language = env.language;
					if (language === 'none') {
						// the language might be 'none' because there is no language set;
						// in this case, we want to use the extension as the language
						var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
						language = EXTENSIONS[extension] || extension;
					}

					// set language classes
					Prism.util.setLanguage(code, language);
					Prism.util.setLanguage(pre, language);

					// preload the language
					var autoloader = Prism.plugins.autoloader;
					if (autoloader) {
						autoloader.loadLanguages(language);
					}

					// load file
					loadFile(
						src,
						function (text) {
							// mark as loaded
							pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

							// handle data-range
							var range = parseRange(pre.getAttribute('data-range'));
							if (range) {
								var lines = text.split(/\r\n?|\n/g);

								// the range is one-based and inclusive on both ends
								var start = range[0];
								var end = range[1] == null ? lines.length : range[1];

								if (start < 0) { start += lines.length; }
								start = Math.max(0, Math.min(start - 1, lines.length));
								if (end < 0) { end += lines.length; }
								end = Math.max(0, Math.min(end, lines.length));

								text = lines.slice(start, end).join('\n');

								// add data-start for line numbers
								if (!pre.hasAttribute('data-start')) {
									pre.setAttribute('data-start', String(start + 1));
								}
							}

							// highlight code
							code.textContent = text;
							Prism.highlightElement(code);
						},
						function (error) {
							// mark as failed
							pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

							code.textContent = error;
						}
					);
				}
			});

			Prism.plugins.fileHighlight = {
				/**
				 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
				 *
				 * Note: Elements which are already loaded or currently loading will not be touched by this method.
				 *
				 * @param {ParentNode} [container=document]
				 */
				highlight: function highlight(container) {
					var elements = (container || document).querySelectorAll(SELECTOR);

					for (var i = 0, element; (element = elements[i++]);) {
						Prism.highlightElement(element);
					}
				}
			};

			var logged = false;
			/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
			Prism.fileHighlight = function () {
				if (!logged) {
					console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
					logged = true;
				}
				Prism.plugins.fileHighlight.highlight.apply(this, arguments);
			};

		}()); 
	} (prism));
	return prism.exports;
}

requirePrism();

var components = {exports: {}};

var hasRequiredComponents$1;

function requireComponents$1 () {
	if (hasRequiredComponents$1) return components.exports;
	hasRequiredComponents$1 = 1;
	(function (module) {
		var components = {"core":{"meta":{"path":"components/prism-core.js","option":"mandatory"},"core":"Core"},"themes":{"meta":{"path":"themes/{id}.css","link":"index.html?theme={id}","exclusive":true},"prism":{"title":"Default","option":"default"},"prism-dark":"Dark","prism-funky":"Funky","prism-okaidia":{"title":"Okaidia","owner":"ocodia"},"prism-twilight":{"title":"Twilight","owner":"remybach"},"prism-coy":{"title":"Coy","owner":"tshedor"},"prism-solarizedlight":{"title":"Solarized Light","owner":"hectormatos2011 "},"prism-tomorrow":{"title":"Tomorrow Night","owner":"Rosey"}},"languages":{"meta":{"path":"components/prism-{id}","noCSS":true,"examplesPath":"examples/prism-{id}","addCheckAll":true},"markup":{"title":"Markup","alias":["html","xml","svg","mathml","ssml","atom","rss"],"aliasTitles":{"html":"HTML","xml":"XML","svg":"SVG","mathml":"MathML","ssml":"SSML","atom":"Atom","rss":"RSS"},"option":"default"},"css":{"title":"CSS","option":"default","modify":"markup"},"clike":{"title":"C-like","option":"default"},"javascript":{"title":"JavaScript","require":"clike","modify":"markup","optional":"regex","alias":"js","option":"default"},"abap":{"title":"ABAP","owner":"dellagustin"},"abnf":{"title":"ABNF","owner":"RunDevelopment"},"actionscript":{"title":"ActionScript","require":"javascript","modify":"markup","owner":"Golmote"},"ada":{"title":"Ada","owner":"Lucretia"},"agda":{"title":"Agda","owner":"xy-ren"},"al":{"title":"AL","owner":"RunDevelopment"},"antlr4":{"title":"ANTLR4","alias":"g4","owner":"RunDevelopment"},"apacheconf":{"title":"Apache Configuration","owner":"GuiTeK"},"apex":{"title":"Apex","require":["clike","sql"],"owner":"RunDevelopment"},"apl":{"title":"APL","owner":"ngn"},"applescript":{"title":"AppleScript","owner":"Golmote"},"aql":{"title":"AQL","owner":"RunDevelopment"},"arduino":{"title":"Arduino","require":"cpp","alias":"ino","owner":"dkern"},"arff":{"title":"ARFF","owner":"Golmote"},"armasm":{"title":"ARM Assembly","alias":"arm-asm","owner":"RunDevelopment"},"arturo":{"title":"Arturo","alias":"art","optional":["bash","css","javascript","markup","markdown","sql"],"owner":"drkameleon"},"asciidoc":{"alias":"adoc","title":"AsciiDoc","owner":"Golmote"},"aspnet":{"title":"ASP.NET (C#)","require":["markup","csharp"],"owner":"nauzilus"},"asm6502":{"title":"6502 Assembly","owner":"kzurawel"},"asmatmel":{"title":"Atmel AVR Assembly","owner":"cerkit"},"autohotkey":{"title":"AutoHotkey","owner":"aviaryan"},"autoit":{"title":"AutoIt","owner":"Golmote"},"avisynth":{"title":"AviSynth","alias":"avs","owner":"Zinfidel"},"avro-idl":{"title":"Avro IDL","alias":"avdl","owner":"RunDevelopment"},"awk":{"title":"AWK","alias":"gawk","aliasTitles":{"gawk":"GAWK"},"owner":"RunDevelopment"},"bash":{"title":"Bash","alias":["sh","shell"],"aliasTitles":{"sh":"Shell","shell":"Shell"},"owner":"zeitgeist87"},"basic":{"title":"BASIC","owner":"Golmote"},"batch":{"title":"Batch","owner":"Golmote"},"bbcode":{"title":"BBcode","alias":"shortcode","aliasTitles":{"shortcode":"Shortcode"},"owner":"RunDevelopment"},"bbj":{"title":"BBj","owner":"hyyan"},"bicep":{"title":"Bicep","owner":"johnnyreilly"},"birb":{"title":"Birb","require":"clike","owner":"Calamity210"},"bison":{"title":"Bison","require":"c","owner":"Golmote"},"bnf":{"title":"BNF","alias":"rbnf","aliasTitles":{"rbnf":"RBNF"},"owner":"RunDevelopment"},"bqn":{"title":"BQN","owner":"yewscion"},"brainfuck":{"title":"Brainfuck","owner":"Golmote"},"brightscript":{"title":"BrightScript","owner":"RunDevelopment"},"bro":{"title":"Bro","owner":"wayward710"},"bsl":{"title":"BSL (1C:Enterprise)","alias":"oscript","aliasTitles":{"oscript":"OneScript"},"owner":"Diversus23"},"c":{"title":"C","require":"clike","owner":"zeitgeist87"},"csharp":{"title":"C#","require":"clike","alias":["cs","dotnet"],"owner":"mvalipour"},"cpp":{"title":"C++","require":"c","owner":"zeitgeist87"},"cfscript":{"title":"CFScript","require":"clike","alias":"cfc","owner":"mjclemente"},"chaiscript":{"title":"ChaiScript","require":["clike","cpp"],"owner":"RunDevelopment"},"cil":{"title":"CIL","owner":"sbrl"},"cilkc":{"title":"Cilk/C","require":"c","alias":"cilk-c","owner":"OpenCilk"},"cilkcpp":{"title":"Cilk/C++","require":"cpp","alias":["cilk-cpp","cilk"],"owner":"OpenCilk"},"clojure":{"title":"Clojure","owner":"troglotit"},"cmake":{"title":"CMake","owner":"mjrogozinski"},"cobol":{"title":"COBOL","owner":"RunDevelopment"},"coffeescript":{"title":"CoffeeScript","require":"javascript","alias":"coffee","owner":"R-osey"},"concurnas":{"title":"Concurnas","alias":"conc","owner":"jasontatton"},"csp":{"title":"Content-Security-Policy","owner":"ScottHelme"},"cooklang":{"title":"Cooklang","owner":"ahue"},"coq":{"title":"Coq","owner":"RunDevelopment"},"crystal":{"title":"Crystal","require":"ruby","owner":"MakeNowJust"},"css-extras":{"title":"CSS Extras","require":"css","modify":"css","owner":"milesj"},"csv":{"title":"CSV","owner":"RunDevelopment"},"cue":{"title":"CUE","owner":"RunDevelopment"},"cypher":{"title":"Cypher","owner":"RunDevelopment"},"d":{"title":"D","require":"clike","owner":"Golmote"},"dart":{"title":"Dart","require":"clike","owner":"Golmote"},"dataweave":{"title":"DataWeave","owner":"machaval"},"dax":{"title":"DAX","owner":"peterbud"},"dhall":{"title":"Dhall","owner":"RunDevelopment"},"diff":{"title":"Diff","owner":"uranusjr"},"django":{"title":"Django/Jinja2","require":"markup-templating","alias":"jinja2","owner":"romanvm"},"dns-zone-file":{"title":"DNS zone file","owner":"RunDevelopment","alias":"dns-zone"},"docker":{"title":"Docker","alias":"dockerfile","owner":"JustinBeckwith"},"dot":{"title":"DOT (Graphviz)","alias":"gv","optional":"markup","owner":"RunDevelopment"},"ebnf":{"title":"EBNF","owner":"RunDevelopment"},"editorconfig":{"title":"EditorConfig","owner":"osipxd"},"eiffel":{"title":"Eiffel","owner":"Conaclos"},"ejs":{"title":"EJS","require":["javascript","markup-templating"],"owner":"RunDevelopment","alias":"eta","aliasTitles":{"eta":"Eta"}},"elixir":{"title":"Elixir","owner":"Golmote"},"elm":{"title":"Elm","owner":"zwilias"},"etlua":{"title":"Embedded Lua templating","require":["lua","markup-templating"],"owner":"RunDevelopment"},"erb":{"title":"ERB","require":["ruby","markup-templating"],"owner":"Golmote"},"erlang":{"title":"Erlang","owner":"Golmote"},"excel-formula":{"title":"Excel Formula","alias":["xlsx","xls"],"owner":"RunDevelopment"},"fsharp":{"title":"F#","require":"clike","owner":"simonreynolds7"},"factor":{"title":"Factor","owner":"catb0t"},"false":{"title":"False","owner":"edukisto"},"firestore-security-rules":{"title":"Firestore security rules","require":"clike","owner":"RunDevelopment"},"flow":{"title":"Flow","require":"javascript","owner":"Golmote"},"fortran":{"title":"Fortran","owner":"Golmote"},"ftl":{"title":"FreeMarker Template Language","require":"markup-templating","owner":"RunDevelopment"},"gml":{"title":"GameMaker Language","alias":"gamemakerlanguage","require":"clike","owner":"LiarOnce"},"gap":{"title":"GAP (CAS)","owner":"RunDevelopment"},"gcode":{"title":"G-code","owner":"RunDevelopment"},"gdscript":{"title":"GDScript","owner":"RunDevelopment"},"gedcom":{"title":"GEDCOM","owner":"Golmote"},"gettext":{"title":"gettext","alias":"po","owner":"RunDevelopment"},"gherkin":{"title":"Gherkin","owner":"hason"},"git":{"title":"Git","owner":"lgiraudel"},"glsl":{"title":"GLSL","require":"c","owner":"Golmote"},"gn":{"title":"GN","alias":"gni","owner":"RunDevelopment"},"linker-script":{"title":"GNU Linker Script","alias":"ld","owner":"RunDevelopment"},"go":{"title":"Go","require":"clike","owner":"arnehormann"},"go-module":{"title":"Go module","alias":"go-mod","owner":"RunDevelopment"},"gradle":{"title":"Gradle","require":"clike","owner":"zeabdelkhalek-badido18"},"graphql":{"title":"GraphQL","optional":"markdown","owner":"Golmote"},"groovy":{"title":"Groovy","require":"clike","owner":"robfletcher"},"haml":{"title":"Haml","require":"ruby","optional":["css","css-extras","coffeescript","erb","javascript","less","markdown","scss","textile"],"owner":"Golmote"},"handlebars":{"title":"Handlebars","require":"markup-templating","alias":["hbs","mustache"],"aliasTitles":{"mustache":"Mustache"},"owner":"Golmote"},"haskell":{"title":"Haskell","alias":"hs","owner":"bholst"},"haxe":{"title":"Haxe","require":"clike","optional":"regex","owner":"Golmote"},"hcl":{"title":"HCL","owner":"outsideris"},"hlsl":{"title":"HLSL","require":"c","owner":"RunDevelopment"},"hoon":{"title":"Hoon","owner":"matildepark"},"http":{"title":"HTTP","optional":["csp","css","hpkp","hsts","javascript","json","markup","uri"],"owner":"danielgtaylor"},"hpkp":{"title":"HTTP Public-Key-Pins","owner":"ScottHelme"},"hsts":{"title":"HTTP Strict-Transport-Security","owner":"ScottHelme"},"ichigojam":{"title":"IchigoJam","owner":"BlueCocoa"},"icon":{"title":"Icon","owner":"Golmote"},"icu-message-format":{"title":"ICU Message Format","owner":"RunDevelopment"},"idris":{"title":"Idris","alias":"idr","owner":"KeenS","require":"haskell"},"ignore":{"title":".ignore","owner":"osipxd","alias":["gitignore","hgignore","npmignore"],"aliasTitles":{"gitignore":".gitignore","hgignore":".hgignore","npmignore":".npmignore"}},"inform7":{"title":"Inform 7","owner":"Golmote"},"ini":{"title":"Ini","owner":"aviaryan"},"io":{"title":"Io","owner":"AlesTsurko"},"j":{"title":"J","owner":"Golmote"},"java":{"title":"Java","require":"clike","owner":"sherblot"},"javadoc":{"title":"JavaDoc","require":["markup","java","javadoclike"],"modify":"java","optional":"scala","owner":"RunDevelopment"},"javadoclike":{"title":"JavaDoc-like","modify":["java","javascript","php"],"owner":"RunDevelopment"},"javastacktrace":{"title":"Java stack trace","owner":"RunDevelopment"},"jexl":{"title":"Jexl","owner":"czosel"},"jolie":{"title":"Jolie","require":"clike","owner":"thesave"},"jq":{"title":"JQ","owner":"RunDevelopment"},"jsdoc":{"title":"JSDoc","require":["javascript","javadoclike","typescript"],"modify":"javascript","optional":["actionscript","coffeescript"],"owner":"RunDevelopment"},"js-extras":{"title":"JS Extras","require":"javascript","modify":"javascript","optional":["actionscript","coffeescript","flow","n4js","typescript"],"owner":"RunDevelopment"},"json":{"title":"JSON","alias":"webmanifest","aliasTitles":{"webmanifest":"Web App Manifest"},"owner":"CupOfTea696"},"json5":{"title":"JSON5","require":"json","owner":"RunDevelopment"},"jsonp":{"title":"JSONP","require":"json","owner":"RunDevelopment"},"jsstacktrace":{"title":"JS stack trace","owner":"sbrl"},"js-templates":{"title":"JS Templates","require":"javascript","modify":"javascript","optional":["css","css-extras","graphql","markdown","markup","sql"],"owner":"RunDevelopment"},"julia":{"title":"Julia","owner":"cdagnino"},"keepalived":{"title":"Keepalived Configure","owner":"dev-itsheng"},"keyman":{"title":"Keyman","owner":"mcdurdin"},"kotlin":{"title":"Kotlin","alias":["kt","kts"],"aliasTitles":{"kts":"Kotlin Script"},"require":"clike","owner":"Golmote"},"kumir":{"title":"KuMir (КуМир)","alias":"kum","owner":"edukisto"},"kusto":{"title":"Kusto","owner":"RunDevelopment"},"latex":{"title":"LaTeX","alias":["tex","context"],"aliasTitles":{"tex":"TeX","context":"ConTeXt"},"owner":"japborst"},"latte":{"title":"Latte","require":["clike","markup-templating","php"],"owner":"nette"},"less":{"title":"Less","require":"css","optional":"css-extras","owner":"Golmote"},"lilypond":{"title":"LilyPond","require":"scheme","alias":"ly","owner":"RunDevelopment"},"liquid":{"title":"Liquid","require":"markup-templating","owner":"cinhtau"},"lisp":{"title":"Lisp","alias":["emacs","elisp","emacs-lisp"],"owner":"JuanCaicedo"},"livescript":{"title":"LiveScript","owner":"Golmote"},"llvm":{"title":"LLVM IR","owner":"porglezomp"},"log":{"title":"Log file","optional":"javastacktrace","owner":"RunDevelopment"},"lolcode":{"title":"LOLCODE","owner":"Golmote"},"lua":{"title":"Lua","owner":"Golmote"},"magma":{"title":"Magma (CAS)","owner":"RunDevelopment"},"makefile":{"title":"Makefile","owner":"Golmote"},"markdown":{"title":"Markdown","require":"markup","optional":"yaml","alias":"md","owner":"Golmote"},"markup-templating":{"title":"Markup templating","require":"markup","owner":"Golmote"},"mata":{"title":"Mata","owner":"RunDevelopment"},"matlab":{"title":"MATLAB","owner":"Golmote"},"maxscript":{"title":"MAXScript","owner":"RunDevelopment"},"mel":{"title":"MEL","owner":"Golmote"},"mermaid":{"title":"Mermaid","owner":"RunDevelopment"},"metafont":{"title":"METAFONT","owner":"LaeriExNihilo"},"mizar":{"title":"Mizar","owner":"Golmote"},"mongodb":{"title":"MongoDB","owner":"airs0urce","require":"javascript"},"monkey":{"title":"Monkey","owner":"Golmote"},"moonscript":{"title":"MoonScript","alias":"moon","owner":"RunDevelopment"},"n1ql":{"title":"N1QL","owner":"TMWilds"},"n4js":{"title":"N4JS","require":"javascript","optional":"jsdoc","alias":"n4jsd","owner":"bsmith-n4"},"nand2tetris-hdl":{"title":"Nand To Tetris HDL","owner":"stephanmax"},"naniscript":{"title":"Naninovel Script","owner":"Elringus","alias":"nani"},"nasm":{"title":"NASM","owner":"rbmj"},"neon":{"title":"NEON","owner":"nette"},"nevod":{"title":"Nevod","owner":"nezaboodka"},"nginx":{"title":"nginx","owner":"volado"},"nim":{"title":"Nim","owner":"Golmote"},"nix":{"title":"Nix","owner":"Golmote"},"nsis":{"title":"NSIS","owner":"idleberg"},"objectivec":{"title":"Objective-C","require":"c","alias":"objc","owner":"uranusjr"},"ocaml":{"title":"OCaml","owner":"Golmote"},"odin":{"title":"Odin","owner":"edukisto"},"opencl":{"title":"OpenCL","require":"c","modify":["c","cpp"],"owner":"Milania1"},"openqasm":{"title":"OpenQasm","alias":"qasm","owner":"RunDevelopment"},"oz":{"title":"Oz","owner":"Golmote"},"parigp":{"title":"PARI/GP","owner":"Golmote"},"parser":{"title":"Parser","require":"markup","owner":"Golmote"},"pascal":{"title":"Pascal","alias":"objectpascal","aliasTitles":{"objectpascal":"Object Pascal"},"owner":"Golmote"},"pascaligo":{"title":"Pascaligo","owner":"DefinitelyNotAGoat"},"psl":{"title":"PATROL Scripting Language","owner":"bertysentry"},"pcaxis":{"title":"PC-Axis","alias":"px","owner":"RunDevelopment"},"peoplecode":{"title":"PeopleCode","alias":"pcode","owner":"RunDevelopment"},"perl":{"title":"Perl","owner":"Golmote"},"php":{"title":"PHP","require":"markup-templating","owner":"milesj"},"phpdoc":{"title":"PHPDoc","require":["php","javadoclike"],"modify":"php","owner":"RunDevelopment"},"php-extras":{"title":"PHP Extras","require":"php","modify":"php","owner":"milesj"},"plant-uml":{"title":"PlantUML","alias":"plantuml","owner":"RunDevelopment"},"plsql":{"title":"PL/SQL","require":"sql","owner":"Golmote"},"powerquery":{"title":"PowerQuery","alias":["pq","mscript"],"owner":"peterbud"},"powershell":{"title":"PowerShell","owner":"nauzilus"},"processing":{"title":"Processing","require":"clike","owner":"Golmote"},"prolog":{"title":"Prolog","owner":"Golmote"},"promql":{"title":"PromQL","owner":"arendjr"},"properties":{"title":".properties","owner":"Golmote"},"protobuf":{"title":"Protocol Buffers","require":"clike","owner":"just-boris"},"pug":{"title":"Pug","require":["markup","javascript"],"optional":["coffeescript","ejs","handlebars","less","livescript","markdown","scss","stylus","twig"],"owner":"Golmote"},"puppet":{"title":"Puppet","owner":"Golmote"},"pure":{"title":"Pure","optional":["c","cpp","fortran"],"owner":"Golmote"},"purebasic":{"title":"PureBasic","require":"clike","alias":"pbfasm","owner":"HeX0R101"},"purescript":{"title":"PureScript","require":"haskell","alias":"purs","owner":"sriharshachilakapati"},"python":{"title":"Python","alias":"py","owner":"multipetros"},"qsharp":{"title":"Q#","require":"clike","alias":"qs","owner":"fedonman"},"q":{"title":"Q (kdb+ database)","owner":"Golmote"},"qml":{"title":"QML","require":"javascript","owner":"RunDevelopment"},"qore":{"title":"Qore","require":"clike","owner":"temnroegg"},"r":{"title":"R","owner":"Golmote"},"racket":{"title":"Racket","require":"scheme","alias":"rkt","owner":"RunDevelopment"},"cshtml":{"title":"Razor C#","alias":"razor","require":["markup","csharp"],"optional":["css","css-extras","javascript","js-extras"],"owner":"RunDevelopment"},"jsx":{"title":"React JSX","require":["markup","javascript"],"optional":["jsdoc","js-extras","js-templates"],"owner":"vkbansal"},"tsx":{"title":"React TSX","require":["jsx","typescript"]},"reason":{"title":"Reason","require":"clike","owner":"Golmote"},"regex":{"title":"Regex","owner":"RunDevelopment"},"rego":{"title":"Rego","owner":"JordanSh"},"renpy":{"title":"Ren'py","alias":"rpy","owner":"HyuchiaDiego"},"rescript":{"title":"ReScript","alias":"res","owner":"vmarcosp"},"rest":{"title":"reST (reStructuredText)","owner":"Golmote"},"rip":{"title":"Rip","owner":"ravinggenius"},"roboconf":{"title":"Roboconf","owner":"Golmote"},"robotframework":{"title":"Robot Framework","alias":"robot","owner":"RunDevelopment"},"ruby":{"title":"Ruby","require":"clike","alias":"rb","owner":"samflores"},"rust":{"title":"Rust","owner":"Golmote"},"sas":{"title":"SAS","optional":["groovy","lua","sql"],"owner":"Golmote"},"sass":{"title":"Sass (Sass)","require":"css","optional":"css-extras","owner":"Golmote"},"scss":{"title":"Sass (SCSS)","require":"css","optional":"css-extras","owner":"MoOx"},"scala":{"title":"Scala","require":"java","owner":"jozic"},"scheme":{"title":"Scheme","owner":"bacchus123"},"shell-session":{"title":"Shell session","require":"bash","alias":["sh-session","shellsession"],"owner":"RunDevelopment"},"smali":{"title":"Smali","owner":"RunDevelopment"},"smalltalk":{"title":"Smalltalk","owner":"Golmote"},"smarty":{"title":"Smarty","require":"markup-templating","optional":"php","owner":"Golmote"},"sml":{"title":"SML","alias":"smlnj","aliasTitles":{"smlnj":"SML/NJ"},"owner":"RunDevelopment"},"solidity":{"title":"Solidity (Ethereum)","alias":"sol","require":"clike","owner":"glachaud"},"solution-file":{"title":"Solution file","alias":"sln","owner":"RunDevelopment"},"soy":{"title":"Soy (Closure Template)","require":"markup-templating","owner":"Golmote"},"sparql":{"title":"SPARQL","require":"turtle","owner":"Triply-Dev","alias":"rq"},"splunk-spl":{"title":"Splunk SPL","owner":"RunDevelopment"},"sqf":{"title":"SQF: Status Quo Function (Arma 3)","require":"clike","owner":"RunDevelopment"},"sql":{"title":"SQL","owner":"multipetros"},"squirrel":{"title":"Squirrel","require":"clike","owner":"RunDevelopment"},"stan":{"title":"Stan","owner":"RunDevelopment"},"stata":{"title":"Stata Ado","require":["mata","java","python"],"owner":"RunDevelopment"},"iecst":{"title":"Structured Text (IEC 61131-3)","owner":"serhioromano"},"stylus":{"title":"Stylus","owner":"vkbansal"},"supercollider":{"title":"SuperCollider","alias":"sclang","owner":"RunDevelopment"},"swift":{"title":"Swift","owner":"chrischares"},"systemd":{"title":"Systemd configuration file","owner":"RunDevelopment"},"t4-templating":{"title":"T4 templating","owner":"RunDevelopment"},"t4-cs":{"title":"T4 Text Templates (C#)","require":["t4-templating","csharp"],"alias":"t4","owner":"RunDevelopment"},"t4-vb":{"title":"T4 Text Templates (VB)","require":["t4-templating","vbnet"],"owner":"RunDevelopment"},"tap":{"title":"TAP","owner":"isaacs","require":"yaml"},"tcl":{"title":"Tcl","owner":"PeterChaplin"},"tt2":{"title":"Template Toolkit 2","require":["clike","markup-templating"],"owner":"gflohr"},"textile":{"title":"Textile","require":"markup","optional":"css","owner":"Golmote"},"toml":{"title":"TOML","owner":"RunDevelopment"},"tremor":{"title":"Tremor","alias":["trickle","troy"],"owner":"darach","aliasTitles":{"trickle":"trickle","troy":"troy"}},"turtle":{"title":"Turtle","alias":"trig","aliasTitles":{"trig":"TriG"},"owner":"jakubklimek"},"twig":{"title":"Twig","require":"markup-templating","owner":"brandonkelly"},"typescript":{"title":"TypeScript","require":"javascript","optional":"js-templates","alias":"ts","owner":"vkbansal"},"typoscript":{"title":"TypoScript","alias":"tsconfig","aliasTitles":{"tsconfig":"TSConfig"},"owner":"dkern"},"unrealscript":{"title":"UnrealScript","alias":["uscript","uc"],"owner":"RunDevelopment"},"uorazor":{"title":"UO Razor Script","owner":"jaseowns"},"uri":{"title":"URI","alias":"url","aliasTitles":{"url":"URL"},"owner":"RunDevelopment"},"v":{"title":"V","require":"clike","owner":"taggon"},"vala":{"title":"Vala","require":"clike","optional":"regex","owner":"TemplarVolk"},"vbnet":{"title":"VB.Net","require":"basic","owner":"Bigsby"},"velocity":{"title":"Velocity","require":"markup","owner":"Golmote"},"verilog":{"title":"Verilog","owner":"a-rey"},"vhdl":{"title":"VHDL","owner":"a-rey"},"vim":{"title":"vim","owner":"westonganger"},"visual-basic":{"title":"Visual Basic","alias":["vb","vba"],"aliasTitles":{"vba":"VBA"},"owner":"Golmote"},"warpscript":{"title":"WarpScript","owner":"RunDevelopment"},"wasm":{"title":"WebAssembly","owner":"Golmote"},"web-idl":{"title":"Web IDL","alias":"webidl","owner":"RunDevelopment"},"wgsl":{"title":"WGSL","owner":"Dr4gonthree"},"wiki":{"title":"Wiki markup","require":"markup","owner":"Golmote"},"wolfram":{"title":"Wolfram language","alias":["mathematica","nb","wl"],"aliasTitles":{"mathematica":"Mathematica","nb":"Mathematica Notebook"},"owner":"msollami"},"wren":{"title":"Wren","owner":"clsource"},"xeora":{"title":"Xeora","require":"markup","alias":"xeoracube","aliasTitles":{"xeoracube":"XeoraCube"},"owner":"freakmaxi"},"xml-doc":{"title":"XML doc (.net)","require":"markup","modify":["csharp","fsharp","vbnet"],"owner":"RunDevelopment"},"xojo":{"title":"Xojo (REALbasic)","owner":"Golmote"},"xquery":{"title":"XQuery","require":"markup","owner":"Golmote"},"yaml":{"title":"YAML","alias":"yml","owner":"hason"},"yang":{"title":"YANG","owner":"RunDevelopment"},"zig":{"title":"Zig","owner":"RunDevelopment"}},"plugins":{"meta":{"path":"plugins/{id}/prism-{id}","link":"plugins/{id}/"},"line-highlight":{"title":"Line Highlight","description":"Highlights specific lines and/or line ranges."},"line-numbers":{"title":"Line Numbers","description":"Line number at the beginning of code lines.","owner":"kuba-kubula"},"show-invisibles":{"title":"Show Invisibles","description":"Show hidden characters such as tabs and line breaks.","optional":["autolinker","data-uri-highlight"]},"autolinker":{"title":"Autolinker","description":"Converts URLs and emails in code to clickable links. Parses Markdown links in comments."},"wpd":{"title":"WebPlatform Docs","description":"Makes tokens link to <a href=\"https://webplatform.github.io/docs/\">WebPlatform.org documentation</a>. The links open in a new tab."},"custom-class":{"title":"Custom Class","description":"This plugin allows you to prefix Prism's default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.","owner":"dvkndn","noCSS":true},"file-highlight":{"title":"File Highlight","description":"Fetch external files and highlight them with Prism. Used on the Prism website itself.","noCSS":true},"show-language":{"title":"Show Language","description":"Display the highlighted language in code blocks (inline code does not show the label).","owner":"nauzilus","noCSS":true,"require":"toolbar"},"jsonp-highlight":{"title":"JSONP Highlight","description":"Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).","noCSS":true,"owner":"nauzilus"},"highlight-keywords":{"title":"Highlight Keywords","description":"Adds special CSS classes for each keyword for fine-grained highlighting.","owner":"vkbansal","noCSS":true},"remove-initial-line-feed":{"title":"Remove initial line feed","description":"Removes the initial line feed in code blocks.","owner":"Golmote","noCSS":true},"inline-color":{"title":"Inline color","description":"Adds a small inline preview for colors in style sheets.","require":"css-extras","owner":"RunDevelopment"},"previewers":{"title":"Previewers","description":"Previewers for angles, colors, gradients, easing and time.","require":"css-extras","owner":"Golmote"},"autoloader":{"title":"Autoloader","description":"Automatically loads the needed languages to highlight the code blocks.","owner":"Golmote","noCSS":true},"keep-markup":{"title":"Keep Markup","description":"Prevents custom markup from being dropped out during highlighting.","owner":"Golmote","optional":"normalize-whitespace","noCSS":true},"command-line":{"title":"Command Line","description":"Display a command line with a prompt and, optionally, the output/response from the commands.","owner":"chriswells0"},"unescaped-markup":{"title":"Unescaped Markup","description":"Write markup without having to escape anything."},"normalize-whitespace":{"title":"Normalize Whitespace","description":"Supports multiple operations to normalize whitespace in code blocks.","owner":"zeitgeist87","optional":"unescaped-markup","noCSS":true},"data-uri-highlight":{"title":"Data-URI Highlight","description":"Highlights data-URI contents.","owner":"Golmote","noCSS":true},"toolbar":{"title":"Toolbar","description":"Attach a toolbar for plugins to easily register buttons on the top of a code block.","owner":"mAAdhaTTah"},"copy-to-clipboard":{"title":"Copy to Clipboard Button","description":"Add a button that copies the code block to the clipboard when clicked.","owner":"mAAdhaTTah","require":"toolbar","noCSS":true},"download-button":{"title":"Download Button","description":"A button in the toolbar of a code block adding a convenient way to download a code file.","owner":"Golmote","require":"toolbar","noCSS":true},"match-braces":{"title":"Match braces","description":"Highlights matching braces.","owner":"RunDevelopment"},"diff-highlight":{"title":"Diff Highlight","description":"Highlights the code inside diff blocks.","owner":"RunDevelopment","require":"diff"},"filter-highlight-all":{"title":"Filter highlightAll","description":"Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.","owner":"RunDevelopment","noCSS":true},"treeview":{"title":"Treeview","description":"A language with special styles to highlight file system tree structures.","owner":"Golmote"}}};
		if (module.exports) { module.exports = components; } 
	} (components));
	return components.exports;
}

var dependencies = {exports: {}};

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies.exports;
	hasRequiredDependencies = 1;
	(function (module) {

		/**
		 * @typedef {Object<string, ComponentCategory>} Components
		 * @typedef {Object<string, ComponentEntry | string>} ComponentCategory
		 *
		 * @typedef ComponentEntry
		 * @property {string} [title] The title of the component.
		 * @property {string} [owner] The GitHub user name of the owner.
		 * @property {boolean} [noCSS=false] Whether the component doesn't have style sheets which should also be loaded.
		 * @property {string | string[]} [alias] An optional list of aliases for the id of the component.
		 * @property {Object<string, string>} [aliasTitles] An optional map from an alias to its title.
		 *
		 * Aliases which are not in this map will the get title of the component.
		 * @property {string | string[]} [optional]
		 * @property {string | string[]} [require]
		 * @property {string | string[]} [modify]
		 */

		var getLoader = (function () {

			/**
			 * A function which does absolutely nothing.
			 *
			 * @type {any}
			 */
			var noop = function () { };

			/**
			 * Invokes the given callback for all elements of the given value.
			 *
			 * If the given value is an array, the callback will be invokes for all elements. If the given value is `null` or
			 * `undefined`, the callback will not be invoked. In all other cases, the callback will be invoked with the given
			 * value as parameter.
			 *
			 * @param {null | undefined | T | T[]} value
			 * @param {(value: T, index: number) => void} callbackFn
			 * @returns {void}
			 * @template T
			 */
			function forEach(value, callbackFn) {
				if (Array.isArray(value)) {
					value.forEach(callbackFn);
				} else if (value != null) {
					callbackFn(value, 0);
				}
			}

			/**
			 * Returns a new set for the given string array.
			 *
			 * @param {string[]} array
			 * @returns {StringSet}
			 *
			 * @typedef {Object<string, true>} StringSet
			 */
			function toSet(array) {
				/** @type {StringSet} */
				var set = {};
				for (var i = 0, l = array.length; i < l; i++) {
					set[array[i]] = true;
				}
				return set;
			}

			/**
			 * Creates a map of every components id to its entry.
			 *
			 * @param {Components} components
			 * @returns {EntryMap}
			 *
			 * @typedef {{ readonly [id: string]: Readonly<ComponentEntry> | undefined }} EntryMap
			 */
			function createEntryMap(components) {
				/** @type {Object<string, Readonly<ComponentEntry>>} */
				var map = {};

				for (var categoryName in components) {
					var category = components[categoryName];
					for (var id in category) {
						if (id != 'meta') {
							/** @type {ComponentEntry | string} */
							var entry = category[id];
							map[id] = typeof entry == 'string' ? { title: entry } : entry;
						}
					}
				}

				return map;
			}

			/**
			 * Creates a full dependencies map which includes all types of dependencies and their transitive dependencies.
			 *
			 * @param {EntryMap} entryMap
			 * @returns {DependencyResolver}
			 *
			 * @typedef {(id: string) => StringSet} DependencyResolver
			 */
			function createDependencyResolver(entryMap) {
				/** @type {Object<string, StringSet>} */
				var map = {};
				var _stackArray = [];

				/**
				 * Adds the dependencies of the given component to the dependency map.
				 *
				 * @param {string} id
				 * @param {string[]} stack
				 */
				function addToMap(id, stack) {
					if (id in map) {
						return;
					}

					stack.push(id);

					// check for circular dependencies
					var firstIndex = stack.indexOf(id);
					if (firstIndex < stack.length - 1) {
						throw new Error('Circular dependency: ' + stack.slice(firstIndex).join(' -> '));
					}

					/** @type {StringSet} */
					var dependencies = {};

					var entry = entryMap[id];
					if (entry) {
						/**
						 * This will add the direct dependency and all of its transitive dependencies to the set of
						 * dependencies of `entry`.
						 *
						 * @param {string} depId
						 * @returns {void}
						 */
						function handleDirectDependency(depId) {
							if (!(depId in entryMap)) {
								throw new Error(id + ' depends on an unknown component ' + depId);
							}
							if (depId in dependencies) {
								// if the given dependency is already in the set of deps, then so are its transitive deps
								return;
							}

							addToMap(depId, stack);
							dependencies[depId] = true;
							for (var transitiveDepId in map[depId]) {
								dependencies[transitiveDepId] = true;
							}
						}

						forEach(entry.require, handleDirectDependency);
						forEach(entry.optional, handleDirectDependency);
						forEach(entry.modify, handleDirectDependency);
					}

					map[id] = dependencies;

					stack.pop();
				}

				return function (id) {
					var deps = map[id];
					if (!deps) {
						addToMap(id, _stackArray);
						deps = map[id];
					}
					return deps;
				};
			}

			/**
			 * Returns a function which resolves the aliases of its given id of alias.
			 *
			 * @param {EntryMap} entryMap
			 * @returns {(idOrAlias: string) => string}
			 */
			function createAliasResolver(entryMap) {
				/** @type {Object<string, string> | undefined} */
				var map;

				return function (idOrAlias) {
					if (idOrAlias in entryMap) {
						return idOrAlias;
					} else {
						// only create the alias map if necessary
						if (!map) {
							map = {};

							for (var id in entryMap) {
								var entry = entryMap[id];
								forEach(entry && entry.alias, function (alias) {
									if (alias in map) {
										throw new Error(alias + ' cannot be alias for both ' + id + ' and ' + map[alias]);
									}
									if (alias in entryMap) {
										throw new Error(alias + ' cannot be alias of ' + id + ' because it is a component.');
									}
									map[alias] = id;
								});
							}
						}
						return map[idOrAlias] || idOrAlias;
					}
				};
			}

			/**
			 * @typedef LoadChainer
			 * @property {(before: T, after: () => T) => T} series
			 * @property {(values: T[]) => T} parallel
			 * @template T
			 */

			/**
			 * Creates an implicit DAG from the given components and dependencies and call the given `loadComponent` for each
			 * component in topological order.
			 *
			 * @param {DependencyResolver} dependencyResolver
			 * @param {StringSet} ids
			 * @param {(id: string) => T} loadComponent
			 * @param {LoadChainer<T>} [chainer]
			 * @returns {T}
			 * @template T
			 */
			function loadComponentsInOrder(dependencyResolver, ids, loadComponent, chainer) {
				var series = chainer ? chainer.series : undefined;
				var parallel = chainer ? chainer.parallel : noop;

				/** @type {Object<string, T>} */
				var cache = {};

				/**
				 * A set of ids of nodes which are not depended upon by any other node in the graph.
				 *
				 * @type {StringSet}
				 */
				var ends = {};

				/**
				 * Loads the given component and its dependencies or returns the cached value.
				 *
				 * @param {string} id
				 * @returns {T}
				 */
				function handleId(id) {
					if (id in cache) {
						return cache[id];
					}

					// assume that it's an end
					// if it isn't, it will be removed later
					ends[id] = true;

					// all dependencies of the component in the given ids
					var dependsOn = [];
					for (var depId in dependencyResolver(id)) {
						if (depId in ids) {
							dependsOn.push(depId);
						}
					}

					/**
					 * The value to be returned.
					 *
					 * @type {T}
					 */
					var value;

					if (dependsOn.length === 0) {
						value = loadComponent(id);
					} else {
						var depsValue = parallel(dependsOn.map(function (depId) {
							var value = handleId(depId);
							// none of the dependencies can be ends
							delete ends[depId];
							return value;
						}));
						if (series) {
							// the chainer will be responsibly for calling the function calling loadComponent
							value = series(depsValue, function () { return loadComponent(id); });
						} else {
							// we don't have a chainer, so we call loadComponent ourselves
							loadComponent(id);
						}
					}

					// cache and return
					return cache[id] = value;
				}

				for (var id in ids) {
					handleId(id);
				}

				/** @type {T[]} */
				var endValues = [];
				for (var endId in ends) {
					endValues.push(cache[endId]);
				}
				return parallel(endValues);
			}

			/**
			 * Returns whether the given object has any keys.
			 *
			 * @param {object} obj
			 */
			function hasKeys(obj) {
				for (var key in obj) {
					return true;
				}
				return false;
			}

			/**
			 * Returns an object which provides methods to get the ids of the components which have to be loaded (`getIds`) and
			 * a way to efficiently load them in synchronously and asynchronous contexts (`load`).
			 *
			 * The set of ids to be loaded is a superset of `load`. If some of these ids are in `loaded`, the corresponding
			 * components will have to reloaded.
			 *
			 * The ids in `load` and `loaded` may be in any order and can contain duplicates.
			 *
			 * @param {Components} components
			 * @param {string[]} load
			 * @param {string[]} [loaded=[]] A list of already loaded components.
			 *
			 * If a component is in this list, then all of its requirements will also be assumed to be in the list.
			 * @returns {Loader}
			 *
			 * @typedef Loader
			 * @property {() => string[]} getIds A function to get all ids of the components to load.
			 *
			 * The returned ids will be duplicate-free, alias-free and in load order.
			 * @property {LoadFunction} load A functional interface to load components.
			 *
			 * @typedef {<T> (loadComponent: (id: string) => T, chainer?: LoadChainer<T>) => T} LoadFunction
			 * A functional interface to load components.
			 *
			 * The `loadComponent` function will be called for every component in the order in which they have to be loaded.
			 *
			 * The `chainer` is useful for asynchronous loading and its `series` and `parallel` functions can be thought of as
			 * `Promise#then` and `Promise.all`.
			 *
			 * @example
			 * load(id => { loadComponent(id); }); // returns undefined
			 *
			 * await load(
			 *     id => loadComponentAsync(id), // returns a Promise for each id
			 *     {
			 *         series: async (before, after) => {
			 *             await before;
			 *             await after();
			 *         },
			 *         parallel: async (values) => {
			 *             await Promise.all(values);
			 *         }
			 *     }
			 * );
			 */
			function getLoader(components, load, loaded) {
				var entryMap = createEntryMap(components);
				var resolveAlias = createAliasResolver(entryMap);

				load = load.map(resolveAlias);
				loaded = (loaded || []).map(resolveAlias);

				var loadSet = toSet(load);
				var loadedSet = toSet(loaded);

				// add requirements

				load.forEach(addRequirements);
				function addRequirements(id) {
					var entry = entryMap[id];
					forEach(entry && entry.require, function (reqId) {
						if (!(reqId in loadedSet)) {
							loadSet[reqId] = true;
							addRequirements(reqId);
						}
					});
				}

				// add components to reload

				// A component x in `loaded` has to be reloaded if
				//  1) a component in `load` modifies x.
				//  2) x depends on a component in `load`.
				// The above two condition have to be applied until nothing changes anymore.

				var dependencyResolver = createDependencyResolver(entryMap);

				/** @type {StringSet} */
				var loadAdditions = loadSet;
				/** @type {StringSet} */
				var newIds;
				while (hasKeys(loadAdditions)) {
					newIds = {};

					// condition 1)
					for (var loadId in loadAdditions) {
						var entry = entryMap[loadId];
						forEach(entry && entry.modify, function (modId) {
							if (modId in loadedSet) {
								newIds[modId] = true;
							}
						});
					}

					// condition 2)
					for (var loadedId in loadedSet) {
						if (!(loadedId in loadSet)) {
							for (var depId in dependencyResolver(loadedId)) {
								if (depId in loadSet) {
									newIds[loadedId] = true;
									break;
								}
							}
						}
					}

					loadAdditions = newIds;
					for (var newId in loadAdditions) {
						loadSet[newId] = true;
					}
				}

				/** @type {Loader} */
				var loader = {
					getIds: function () {
						var ids = [];
						loader.load(function (id) {
							ids.push(id);
						});
						return ids;
					},
					load: function (loadComponent, chainer) {
						return loadComponentsInOrder(dependencyResolver, loadSet, loadComponent, chainer);
					}
				};

				return loader;
			}

			return getLoader;

		}());

		{
			module.exports = getLoader;
		} 
	} (dependencies));
	return dependencies.exports;
}

var components_1;
var hasRequiredComponents;

function requireComponents () {
	if (hasRequiredComponents) return components_1;
	hasRequiredComponents = 1;
	const components = requireComponents$1();
	const getLoader = requireDependencies();


	/**
	 * The set of all languages which have been loaded using the below function.
	 *
	 * @type {Set<string>}
	 */
	const loadedLanguages = new Set();

	/**
	 * Loads the given languages and adds them to the current Prism instance.
	 *
	 * If no languages are provided, __all__ Prism languages will be loaded.
	 *
	 * @param {string|string[]} [languages]
	 * @returns {void}
	 */
	function loadLanguages(languages) {
		if (languages === undefined) {
			languages = Object.keys(components.languages).filter(l => l != 'meta');
		} else if (!Array.isArray(languages)) {
			languages = [languages];
		}

		// the user might have loaded languages via some other way or used `prism.js` which already includes some
		// we don't need to validate the ids because `getLoader` will ignore invalid ones
		const loaded = [...loadedLanguages, ...Object.keys(Prism.languages)];

		getLoader(components, languages, loaded).load(lang => {
			if (!(lang in components.languages)) {
				if (!loadLanguages.silent) {
					console.warn('Language does not exist: ' + lang);
				}
				return;
			}

			const pathToLanguage = './prism-' + lang;

			// remove from require cache and from Prism
			delete require.cache[require.resolve(pathToLanguage)];
			delete Prism.languages[lang];

			commonjsRequire(pathToLanguage);

			loadedLanguages.add(lang);
		});
	}

	/**
	 * Set this to `true` to prevent all warning messages `loadLanguages` logs.
	 */
	loadLanguages.silent = false;

	components_1 = loadLanguages;
	return components_1;
}

requireComponents();

const bundledThemesInfo = [
  {
    "id": "github-dark",
    "displayName": "GitHub Dark",
    "type": "dark",
    "import": (() => import('./github-dark_D_gS3ClN.mjs'))
  },
];
const bundledThemes = Object.fromEntries(bundledThemesInfo.map((i) => [i.id, i.import]));

/*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject$1(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


var isNothing_1      = isNothing;
var isObject_1       = isObject$1;
var toArray_1        = toArray;
var repeat_1         = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1         = extend;

var common$1 = {
	isNothing: isNothing_1,
	isObject: isObject_1,
	toArray: toArray_1,
	repeat: repeat_1,
	isNegativeZero: isNegativeZero_1,
	extend: extend_1
};

// YAML error class. http://stackoverflow.com/questions/8458984


function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException$1(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;


YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


var exception = YAMLException$1;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type$1(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type$1;

/*eslint-disable max-len*/





function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema$1(definition) {
  return this.extend(definition);
}


Schema$1.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof type) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type$1.loadKind && type$1.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type$1.multi) {
      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema$1.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


var schema = Schema$1;

var str = new type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

var seq = new type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

var map$1 = new type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

var failsafe = new schema({
  explicit: [
    str,
    seq,
    map$1
  ]
});

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common$1.isNegativeZero(object));
}

var int = new type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common$1.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common$1.isNegativeZero(object));
}

var float = new type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});

var core = json;

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

var timestamp = new type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/





// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

var binary$2 = new type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString$2.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

var pairs = new type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set$1 = new type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary$2,
    omap,
    pairs,
    set$1
  ]
});

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i$1 = 0; i$1 < 256; i$1++) {
  simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
  simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
}

const syntaxHighlightDefaults = {
  type: "shiki",
  excludeLangs: defaultExcludeLanguages
};
const markdownConfigDefaults = {
  syntaxHighlight: syntaxHighlightDefaults,
  shikiConfig: {
    theme: "github-dark",
    themes: {},
    wrap: false,
    transformers: [],
    langAlias: {}
  },
  remarkPlugins: [],
  rehypePlugins: [],
  remarkRehype: {},
  gfm: true,
  smartypants: true
};
Boolean(process.env.ASTRO_PERFORMANCE_BENCHMARK);

const LOCAL_PROVIDER_NAME = "local";

const weightSchema = unionType([stringType(), numberType()]);
const styleSchema = enumType(["normal", "italic", "oblique"]);
const unicodeRangeSchema = arrayType(stringType()).nonempty();
const familyPropertiesSchema = objectType({
  /**
   * A [font weight](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight). If the associated font is a [variable font](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_fonts/Variable_fonts_guide), you can specify a range of weights:
   *
   * ```js
   * weight: "100 900"
   * ```
   */
  weight: weightSchema.optional(),
  /**
   * A [font style](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style).
   */
  style: styleSchema.optional(),
  /**
   * @default `"swap"`
   *
   * A [font display](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display).
   */
  display: enumType(["auto", "block", "swap", "fallback", "optional"]).optional(),
  /**
   * A [font stretch](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-stretch).
   */
  stretch: stringType().optional(),
  /**
   * Font [feature settings](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-feature-settings).
   */
  featureSettings: stringType().optional(),
  /**
   * Font [variation settings](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-variation-settings).
   */
  variationSettings: stringType().optional()
});
const fallbacksSchema = objectType({
  /**
  	 * @default `["sans-serif"]`
  	 *
  	 * An array of fonts to use when your chosen font is unavailable, or loading. Fallback fonts will be chosen in the order listed. The first available font will be used:
  	 *
  	 * ```js
  	 * fallbacks: ["CustomFont", "serif"]
  	 * ```
  	 *
  	 * To disable fallback fonts completely, configure an empty array:
  	 *
  	 * ```js
  	 * fallbacks: []
  	 * ```
  	 *
  
  	 * If the last font in the `fallbacks` array is a [generic family name](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#generic-name), Astro will attempt to generate [optimized fallbacks](https://developer.chrome.com/blog/font-fallbacks) using font metrics will be generated. To disable this optimization, set `optimizedFallbacks` to false.
  	 */
  fallbacks: arrayType(stringType()).optional(),
  /**
   * @default `true`
   *
   * Whether or not to enable optimized fallback generation. You may disable this default optimization to have full control over `fallbacks`.
   */
  optimizedFallbacks: booleanType().optional()
});
const requiredFamilyAttributesSchema = objectType({
  /**
   * The font family name, as identified by your font provider.
   */
  name: stringType(),
  /**
   * A valid [ident](https://developer.mozilla.org/en-US/docs/Web/CSS/ident) in the form of a CSS variable (i.e. starting with `--`).
   */
  cssVariable: stringType()
});
const entrypointSchema = unionType([stringType(), instanceOfType(URL)]);
const fontProviderSchema = objectType({
  /**
   * URL, path relative to the root or package import.
   */
  entrypoint: entrypointSchema,
  /**
   * Optional serializable object passed to the unifont provider.
   */
  config: recordType(stringType(), anyType()).optional()
}).strict();
const localFontFamilySchema = requiredFamilyAttributesSchema.merge(fallbacksSchema).merge(
  objectType({
    /**
     * The source of your font files. Set to `"local"` to use local font files.
     */
    provider: literalType(LOCAL_PROVIDER_NAME),
    /**
     * Each variant represents a [`@font-face` declaration](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/).
     */
    variants: arrayType(
      familyPropertiesSchema.merge(
        objectType({
          /**
           * Font [sources](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src). It can be a path relative to the root, a package import or a URL. URLs are particularly useful if you inject local fonts through an integration.
           */
          src: arrayType(
            unionType([
              entrypointSchema,
              objectType({ url: entrypointSchema, tech: stringType().optional() }).strict()
            ])
          ).nonempty(),
          /**
           * A [unicode range](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range).
           */
          unicodeRange: unicodeRangeSchema.optional()
          // TODO: find a way to support subsets (through fontkit?)
        }).strict()
      )
    ).nonempty()
  })
).strict();
const remoteFontFamilySchema = requiredFamilyAttributesSchema.merge(
  familyPropertiesSchema.omit({
    weight: true,
    style: true
  })
).merge(fallbacksSchema).merge(
  objectType({
    /**
     * The source of your font files. You can use a built-in provider or write your own custom provider.
     */
    provider: fontProviderSchema,
    /**
     * @default `[400]`
     *
     * An array of [font weights](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight). If the associated font is a [variable font](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_fonts/Variable_fonts_guide), you can specify a range of weights:
     *
     * ```js
     * weight: "100 900"
     * ```
     */
    weights: arrayType(weightSchema).nonempty().optional(),
    /**
     * @default `["normal", "italic"]`
     *
     * An array of [font styles](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style).
     */
    styles: arrayType(styleSchema).nonempty().optional(),
    /**
     * @default `["cyrillic-ext", "cyrillic", "greek-ext", "greek", "vietnamese", "latin-ext", "latin"]`
     *
     * An array of [font subsets](https://knaap.dev/posts/font-subsetting/):
     */
    subsets: arrayType(stringType()).nonempty().optional(),
    /**
     * A [unicode range](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range).
     */
    unicodeRange: unicodeRangeSchema.optional()
  })
).strict();

const StringSchema = objectType({
  type: literalType("string"),
  optional: booleanType().optional(),
  default: stringType().optional(),
  max: numberType().optional(),
  min: numberType().min(0).optional(),
  length: numberType().optional(),
  url: booleanType().optional(),
  includes: stringType().optional(),
  startsWith: stringType().optional(),
  endsWith: stringType().optional()
});
const NumberSchema = objectType({
  type: literalType("number"),
  optional: booleanType().optional(),
  default: numberType().optional(),
  gt: numberType().optional(),
  min: numberType().optional(),
  lt: numberType().optional(),
  max: numberType().optional(),
  int: booleanType().optional()
});
const BooleanSchema = objectType({
  type: literalType("boolean"),
  optional: booleanType().optional(),
  default: booleanType().optional()
});
const EnumSchema = objectType({
  type: literalType("enum"),
  values: arrayType(
    // We use "'" for codegen so it can't be passed here
    stringType().refine((v) => !v.includes("'"), {
      message: `The "'" character can't be used as an enum value`
    })
  ),
  optional: booleanType().optional(),
  default: stringType().optional()
});
const EnvFieldType = unionType([
  StringSchema,
  NumberSchema,
  BooleanSchema,
  EnumSchema.superRefine((schema, ctx) => {
    if (schema.default) {
      if (!schema.values.includes(schema.default)) {
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: `The default value "${schema.default}" must be one of the specified values: ${schema.values.join(", ")}.`
        });
      }
    }
  })
]);
const PublicClientEnvFieldMetadata = objectType({
  context: literalType("client"),
  access: literalType("public")
});
const PublicServerEnvFieldMetadata = objectType({
  context: literalType("server"),
  access: literalType("public")
});
const SecretServerEnvFieldMetadata = objectType({
  context: literalType("server"),
  access: literalType("secret")
});
const _EnvFieldMetadata = unionType([
  PublicClientEnvFieldMetadata,
  PublicServerEnvFieldMetadata,
  SecretServerEnvFieldMetadata
]);
const EnvFieldMetadata = custom().superRefine((data, ctx) => {
  const result = _EnvFieldMetadata.safeParse(data);
  if (result.success) {
    return;
  }
  for (const issue of result.error.issues) {
    if (issue.code === ZodIssueCode.invalid_union) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: `**Invalid combination** of "access" and "context" options:
  Secret client variables are not supported. Please review the configuration of \`env.schema.${ctx.path.at(-1)}\`.
  Learn more at https://docs.astro.build/en/guides/environment-variables/#variable-types`,
        path: ["context", "access"]
      });
    } else {
      ctx.addIssue(issue);
    }
  }
});
const EnvSchemaKey = stringType().min(1).refine(([firstChar]) => isNaN(Number.parseInt(firstChar)), {
  message: "A valid variable name cannot start with a number."
}).refine((str) => /^[A-Z0-9_]+$/.test(str), {
  message: "A valid variable name can only contain uppercase letters, numbers and underscores."
});
const EnvSchema = recordType(EnvSchemaKey, intersectionType(EnvFieldMetadata, EnvFieldType));

const ASTRO_CONFIG_DEFAULTS = {
  root: ".",
  srcDir: "./src",
  publicDir: "./public",
  outDir: "./dist",
  cacheDir: "./node_modules/.astro",
  base: "/",
  trailingSlash: "ignore",
  build: {
    format: "directory",
    client: "./client/",
    server: "./server/",
    assets: "_astro",
    serverEntry: "entry.mjs",
    redirects: true,
    inlineStylesheets: "auto",
    concurrency: 1
  },
  image: {
    endpoint: { entrypoint: void 0, route: "/_image" },
    service: { entrypoint: "astro/assets/services/sharp", config: {} },
    responsiveStyles: false
  },
  devToolbar: {
    enabled: true
  },
  compressHTML: true,
  server: {
    host: false,
    port: 4321,
    open: false,
    allowedHosts: []
  },
  integrations: [],
  markdown: markdownConfigDefaults,
  vite: {},
  legacy: {
    collections: false
  },
  redirects: {},
  security: {
    checkOrigin: true
  },
  env: {
    schema: {},
    validateSecrets: false
  },
  experimental: {
    clientPrerender: false,
    contentIntellisense: false,
    headingIdCompat: false,
    preserveScriptOrder: false,
    liveContentCollections: false,
    csp: false,
    staticImportMetaEnv: false,
    chromeDevtoolsWorkspace: false
  }
};
const highlighterTypesSchema = unionType([literalType("shiki"), literalType("prism")]).default(syntaxHighlightDefaults.type);
objectType({
  root: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.root).transform((val) => new URL(val)),
  srcDir: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.srcDir).transform((val) => new URL(val)),
  publicDir: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.publicDir).transform((val) => new URL(val)),
  outDir: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.outDir).transform((val) => new URL(val)),
  cacheDir: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.cacheDir).transform((val) => new URL(val)),
  site: stringType().url().optional(),
  compressHTML: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.compressHTML),
  base: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.base),
  trailingSlash: unionType([literalType("always"), literalType("never"), literalType("ignore")]).optional().default(ASTRO_CONFIG_DEFAULTS.trailingSlash),
  output: unionType([literalType("static"), literalType("server")]).optional().default("static"),
  scopedStyleStrategy: unionType([literalType("where"), literalType("class"), literalType("attribute")]).optional().default("attribute"),
  adapter: objectType({ name: stringType(), hooks: objectType({}).passthrough().default({}) }).optional(),
  integrations: preprocessType(
    // preprocess
    (val) => Array.isArray(val) ? val.flat(Infinity).filter(Boolean) : val,
    // validate
    arrayType(objectType({ name: stringType(), hooks: objectType({}).passthrough().default({}) })).default(ASTRO_CONFIG_DEFAULTS.integrations)
  ),
  build: objectType({
    format: unionType([literalType("file"), literalType("directory"), literalType("preserve")]).optional().default(ASTRO_CONFIG_DEFAULTS.build.format),
    client: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.build.client).transform((val) => new URL(val)),
    server: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.build.server).transform((val) => new URL(val)),
    assets: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.build.assets),
    assetsPrefix: stringType().optional().or(objectType({ fallback: stringType() }).and(recordType(stringType())).optional()),
    serverEntry: stringType().optional().default(ASTRO_CONFIG_DEFAULTS.build.serverEntry),
    redirects: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.build.redirects),
    inlineStylesheets: enumType(["always", "auto", "never"]).optional().default(ASTRO_CONFIG_DEFAULTS.build.inlineStylesheets),
    concurrency: numberType().min(1).optional().default(ASTRO_CONFIG_DEFAULTS.build.concurrency)
  }).default({}),
  server: preprocessType(
    // preprocess
    // NOTE: Uses the "error" command here because this is overwritten by the
    // individualized schema parser with the correct command.
    (val) => typeof val === "function" ? val({ command: "error" }) : val,
    // validate
    objectType({
      open: unionType([stringType(), booleanType()]).optional().default(ASTRO_CONFIG_DEFAULTS.server.open),
      host: unionType([stringType(), booleanType()]).optional().default(ASTRO_CONFIG_DEFAULTS.server.host),
      port: numberType().optional().default(ASTRO_CONFIG_DEFAULTS.server.port),
      headers: custom().optional(),
      allowedHosts: unionType([arrayType(stringType()), literalType(true)]).optional().default(ASTRO_CONFIG_DEFAULTS.server.allowedHosts)
    }).default({})
  ),
  redirects: recordType(
    stringType(),
    unionType([
      stringType(),
      objectType({
        status: unionType([
          literalType(300),
          literalType(301),
          literalType(302),
          literalType(303),
          literalType(304),
          literalType(307),
          literalType(308)
        ]),
        destination: stringType()
      })
    ])
  ).default(ASTRO_CONFIG_DEFAULTS.redirects),
  prefetch: unionType([
    booleanType(),
    objectType({
      prefetchAll: booleanType().optional(),
      defaultStrategy: enumType(["tap", "hover", "viewport", "load"]).optional()
    })
  ]).optional(),
  image: objectType({
    endpoint: objectType({
      route: literalType("/_image").or(stringType()).default(ASTRO_CONFIG_DEFAULTS.image.endpoint.route),
      entrypoint: stringType().optional()
    }).default(ASTRO_CONFIG_DEFAULTS.image.endpoint),
    service: objectType({
      entrypoint: unionType([literalType("astro/assets/services/sharp"), stringType()]).default(ASTRO_CONFIG_DEFAULTS.image.service.entrypoint),
      config: recordType(anyType()).default({})
    }).default(ASTRO_CONFIG_DEFAULTS.image.service),
    domains: arrayType(stringType()).default([]),
    remotePatterns: arrayType(
      objectType({
        protocol: stringType().optional(),
        hostname: stringType().optional(),
        port: stringType().optional(),
        pathname: stringType().optional()
      })
    ).default([]),
    layout: enumType(["constrained", "fixed", "full-width", "none"]).optional(),
    objectFit: stringType().optional(),
    objectPosition: stringType().optional(),
    breakpoints: arrayType(numberType()).optional(),
    responsiveStyles: booleanType().default(ASTRO_CONFIG_DEFAULTS.image.responsiveStyles)
  }).default(ASTRO_CONFIG_DEFAULTS.image),
  devToolbar: objectType({
    enabled: booleanType().default(ASTRO_CONFIG_DEFAULTS.devToolbar.enabled)
  }).default(ASTRO_CONFIG_DEFAULTS.devToolbar),
  markdown: objectType({
    syntaxHighlight: unionType([
      objectType({
        type: highlighterTypesSchema,
        excludeLangs: arrayType(stringType()).optional().default(syntaxHighlightDefaults.excludeLangs)
      }).default(syntaxHighlightDefaults),
      highlighterTypesSchema,
      literalType(false)
    ]).default(ASTRO_CONFIG_DEFAULTS.markdown.syntaxHighlight),
    shikiConfig: objectType({
      langs: custom().array().transform((langs) => {
        for (const lang of langs) {
          if (typeof lang === "object") {
            if (lang.id) {
              lang.name = lang.id;
            }
            if (lang.grammar) {
              Object.assign(lang, lang.grammar);
            }
          }
        }
        return langs;
      }).default([]),
      langAlias: recordType(stringType(), stringType()).optional().default(ASTRO_CONFIG_DEFAULTS.markdown.shikiConfig.langAlias),
      theme: enumType(Object.keys(bundledThemes)).or(custom()).default(ASTRO_CONFIG_DEFAULTS.markdown.shikiConfig.theme),
      themes: recordType(
        enumType(Object.keys(bundledThemes)).or(custom())
      ).default(ASTRO_CONFIG_DEFAULTS.markdown.shikiConfig.themes),
      defaultColor: unionType([literalType("light"), literalType("dark"), stringType(), literalType(false)]).optional(),
      wrap: booleanType().or(nullType()).default(ASTRO_CONFIG_DEFAULTS.markdown.shikiConfig.wrap),
      transformers: custom().array().default(ASTRO_CONFIG_DEFAULTS.markdown.shikiConfig.transformers)
    }).default({}),
    remarkPlugins: unionType([
      stringType(),
      tupleType([stringType(), anyType()]),
      custom((data) => typeof data === "function"),
      tupleType([custom((data) => typeof data === "function"), anyType()])
    ]).array().default(ASTRO_CONFIG_DEFAULTS.markdown.remarkPlugins),
    rehypePlugins: unionType([
      stringType(),
      tupleType([stringType(), anyType()]),
      custom((data) => typeof data === "function"),
      tupleType([custom((data) => typeof data === "function"), anyType()])
    ]).array().default(ASTRO_CONFIG_DEFAULTS.markdown.rehypePlugins),
    remarkRehype: custom((data) => data instanceof Object && !Array.isArray(data)).default(ASTRO_CONFIG_DEFAULTS.markdown.remarkRehype),
    gfm: booleanType().default(ASTRO_CONFIG_DEFAULTS.markdown.gfm),
    smartypants: booleanType().default(ASTRO_CONFIG_DEFAULTS.markdown.smartypants)
  }).default({}),
  vite: custom((data) => data instanceof Object && !Array.isArray(data)).default(ASTRO_CONFIG_DEFAULTS.vite),
  i18n: optionalType(
    objectType({
      defaultLocale: stringType(),
      locales: arrayType(
        unionType([
          stringType(),
          objectType({
            path: stringType(),
            codes: stringType().array().nonempty()
          })
        ])
      ),
      domains: recordType(
        stringType(),
        stringType().url(
          "The domain value must be a valid URL, and it has to start with 'https' or 'http'."
        )
      ).optional(),
      fallback: recordType(stringType(), stringType()).optional(),
      routing: literalType("manual").or(
        objectType({
          prefixDefaultLocale: booleanType().optional().default(false),
          // TODO: Astro 6.0 change to false
          redirectToDefaultLocale: booleanType().optional().default(true),
          fallbackType: enumType(["redirect", "rewrite"]).optional().default("redirect")
        })
      ).optional().default({})
    }).optional()
  ),
  security: objectType({
    checkOrigin: booleanType().default(ASTRO_CONFIG_DEFAULTS.security.checkOrigin)
  }).optional().default(ASTRO_CONFIG_DEFAULTS.security),
  env: objectType({
    schema: EnvSchema.optional().default(ASTRO_CONFIG_DEFAULTS.env.schema),
    validateSecrets: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.env.validateSecrets)
  }).strict().optional().default(ASTRO_CONFIG_DEFAULTS.env),
  session: objectType({
    driver: stringType().optional(),
    options: recordType(anyType()).optional(),
    cookie: objectType({
      name: stringType().optional(),
      domain: stringType().optional(),
      path: stringType().optional(),
      maxAge: numberType().optional(),
      sameSite: unionType([enumType(["strict", "lax", "none"]), booleanType()]).optional(),
      secure: booleanType().optional()
    }).or(stringType()).transform((val) => {
      if (typeof val === "string") {
        return { name: val };
      }
      return val;
    }).optional(),
    ttl: numberType().optional()
  }).optional(),
  experimental: objectType({
    clientPrerender: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.clientPrerender),
    contentIntellisense: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.contentIntellisense),
    headingIdCompat: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.headingIdCompat),
    preserveScriptOrder: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.preserveScriptOrder),
    fonts: arrayType(unionType([localFontFamilySchema, remoteFontFamilySchema])).optional(),
    liveContentCollections: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.liveContentCollections),
    csp: unionType([
      booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.csp),
      objectType({
        algorithm: cspAlgorithmSchema,
        directives: arrayType(allowedDirectivesSchema).optional(),
        styleDirective: objectType({
          resources: arrayType(stringType()).optional(),
          hashes: arrayType(cspHashSchema).optional()
        }).optional(),
        scriptDirective: objectType({
          resources: arrayType(stringType()).optional(),
          hashes: arrayType(cspHashSchema).optional(),
          strictDynamic: booleanType().optional()
        }).optional()
      })
    ]).optional().default(ASTRO_CONFIG_DEFAULTS.experimental.csp),
    staticImportMetaEnv: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.staticImportMetaEnv),
    chromeDevtoolsWorkspace: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.experimental.chromeDevtoolsWorkspace)
  }).strict(
    `Invalid or outdated experimental feature.
Check for incorrect spelling or outdated Astro version.
See https://docs.astro.build/en/reference/experimental-flags/ for a list of all current experiments.`
  ).default({}),
  legacy: objectType({
    collections: booleanType().optional().default(ASTRO_CONFIG_DEFAULTS.legacy.collections)
  }).default({})
});

custom().superRefine((config, ctx) => {
  if (config.build.assetsPrefix && typeof config.build.assetsPrefix !== "string" && !config.build.assetsPrefix.fallback) {
    ctx.addIssue({
      code: ZodIssueCode.custom,
      message: "The `fallback` is mandatory when defining the option as an object.",
      path: ["build", "assetsPrefix"]
    });
  }
  for (let i = 0; i < config.image.remotePatterns.length; i++) {
    const { hostname, pathname } = config.image.remotePatterns[i];
    if (hostname && hostname.includes("*") && !(hostname.startsWith("*.") || hostname.startsWith("**."))) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: "wildcards can only be placed at the beginning of the hostname",
        path: ["image", "remotePatterns", i, "hostname"]
      });
    }
    if (pathname && pathname.includes("*") && !(pathname.endsWith("/*") || pathname.endsWith("/**"))) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: "wildcards can only be placed at the end of a pathname",
        path: ["image", "remotePatterns", i, "pathname"]
      });
    }
  }
  if (config.outDir.toString().startsWith(config.publicDir.toString())) {
    ctx.addIssue({
      code: ZodIssueCode.custom,
      message: "The value of `outDir` must not point to a path within the folder set as `publicDir`, this will cause an infinite loop",
      path: ["outDir"]
    });
  }
  if (config.i18n) {
    const { defaultLocale, locales: _locales, fallback, domains } = config.i18n;
    const locales = _locales.map((locale) => {
      if (typeof locale === "string") {
        return locale;
      } else {
        return locale.path;
      }
    });
    if (!locales.includes(defaultLocale)) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: `The default locale \`${defaultLocale}\` is not present in the \`i18n.locales\` array.`,
        path: ["i18n", "locales"]
      });
    }
    if (fallback) {
      for (const [fallbackFrom, fallbackTo] of Object.entries(fallback)) {
        if (!locales.includes(fallbackFrom)) {
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: `The locale \`${fallbackFrom}\` key in the \`i18n.fallback\` record doesn't exist in the \`i18n.locales\` array.`,
            path: ["i18n", "fallbacks"]
          });
        }
        if (fallbackFrom === defaultLocale) {
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: `You can't use the default locale as a key. The default locale can only be used as value.`,
            path: ["i18n", "fallbacks"]
          });
        }
        if (!locales.includes(fallbackTo)) {
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: `The locale \`${fallbackTo}\` value in the \`i18n.fallback\` record doesn't exist in the \`i18n.locales\` array.`,
            path: ["i18n", "fallbacks"]
          });
        }
      }
    }
    if (domains) {
      const entries = Object.entries(domains);
      const hasDomains = domains ? Object.keys(domains).length > 0 : false;
      if (entries.length > 0 && !hasDomains) {
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: `When specifying some domains, the property \`i18n.routing.strategy\` must be set to \`"domains"\`.`,
          path: ["i18n", "routing", "strategy"]
        });
      }
      if (hasDomains) {
        if (!config.site) {
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: "The option `site` isn't set. When using the 'domains' strategy for `i18n`, `site` is required to create absolute URLs for locales that aren't mapped to a domain.",
            path: ["site"]
          });
        }
        if (config.output !== "server") {
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: 'Domain support is only available when `output` is `"server"`.',
            path: ["output"]
          });
        }
      }
      for (const [domainKey, domainValue] of entries) {
        if (!locales.includes(domainKey)) {
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: `The locale \`${domainKey}\` key in the \`i18n.domains\` record doesn't exist in the \`i18n.locales\` array.`,
            path: ["i18n", "domains"]
          });
        }
        if (!domainValue.startsWith("https") && !domainValue.startsWith("http")) {
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: "The domain value must be a valid URL, and it has to start with 'https' or 'http'.",
            path: ["i18n", "domains"]
          });
        } else {
          try {
            const domainUrl = new URL(domainValue);
            if (domainUrl.pathname !== "/") {
              ctx.addIssue({
                code: ZodIssueCode.custom,
                message: `The URL \`${domainValue}\` must contain only the origin. A subsequent pathname isn't allowed here. Remove \`${domainUrl.pathname}\`.`,
                path: ["i18n", "domains"]
              });
            }
          } catch {
          }
        }
      }
    }
  }
  if (config.experimental.fonts && config.experimental.fonts.length > 0) {
    for (let i = 0; i < config.experimental.fonts.length; i++) {
      const { cssVariable } = config.experimental.fonts[i];
      if (!cssVariable.startsWith("--") || cssVariable.includes(" ") || cssVariable.includes(":")) {
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: `**cssVariable** property "${cssVariable}" contains invalid characters for CSS variable generation. It must start with -- and be a valid indent: https://developer.mozilla.org/en-US/docs/Web/CSS/ident.`,
          path: ["fonts", i, "cssVariable"]
        });
      }
    }
  }
});

typeof process !== "undefined" && process.platform === "win32";

const decoder = new TextDecoder();
const toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
const toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i) => memo + ("0" + i.toString(16)).slice(-2), "");
const readInt16LE = (input, offset = 0) => {
  const val = input[offset] + input[offset + 1] * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
const readUInt16BE = (input, offset = 0) => input[offset] * 2 ** 8 + input[offset + 1];
const readUInt16LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8;
const readUInt24LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16;
const readInt32LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + (input[offset + 3] << 24);
const readUInt32BE = (input, offset = 0) => input[offset] * 2 ** 24 + input[offset + 1] * 2 ** 16 + input[offset + 2] * 2 ** 8 + input[offset + 3];
const readUInt32LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + input[offset + 3] * 2 ** 24;
const methods = {
  readUInt16BE,
  readUInt16LE,
  readUInt32BE,
  readUInt32LE
};
function readUInt(input, bits, offset, isBigEndian) {
  offset = offset || 0;
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = "readUInt" + bits + endian;
  return methods[methodName](input, offset);
}
function readBox(buffer, offset) {
  if (buffer.length - offset < 4) return;
  const boxSize = readUInt32BE(buffer, offset);
  if (buffer.length - offset < boxSize) return;
  return {
    name: toUTF8String(buffer, 4 + offset, 8 + offset),
    offset,
    size: boxSize
  };
}
function findBox(buffer, boxName, offset) {
  while (offset < buffer.length) {
    const box = readBox(buffer, offset);
    if (!box) break;
    if (box.name === boxName) return box;
    offset += box.size;
  }
}

const BMP = {
  validate: (input) => toUTF8String(input, 0, 2) === "BM",
  calculate: (input) => ({
    height: Math.abs(readInt32LE(input, 22)),
    width: readUInt32LE(input, 18)
  })
};

const TYPE_ICON = 1;
const SIZE_HEADER$1 = 2 + 2 + 2;
const SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
  const value = input[offset];
  return value === 0 ? 256 : value;
}
function getImageSize$1(input, imageIndex) {
  const offset = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset + 1),
    width: getSizeFromOffset(input, offset)
  };
}
const ICO = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_ICON;
  },
  calculate(input) {
    const nbImages = readUInt16LE(input, 4);
    const imageSize = getImageSize$1(input, 0);
    if (nbImages === 1) return imageSize;
    const imgs = [imageSize];
    for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
      imgs.push(getImageSize$1(input, imageIndex));
    }
    return {
      height: imageSize.height,
      images: imgs,
      width: imageSize.width
    };
  }
};

const TYPE_CURSOR = 2;
const CUR = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_CURSOR;
  },
  calculate: (input) => ICO.calculate(input)
};

const DDS = {
  validate: (input) => readUInt32LE(input, 0) === 542327876,
  calculate: (input) => ({
    height: readUInt32LE(input, 12),
    width: readUInt32LE(input, 16)
  })
};

const gifRegexp = /^GIF8[79]a/;
const GIF = {
  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),
  calculate: (input) => ({
    height: readUInt16LE(input, 8),
    width: readUInt16LE(input, 6)
  })
};

const brandMap = {
  avif: "avif",
  avis: "avif",
  // avif-sequence
  mif1: "heif",
  msf1: "heif",
  // heif-sequence
  heic: "heic",
  heix: "heic",
  hevc: "heic",
  // heic-sequence
  hevx: "heic"
  // heic-sequence
};
function detectBrands(buffer, start, end) {
  let brandsDetected = {};
  for (let i = start; i <= end; i += 4) {
    const brand = toUTF8String(buffer, i, i + 4);
    if (brand in brandMap) {
      brandsDetected[brand] = 1;
    }
  }
  if ("avif" in brandsDetected || "avis" in brandsDetected) {
    return "avif";
  } else if ("heic" in brandsDetected || "heix" in brandsDetected || "hevc" in brandsDetected || "hevx" in brandsDetected) {
    return "heic";
  } else if ("mif1" in brandsDetected || "msf1" in brandsDetected) {
    return "heif";
  }
}
const HEIF = {
  validate(buffer) {
    const ftype = toUTF8String(buffer, 4, 8);
    const brand = toUTF8String(buffer, 8, 12);
    return "ftyp" === ftype && brand in brandMap;
  },
  calculate(buffer) {
    const metaBox = findBox(buffer, "meta", 0);
    const iprpBox = metaBox && findBox(buffer, "iprp", metaBox.offset + 12);
    const ipcoBox = iprpBox && findBox(buffer, "ipco", iprpBox.offset + 8);
    const ispeBox = ipcoBox && findBox(buffer, "ispe", ipcoBox.offset + 8);
    if (ispeBox) {
      return {
        height: readUInt32BE(buffer, ispeBox.offset + 16),
        width: readUInt32BE(buffer, ispeBox.offset + 12),
        type: detectBrands(buffer, 8, metaBox.offset)
      };
    }
    throw new TypeError("Invalid HEIF, no size found");
  }
};

const SIZE_HEADER = 4 + 4;
const FILE_LENGTH_OFFSET = 4;
const ENTRY_LENGTH_OFFSET = 4;
const ICON_TYPE_SIZE = {
  ICON: 32,
  "ICN#": 32,
  // m => 16 x 16
  "icm#": 16,
  icm4: 16,
  icm8: 16,
  // s => 16 x 16
  "ics#": 16,
  ics4: 16,
  ics8: 16,
  is32: 16,
  s8mk: 16,
  icp4: 16,
  // l => 32 x 32
  icl4: 32,
  icl8: 32,
  il32: 32,
  l8mk: 32,
  icp5: 32,
  ic11: 32,
  // h => 48 x 48
  ich4: 48,
  ich8: 48,
  ih32: 48,
  h8mk: 48,
  // . => 64 x 64
  icp6: 64,
  ic12: 32,
  // t => 128 x 128
  it32: 128,
  t8mk: 128,
  ic07: 128,
  // . => 256 x 256
  ic08: 256,
  ic13: 256,
  // . => 512 x 512
  ic09: 512,
  ic14: 512,
  // . => 1024 x 1024
  ic10: 1024
};
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize(type) {
  const size = ICON_TYPE_SIZE[type];
  return { width: size, height: size, type };
}
const ICNS = {
  validate: (input) => toUTF8String(input, 0, 4) === "icns",
  calculate(input) {
    const inputLength = input.length;
    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
    let imageOffset = SIZE_HEADER;
    let imageHeader = readImageHeader(input, imageOffset);
    let imageSize = getImageSize(imageHeader[0]);
    imageOffset += imageHeader[1];
    if (imageOffset === fileLength) return imageSize;
    const result = {
      height: imageSize.height,
      images: [imageSize],
      width: imageSize.width
    };
    while (imageOffset < fileLength && imageOffset < inputLength) {
      imageHeader = readImageHeader(input, imageOffset);
      imageSize = getImageSize(imageHeader[0]);
      imageOffset += imageHeader[1];
      result.images.push(imageSize);
    }
    return result;
  }
};

const J2C = {
  // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
  validate: (input) => toHexString(input, 0, 4) === "ff4fff51",
  calculate: (input) => ({
    height: readUInt32BE(input, 12),
    width: readUInt32BE(input, 8)
  })
};

const JP2 = {
  validate(input) {
    if (readUInt32BE(input, 4) !== 1783636e3 || readUInt32BE(input, 0) < 1) return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    return readUInt32BE(input, ftypBox.offset + 4) === 1718909296;
  },
  calculate(input) {
    const jp2hBox = findBox(input, "jp2h", 0);
    const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
    if (ihdrBox) {
      return {
        height: readUInt32BE(input, ihdrBox.offset + 8),
        width: readUInt32BE(input, ihdrBox.offset + 12)
      };
    }
    throw new TypeError("Unsupported JPEG 2000 format");
  }
};

const EXIF_MARKER = "45786966";
const APP1_DATA_SIZE_BYTES = 2;
const EXIF_HEADER_BYTES = 6;
const TIFF_BYTE_ALIGN_BYTES = 2;
const BIG_ENDIAN_BYTE_ALIGN = "4d4d";
const LITTLE_ENDIAN_BYTE_ALIGN = "4949";
const IDF_ENTRY_BYTES = 12;
const NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index) {
  return {
    height: readUInt16BE(input, index),
    width: readUInt16BE(input, index + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end = start + IDF_ENTRY_BYTES;
    if (start > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start, end);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
  const byteAlign = toHexString(
    exifBlock,
    EXIF_HEADER_BYTES,
    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES
  );
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index) {
  if (index > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
const JPG = {
  validate: (input) => toHexString(input, 0, 2) === "ffd8",
  calculate(input) {
    input = input.slice(4);
    let orientation;
    let next;
    while (input.length) {
      const i = readUInt16BE(input, 0);
      if (input[i] !== 255) {
        input = input.slice(i);
        continue;
      }
      if (isEXIF(input)) {
        orientation = validateExifBlock(input, i);
      }
      validateInput(input, i);
      next = input[i + 1];
      if (next === 192 || next === 193 || next === 194) {
        const size = extractSize(input, i + 5);
        if (!orientation) {
          return size;
        }
        return {
          height: size.height,
          orientation,
          width: size.width
        };
      }
      input = input.slice(i + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
};

const KTX = {
  validate: (input) => {
    const signature = toUTF8String(input, 1, 7);
    return ["KTX 11", "KTX 20"].includes(signature);
  },
  calculate: (input) => {
    const type = input[5] === 49 ? "ktx" : "ktx2";
    const offset = type === "ktx" ? 36 : 20;
    return {
      height: readUInt32LE(input, offset + 4),
      width: readUInt32LE(input, offset),
      type
    };
  }
};

const pngSignature = "PNG\r\n\n";
const pngImageHeaderChunkName = "IHDR";
const pngFriedChunkName = "CgBI";
const PNG = {
  validate(input) {
    if (pngSignature === toUTF8String(input, 1, 8)) {
      let chunkName = toUTF8String(input, 12, 16);
      if (chunkName === pngFriedChunkName) {
        chunkName = toUTF8String(input, 28, 32);
      }
      if (chunkName !== pngImageHeaderChunkName) {
        throw new TypeError("Invalid PNG");
      }
      return true;
    }
    return false;
  },
  calculate(input) {
    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
      return {
        height: readUInt32BE(input, 36),
        width: readUInt32BE(input, 32)
      };
    }
    return {
      height: readUInt32BE(input, 20),
      width: readUInt32BE(input, 16)
    };
  }
};

const PNMTypes = {
  P1: "pbm/ascii",
  P2: "pgm/ascii",
  P3: "ppm/ascii",
  P4: "pbm",
  P5: "pgm",
  P6: "ppm",
  P7: "pam",
  PF: "pfm"
};
const handlers = {
  default: (lines) => {
    let dimensions = [];
    while (lines.length > 0) {
      const line = lines.shift();
      if (line[0] === "#") {
        continue;
      }
      dimensions = line.split(" ");
      break;
    }
    if (dimensions.length === 2) {
      return {
        height: parseInt(dimensions[1], 10),
        width: parseInt(dimensions[0], 10)
      };
    } else {
      throw new TypeError("Invalid PNM");
    }
  },
  pam: (lines) => {
    const size = {};
    while (lines.length > 0) {
      const line = lines.shift();
      if (line.length > 16 || line.charCodeAt(0) > 128) {
        continue;
      }
      const [key, value] = line.split(" ");
      if (key && value) {
        size[key.toLowerCase()] = parseInt(value, 10);
      }
      if (size.height && size.width) {
        break;
      }
    }
    if (size.height && size.width) {
      return {
        height: size.height,
        width: size.width
      };
    } else {
      throw new TypeError("Invalid PAM");
    }
  }
};
const PNM = {
  validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,
  calculate(input) {
    const signature = toUTF8String(input, 0, 2);
    const type = PNMTypes[signature];
    const lines = toUTF8String(input, 3).split(/[\r\n]+/);
    const handler = handlers[type] || handlers.default;
    return handler(lines);
  }
};

const PSD = {
  validate: (input) => toUTF8String(input, 0, 4) === "8BPS",
  calculate: (input) => ({
    height: readUInt32BE(input, 14),
    width: readUInt32BE(input, 18)
  })
};

const svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
const extractorRegExps = {
  height: /\sheight=(['"])([^%]+?)\1/,
  root: svgReg,
  viewbox: /\sviewBox=(['"])(.+?)\1/i,
  width: /\swidth=(['"])([^%]+?)\1/
};
const INCH_CM = 2.54;
const units = {
  in: 96,
  cm: 96 / INCH_CM,
  em: 16,
  ex: 8,
  m: 96 / INCH_CM * 100,
  mm: 96 / INCH_CM / 10,
  pc: 96 / 72 / 12,
  pt: 96 / 72,
  px: 1
};
const unitsReg = new RegExp(
  `^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`
);
function parseLength(len) {
  const m = unitsReg.exec(len);
  if (!m) {
    return void 0;
  }
  return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root) {
  const width = extractorRegExps.width.exec(root);
  const height = extractorRegExps.height.exec(root);
  const viewbox = extractorRegExps.viewbox.exec(root);
  return {
    height: height && parseLength(height[2]),
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
const SVG = {
  // Scan only the first kilo-byte to speed up the check on larger files
  validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),
  calculate(input) {
    const root = extractorRegExps.root.exec(toUTF8String(input));
    if (root) {
      const attrs = parseAttributes(root[0]);
      if (attrs.width && attrs.height) {
        return calculateByDimensions(attrs);
      }
      if (attrs.viewbox) {
        return calculateByViewbox(attrs, attrs.viewbox);
      }
    }
    throw new TypeError("Invalid SVG");
  }
};

const TGA = {
  validate(input) {
    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
  },
  calculate(input) {
    return {
      height: readUInt16LE(input, 14),
      width: readUInt16LE(input, 12)
    };
  }
};

function readIFD(input, isBigEndian) {
  const ifdOffset = readUInt(input, 32, 4, isBigEndian);
  return input.slice(ifdOffset + 2);
}
function readValue(input, isBigEndian) {
  const low = readUInt(input, 16, 8, isBigEndian);
  const high = readUInt(input, 16, 10, isBigEndian);
  return (high << 16) + low;
}
function nextTag(input) {
  if (input.length > 24) {
    return input.slice(12);
  }
}
function extractTags(input, isBigEndian) {
  const tags = {};
  let temp = input;
  while (temp && temp.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type = readUInt(temp, 16, 2, isBigEndian);
    const length = readUInt(temp, 32, 4, isBigEndian);
    if (code === 0) {
      break;
    } else {
      if (length === 1 && (type === 3 || type === 4)) {
        tags[code] = readValue(temp, isBigEndian);
      }
      temp = nextTag(temp);
    }
  }
  return tags;
}
function determineEndianness(input) {
  const signature = toUTF8String(input, 0, 2);
  if ("II" === signature) {
    return "LE";
  } else if ("MM" === signature) {
    return "BE";
  }
}
const signatures = [
  // '492049', // currently not supported
  "49492a00",
  // Little endian
  "4d4d002a"
  // Big Endian
  // '4d4d002a', // BigTIFF > 4GB. currently not supported
];
const TIFF = {
  validate: (input) => signatures.includes(toHexString(input, 0, 4)),
  calculate(input) {
    const isBigEndian = determineEndianness(input) === "BE";
    const ifdBuffer = readIFD(input, isBigEndian);
    const tags = extractTags(ifdBuffer, isBigEndian);
    const width = tags[256];
    const height = tags[257];
    if (!width || !height) {
      throw new TypeError("Invalid Tiff. Missing tags");
    }
    return { height, width };
  }
};

function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
const WEBP = {
  validate(input) {
    const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
    const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
    const vp8Header = "VP8" === toUTF8String(input, 12, 15);
    return riffHeader && webpHeader && vp8Header;
  },
  calculate(input) {
    const chunkHeader = toUTF8String(input, 12, 16);
    input = input.slice(20, 30);
    if (chunkHeader === "VP8X") {
      const extendedHeader = input[0];
      const validStart = (extendedHeader & 192) === 0;
      const validEnd = (extendedHeader & 1) === 0;
      if (validStart && validEnd) {
        return calculateExtended(input);
      } else {
        throw new TypeError("Invalid WebP");
      }
    }
    if (chunkHeader === "VP8 " && input[0] !== 47) {
      return calculateLossy(input);
    }
    const signature = toHexString(input, 3, 6);
    if (chunkHeader === "VP8L" && signature !== "9d012a") {
      return calculateLossless(input);
    }
    throw new TypeError("Invalid WebP");
  }
};

const typeHandlers = /* @__PURE__ */ new Map([
  ["bmp", BMP],
  ["cur", CUR],
  ["dds", DDS],
  ["gif", GIF],
  ["heif", HEIF],
  ["icns", ICNS],
  ["ico", ICO],
  ["j2c", J2C],
  ["jp2", JP2],
  ["jpg", JPG],
  ["ktx", KTX],
  ["png", PNG],
  ["pnm", PNM],
  ["psd", PSD],
  ["svg", SVG],
  ["tga", TGA],
  ["tiff", TIFF],
  ["webp", WEBP]
]);
const types$2 = Array.from(typeHandlers.keys());

const entryTypeSchema = objectType({
  id: stringType({
    invalid_type_error: "Content entry `id` must be a string"
    // Default to empty string so we can validate properly in the loader
  })
}).passthrough();
unionType([
  arrayType(entryTypeSchema),
  recordType(
    stringType(),
    objectType({
      id: stringType({
        invalid_type_error: "Content entry `id` must be a string"
      }).optional()
    }).passthrough()
  )
]);
const collectionConfigParser = unionType([
  objectType({
    type: literalType("content").optional().default("content"),
    schema: anyType().optional()
  }),
  objectType({
    type: literalType("data"),
    schema: anyType().optional()
  }),
  objectType({
    type: literalType(CONTENT_LAYER_TYPE),
    schema: anyType().optional(),
    loader: unionType([
      functionType(),
      objectType({
        name: stringType(),
        load: functionType(
          tupleType(
            [
              objectType({
                collection: stringType(),
                store: anyType(),
                meta: anyType(),
                logger: anyType(),
                config: anyType(),
                entryTypes: anyType(),
                parseData: anyType(),
                renderMarkdown: anyType(),
                generateDigest: functionType(tupleType([anyType()], stringType())),
                watcher: anyType().optional(),
                refreshContextData: recordType(unknownType()).optional()
              })
            ],
            unknownType()
          )
        ),
        schema: anyType().optional(),
        render: functionType(tupleType([anyType()], unknownType())).optional()
      })
    ]),
    /** deprecated */
    _legacy: booleanType().optional()
  }),
  objectType({
    type: literalType(LIVE_CONTENT_TYPE).optional().default(LIVE_CONTENT_TYPE),
    schema: anyType().optional(),
    loader: functionType()
  })
]);
objectType({
  collections: recordType(collectionConfigParser)
});

var ciInfo = {};

const require$$0 = [
	{
		name: "Agola CI",
		constant: "AGOLA",
		env: "AGOLA_GIT_REF",
		pr: "AGOLA_PULL_REQUEST_ID"
	},
	{
		name: "Appcircle",
		constant: "APPCIRCLE",
		env: "AC_APPCIRCLE",
		pr: {
			env: "AC_GIT_PR",
			ne: "false"
		}
	},
	{
		name: "AppVeyor",
		constant: "APPVEYOR",
		env: "APPVEYOR",
		pr: "APPVEYOR_PULL_REQUEST_NUMBER"
	},
	{
		name: "AWS CodeBuild",
		constant: "CODEBUILD",
		env: "CODEBUILD_BUILD_ARN",
		pr: {
			env: "CODEBUILD_WEBHOOK_EVENT",
			any: [
				"PULL_REQUEST_CREATED",
				"PULL_REQUEST_UPDATED",
				"PULL_REQUEST_REOPENED"
			]
		}
	},
	{
		name: "Azure Pipelines",
		constant: "AZURE_PIPELINES",
		env: "TF_BUILD",
		pr: {
			BUILD_REASON: "PullRequest"
		}
	},
	{
		name: "Bamboo",
		constant: "BAMBOO",
		env: "bamboo_planKey"
	},
	{
		name: "Bitbucket Pipelines",
		constant: "BITBUCKET",
		env: "BITBUCKET_COMMIT",
		pr: "BITBUCKET_PR_ID"
	},
	{
		name: "Bitrise",
		constant: "BITRISE",
		env: "BITRISE_IO",
		pr: "BITRISE_PULL_REQUEST"
	},
	{
		name: "Buddy",
		constant: "BUDDY",
		env: "BUDDY_WORKSPACE_ID",
		pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
	},
	{
		name: "Buildkite",
		constant: "BUILDKITE",
		env: "BUILDKITE",
		pr: {
			env: "BUILDKITE_PULL_REQUEST",
			ne: "false"
		}
	},
	{
		name: "CircleCI",
		constant: "CIRCLE",
		env: "CIRCLECI",
		pr: "CIRCLE_PULL_REQUEST"
	},
	{
		name: "Cirrus CI",
		constant: "CIRRUS",
		env: "CIRRUS_CI",
		pr: "CIRRUS_PR"
	},
	{
		name: "Cloudflare Pages",
		constant: "CLOUDFLARE_PAGES",
		env: "CF_PAGES"
	},
	{
		name: "Cloudflare Workers",
		constant: "CLOUDFLARE_WORKERS",
		env: "WORKERS_CI"
	},
	{
		name: "Codefresh",
		constant: "CODEFRESH",
		env: "CF_BUILD_ID",
		pr: {
			any: [
				"CF_PULL_REQUEST_NUMBER",
				"CF_PULL_REQUEST_ID"
			]
		}
	},
	{
		name: "Codemagic",
		constant: "CODEMAGIC",
		env: "CM_BUILD_ID",
		pr: "CM_PULL_REQUEST"
	},
	{
		name: "Codeship",
		constant: "CODESHIP",
		env: {
			CI_NAME: "codeship"
		}
	},
	{
		name: "Drone",
		constant: "DRONE",
		env: "DRONE",
		pr: {
			DRONE_BUILD_EVENT: "pull_request"
		}
	},
	{
		name: "dsari",
		constant: "DSARI",
		env: "DSARI"
	},
	{
		name: "Earthly",
		constant: "EARTHLY",
		env: "EARTHLY_CI"
	},
	{
		name: "Expo Application Services",
		constant: "EAS",
		env: "EAS_BUILD"
	},
	{
		name: "Gerrit",
		constant: "GERRIT",
		env: "GERRIT_PROJECT"
	},
	{
		name: "Gitea Actions",
		constant: "GITEA_ACTIONS",
		env: "GITEA_ACTIONS"
	},
	{
		name: "GitHub Actions",
		constant: "GITHUB_ACTIONS",
		env: "GITHUB_ACTIONS",
		pr: {
			GITHUB_EVENT_NAME: "pull_request"
		}
	},
	{
		name: "GitLab CI",
		constant: "GITLAB",
		env: "GITLAB_CI",
		pr: "CI_MERGE_REQUEST_ID"
	},
	{
		name: "GoCD",
		constant: "GOCD",
		env: "GO_PIPELINE_LABEL"
	},
	{
		name: "Google Cloud Build",
		constant: "GOOGLE_CLOUD_BUILD",
		env: "BUILDER_OUTPUT"
	},
	{
		name: "Harness CI",
		constant: "HARNESS",
		env: "HARNESS_BUILD_ID"
	},
	{
		name: "Heroku",
		constant: "HEROKU",
		env: {
			env: "NODE",
			includes: "/app/.heroku/node/bin/node"
		}
	},
	{
		name: "Hudson",
		constant: "HUDSON",
		env: "HUDSON_URL"
	},
	{
		name: "Jenkins",
		constant: "JENKINS",
		env: [
			"JENKINS_URL",
			"BUILD_ID"
		],
		pr: {
			any: [
				"ghprbPullId",
				"CHANGE_ID"
			]
		}
	},
	{
		name: "LayerCI",
		constant: "LAYERCI",
		env: "LAYERCI",
		pr: "LAYERCI_PULL_REQUEST"
	},
	{
		name: "Magnum CI",
		constant: "MAGNUM",
		env: "MAGNUM"
	},
	{
		name: "Netlify CI",
		constant: "NETLIFY",
		env: "NETLIFY",
		pr: {
			env: "PULL_REQUEST",
			ne: "false"
		}
	},
	{
		name: "Nevercode",
		constant: "NEVERCODE",
		env: "NEVERCODE",
		pr: {
			env: "NEVERCODE_PULL_REQUEST",
			ne: "false"
		}
	},
	{
		name: "Prow",
		constant: "PROW",
		env: "PROW_JOB_ID"
	},
	{
		name: "ReleaseHub",
		constant: "RELEASEHUB",
		env: "RELEASE_BUILD_ID"
	},
	{
		name: "Render",
		constant: "RENDER",
		env: "RENDER",
		pr: {
			IS_PULL_REQUEST: "true"
		}
	},
	{
		name: "Sail CI",
		constant: "SAIL",
		env: "SAILCI",
		pr: "SAIL_PULL_REQUEST_NUMBER"
	},
	{
		name: "Screwdriver",
		constant: "SCREWDRIVER",
		env: "SCREWDRIVER",
		pr: {
			env: "SD_PULL_REQUEST",
			ne: "false"
		}
	},
	{
		name: "Semaphore",
		constant: "SEMAPHORE",
		env: "SEMAPHORE",
		pr: "PULL_REQUEST_NUMBER"
	},
	{
		name: "Sourcehut",
		constant: "SOURCEHUT",
		env: {
			CI_NAME: "sourcehut"
		}
	},
	{
		name: "Strider CD",
		constant: "STRIDER",
		env: "STRIDER"
	},
	{
		name: "TaskCluster",
		constant: "TASKCLUSTER",
		env: [
			"TASK_ID",
			"RUN_ID"
		]
	},
	{
		name: "TeamCity",
		constant: "TEAMCITY",
		env: "TEAMCITY_VERSION"
	},
	{
		name: "Travis CI",
		constant: "TRAVIS",
		env: "TRAVIS",
		pr: {
			env: "TRAVIS_PULL_REQUEST",
			ne: "false"
		}
	},
	{
		name: "Vela",
		constant: "VELA",
		env: "VELA",
		pr: {
			VELA_PULL_REQUEST: "1"
		}
	},
	{
		name: "Vercel",
		constant: "VERCEL",
		env: {
			any: [
				"NOW_BUILDER",
				"VERCEL"
			]
		},
		pr: "VERCEL_GIT_PULL_REQUEST_ID"
	},
	{
		name: "Visual Studio App Center",
		constant: "APPCENTER",
		env: "APPCENTER_BUILD_ID"
	},
	{
		name: "Woodpecker",
		constant: "WOODPECKER",
		env: {
			CI: "woodpecker"
		},
		pr: {
			CI_BUILD_EVENT: "pull_request"
		}
	},
	{
		name: "Xcode Cloud",
		constant: "XCODE_CLOUD",
		env: "CI_XCODE_PROJECT",
		pr: "CI_PULL_REQUEST_NUMBER"
	},
	{
		name: "Xcode Server",
		constant: "XCODE_SERVER",
		env: "XCS"
	}
];

var hasRequiredCiInfo;

function requireCiInfo () {
	if (hasRequiredCiInfo) return ciInfo;
	hasRequiredCiInfo = 1;
	(function (exports$1) {

		const vendors = require$$0;

		const env = process.env;

		// Used for testing only
		Object.defineProperty(exports$1, '_vendors', {
		  value: vendors.map(function (v) {
		    return v.constant
		  })
		});

		exports$1.name = null;
		exports$1.isPR = null;
		exports$1.id = null;

		if (env.CI !== 'false') {
		  vendors.forEach(function (vendor) {
		    const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
		    const isCI = envs.every(function (obj) {
		      return checkEnv(obj)
		    });

		    exports$1[vendor.constant] = isCI;

		    if (!isCI) {
		      return
		    }

		    exports$1.name = vendor.name;
		    exports$1.isPR = checkPR(vendor);
		    exports$1.id = vendor.constant;
		  });
		}

		exports$1.isCI = !!(
		  env.CI !== 'false' && // Bypass all checks if CI env is explicitly set to 'false'
		  (env.BUILD_ID || // Jenkins, Cloudbees
		    env.BUILD_NUMBER || // Jenkins, TeamCity
		    env.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari, Cloudflare Pages/Workers
		    env.CI_APP_ID || // Appflow
		    env.CI_BUILD_ID || // Appflow
		    env.CI_BUILD_NUMBER || // Appflow
		    env.CI_NAME || // Codeship and others
		    env.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
		    env.RUN_ID || // TaskCluster, dsari
		    exports$1.name ||
		    false)
		);

		function checkEnv (obj) {
		  // "env": "CIRRUS"
		  if (typeof obj === 'string') return !!env[obj]

		  // "env": { "env": "NODE", "includes": "/app/.heroku/node/bin/node" }
		  if ('env' in obj) {
		    // Currently there are no other types, uncomment when there are
		    // if ('includes' in obj) {
		    return env[obj.env] && env[obj.env].includes(obj.includes)
		    // }
		  }

		  if ('any' in obj) {
		    return obj.any.some(function (k) {
		      return !!env[k]
		    })
		  }

		  return Object.keys(obj).every(function (k) {
		    return env[k] === obj[k]
		  })
		}

		function checkPR (vendor) {
		  switch (typeof vendor.pr) {
		    case 'string':
		      // "pr": "CIRRUS_PR"
		      return !!env[vendor.pr]
		    case 'object':
		      if ('env' in vendor.pr) {
		        if ('any' in vendor.pr) {
		          // "pr": { "env": "CODEBUILD_WEBHOOK_EVENT", "any": ["PULL_REQUEST_CREATED", "PULL_REQUEST_UPDATED"] }
		          return vendor.pr.any.some(function (key) {
		            return env[vendor.pr.env] === key
		          })
		        } else {
		          // "pr": { "env": "BUILDKITE_PULL_REQUEST", "ne": "false" }
		          return vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne
		        }
		      } else if ('any' in vendor.pr) {
		        // "pr": { "any": ["ghprbPullId", "CHANGE_ID"] }
		        return vendor.pr.any.some(function (key) {
		          return !!env[key]
		        })
		      } else {
		        // "pr": { "DRONE_BUILD_EVENT": "pull_request" }
		        return checkEnv(vendor.pr)
		      }
		    default:
		      // PR detection not supported for this vendor
		      return null
		  }
		} 
	} (ciInfo));
	return ciInfo;
}

requireCiInfo();

var src$1 = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(/\s+/g, ',')
				.split(',')
				.filter(Boolean);

			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}

		/**
		 * Checks if the given string matches a namespace template, honoring
		 * asterisks as wildcards.
		 *
		 * @param {String} search
		 * @param {String} template
		 * @return {Boolean}
		 */
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;

			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					// Match character or proceed with wildcard
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++; // Skip the '*'
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
					// Backtrack to the last '*' and try to match more characters
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false; // No match
				}
			}

			// Handle trailing '*' in template
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}

			return templateIndex === template.length;
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}

			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports$1) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.storage = localstorage();
		exports$1.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports$1.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			let m;

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			// eslint-disable-next-line no-return-assign
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports$1.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports$1.storage.setItem('debug', namespaces);
				} else {
					exports$1.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports$1.storage.getItem('debug') || exports$1.storage.getItem('DEBUG') ;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports$1);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var node$2 = {exports: {}};

var supportsColor;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor;
	hasRequiredSupportsColor = 1;
	var argv = process.argv;

	var terminator = argv.indexOf('--');
	var hasFlag = function (flag) {
		flag = '--' + flag;
		var pos = argv.indexOf(flag);
		return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
	};

	supportsColor = (function () {
		if ('FORCE_COLOR' in process.env) {
			return true;
		}

		if (hasFlag('no-color') ||
			hasFlag('no-colors') ||
			hasFlag('color=false')) {
			return false;
		}

		if (hasFlag('color') ||
			hasFlag('colors') ||
			hasFlag('color=true') ||
			hasFlag('color=always')) {
			return true;
		}

		if (process.stdout && !process.stdout.isTTY) {
			return false;
		}

		if (process.platform === 'win32') {
			return true;
		}

		if ('COLORTERM' in process.env) {
			return true;
		}

		if (process.env.TERM === 'dumb') {
			return false;
		}

		if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
			return true;
		}

		return false;
	})();
	return supportsColor;
}

/**
 * Module dependencies.
 */

var hasRequiredNode$2;

function requireNode$2 () {
	if (hasRequiredNode$2) return node$2.exports;
	hasRequiredNode$2 = 1;
	(function (module, exports$1) {
		const tty = require$$0$3;
		const util = require$$1$1;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports$1.init = init;
		exports$1.log = log;
		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports$1.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports$1.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports$1.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports$1.inspectOpts ?
				Boolean(exports$1.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports$1.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.formatWithOptions(exports$1.inspectOpts, ...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports$1.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports$1);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node$2, node$2.exports));
	return node$2.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc$1;

function requireSrc$1 () {
	if (hasRequiredSrc$1) return src$1.exports;
	hasRequiredSrc$1 = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src$1.exports = requireBrowser();
	} else {
		src$1.exports = requireNode$2();
	}
	return src$1.exports;
}

var srcExports = requireSrc$1();
const createDebugger = /*@__PURE__*/getDefaultExportFromCjs$1(srcExports);

let isDockerCached;

function hasDockerEnv() {
	try {
		fs__default.statSync('/.dockerenv');
		return true;
	} catch {
		return false;
	}
}

function hasDockerCGroup() {
	try {
		return fs__default.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
	} catch {
		return false;
	}
}

function isDocker() {
	// TODO: Use `??=` when targeting Node.js 16.
	if (isDockerCached === undefined) {
		isDockerCached = hasDockerEnv() || hasDockerCGroup();
	}

	return isDockerCached;
}

let cachedResult;

// Podman detection
const hasContainerEnv = () => {
	try {
		fs__default.statSync('/run/.containerenv');
		return true;
	} catch {
		return false;
	}
};

function isInsideContainer() {
	// TODO: Use `??=` when targeting Node.js 16.
	if (cachedResult === undefined) {
		cachedResult = hasContainerEnv() || isDocker();
	}

	return cachedResult;
}

const isWsl = () => {
	if (process$1.platform !== 'linux') {
		return false;
	}

	if (os.release().toLowerCase().includes('microsoft')) {
		if (isInsideContainer()) {
			return false;
		}

		return true;
	}

	try {
		return fs__default.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft')
			? !isInsideContainer() : false;
	} catch {
		return false;
	}
};

process$1.env.__IS_WSL_TEST__ ? isWsl : isWsl();

const debuggers = {};
function debug$1(type, ...messages) {
  const namespace = `astro:${type}`;
  debuggers[namespace] = debuggers[namespace] || createDebugger(namespace);
  return debuggers[namespace](...messages);
}
globalThis._astroGlobalDebug = debug$1;

new RegExp('\\' + path$b.posix.sep, 'g');
new RegExp('\\' + path$b.sep, 'g');
const TS_EXTENSIONS = ['.ts', '.tsx', '.mts', '.cts'];
const JS_EXTENSIONS = ['.js', '.jsx', '.mjs', '.cjs'];
const TSJS_EXTENSIONS = TS_EXTENSIONS.concat(JS_EXTENSIONS);
`\\.(?:${TS_EXTENSIONS.map((ext) => ext.substring(1)).join('|')})`;
`\\.(?:${TSJS_EXTENSIONS.map((ext) => ext.substring(1)).join(
	'|'
)})`;
path$b.posix.sep === path$b.sep;

/**
 * @typedef WalkState
 * @interface
 * @property {string[]} files - files
 * @property {number} calls - number of ongoing calls
 * @property {(dir: string)=>boolean} skip - function to skip dirs
 * @property {boolean} err - error flag
 * @property {string[]} configNames - config file names
 */

path$b.sep;

new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

new RegExp(`\\${win32.sep}`, 'g');

const reservedWords$1 = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
const builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
const forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins}`.split(' '));
forbiddenIdentifiers.add('');

new AstroError({
  ...UnknownContentCollectionError,
  message: `Unexpected error while parsing content entry IDs and slugs.`
});

createRequire$2(import.meta.url);

var prompts$2 = {};

var kleur;
var hasRequiredKleur;

function requireKleur () {
	if (hasRequiredKleur) return kleur;
	hasRequiredKleur = 1;

	const { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env;

	const $ = {
		enabled: !NODE_DISABLE_COLORS && TERM !== 'dumb' && FORCE_COLOR !== '0',

		// modifiers
		reset: init(0, 0),
		bold: init(1, 22),
		dim: init(2, 22),
		italic: init(3, 23),
		underline: init(4, 24),
		inverse: init(7, 27),
		hidden: init(8, 28),
		strikethrough: init(9, 29),

		// colors
		black: init(30, 39),
		red: init(31, 39),
		green: init(32, 39),
		yellow: init(33, 39),
		blue: init(34, 39),
		magenta: init(35, 39),
		cyan: init(36, 39),
		white: init(37, 39),
		gray: init(90, 39),
		grey: init(90, 39),

		// background colors
		bgBlack: init(40, 49),
		bgRed: init(41, 49),
		bgGreen: init(42, 49),
		bgYellow: init(43, 49),
		bgBlue: init(44, 49),
		bgMagenta: init(45, 49),
		bgCyan: init(46, 49),
		bgWhite: init(47, 49)
	};

	function run(arr, str) {
		let i=0, tmp, beg='', end='';
		for (; i < arr.length; i++) {
			tmp = arr[i];
			beg += tmp.open;
			end += tmp.close;
			if (str.includes(tmp.close)) {
				str = str.replace(tmp.rgx, tmp.close + tmp.open);
			}
		}
		return beg + str + end;
	}

	function chain(has, keys) {
		let ctx = { has, keys };

		ctx.reset = $.reset.bind(ctx);
		ctx.bold = $.bold.bind(ctx);
		ctx.dim = $.dim.bind(ctx);
		ctx.italic = $.italic.bind(ctx);
		ctx.underline = $.underline.bind(ctx);
		ctx.inverse = $.inverse.bind(ctx);
		ctx.hidden = $.hidden.bind(ctx);
		ctx.strikethrough = $.strikethrough.bind(ctx);

		ctx.black = $.black.bind(ctx);
		ctx.red = $.red.bind(ctx);
		ctx.green = $.green.bind(ctx);
		ctx.yellow = $.yellow.bind(ctx);
		ctx.blue = $.blue.bind(ctx);
		ctx.magenta = $.magenta.bind(ctx);
		ctx.cyan = $.cyan.bind(ctx);
		ctx.white = $.white.bind(ctx);
		ctx.gray = $.gray.bind(ctx);
		ctx.grey = $.grey.bind(ctx);

		ctx.bgBlack = $.bgBlack.bind(ctx);
		ctx.bgRed = $.bgRed.bind(ctx);
		ctx.bgGreen = $.bgGreen.bind(ctx);
		ctx.bgYellow = $.bgYellow.bind(ctx);
		ctx.bgBlue = $.bgBlue.bind(ctx);
		ctx.bgMagenta = $.bgMagenta.bind(ctx);
		ctx.bgCyan = $.bgCyan.bind(ctx);
		ctx.bgWhite = $.bgWhite.bind(ctx);

		return ctx;
	}

	function init(open, close) {
		let blk = {
			open: `\x1b[${open}m`,
			close: `\x1b[${close}m`,
			rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
		};
		return function (txt) {
			if (this !== void 0 && this.has !== void 0) {
				this.has.includes(open) || (this.has.push(open),this.keys.push(blk));
				return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
			}
			return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
		};
	}

	kleur = $;
	return kleur;
}

var action$1;
var hasRequiredAction$1;

function requireAction$1 () {
	if (hasRequiredAction$1) return action$1;
	hasRequiredAction$1 = 1;

	action$1 = (key, isSelect) => {
	  if (key.meta && key.name !== 'escape') return;

	  if (key.ctrl) {
	    if (key.name === 'a') return 'first';
	    if (key.name === 'c') return 'abort';
	    if (key.name === 'd') return 'abort';
	    if (key.name === 'e') return 'last';
	    if (key.name === 'g') return 'reset';
	  }

	  if (isSelect) {
	    if (key.name === 'j') return 'down';
	    if (key.name === 'k') return 'up';
	  }

	  if (key.name === 'return') return 'submit';
	  if (key.name === 'enter') return 'submit'; // ctrl + J

	  if (key.name === 'backspace') return 'delete';
	  if (key.name === 'delete') return 'deleteForward';
	  if (key.name === 'abort') return 'abort';
	  if (key.name === 'escape') return 'exit';
	  if (key.name === 'tab') return 'next';
	  if (key.name === 'pagedown') return 'nextPage';
	  if (key.name === 'pageup') return 'prevPage'; // TODO create home() in prompt types (e.g. TextPrompt)

	  if (key.name === 'home') return 'home'; // TODO create end() in prompt types (e.g. TextPrompt)

	  if (key.name === 'end') return 'end';
	  if (key.name === 'up') return 'up';
	  if (key.name === 'down') return 'down';
	  if (key.name === 'right') return 'right';
	  if (key.name === 'left') return 'left';
	  return false;
	};
	return action$1;
}

var strip$1;
var hasRequiredStrip$1;

function requireStrip$1 () {
	if (hasRequiredStrip$1) return strip$1;
	hasRequiredStrip$1 = 1;

	strip$1 = str => {
	  const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'].join('|');
	  const RGX = new RegExp(pattern, 'g');
	  return typeof str === 'string' ? str.replace(RGX, '') : str;
	};
	return strip$1;
}

var src;
var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;

	const ESC = '\x1B';
	const CSI = `${ESC}[`;
	const beep = '\u0007';

	const cursor = {
	  to(x, y) {
	    if (!y) return `${CSI}${x + 1}G`;
	    return `${CSI}${y + 1};${x + 1}H`;
	  },
	  move(x, y) {
	    let ret = '';

	    if (x < 0) ret += `${CSI}${-x}D`;
	    else if (x > 0) ret += `${CSI}${x}C`;

	    if (y < 0) ret += `${CSI}${-y}A`;
	    else if (y > 0) ret += `${CSI}${y}B`;

	    return ret;
	  },
	  up: (count = 1) => `${CSI}${count}A`,
	  down: (count = 1) => `${CSI}${count}B`,
	  forward: (count = 1) => `${CSI}${count}C`,
	  backward: (count = 1) => `${CSI}${count}D`,
	  nextLine: (count = 1) => `${CSI}E`.repeat(count),
	  prevLine: (count = 1) => `${CSI}F`.repeat(count),
	  left: `${CSI}G`,
	  hide: `${CSI}?25l`,
	  show: `${CSI}?25h`,
	  save: `${ESC}7`,
	  restore: `${ESC}8`
	};

	const scroll = {
	  up: (count = 1) => `${CSI}S`.repeat(count),
	  down: (count = 1) => `${CSI}T`.repeat(count)
	};

	const erase = {
	  screen: `${CSI}2J`,
	  up: (count = 1) => `${CSI}1J`.repeat(count),
	  down: (count = 1) => `${CSI}J`.repeat(count),
	  line: `${CSI}2K`,
	  lineEnd: `${CSI}K`,
	  lineStart: `${CSI}1K`,
	  lines(count) {
	    let clear = '';
	    for (let i = 0; i < count; i++)
	      clear += this.line + (i < count - 1 ? cursor.up() : '');
	    if (count)
	      clear += cursor.left;
	    return clear;
	  }
	};

	src = { cursor, scroll, erase, beep };
	return src;
}

var clear$1;
var hasRequiredClear$1;

function requireClear$1 () {
	if (hasRequiredClear$1) return clear$1;
	hasRequiredClear$1 = 1;

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

	const strip = requireStrip$1();

	const _require = requireSrc(),
	      erase = _require.erase,
	      cursor = _require.cursor;

	const width = str => [...strip(str)].length;
	/**
	 * @param {string} prompt
	 * @param {number} perLine
	 */


	clear$1 = function (prompt, perLine) {
	  if (!perLine) return erase.line + cursor.to(0);
	  let rows = 0;
	  const lines = prompt.split(/\r?\n/);

	  var _iterator = _createForOfIteratorHelper(lines),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      let line = _step.value;
	      rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  return erase.lines(rows);
	};
	return clear$1;
}

var figures_1$1;
var hasRequiredFigures$1;

function requireFigures$1 () {
	if (hasRequiredFigures$1) return figures_1$1;
	hasRequiredFigures$1 = 1;

	const main = {
	  arrowUp: '↑',
	  arrowDown: '↓',
	  arrowLeft: '←',
	  arrowRight: '→',
	  radioOn: '◉',
	  radioOff: '◯',
	  tick: '✔',
	  cross: '✖',
	  ellipsis: '…',
	  pointerSmall: '›',
	  line: '─',
	  pointer: '❯'
	};
	const win = {
	  arrowUp: main.arrowUp,
	  arrowDown: main.arrowDown,
	  arrowLeft: main.arrowLeft,
	  arrowRight: main.arrowRight,
	  radioOn: '(*)',
	  radioOff: '( )',
	  tick: '√',
	  cross: '×',
	  ellipsis: '...',
	  pointerSmall: '»',
	  line: '─',
	  pointer: '>'
	};
	const figures = process.platform === 'win32' ? win : main;
	figures_1$1 = figures;
	return figures_1$1;
}

var style$1;
var hasRequiredStyle$1;

function requireStyle$1 () {
	if (hasRequiredStyle$1) return style$1;
	hasRequiredStyle$1 = 1;

	const c = requireKleur();

	const figures = requireFigures$1(); // rendering user input.


	const styles = Object.freeze({
	  password: {
	    scale: 1,
	    render: input => '*'.repeat(input.length)
	  },
	  emoji: {
	    scale: 2,
	    render: input => '😃'.repeat(input.length)
	  },
	  invisible: {
	    scale: 0,
	    render: input => ''
	  },
	  default: {
	    scale: 1,
	    render: input => `${input}`
	  }
	});

	const render = type => styles[type] || styles.default; // icon to signalize a prompt.


	const symbols = Object.freeze({
	  aborted: c.red(figures.cross),
	  done: c.green(figures.tick),
	  exited: c.yellow(figures.cross),
	  default: c.cyan('?')
	});

	const symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default; // between the question and the user's input.


	const delimiter = completing => c.gray(completing ? figures.ellipsis : figures.pointerSmall);

	const item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : '+' : figures.line);

	style$1 = {
	  styles,
	  render,
	  symbols,
	  symbol,
	  delimiter,
	  item
	};
	return style$1;
}

var lines$1;
var hasRequiredLines$1;

function requireLines$1 () {
	if (hasRequiredLines$1) return lines$1;
	hasRequiredLines$1 = 1;

	const strip = requireStrip$1();
	/**
	 * @param {string} msg
	 * @param {number} perLine
	 */


	lines$1 = function (msg, perLine) {
	  let lines = String(strip(msg) || '').split(/\r?\n/);
	  if (!perLine) return lines.length;
	  return lines.map(l => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
	};
	return lines$1;
}

var wrap$1;
var hasRequiredWrap$1;

function requireWrap$1 () {
	if (hasRequiredWrap$1) return wrap$1;
	hasRequiredWrap$1 = 1;
	/**
	 * @param {string} msg The message to wrap
	 * @param {object} opts
	 * @param {number|string} [opts.margin] Left margin
	 * @param {number} opts.width Maximum characters per line including the margin
	 */

	wrap$1 = (msg, opts = {}) => {
	  const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(' ').join('') : opts.margin || '';
	  const width = opts.width;
	  return (msg || '').split(/\r?\n/g).map(line => line.split(/\s+/g).reduce((arr, w) => {
	    if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width) arr[arr.length - 1] += ` ${w}`;else arr.push(`${tab}${w}`);
	    return arr;
	  }, [tab]).join('\n')).join('\n');
	};
	return wrap$1;
}

var entriesToDisplay$1;
var hasRequiredEntriesToDisplay$1;

function requireEntriesToDisplay$1 () {
	if (hasRequiredEntriesToDisplay$1) return entriesToDisplay$1;
	hasRequiredEntriesToDisplay$1 = 1;
	/**
	 * Determine what entries should be displayed on the screen, based on the
	 * currently selected index and the maximum visible. Used in list-based
	 * prompts like `select` and `multiselect`.
	 *
	 * @param {number} cursor the currently selected entry
	 * @param {number} total the total entries available to display
	 * @param {number} [maxVisible] the number of entries that can be displayed
	 */

	entriesToDisplay$1 = (cursor, total, maxVisible) => {
	  maxVisible = maxVisible || total;
	  let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
	  if (startIndex < 0) startIndex = 0;
	  let endIndex = Math.min(startIndex + maxVisible, total);
	  return {
	    startIndex,
	    endIndex
	  };
	};
	return entriesToDisplay$1;
}

var util$2;
var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;

	util$2 = {
	  action: requireAction$1(),
	  clear: requireClear$1(),
	  style: requireStyle$1(),
	  strip: requireStrip$1(),
	  figures: requireFigures$1(),
	  lines: requireLines$1(),
	  wrap: requireWrap$1(),
	  entriesToDisplay: requireEntriesToDisplay$1()
	};
	return util$2;
}

var prompt$1;
var hasRequiredPrompt$1;

function requirePrompt$1 () {
	if (hasRequiredPrompt$1) return prompt$1;
	hasRequiredPrompt$1 = 1;

	const readline = require$$0$a;

	const _require = requireUtil$2(),
	      action = _require.action;

	const EventEmitter = require$$0$7;

	const _require2 = requireSrc(),
	      beep = _require2.beep,
	      cursor = _require2.cursor;

	const color = requireKleur();
	/**
	 * Base prompt skeleton
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */


	class Prompt extends EventEmitter {
	  constructor(opts = {}) {
	    super();
	    this.firstRender = true;
	    this.in = opts.stdin || process.stdin;
	    this.out = opts.stdout || process.stdout;

	    this.onRender = (opts.onRender || (() => void 0)).bind(this);

	    const rl = readline.createInterface({
	      input: this.in,
	      escapeCodeTimeout: 50
	    });
	    readline.emitKeypressEvents(this.in, rl);
	    if (this.in.isTTY) this.in.setRawMode(true);
	    const isSelect = ['SelectPrompt', 'MultiselectPrompt'].indexOf(this.constructor.name) > -1;

	    const keypress = (str, key) => {
	      let a = action(key, isSelect);

	      if (a === false) {
	        this._ && this._(str, key);
	      } else if (typeof this[a] === 'function') {
	        this[a](key);
	      } else {
	        this.bell();
	      }
	    };

	    this.close = () => {
	      this.out.write(cursor.show);
	      this.in.removeListener('keypress', keypress);
	      if (this.in.isTTY) this.in.setRawMode(false);
	      rl.close();
	      this.emit(this.aborted ? 'abort' : this.exited ? 'exit' : 'submit', this.value);
	      this.closed = true;
	    };

	    this.in.on('keypress', keypress);
	  }

	  fire() {
	    this.emit('state', {
	      value: this.value,
	      aborted: !!this.aborted,
	      exited: !!this.exited
	    });
	  }

	  bell() {
	    this.out.write(beep);
	  }

	  render() {
	    this.onRender(color);
	    if (this.firstRender) this.firstRender = false;
	  }

	}

	prompt$1 = Prompt;
	return prompt$1;
}

var text$2;
var hasRequiredText$1;

function requireText$1 () {
	if (hasRequiredText$1) return text$2;
	hasRequiredText$1 = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	const color = requireKleur();

	const Prompt = requirePrompt$1();

	const _require = requireSrc(),
	      erase = _require.erase,
	      cursor = _require.cursor;

	const _require2 = requireUtil$2(),
	      style = _require2.style,
	      clear = _require2.clear,
	      lines = _require2.lines,
	      figures = _require2.figures;
	/**
	 * TextPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {String} [opts.style='default'] Render style
	 * @param {String} [opts.initial] Default value
	 * @param {Function} [opts.validate] Validate function
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.error] The invalid error label
	 */


	class TextPrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.transform = style.render(opts.style);
	    this.scale = this.transform.scale;
	    this.msg = opts.message;
	    this.initial = opts.initial || ``;

	    this.validator = opts.validate || (() => true);

	    this.value = ``;
	    this.errorMsg = opts.error || `Please Enter A Valid Value`;
	    this.cursor = Number(!!this.initial);
	    this.cursorOffset = 0;
	    this.clear = clear(``, this.out.columns);
	    this.render();
	  }

	  set value(v) {
	    if (!v && this.initial) {
	      this.placeholder = true;
	      this.rendered = color.gray(this.transform.render(this.initial));
	    } else {
	      this.placeholder = false;
	      this.rendered = this.transform.render(v);
	    }

	    this._value = v;
	    this.fire();
	  }

	  get value() {
	    return this._value;
	  }

	  reset() {
	    this.value = ``;
	    this.cursor = Number(!!this.initial);
	    this.cursorOffset = 0;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.value = this.value || this.initial;
	    this.done = this.aborted = true;
	    this.error = false;
	    this.red = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  validate() {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      let valid = yield _this.validator(_this.value);

	      if (typeof valid === `string`) {
	        _this.errorMsg = valid;
	        valid = false;
	      }

	      _this.error = !valid;
	    })();
	  }

	  submit() {
	    var _this2 = this;

	    return _asyncToGenerator(function* () {
	      _this2.value = _this2.value || _this2.initial;
	      _this2.cursorOffset = 0;
	      _this2.cursor = _this2.rendered.length;
	      yield _this2.validate();

	      if (_this2.error) {
	        _this2.red = true;

	        _this2.fire();

	        _this2.render();

	        return;
	      }

	      _this2.done = true;
	      _this2.aborted = false;

	      _this2.fire();

	      _this2.render();

	      _this2.out.write('\n');

	      _this2.close();
	    })();
	  }

	  next() {
	    if (!this.placeholder) return this.bell();
	    this.value = this.initial;
	    this.cursor = this.rendered.length;
	    this.fire();
	    this.render();
	  }

	  moveCursor(n) {
	    if (this.placeholder) return;
	    this.cursor = this.cursor + n;
	    this.cursorOffset += n;
	  }

	  _(c, key) {
	    let s1 = this.value.slice(0, this.cursor);
	    let s2 = this.value.slice(this.cursor);
	    this.value = `${s1}${c}${s2}`;
	    this.red = false;
	    this.cursor = this.placeholder ? 0 : s1.length + 1;
	    this.render();
	  }

	  delete() {
	    if (this.isCursorAtStart()) return this.bell();
	    let s1 = this.value.slice(0, this.cursor - 1);
	    let s2 = this.value.slice(this.cursor);
	    this.value = `${s1}${s2}`;
	    this.red = false;

	    if (this.isCursorAtStart()) {
	      this.cursorOffset = 0;
	    } else {
	      this.cursorOffset++;
	      this.moveCursor(-1);
	    }

	    this.render();
	  }

	  deleteForward() {
	    if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
	    let s1 = this.value.slice(0, this.cursor);
	    let s2 = this.value.slice(this.cursor + 1);
	    this.value = `${s1}${s2}`;
	    this.red = false;

	    if (this.isCursorAtEnd()) {
	      this.cursorOffset = 0;
	    } else {
	      this.cursorOffset++;
	    }

	    this.render();
	  }

	  first() {
	    this.cursor = 0;
	    this.render();
	  }

	  last() {
	    this.cursor = this.value.length;
	    this.render();
	  }

	  left() {
	    if (this.cursor <= 0 || this.placeholder) return this.bell();
	    this.moveCursor(-1);
	    this.render();
	  }

	  right() {
	    if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
	    this.moveCursor(1);
	    this.render();
	  }

	  isCursorAtStart() {
	    return this.cursor === 0 || this.placeholder && this.cursor === 1;
	  }

	  isCursorAtEnd() {
	    return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
	  }

	  render() {
	    if (this.closed) return;

	    if (!this.firstRender) {
	      if (this.outputError) this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
	      this.out.write(clear(this.outputText, this.out.columns));
	    }

	    super.render();
	    this.outputError = '';
	    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(` `);

	    if (this.error) {
	      this.outputError += this.errorMsg.split(`\n`).reduce((a, l, i) => a + `\n${i ? ' ' : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
	  }

	}

	text$2 = TextPrompt;
	return text$2;
}

var select$1;
var hasRequiredSelect$1;

function requireSelect$1 () {
	if (hasRequiredSelect$1) return select$1;
	hasRequiredSelect$1 = 1;

	const color = requireKleur();

	const Prompt = requirePrompt$1();

	const _require = requireUtil$2(),
	      style = _require.style,
	      clear = _require.clear,
	      figures = _require.figures,
	      wrap = _require.wrap,
	      entriesToDisplay = _require.entriesToDisplay;

	const _require2 = requireSrc(),
	      cursor = _require2.cursor;
	/**
	 * SelectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {Number} [opts.initial] Index of default value
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {Number} [opts.optionsPerPage=10] Max options to display at once
	 */


	class SelectPrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.msg = opts.message;
	    this.hint = opts.hint || '- Use arrow-keys. Return to submit.';
	    this.warn = opts.warn || '- This option is disabled';
	    this.cursor = opts.initial || 0;
	    this.choices = opts.choices.map((ch, idx) => {
	      if (typeof ch === 'string') ch = {
	        title: ch,
	        value: idx
	      };
	      return {
	        title: ch && (ch.title || ch.value || ch),
	        value: ch && (ch.value === undefined ? idx : ch.value),
	        description: ch && ch.description,
	        selected: ch && ch.selected,
	        disabled: ch && ch.disabled
	      };
	    });
	    this.optionsPerPage = opts.optionsPerPage || 10;
	    this.value = (this.choices[this.cursor] || {}).value;
	    this.clear = clear('', this.out.columns);
	    this.render();
	  }

	  moveCursor(n) {
	    this.cursor = n;
	    this.value = this.choices[n].value;
	    this.fire();
	  }

	  reset() {
	    this.moveCursor(0);
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    if (!this.selection.disabled) {
	      this.done = true;
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    } else this.bell();
	  }

	  first() {
	    this.moveCursor(0);
	    this.render();
	  }

	  last() {
	    this.moveCursor(this.choices.length - 1);
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.moveCursor(this.choices.length - 1);
	    } else {
	      this.moveCursor(this.cursor - 1);
	    }

	    this.render();
	  }

	  down() {
	    if (this.cursor === this.choices.length - 1) {
	      this.moveCursor(0);
	    } else {
	      this.moveCursor(this.cursor + 1);
	    }

	    this.render();
	  }

	  next() {
	    this.moveCursor((this.cursor + 1) % this.choices.length);
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') return this.submit();
	  }

	  get selection() {
	    return this.choices[this.cursor];
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    let _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage),
	        startIndex = _entriesToDisplay.startIndex,
	        endIndex = _entriesToDisplay.endIndex; // Print prompt


	    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(' '); // Print choices

	    if (!this.done) {
	      this.outputText += '\n';

	      for (let i = startIndex; i < endIndex; i++) {
	        let title,
	            prefix,
	            desc = '',
	            v = this.choices[i]; // Determine whether to display "more choices" indicators

	        if (i === startIndex && startIndex > 0) {
	          prefix = figures.arrowUp;
	        } else if (i === endIndex - 1 && endIndex < this.choices.length) {
	          prefix = figures.arrowDown;
	        } else {
	          prefix = ' ';
	        }

	        if (v.disabled) {
	          title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	          prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + ' ' : '  ') + prefix;
	        } else {
	          title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
	          prefix = (this.cursor === i ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;

	          if (v.description && this.cursor === i) {
	            desc = ` - ${v.description}`;

	            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
	              desc = '\n' + wrap(v.description, {
	                margin: 3,
	                width: this.out.columns
	              });
	            }
	          }
	        }

	        this.outputText += `${prefix} ${title}${color.gray(desc)}\n`;
	      }
	    }

	    this.out.write(this.outputText);
	  }

	}

	select$1 = SelectPrompt;
	return select$1;
}

var toggle$1;
var hasRequiredToggle$1;

function requireToggle$1 () {
	if (hasRequiredToggle$1) return toggle$1;
	hasRequiredToggle$1 = 1;

	const color = requireKleur();

	const Prompt = requirePrompt$1();

	const _require = requireUtil$2(),
	      style = _require.style,
	      clear = _require.clear;

	const _require2 = requireSrc(),
	      cursor = _require2.cursor,
	      erase = _require2.erase;
	/**
	 * TogglePrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Boolean} [opts.initial=false] Default value
	 * @param {String} [opts.active='no'] Active label
	 * @param {String} [opts.inactive='off'] Inactive label
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */


	class TogglePrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.msg = opts.message;
	    this.value = !!opts.initial;
	    this.active = opts.active || 'on';
	    this.inactive = opts.inactive || 'off';
	    this.initialValue = this.value;
	    this.render();
	  }

	  reset() {
	    this.value = this.initialValue;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  deactivate() {
	    if (this.value === false) return this.bell();
	    this.value = false;
	    this.render();
	  }

	  activate() {
	    if (this.value === true) return this.bell();
	    this.value = true;
	    this.render();
	  }

	  delete() {
	    this.deactivate();
	  }

	  left() {
	    this.deactivate();
	  }

	  right() {
	    this.activate();
	  }

	  down() {
	    this.deactivate();
	  }

	  up() {
	    this.activate();
	  }

	  next() {
	    this.value = !this.value;
	    this.fire();
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.value = !this.value;
	    } else if (c === '1') {
	      this.value = true;
	    } else if (c === '0') {
	      this.value = false;
	    } else return this.bell();

	    this.render();
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();
	    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray('/'), this.value ? color.cyan().underline(this.active) : this.active].join(' ');
	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }

	}

	toggle$1 = TogglePrompt;
	return toggle$1;
}

var datepart$1;
var hasRequiredDatepart$1;

function requireDatepart$1 () {
	if (hasRequiredDatepart$1) return datepart$1;
	hasRequiredDatepart$1 = 1;

	class DatePart {
	  constructor({
	    token,
	    date,
	    parts,
	    locales
	  }) {
	    this.token = token;
	    this.date = date || new Date();
	    this.parts = parts || [this];
	    this.locales = locales || {};
	  }

	  up() {}

	  down() {}

	  next() {
	    const currentIdx = this.parts.indexOf(this);
	    return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
	  }

	  setTo(val) {}

	  prev() {
	    let parts = [].concat(this.parts).reverse();
	    const currentIdx = parts.indexOf(this);
	    return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
	  }

	  toString() {
	    return String(this.date);
	  }

	}

	datepart$1 = DatePart;
	return datepart$1;
}

var meridiem$1;
var hasRequiredMeridiem$1;

function requireMeridiem$1 () {
	if (hasRequiredMeridiem$1) return meridiem$1;
	hasRequiredMeridiem$1 = 1;

	const DatePart = requireDatepart$1();

	class Meridiem extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setHours((this.date.getHours() + 12) % 24);
	  }

	  down() {
	    this.up();
	  }

	  toString() {
	    let meridiem = this.date.getHours() > 12 ? 'pm' : 'am';
	    return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
	  }

	}

	meridiem$1 = Meridiem;
	return meridiem$1;
}

var day$1;
var hasRequiredDay$1;

function requireDay$1 () {
	if (hasRequiredDay$1) return day$1;
	hasRequiredDay$1 = 1;

	const DatePart = requireDatepart$1();

	const pos = n => {
	  n = n % 10;
	  return n === 1 ? 'st' : n === 2 ? 'nd' : n === 3 ? 'rd' : 'th';
	};

	class Day extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setDate(this.date.getDate() + 1);
	  }

	  down() {
	    this.date.setDate(this.date.getDate() - 1);
	  }

	  setTo(val) {
	    this.date.setDate(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let date = this.date.getDate();
	    let day = this.date.getDay();
	    return this.token === 'DD' ? String(date).padStart(2, '0') : this.token === 'Do' ? date + pos(date) : this.token === 'd' ? day + 1 : this.token === 'ddd' ? this.locales.weekdaysShort[day] : this.token === 'dddd' ? this.locales.weekdays[day] : date;
	  }

	}

	day$1 = Day;
	return day$1;
}

var hours$1;
var hasRequiredHours$1;

function requireHours$1 () {
	if (hasRequiredHours$1) return hours$1;
	hasRequiredHours$1 = 1;

	const DatePart = requireDatepart$1();

	class Hours extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setHours(this.date.getHours() + 1);
	  }

	  down() {
	    this.date.setHours(this.date.getHours() - 1);
	  }

	  setTo(val) {
	    this.date.setHours(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let hours = this.date.getHours();
	    if (/h/.test(this.token)) hours = hours % 12 || 12;
	    return this.token.length > 1 ? String(hours).padStart(2, '0') : hours;
	  }

	}

	hours$1 = Hours;
	return hours$1;
}

var milliseconds$1;
var hasRequiredMilliseconds$1;

function requireMilliseconds$1 () {
	if (hasRequiredMilliseconds$1) return milliseconds$1;
	hasRequiredMilliseconds$1 = 1;

	const DatePart = requireDatepart$1();

	class Milliseconds extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
	  }

	  down() {
	    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
	  }

	  setTo(val) {
	    this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
	  }

	  toString() {
	    return String(this.date.getMilliseconds()).padStart(4, '0').substr(0, this.token.length);
	  }

	}

	milliseconds$1 = Milliseconds;
	return milliseconds$1;
}

var minutes$1;
var hasRequiredMinutes$1;

function requireMinutes$1 () {
	if (hasRequiredMinutes$1) return minutes$1;
	hasRequiredMinutes$1 = 1;

	const DatePart = requireDatepart$1();

	class Minutes extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMinutes(this.date.getMinutes() + 1);
	  }

	  down() {
	    this.date.setMinutes(this.date.getMinutes() - 1);
	  }

	  setTo(val) {
	    this.date.setMinutes(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let m = this.date.getMinutes();
	    return this.token.length > 1 ? String(m).padStart(2, '0') : m;
	  }

	}

	minutes$1 = Minutes;
	return minutes$1;
}

var month$1;
var hasRequiredMonth$1;

function requireMonth$1 () {
	if (hasRequiredMonth$1) return month$1;
	hasRequiredMonth$1 = 1;

	const DatePart = requireDatepart$1();

	class Month extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMonth(this.date.getMonth() + 1);
	  }

	  down() {
	    this.date.setMonth(this.date.getMonth() - 1);
	  }

	  setTo(val) {
	    val = parseInt(val.substr(-2)) - 1;
	    this.date.setMonth(val < 0 ? 0 : val);
	  }

	  toString() {
	    let month = this.date.getMonth();
	    let tl = this.token.length;
	    return tl === 2 ? String(month + 1).padStart(2, '0') : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
	  }

	}

	month$1 = Month;
	return month$1;
}

var seconds$1;
var hasRequiredSeconds$1;

function requireSeconds$1 () {
	if (hasRequiredSeconds$1) return seconds$1;
	hasRequiredSeconds$1 = 1;

	const DatePart = requireDatepart$1();

	class Seconds extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setSeconds(this.date.getSeconds() + 1);
	  }

	  down() {
	    this.date.setSeconds(this.date.getSeconds() - 1);
	  }

	  setTo(val) {
	    this.date.setSeconds(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let s = this.date.getSeconds();
	    return this.token.length > 1 ? String(s).padStart(2, '0') : s;
	  }

	}

	seconds$1 = Seconds;
	return seconds$1;
}

var year$1;
var hasRequiredYear$1;

function requireYear$1 () {
	if (hasRequiredYear$1) return year$1;
	hasRequiredYear$1 = 1;

	const DatePart = requireDatepart$1();

	class Year extends DatePart {
	  constructor(opts = {}) {
	    super(opts);
	  }

	  up() {
	    this.date.setFullYear(this.date.getFullYear() + 1);
	  }

	  down() {
	    this.date.setFullYear(this.date.getFullYear() - 1);
	  }

	  setTo(val) {
	    this.date.setFullYear(val.substr(-4));
	  }

	  toString() {
	    let year = String(this.date.getFullYear()).padStart(4, '0');
	    return this.token.length === 2 ? year.substr(-2) : year;
	  }

	}

	year$1 = Year;
	return year$1;
}

var dateparts$1;
var hasRequiredDateparts$1;

function requireDateparts$1 () {
	if (hasRequiredDateparts$1) return dateparts$1;
	hasRequiredDateparts$1 = 1;

	dateparts$1 = {
	  DatePart: requireDatepart$1(),
	  Meridiem: requireMeridiem$1(),
	  Day: requireDay$1(),
	  Hours: requireHours$1(),
	  Milliseconds: requireMilliseconds$1(),
	  Minutes: requireMinutes$1(),
	  Month: requireMonth$1(),
	  Seconds: requireSeconds$1(),
	  Year: requireYear$1()
	};
	return dateparts$1;
}

var date$1;
var hasRequiredDate$1;

function requireDate$1 () {
	if (hasRequiredDate$1) return date$1;
	hasRequiredDate$1 = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	const color = requireKleur();

	const Prompt = requirePrompt$1();

	const _require = requireUtil$2(),
	      style = _require.style,
	      clear = _require.clear,
	      figures = _require.figures;

	const _require2 = requireSrc(),
	      erase = _require2.erase,
	      cursor = _require2.cursor;

	const _require3 = requireDateparts$1(),
	      DatePart = _require3.DatePart,
	      Meridiem = _require3.Meridiem,
	      Day = _require3.Day,
	      Hours = _require3.Hours,
	      Milliseconds = _require3.Milliseconds,
	      Minutes = _require3.Minutes,
	      Month = _require3.Month,
	      Seconds = _require3.Seconds,
	      Year = _require3.Year;

	const regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
	const regexGroups = {
	  1: ({
	    token
	  }) => token.replace(/\\(.)/g, '$1'),
	  2: opts => new Day(opts),
	  // Day // TODO
	  3: opts => new Month(opts),
	  // Month
	  4: opts => new Year(opts),
	  // Year
	  5: opts => new Meridiem(opts),
	  // AM/PM // TODO (special)
	  6: opts => new Hours(opts),
	  // Hours
	  7: opts => new Minutes(opts),
	  // Minutes
	  8: opts => new Seconds(opts),
	  // Seconds
	  9: opts => new Milliseconds(opts) // Fractional seconds

	};
	const dfltLocales = {
	  months: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
	  monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
	  weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
	  weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(',')
	};
	/**
	 * DatePrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Number} [opts.initial] Index of default value
	 * @param {String} [opts.mask] The format mask
	 * @param {object} [opts.locales] The date locales
	 * @param {String} [opts.error] The error message shown on invalid value
	 * @param {Function} [opts.validate] Function to validate the submitted value
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */

	class DatePrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.msg = opts.message;
	    this.cursor = 0;
	    this.typed = '';
	    this.locales = Object.assign(dfltLocales, opts.locales);
	    this._date = opts.initial || new Date();
	    this.errorMsg = opts.error || 'Please Enter A Valid Value';

	    this.validator = opts.validate || (() => true);

	    this.mask = opts.mask || 'YYYY-MM-DD HH:mm:ss';
	    this.clear = clear('', this.out.columns);
	    this.render();
	  }

	  get value() {
	    return this.date;
	  }

	  get date() {
	    return this._date;
	  }

	  set date(date) {
	    if (date) this._date.setTime(date.getTime());
	  }

	  set mask(mask) {
	    let result;
	    this.parts = [];

	    while (result = regex.exec(mask)) {
	      let match = result.shift();
	      let idx = result.findIndex(gr => gr != null);
	      this.parts.push(idx in regexGroups ? regexGroups[idx]({
	        token: result[idx] || match,
	        date: this.date,
	        parts: this.parts,
	        locales: this.locales
	      }) : result[idx] || match);
	    }

	    let parts = this.parts.reduce((arr, i) => {
	      if (typeof i === 'string' && typeof arr[arr.length - 1] === 'string') arr[arr.length - 1] += i;else arr.push(i);
	      return arr;
	    }, []);
	    this.parts.splice(0);
	    this.parts.push(...parts);
	    this.reset();
	  }

	  moveCursor(n) {
	    this.typed = '';
	    this.cursor = n;
	    this.fire();
	  }

	  reset() {
	    this.moveCursor(this.parts.findIndex(p => p instanceof DatePart));
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  validate() {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      let valid = yield _this.validator(_this.value);

	      if (typeof valid === 'string') {
	        _this.errorMsg = valid;
	        valid = false;
	      }

	      _this.error = !valid;
	    })();
	  }

	  submit() {
	    var _this2 = this;

	    return _asyncToGenerator(function* () {
	      yield _this2.validate();

	      if (_this2.error) {
	        _this2.color = 'red';

	        _this2.fire();

	        _this2.render();

	        return;
	      }

	      _this2.done = true;
	      _this2.aborted = false;

	      _this2.fire();

	      _this2.render();

	      _this2.out.write('\n');

	      _this2.close();
	    })();
	  }

	  up() {
	    this.typed = '';
	    this.parts[this.cursor].up();
	    this.render();
	  }

	  down() {
	    this.typed = '';
	    this.parts[this.cursor].down();
	    this.render();
	  }

	  left() {
	    let prev = this.parts[this.cursor].prev();
	    if (prev == null) return this.bell();
	    this.moveCursor(this.parts.indexOf(prev));
	    this.render();
	  }

	  right() {
	    let next = this.parts[this.cursor].next();
	    if (next == null) return this.bell();
	    this.moveCursor(this.parts.indexOf(next));
	    this.render();
	  }

	  next() {
	    let next = this.parts[this.cursor].next();
	    this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex(part => part instanceof DatePart));
	    this.render();
	  }

	  _(c) {
	    if (/\d/.test(c)) {
	      this.typed += c;
	      this.parts[this.cursor].setTo(this.typed);
	      this.render();
	    }
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);else this.out.write(clear(this.outputText, this.out.columns));
	    super.render(); // Print prompt

	    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join('')].join(' '); // Print error

	    if (this.error) {
	      this.outputText += this.errorMsg.split('\n').reduce((a, l, i) => a + `\n${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }

	}

	date$1 = DatePrompt;
	return date$1;
}

var number$1;
var hasRequiredNumber$1;

function requireNumber$1 () {
	if (hasRequiredNumber$1) return number$1;
	hasRequiredNumber$1 = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	const color = requireKleur();

	const Prompt = requirePrompt$1();

	const _require = requireSrc(),
	      cursor = _require.cursor,
	      erase = _require.erase;

	const _require2 = requireUtil$2(),
	      style = _require2.style,
	      figures = _require2.figures,
	      clear = _require2.clear,
	      lines = _require2.lines;

	const isNumber = /[0-9]/;

	const isDef = any => any !== undefined;

	const round = (number, precision) => {
	  let factor = Math.pow(10, precision);
	  return Math.round(number * factor) / factor;
	};
	/**
	 * NumberPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {String} [opts.style='default'] Render style
	 * @param {Number} [opts.initial] Default value
	 * @param {Number} [opts.max=+Infinity] Max value
	 * @param {Number} [opts.min=-Infinity] Min value
	 * @param {Boolean} [opts.float=false] Parse input as floats
	 * @param {Number} [opts.round=2] Round floats to x decimals
	 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
	 * @param {Function} [opts.validate] Validate function
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.error] The invalid error label
	 */


	class NumberPrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.transform = style.render(opts.style);
	    this.msg = opts.message;
	    this.initial = isDef(opts.initial) ? opts.initial : '';
	    this.float = !!opts.float;
	    this.round = opts.round || 2;
	    this.inc = opts.increment || 1;
	    this.min = isDef(opts.min) ? opts.min : -Infinity;
	    this.max = isDef(opts.max) ? opts.max : Infinity;
	    this.errorMsg = opts.error || `Please Enter A Valid Value`;

	    this.validator = opts.validate || (() => true);

	    this.color = `cyan`;
	    this.value = ``;
	    this.typed = ``;
	    this.lastHit = 0;
	    this.render();
	  }

	  set value(v) {
	    if (!v && v !== 0) {
	      this.placeholder = true;
	      this.rendered = color.gray(this.transform.render(`${this.initial}`));
	      this._value = ``;
	    } else {
	      this.placeholder = false;
	      this.rendered = this.transform.render(`${round(v, this.round)}`);
	      this._value = round(v, this.round);
	    }

	    this.fire();
	  }

	  get value() {
	    return this._value;
	  }

	  parse(x) {
	    return this.float ? parseFloat(x) : parseInt(x);
	  }

	  valid(c) {
	    return c === `-` || c === `.` && this.float || isNumber.test(c);
	  }

	  reset() {
	    this.typed = ``;
	    this.value = ``;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    let x = this.value;
	    this.value = x !== `` ? x : this.initial;
	    this.done = this.aborted = true;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write(`\n`);
	    this.close();
	  }

	  validate() {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      let valid = yield _this.validator(_this.value);

	      if (typeof valid === `string`) {
	        _this.errorMsg = valid;
	        valid = false;
	      }

	      _this.error = !valid;
	    })();
	  }

	  submit() {
	    var _this2 = this;

	    return _asyncToGenerator(function* () {
	      yield _this2.validate();

	      if (_this2.error) {
	        _this2.color = `red`;

	        _this2.fire();

	        _this2.render();

	        return;
	      }

	      let x = _this2.value;
	      _this2.value = x !== `` ? x : _this2.initial;
	      _this2.done = true;
	      _this2.aborted = false;
	      _this2.error = false;

	      _this2.fire();

	      _this2.render();

	      _this2.out.write(`\n`);

	      _this2.close();
	    })();
	  }

	  up() {
	    this.typed = ``;

	    if (this.value === '') {
	      this.value = this.min - this.inc;
	    }

	    if (this.value >= this.max) return this.bell();
	    this.value += this.inc;
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  down() {
	    this.typed = ``;

	    if (this.value === '') {
	      this.value = this.min + this.inc;
	    }

	    if (this.value <= this.min) return this.bell();
	    this.value -= this.inc;
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  delete() {
	    let val = this.value.toString();
	    if (val.length === 0) return this.bell();
	    this.value = this.parse(val = val.slice(0, -1)) || ``;

	    if (this.value !== '' && this.value < this.min) {
	      this.value = this.min;
	    }

	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  next() {
	    this.value = this.initial;
	    this.fire();
	    this.render();
	  }

	  _(c, key) {
	    if (!this.valid(c)) return this.bell();
	    const now = Date.now();
	    if (now - this.lastHit > 1000) this.typed = ``; // 1s elapsed

	    this.typed += c;
	    this.lastHit = now;
	    this.color = `cyan`;
	    if (c === `.`) return this.fire();
	    this.value = Math.min(this.parse(this.typed), this.max);
	    if (this.value > this.max) this.value = this.max;
	    if (this.value < this.min) this.value = this.min;
	    this.fire();
	    this.render();
	  }

	  render() {
	    if (this.closed) return;

	    if (!this.firstRender) {
	      if (this.outputError) this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
	      this.out.write(clear(this.outputText, this.out.columns));
	    }

	    super.render();
	    this.outputError = ''; // Print prompt

	    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(` `); // Print error

	    if (this.error) {
	      this.outputError += this.errorMsg.split(`\n`).reduce((a, l, i) => a + `\n${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
	  }

	}

	number$1 = NumberPrompt;
	return number$1;
}

var multiselect$1;
var hasRequiredMultiselect$1;

function requireMultiselect$1 () {
	if (hasRequiredMultiselect$1) return multiselect$1;
	hasRequiredMultiselect$1 = 1;

	const color = requireKleur();

	const _require = requireSrc(),
	      cursor = _require.cursor;

	const Prompt = requirePrompt$1();

	const _require2 = requireUtil$2(),
	      clear = _require2.clear,
	      figures = _require2.figures,
	      style = _require2.style,
	      wrap = _require2.wrap,
	      entriesToDisplay = _require2.entriesToDisplay;
	/**
	 * MultiselectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {String} [opts.warn] Hint shown for disabled choices
	 * @param {Number} [opts.max] Max choices
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {Number} [opts.optionsPerPage=10] Max options to display at once
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */


	class MultiselectPrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.msg = opts.message;
	    this.cursor = opts.cursor || 0;
	    this.scrollIndex = opts.cursor || 0;
	    this.hint = opts.hint || '';
	    this.warn = opts.warn || '- This option is disabled -';
	    this.minSelected = opts.min;
	    this.showMinError = false;
	    this.maxChoices = opts.max;
	    this.instructions = opts.instructions;
	    this.optionsPerPage = opts.optionsPerPage || 10;
	    this.value = opts.choices.map((ch, idx) => {
	      if (typeof ch === 'string') ch = {
	        title: ch,
	        value: idx
	      };
	      return {
	        title: ch && (ch.title || ch.value || ch),
	        description: ch && ch.description,
	        value: ch && (ch.value === undefined ? idx : ch.value),
	        selected: ch && ch.selected,
	        disabled: ch && ch.disabled
	      };
	    });
	    this.clear = clear('', this.out.columns);

	    if (!opts.overrideRender) {
	      this.render();
	    }
	  }

	  reset() {
	    this.value.map(v => !v.selected);
	    this.cursor = 0;
	    this.fire();
	    this.render();
	  }

	  selected() {
	    return this.value.filter(v => v.selected);
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    const selected = this.value.filter(e => e.selected);

	    if (this.minSelected && selected.length < this.minSelected) {
	      this.showMinError = true;
	      this.render();
	    } else {
	      this.done = true;
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    }
	  }

	  first() {
	    this.cursor = 0;
	    this.render();
	  }

	  last() {
	    this.cursor = this.value.length - 1;
	    this.render();
	  }

	  next() {
	    this.cursor = (this.cursor + 1) % this.value.length;
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.cursor = this.value.length - 1;
	    } else {
	      this.cursor--;
	    }

	    this.render();
	  }

	  down() {
	    if (this.cursor === this.value.length - 1) {
	      this.cursor = 0;
	    } else {
	      this.cursor++;
	    }

	    this.render();
	  }

	  left() {
	    this.value[this.cursor].selected = false;
	    this.render();
	  }

	  right() {
	    if (this.value.filter(e => e.selected).length >= this.maxChoices) return this.bell();
	    this.value[this.cursor].selected = true;
	    this.render();
	  }

	  handleSpaceToggle() {
	    const v = this.value[this.cursor];

	    if (v.selected) {
	      v.selected = false;
	      this.render();
	    } else if (v.disabled || this.value.filter(e => e.selected).length >= this.maxChoices) {
	      return this.bell();
	    } else {
	      v.selected = true;
	      this.render();
	    }
	  }

	  toggleAll() {
	    if (this.maxChoices !== undefined || this.value[this.cursor].disabled) {
	      return this.bell();
	    }

	    const newSelected = !this.value[this.cursor].selected;
	    this.value.filter(v => !v.disabled).forEach(v => v.selected = newSelected);
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.handleSpaceToggle();
	    } else if (c === 'a') {
	      this.toggleAll();
	    } else {
	      return this.bell();
	    }
	  }

	  renderInstructions() {
	    if (this.instructions === undefined || this.instructions) {
	      if (typeof this.instructions === 'string') {
	        return this.instructions;
	      }

	      return '\nInstructions:\n' + `    ${figures.arrowUp}/${figures.arrowDown}: Highlight option\n` + `    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection\n` + (this.maxChoices === undefined ? `    a: Toggle all\n` : '') + `    enter/return: Complete answer`;
	    }

	    return '';
	  }

	  renderOption(cursor, v, i, arrowIndicator) {
	    const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + ' ' + arrowIndicator + ' ';
	    let title, desc;

	    if (v.disabled) {
	      title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	    } else {
	      title = cursor === i ? color.cyan().underline(v.title) : v.title;

	      if (cursor === i && v.description) {
	        desc = ` - ${v.description}`;

	        if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
	          desc = '\n' + wrap(v.description, {
	            margin: prefix.length,
	            width: this.out.columns
	          });
	        }
	      }
	    }

	    return prefix + title + color.gray(desc || '');
	  } // shared with autocompleteMultiselect


	  paginateOptions(options) {
	    if (options.length === 0) {
	      return color.red('No matches for this query.');
	    }

	    let _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage),
	        startIndex = _entriesToDisplay.startIndex,
	        endIndex = _entriesToDisplay.endIndex;

	    let prefix,
	        styledOptions = [];

	    for (let i = startIndex; i < endIndex; i++) {
	      if (i === startIndex && startIndex > 0) {
	        prefix = figures.arrowUp;
	      } else if (i === endIndex - 1 && endIndex < options.length) {
	        prefix = figures.arrowDown;
	      } else {
	        prefix = ' ';
	      }

	      styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
	    }

	    return '\n' + styledOptions.join('\n');
	  } // shared with autocomleteMultiselect


	  renderOptions(options) {
	    if (!this.done) {
	      return this.paginateOptions(options);
	    }

	    return '';
	  }

	  renderDoneOrInstructions() {
	    if (this.done) {
	      return this.value.filter(e => e.selected).map(v => v.title).join(', ');
	    }

	    const output = [color.gray(this.hint), this.renderInstructions()];

	    if (this.value[this.cursor].disabled) {
	      output.push(color.yellow(this.warn));
	    }

	    return output.join(' ');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    super.render(); // print prompt

	    let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(' ');

	    if (this.showMinError) {
	      prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
	      this.showMinError = false;
	    }

	    prompt += this.renderOptions(this.value);
	    this.out.write(this.clear + prompt);
	    this.clear = clear(prompt, this.out.columns);
	  }

	}

	multiselect$1 = MultiselectPrompt;
	return multiselect$1;
}

var autocomplete$1;
var hasRequiredAutocomplete$1;

function requireAutocomplete$1 () {
	if (hasRequiredAutocomplete$1) return autocomplete$1;
	hasRequiredAutocomplete$1 = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	const color = requireKleur();

	const Prompt = requirePrompt$1();

	const _require = requireSrc(),
	      erase = _require.erase,
	      cursor = _require.cursor;

	const _require2 = requireUtil$2(),
	      style = _require2.style,
	      clear = _require2.clear,
	      figures = _require2.figures,
	      wrap = _require2.wrap,
	      entriesToDisplay = _require2.entriesToDisplay;

	const getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);

	const getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);

	const getIndex = (arr, valOrTitle) => {
	  const index = arr.findIndex(el => el.value === valOrTitle || el.title === valOrTitle);
	  return index > -1 ? index : undefined;
	};
	/**
	 * TextPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of auto-complete choices objects
	 * @param {Function} [opts.suggest] Filter function. Defaults to sort by title
	 * @param {Number} [opts.limit=10] Max number of results to show
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {String} [opts.style='default'] Render style
	 * @param {String} [opts.fallback] Fallback message - initial to default value
	 * @param {String} [opts.initial] Index of the default value
	 * @param {Boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.noMatches] The no matches found label
	 */


	class AutocompletePrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.msg = opts.message;
	    this.suggest = opts.suggest;
	    this.choices = opts.choices;
	    this.initial = typeof opts.initial === 'number' ? opts.initial : getIndex(opts.choices, opts.initial);
	    this.select = this.initial || opts.cursor || 0;
	    this.i18n = {
	      noMatches: opts.noMatches || 'no matches found'
	    };
	    this.fallback = opts.fallback || this.initial;
	    this.clearFirst = opts.clearFirst || false;
	    this.suggestions = [];
	    this.input = '';
	    this.limit = opts.limit || 10;
	    this.cursor = 0;
	    this.transform = style.render(opts.style);
	    this.scale = this.transform.scale;
	    this.render = this.render.bind(this);
	    this.complete = this.complete.bind(this);
	    this.clear = clear('', this.out.columns);
	    this.complete(this.render);
	    this.render();
	  }

	  set fallback(fb) {
	    this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
	  }

	  get fallback() {
	    let choice;
	    if (typeof this._fb === 'number') choice = this.choices[this._fb];else if (typeof this._fb === 'string') choice = {
	      title: this._fb
	    };
	    return choice || this._fb || {
	      title: this.i18n.noMatches
	    };
	  }

	  moveSelect(i) {
	    this.select = i;
	    if (this.suggestions.length > 0) this.value = getVal(this.suggestions, i);else this.value = this.fallback.value;
	    this.fire();
	  }

	  complete(cb) {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      const p = _this.completing = _this.suggest(_this.input, _this.choices);

	      const suggestions = yield p;
	      if (_this.completing !== p) return;
	      _this.suggestions = suggestions.map((s, i, arr) => ({
	        title: getTitle(arr, i),
	        value: getVal(arr, i),
	        description: s.description
	      }));
	      _this.completing = false;
	      const l = Math.max(suggestions.length - 1, 0);

	      _this.moveSelect(Math.min(l, _this.select));

	      cb && cb();
	    })();
	  }

	  reset() {
	    this.input = '';
	    this.complete(() => {
	      this.moveSelect(this.initial !== void 0 ? this.initial : 0);
	      this.render();
	    });
	    this.render();
	  }

	  exit() {
	    if (this.clearFirst && this.input.length > 0) {
	      this.reset();
	    } else {
	      this.done = this.exited = true;
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    }
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.exited = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.done = true;
	    this.aborted = this.exited = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  _(c, key) {
	    let s1 = this.input.slice(0, this.cursor);
	    let s2 = this.input.slice(this.cursor);
	    this.input = `${s1}${c}${s2}`;
	    this.cursor = s1.length + 1;
	    this.complete(this.render);
	    this.render();
	  }

	  delete() {
	    if (this.cursor === 0) return this.bell();
	    let s1 = this.input.slice(0, this.cursor - 1);
	    let s2 = this.input.slice(this.cursor);
	    this.input = `${s1}${s2}`;
	    this.complete(this.render);
	    this.cursor = this.cursor - 1;
	    this.render();
	  }

	  deleteForward() {
	    if (this.cursor * this.scale >= this.rendered.length) return this.bell();
	    let s1 = this.input.slice(0, this.cursor);
	    let s2 = this.input.slice(this.cursor + 1);
	    this.input = `${s1}${s2}`;
	    this.complete(this.render);
	    this.render();
	  }

	  first() {
	    this.moveSelect(0);
	    this.render();
	  }

	  last() {
	    this.moveSelect(this.suggestions.length - 1);
	    this.render();
	  }

	  up() {
	    if (this.select === 0) {
	      this.moveSelect(this.suggestions.length - 1);
	    } else {
	      this.moveSelect(this.select - 1);
	    }

	    this.render();
	  }

	  down() {
	    if (this.select === this.suggestions.length - 1) {
	      this.moveSelect(0);
	    } else {
	      this.moveSelect(this.select + 1);
	    }

	    this.render();
	  }

	  next() {
	    if (this.select === this.suggestions.length - 1) {
	      this.moveSelect(0);
	    } else this.moveSelect(this.select + 1);

	    this.render();
	  }

	  nextPage() {
	    this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
	    this.render();
	  }

	  prevPage() {
	    this.moveSelect(Math.max(this.select - this.limit, 0));
	    this.render();
	  }

	  left() {
	    if (this.cursor <= 0) return this.bell();
	    this.cursor = this.cursor - 1;
	    this.render();
	  }

	  right() {
	    if (this.cursor * this.scale >= this.rendered.length) return this.bell();
	    this.cursor = this.cursor + 1;
	    this.render();
	  }

	  renderOption(v, hovered, isStart, isEnd) {
	    let desc;
	    let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : ' ';
	    let title = hovered ? color.cyan().underline(v.title) : v.title;
	    prefix = (hovered ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;

	    if (v.description) {
	      desc = ` - ${v.description}`;

	      if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
	        desc = '\n' + wrap(v.description, {
	          margin: 3,
	          width: this.out.columns
	        });
	      }
	    }

	    return prefix + ' ' + title + color.gray(desc || '');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    let _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit),
	        startIndex = _entriesToDisplay.startIndex,
	        endIndex = _entriesToDisplay.endIndex;

	    this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(' ');

	    if (!this.done) {
	      const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join('\n');
	      this.outputText += `\n` + (suggestions || color.gray(this.fallback.title));
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }

	}

	autocomplete$1 = AutocompletePrompt;
	return autocomplete$1;
}

var autocompleteMultiselect$1;
var hasRequiredAutocompleteMultiselect$1;

function requireAutocompleteMultiselect$1 () {
	if (hasRequiredAutocompleteMultiselect$1) return autocompleteMultiselect$1;
	hasRequiredAutocompleteMultiselect$1 = 1;

	const color = requireKleur();

	const _require = requireSrc(),
	      cursor = _require.cursor;

	const MultiselectPrompt = requireMultiselect$1();

	const _require2 = requireUtil$2(),
	      clear = _require2.clear,
	      style = _require2.style,
	      figures = _require2.figures;
	/**
	 * MultiselectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {String} [opts.warn] Hint shown for disabled choices
	 * @param {Number} [opts.max] Max choices
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */


	class AutocompleteMultiselectPrompt extends MultiselectPrompt {
	  constructor(opts = {}) {
	    opts.overrideRender = true;
	    super(opts);
	    this.inputValue = '';
	    this.clear = clear('', this.out.columns);
	    this.filteredOptions = this.value;
	    this.render();
	  }

	  last() {
	    this.cursor = this.filteredOptions.length - 1;
	    this.render();
	  }

	  next() {
	    this.cursor = (this.cursor + 1) % this.filteredOptions.length;
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.cursor = this.filteredOptions.length - 1;
	    } else {
	      this.cursor--;
	    }

	    this.render();
	  }

	  down() {
	    if (this.cursor === this.filteredOptions.length - 1) {
	      this.cursor = 0;
	    } else {
	      this.cursor++;
	    }

	    this.render();
	  }

	  left() {
	    this.filteredOptions[this.cursor].selected = false;
	    this.render();
	  }

	  right() {
	    if (this.value.filter(e => e.selected).length >= this.maxChoices) return this.bell();
	    this.filteredOptions[this.cursor].selected = true;
	    this.render();
	  }

	  delete() {
	    if (this.inputValue.length) {
	      this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
	      this.updateFilteredOptions();
	    }
	  }

	  updateFilteredOptions() {
	    const currentHighlight = this.filteredOptions[this.cursor];
	    this.filteredOptions = this.value.filter(v => {
	      if (this.inputValue) {
	        if (typeof v.title === 'string') {
	          if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
	            return true;
	          }
	        }

	        if (typeof v.value === 'string') {
	          if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
	            return true;
	          }
	        }

	        return false;
	      }

	      return true;
	    });
	    const newHighlightIndex = this.filteredOptions.findIndex(v => v === currentHighlight);
	    this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
	    this.render();
	  }

	  handleSpaceToggle() {
	    const v = this.filteredOptions[this.cursor];

	    if (v.selected) {
	      v.selected = false;
	      this.render();
	    } else if (v.disabled || this.value.filter(e => e.selected).length >= this.maxChoices) {
	      return this.bell();
	    } else {
	      v.selected = true;
	      this.render();
	    }
	  }

	  handleInputChange(c) {
	    this.inputValue = this.inputValue + c;
	    this.updateFilteredOptions();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.handleSpaceToggle();
	    } else {
	      this.handleInputChange(c);
	    }
	  }

	  renderInstructions() {
	    if (this.instructions === undefined || this.instructions) {
	      if (typeof this.instructions === 'string') {
	        return this.instructions;
	      }

	      return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
	    }

	    return '';
	  }

	  renderCurrentInput() {
	    return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray('Enter something to filter')}\n`;
	  }

	  renderOption(cursor, v, i) {
	    let title;
	    if (v.disabled) title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);else title = cursor === i ? color.cyan().underline(v.title) : v.title;
	    return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + '  ' + title;
	  }

	  renderDoneOrInstructions() {
	    if (this.done) {
	      return this.value.filter(e => e.selected).map(v => v.title).join(', ');
	    }

	    const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];

	    if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
	      output.push(color.yellow(this.warn));
	    }

	    return output.join(' ');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    super.render(); // print prompt

	    let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(' ');

	    if (this.showMinError) {
	      prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
	      this.showMinError = false;
	    }

	    prompt += this.renderOptions(this.filteredOptions);
	    this.out.write(this.clear + prompt);
	    this.clear = clear(prompt, this.out.columns);
	  }

	}

	autocompleteMultiselect$1 = AutocompleteMultiselectPrompt;
	return autocompleteMultiselect$1;
}

var confirm$1;
var hasRequiredConfirm$1;

function requireConfirm$1 () {
	if (hasRequiredConfirm$1) return confirm$1;
	hasRequiredConfirm$1 = 1;

	const color = requireKleur();

	const Prompt = requirePrompt$1();

	const _require = requireUtil$2(),
	      style = _require.style,
	      clear = _require.clear;

	const _require2 = requireSrc(),
	      erase = _require2.erase,
	      cursor = _require2.cursor;
	/**
	 * ConfirmPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Boolean} [opts.initial] Default value (true/false)
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.yes] The "Yes" label
	 * @param {String} [opts.yesOption] The "Yes" option when choosing between yes/no
	 * @param {String} [opts.no] The "No" label
	 * @param {String} [opts.noOption] The "No" option when choosing between yes/no
	 */


	class ConfirmPrompt extends Prompt {
	  constructor(opts = {}) {
	    super(opts);
	    this.msg = opts.message;
	    this.value = opts.initial;
	    this.initialValue = !!opts.initial;
	    this.yesMsg = opts.yes || 'yes';
	    this.yesOption = opts.yesOption || '(Y/n)';
	    this.noMsg = opts.no || 'no';
	    this.noOption = opts.noOption || '(y/N)';
	    this.render();
	  }

	  reset() {
	    this.value = this.initialValue;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.value = this.value || false;
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  _(c, key) {
	    if (c.toLowerCase() === 'y') {
	      this.value = true;
	      return this.submit();
	    }

	    if (c.toLowerCase() === 'n') {
	      this.value = false;
	      return this.submit();
	    }

	    return this.bell();
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();
	    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(' ');
	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }

	}

	confirm$1 = ConfirmPrompt;
	return confirm$1;
}

var elements$1;
var hasRequiredElements$1;

function requireElements$1 () {
	if (hasRequiredElements$1) return elements$1;
	hasRequiredElements$1 = 1;

	elements$1 = {
	  TextPrompt: requireText$1(),
	  SelectPrompt: requireSelect$1(),
	  TogglePrompt: requireToggle$1(),
	  DatePrompt: requireDate$1(),
	  NumberPrompt: requireNumber$1(),
	  MultiselectPrompt: requireMultiselect$1(),
	  AutocompletePrompt: requireAutocomplete$1(),
	  AutocompleteMultiselectPrompt: requireAutocompleteMultiselect$1(),
	  ConfirmPrompt: requireConfirm$1()
	};
	return elements$1;
}

var hasRequiredPrompts$2;

function requirePrompts$2 () {
	if (hasRequiredPrompts$2) return prompts$2;
	hasRequiredPrompts$2 = 1;
	(function (exports$1) {

		const $ = exports$1;

		const el = requireElements$1();

		const noop = v => v;

		function toPrompt(type, args, opts = {}) {
		  return new Promise((res, rej) => {
		    const p = new el[type](args);
		    const onAbort = opts.onAbort || noop;
		    const onSubmit = opts.onSubmit || noop;
		    const onExit = opts.onExit || noop;
		    p.on('state', args.onState || noop);
		    p.on('submit', x => res(onSubmit(x)));
		    p.on('exit', x => res(onExit(x)));
		    p.on('abort', x => rej(onAbort(x)));
		  });
		}
		/**
		 * Text prompt
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.text = args => toPrompt('TextPrompt', args);
		/**
		 * Password prompt with masked input
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.password = args => {
		  args.style = 'password';
		  return $.text(args);
		};
		/**
		 * Prompt where input is invisible, like sudo
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.invisible = args => {
		  args.style = 'invisible';
		  return $.text(args);
		};
		/**
		 * Number prompt
		 * @param {string} args.message Prompt message to display
		 * @param {number} args.initial Default number value
		 * @param {function} [args.onState] On state change callback
		 * @param {number} [args.max] Max value
		 * @param {number} [args.min] Min value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {Boolean} [opts.float=false] Parse input as floats
		 * @param {Number} [opts.round=2] Round floats to x decimals
		 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.number = args => toPrompt('NumberPrompt', args);
		/**
		 * Date prompt
		 * @param {string} args.message Prompt message to display
		 * @param {number} args.initial Default number value
		 * @param {function} [args.onState] On state change callback
		 * @param {number} [args.max] Max value
		 * @param {number} [args.min] Min value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {Boolean} [opts.float=false] Parse input as floats
		 * @param {Number} [opts.round=2] Round floats to x decimals
		 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.date = args => toPrompt('DatePrompt', args);
		/**
		 * Classic yes/no prompt
		 * @param {string} args.message Prompt message to display
		 * @param {boolean} [args.initial=false] Default value
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.confirm = args => toPrompt('ConfirmPrompt', args);
		/**
		 * List prompt, split intput string by `seperator`
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {string} [args.separator] String separator
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input, in form of an `Array`
		 */


		$.list = args => {
		  const sep = args.separator || ',';
		  return toPrompt('TextPrompt', args, {
		    onSubmit: str => str.split(sep).map(s => s.trim())
		  });
		};
		/**
		 * Toggle/switch prompt
		 * @param {string} args.message Prompt message to display
		 * @param {boolean} [args.initial=false] Default value
		 * @param {string} [args.active="on"] Text for `active` state
		 * @param {string} [args.inactive="off"] Text for `inactive` state
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.toggle = args => toPrompt('TogglePrompt', args);
		/**
		 * Interactive select prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of choices objects `[{ title, value }, ...]`
		 * @param {number} [args.initial] Index of default value
		 * @param {String} [args.hint] Hint to display
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.select = args => toPrompt('SelectPrompt', args);
		/**
		 * Interactive multi-select / autocompleteMultiselect prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of choices objects `[{ title, value, [selected] }, ...]`
		 * @param {number} [args.max] Max select
		 * @param {string} [args.hint] Hint to display user
		 * @param {Number} [args.cursor=0] Cursor start position
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.multiselect = args => {
		  args.choices = [].concat(args.choices || []);

		  const toSelected = items => items.filter(item => item.selected).map(item => item.value);

		  return toPrompt('MultiselectPrompt', args, {
		    onAbort: toSelected,
		    onSubmit: toSelected
		  });
		};

		$.autocompleteMultiselect = args => {
		  args.choices = [].concat(args.choices || []);

		  const toSelected = items => items.filter(item => item.selected).map(item => item.value);

		  return toPrompt('AutocompleteMultiselectPrompt', args, {
		    onAbort: toSelected,
		    onSubmit: toSelected
		  });
		};

		const byTitle = (input, choices) => Promise.resolve(choices.filter(item => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
		/**
		 * Interactive auto-complete prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of auto-complete choices objects `[{ title, value }, ...]`
		 * @param {Function} [args.suggest] Function to filter results based on user input. Defaults to sort by `title`
		 * @param {number} [args.limit=10] Max number of results to show
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {String} [args.initial] Index of the default value
		 * @param {boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
		 * @param {String} [args.fallback] Fallback message - defaults to initial value
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */


		$.autocomplete = args => {
		  args.suggest = args.suggest || byTitle;
		  args.choices = [].concat(args.choices || []);
		  return toPrompt('AutocompletePrompt', args);
		}; 
	} (prompts$2));
	return prompts$2;
}

var dist$1;
var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$1;
	hasRequiredDist$1 = 1;

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	const prompts = requirePrompts$2();

	const passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];

	const noop = () => {};
	/**
	 * Prompt for a series of questions
	 * @param {Array|Object} questions Single question object or Array of question objects
	 * @param {Function} [onSubmit] Callback function called on prompt submit
	 * @param {Function} [onCancel] Callback function called on cancel/abort
	 * @returns {Object} Object with values from user input
	 */


	function prompt() {
	  return _prompt.apply(this, arguments);
	}

	function _prompt() {
	  _prompt = _asyncToGenerator(function* (questions = [], {
	    onSubmit = noop,
	    onCancel = noop
	  } = {}) {
	    const answers = {};
	    const override = prompt._override || {};
	    questions = [].concat(questions);
	    let answer, question, quit, name, type, lastPrompt;

	    const getFormattedAnswer = /*#__PURE__*/function () {
	      var _ref = _asyncToGenerator(function* (question, answer, skipValidation = false) {
	        if (!skipValidation && question.validate && question.validate(answer) !== true) {
	          return;
	        }

	        return question.format ? yield question.format(answer, answers) : answer;
	      });

	      return function getFormattedAnswer(_x, _x2) {
	        return _ref.apply(this, arguments);
	      };
	    }();

	    var _iterator = _createForOfIteratorHelper(questions),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        question = _step.value;
	        var _question = question;
	        name = _question.name;
	        type = _question.type;

	        // evaluate type first and skip if type is a falsy value
	        if (typeof type === 'function') {
	          type = yield type(answer, _objectSpread({}, answers), question);
	          question['type'] = type;
	        }

	        if (!type) continue; // if property is a function, invoke it unless it's a special function

	        for (let key in question) {
	          if (passOn.includes(key)) continue;
	          let value = question[key];
	          question[key] = typeof value === 'function' ? yield value(answer, _objectSpread({}, answers), lastPrompt) : value;
	        }

	        lastPrompt = question;

	        if (typeof question.message !== 'string') {
	          throw new Error('prompt message is required');
	        } // update vars in case they changed


	        var _question2 = question;
	        name = _question2.name;
	        type = _question2.type;

	        if (prompts[type] === void 0) {
	          throw new Error(`prompt type (${type}) is not defined`);
	        }

	        if (override[question.name] !== undefined) {
	          answer = yield getFormattedAnswer(question, override[question.name]);

	          if (answer !== undefined) {
	            answers[name] = answer;
	            continue;
	          }
	        }

	        try {
	          // Get the injected answer if there is one or prompt the user
	          answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : yield prompts[type](question);
	          answers[name] = answer = yield getFormattedAnswer(question, answer, true);
	          quit = yield onSubmit(question, answer, answers);
	        } catch (err) {
	          quit = !(yield onCancel(question, answers));
	        }

	        if (quit) return answers;
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }

	    return answers;
	  });
	  return _prompt.apply(this, arguments);
	}

	function getInjectedAnswer(injected, deafultValue) {
	  const answer = injected.shift();

	  if (answer instanceof Error) {
	    throw answer;
	  }

	  return answer === undefined ? deafultValue : answer;
	}

	function inject(answers) {
	  prompt._injected = (prompt._injected || []).concat(answers);
	}

	function override(answers) {
	  prompt._override = Object.assign({}, answers);
	}

	dist$1 = Object.assign(prompt, {
	  prompt,
	  prompts,
	  inject,
	  override
	});
	return dist$1;
}

var prompts$1 = {};

var action;
var hasRequiredAction;

function requireAction () {
	if (hasRequiredAction) return action;
	hasRequiredAction = 1;

	action = (key, isSelect) => {
	  if (key.meta && key.name !== 'escape') return;
	  
	  if (key.ctrl) {
	    if (key.name === 'a') return 'first';
	    if (key.name === 'c') return 'abort';
	    if (key.name === 'd') return 'abort';
	    if (key.name === 'e') return 'last';
	    if (key.name === 'g') return 'reset';
	  }
	  
	  if (isSelect) {
	    if (key.name === 'j') return 'down';
	    if (key.name === 'k') return 'up';
	  }

	  if (key.name === 'return') return 'submit';
	  if (key.name === 'enter') return 'submit'; // ctrl + J
	  if (key.name === 'backspace') return 'delete';
	  if (key.name === 'delete') return 'deleteForward';
	  if (key.name === 'abort') return 'abort';
	  if (key.name === 'escape') return 'exit';
	  if (key.name === 'tab') return 'next';
	  if (key.name === 'pagedown') return 'nextPage';
	  if (key.name === 'pageup') return 'prevPage';
	  // TODO create home() in prompt types (e.g. TextPrompt)
	  if (key.name === 'home') return 'home';
	  // TODO create end() in prompt types (e.g. TextPrompt)
	  if (key.name === 'end') return 'end';

	  if (key.name === 'up') return 'up';
	  if (key.name === 'down') return 'down';
	  if (key.name === 'right') return 'right';
	  if (key.name === 'left') return 'left';

	  return false;
	};
	return action;
}

var strip;
var hasRequiredStrip;

function requireStrip () {
	if (hasRequiredStrip) return strip;
	hasRequiredStrip = 1;

	strip = str => {
	  const pattern = [
	    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
	    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'
	  ].join('|');

	  const RGX = new RegExp(pattern, 'g');
	  return typeof str === 'string' ? str.replace(RGX, '') : str;
	};
	return strip;
}

var clear;
var hasRequiredClear;

function requireClear () {
	if (hasRequiredClear) return clear;
	hasRequiredClear = 1;

	const strip = requireStrip();
	const { erase, cursor } = requireSrc();

	const width = str => [...strip(str)].length;

	/**
	 * @param {string} prompt
	 * @param {number} perLine
	 */
	clear = function(prompt, perLine) {
	  if (!perLine) return erase.line + cursor.to(0);

	  let rows = 0;
	  const lines = prompt.split(/\r?\n/);
	  for (let line of lines) {
	    rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
	  }

	  return erase.lines(rows);
	};
	return clear;
}

var figures_1;
var hasRequiredFigures;

function requireFigures () {
	if (hasRequiredFigures) return figures_1;
	hasRequiredFigures = 1;

	 const main = {
	  arrowUp: '↑',
	  arrowDown: '↓',
	  arrowLeft: '←',
	  arrowRight: '→',
	  radioOn: '◉',
	  radioOff: '◯',
	  tick: '✔',	
	  cross: '✖',	
	  ellipsis: '…',	
	  pointerSmall: '›',	
	  line: '─',	
	  pointer: '❯'	
	};	
	const win = {
	  arrowUp: main.arrowUp,
	  arrowDown: main.arrowDown,
	  arrowLeft: main.arrowLeft,
	  arrowRight: main.arrowRight,
	  radioOn: '(*)',
	  radioOff: '( )',	
	  tick: '√',	
	  cross: '×',	
	  ellipsis: '...',	
	  pointerSmall: '»',	
	  line: '─',	
	  pointer: '>'	
	};	
	const figures = process.platform === 'win32' ? win : main;	

	 figures_1 = figures;
	return figures_1;
}

var style;
var hasRequiredStyle;

function requireStyle () {
	if (hasRequiredStyle) return style;
	hasRequiredStyle = 1;

	const c = requireKleur();
	const figures = requireFigures();

	// rendering user input.
	const styles = Object.freeze({
	  password: { scale: 1, render: input => '*'.repeat(input.length) },
	  emoji: { scale: 2, render: input => '😃'.repeat(input.length) },
	  invisible: { scale: 0, render: input => '' },
	  default: { scale: 1, render: input => `${input}` }
	});
	const render = type => styles[type] || styles.default;

	// icon to signalize a prompt.
	const symbols = Object.freeze({
	  aborted: c.red(figures.cross),
	  done: c.green(figures.tick),
	  exited: c.yellow(figures.cross),
	  default: c.cyan('?')
	});

	const symbol = (done, aborted, exited) =>
	  aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;

	// between the question and the user's input.
	const delimiter = completing =>
	  c.gray(completing ? figures.ellipsis : figures.pointerSmall);

	const item = (expandable, expanded) =>
	  c.gray(expandable ? (expanded ? figures.pointerSmall : '+') : figures.line);

	style = {
	  styles,
	  render,
	  symbols,
	  symbol,
	  delimiter,
	  item
	};
	return style;
}

var lines;
var hasRequiredLines;

function requireLines () {
	if (hasRequiredLines) return lines;
	hasRequiredLines = 1;

	const strip = requireStrip();

	/**
	 * @param {string} msg
	 * @param {number} perLine
	 */
	lines = function (msg, perLine) {
	  let lines = String(strip(msg) || '').split(/\r?\n/);

	  if (!perLine) return lines.length;
	  return lines.map(l => Math.ceil(l.length / perLine))
	      .reduce((a, b) => a + b);
	};
	return lines;
}

var wrap;
var hasRequiredWrap;

function requireWrap () {
	if (hasRequiredWrap) return wrap;
	hasRequiredWrap = 1;

	/**
	 * @param {string} msg The message to wrap
	 * @param {object} opts
	 * @param {number|string} [opts.margin] Left margin
	 * @param {number} opts.width Maximum characters per line including the margin
	 */
	wrap = (msg, opts = {}) => {
	  const tab = Number.isSafeInteger(parseInt(opts.margin))
	    ? new Array(parseInt(opts.margin)).fill(' ').join('')
	    : (opts.margin || '');

	  const width = opts.width;

	  return (msg || '').split(/\r?\n/g)
	    .map(line => line
	      .split(/\s+/g)
	      .reduce((arr, w) => {
	        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
	          arr[arr.length - 1] += ` ${w}`;
	        else arr.push(`${tab}${w}`);
	        return arr;
	      }, [ tab ])
	      .join('\n'))
	    .join('\n');
	};
	return wrap;
}

var entriesToDisplay;
var hasRequiredEntriesToDisplay;

function requireEntriesToDisplay () {
	if (hasRequiredEntriesToDisplay) return entriesToDisplay;
	hasRequiredEntriesToDisplay = 1;

	/**
	 * Determine what entries should be displayed on the screen, based on the
	 * currently selected index and the maximum visible. Used in list-based
	 * prompts like `select` and `multiselect`.
	 *
	 * @param {number} cursor the currently selected entry
	 * @param {number} total the total entries available to display
	 * @param {number} [maxVisible] the number of entries that can be displayed
	 */
	entriesToDisplay = (cursor, total, maxVisible)  => {
	  maxVisible = maxVisible || total;

	  let startIndex = Math.min(total- maxVisible, cursor - Math.floor(maxVisible / 2));
	  if (startIndex < 0) startIndex = 0;

	  let endIndex = Math.min(startIndex + maxVisible, total);

	  return { startIndex, endIndex };
	};
	return entriesToDisplay;
}

var util$1;
var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;

	util$1 = {
	  action: requireAction(),
	  clear: requireClear(),
	  style: requireStyle(),
	  strip: requireStrip(),
	  figures: requireFigures(),
	  lines: requireLines(),
	  wrap: requireWrap(),
	  entriesToDisplay: requireEntriesToDisplay()
	};
	return util$1;
}

var prompt;
var hasRequiredPrompt;

function requirePrompt () {
	if (hasRequiredPrompt) return prompt;
	hasRequiredPrompt = 1;

	const readline = require$$0$a;
	const { action } = requireUtil$1();
	const EventEmitter = require$$0$7;
	const { beep, cursor } = requireSrc();
	const color = requireKleur();

	/**
	 * Base prompt skeleton
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class Prompt extends EventEmitter {
	  constructor(opts={}) {
	    super();

	    this.firstRender = true;
	    this.in = opts.stdin || process.stdin;
	    this.out = opts.stdout || process.stdout;
	    this.onRender = (opts.onRender || (() => void 0)).bind(this);
	    const rl = readline.createInterface({ input:this.in, escapeCodeTimeout:50 });
	    readline.emitKeypressEvents(this.in, rl);

	    if (this.in.isTTY) this.in.setRawMode(true);
	    const isSelect = [ 'SelectPrompt', 'MultiselectPrompt' ].indexOf(this.constructor.name) > -1;
	    const keypress = (str, key) => {
	      let a = action(key, isSelect);
	      if (a === false) {
	        this._ && this._(str, key);
	      } else if (typeof this[a] === 'function') {
	        this[a](key);
	      } else {
	        this.bell();
	      }
	    };

	    this.close = () => {
	      this.out.write(cursor.show);
	      this.in.removeListener('keypress', keypress);
	      if (this.in.isTTY) this.in.setRawMode(false);
	      rl.close();
	      this.emit(this.aborted ? 'abort' : this.exited ? 'exit' : 'submit', this.value);
	      this.closed = true;
	    };

	    this.in.on('keypress', keypress);
	  }

	  fire() {
	    this.emit('state', {
	      value: this.value,
	      aborted: !!this.aborted,
	      exited: !!this.exited
	    });
	  }

	  bell() {
	    this.out.write(beep);
	  }

	  render() {
	    this.onRender(color);
	    if (this.firstRender) this.firstRender = false;
	  }
	}

	prompt = Prompt;
	return prompt;
}

var text$1;
var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text$1;
	hasRequiredText = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { erase, cursor } = requireSrc();
	const { style, clear, lines, figures } = requireUtil$1();

	/**
	 * TextPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {String} [opts.style='default'] Render style
	 * @param {String} [opts.initial] Default value
	 * @param {Function} [opts.validate] Validate function
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.error] The invalid error label
	 */
	class TextPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.transform = style.render(opts.style);
	    this.scale = this.transform.scale;
	    this.msg = opts.message;
	    this.initial = opts.initial || ``;
	    this.validator = opts.validate || (() => true);
	    this.value = ``;
	    this.errorMsg = opts.error || `Please Enter A Valid Value`;
	    this.cursor = Number(!!this.initial);
	    this.cursorOffset = 0;
	    this.clear = clear(``, this.out.columns);
	    this.render();
	  }

	  set value(v) {
	    if (!v && this.initial) {
	      this.placeholder = true;
	      this.rendered = color.gray(this.transform.render(this.initial));
	    } else {
	      this.placeholder = false;
	      this.rendered = this.transform.render(v);
	    }
	    this._value = v;
	    this.fire();
	  }

	  get value() {
	    return this._value;
	  }

	  reset() {
	    this.value = ``;
	    this.cursor = Number(!!this.initial);
	    this.cursorOffset = 0;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.value = this.value || this.initial;
	    this.done = this.aborted = true;
	    this.error = false;
	    this.red = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  async validate() {
	    let valid = await this.validator(this.value);
	    if (typeof valid === `string`) {
	      this.errorMsg = valid;
	      valid = false;
	    }
	    this.error = !valid;
	  }

	  async submit() {
	    this.value = this.value || this.initial;
	    this.cursorOffset = 0;
	    this.cursor = this.rendered.length;
	    await this.validate();
	    if (this.error) {
	      this.red = true;
	      this.fire();
	      this.render();
	      return;
	    }
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  next() {
	    if (!this.placeholder) return this.bell();
	    this.value = this.initial;
	    this.cursor = this.rendered.length;
	    this.fire();
	    this.render();
	  }

	  moveCursor(n) {
	    if (this.placeholder) return;
	    this.cursor = this.cursor+n;
	    this.cursorOffset += n;
	  }

	  _(c, key) {
	    let s1 = this.value.slice(0, this.cursor);
	    let s2 = this.value.slice(this.cursor);
	    this.value = `${s1}${c}${s2}`;
	    this.red = false;
	    this.cursor = this.placeholder ? 0 : s1.length+1;
	    this.render();
	  }

	  delete() {
	    if (this.isCursorAtStart()) return this.bell();
	    let s1 = this.value.slice(0, this.cursor-1);
	    let s2 = this.value.slice(this.cursor);
	    this.value = `${s1}${s2}`;
	    this.red = false;
	    if (this.isCursorAtStart()) {
	      this.cursorOffset = 0;
	    } else {
	      this.cursorOffset++;
	      this.moveCursor(-1);
	    }
	    this.render();
	  }

	  deleteForward() {
	    if(this.cursor*this.scale >= this.rendered.length || this.placeholder) return this.bell();
	    let s1 = this.value.slice(0, this.cursor);
	    let s2 = this.value.slice(this.cursor+1);
	    this.value = `${s1}${s2}`;
	    this.red = false;
	    if (this.isCursorAtEnd()) {
	      this.cursorOffset = 0;
	    } else {
	      this.cursorOffset++;
	    }
	    this.render();
	  }

	  first() {
	    this.cursor = 0;
	    this.render();
	  }

	  last() {
	    this.cursor = this.value.length;
	    this.render();
	  }

	  left() {
	    if (this.cursor <= 0 || this.placeholder) return this.bell();
	    this.moveCursor(-1);
	    this.render();
	  }

	  right() {
	    if (this.cursor*this.scale >= this.rendered.length || this.placeholder) return this.bell();
	    this.moveCursor(1);
	    this.render();
	  }

	  isCursorAtStart() {
	    return this.cursor === 0 || (this.placeholder && this.cursor === 1);
	  }

	  isCursorAtEnd() {
	    return this.cursor === this.rendered.length || (this.placeholder && this.cursor === this.rendered.length + 1)
	  }

	  render() {
	    if (this.closed) return;
	    if (!this.firstRender) {
	      if (this.outputError)
	        this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
	      this.out.write(clear(this.outputText, this.out.columns));
	    }
	    super.render();
	    this.outputError = '';

	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      this.red ? color.red(this.rendered) : this.rendered
	    ].join(` `);

	    if (this.error) {
	      this.outputError += this.errorMsg.split(`\n`)
	          .reduce((a, l, i) => a + `\n${i ? ' ' : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
	  }
	}

	text$1 = TextPrompt;
	return text$1;
}

var select;
var hasRequiredSelect;

function requireSelect () {
	if (hasRequiredSelect) return select;
	hasRequiredSelect = 1;

	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear, figures, wrap, entriesToDisplay } = requireUtil$1();
	const { cursor } = requireSrc();

	/**
	 * SelectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {Number} [opts.initial] Index of default value
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {Number} [opts.optionsPerPage=10] Max options to display at once
	 */
	class SelectPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.hint = opts.hint || '- Use arrow-keys. Return to submit.';
	    this.warn = opts.warn || '- This option is disabled';
	    this.cursor = opts.initial || 0;
	    this.choices = opts.choices.map((ch, idx) => {
	      if (typeof ch === 'string')
	        ch = {title: ch, value: idx};
	      return {
	        title: ch && (ch.title || ch.value || ch),
	        value: ch && (ch.value === undefined ? idx : ch.value),
	        description: ch && ch.description,
	        selected: ch && ch.selected,
	        disabled: ch && ch.disabled
	      };
	    });
	    this.optionsPerPage = opts.optionsPerPage || 10;
	    this.value = (this.choices[this.cursor] || {}).value;
	    this.clear = clear('', this.out.columns);
	    this.render();
	  }

	  moveCursor(n) {
	    this.cursor = n;
	    this.value = this.choices[n].value;
	    this.fire();
	  }

	  reset() {
	    this.moveCursor(0);
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    if (!this.selection.disabled) {
	      this.done = true;
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    } else
	      this.bell();
	  }

	  first() {
	    this.moveCursor(0);
	    this.render();
	  }

	  last() {
	    this.moveCursor(this.choices.length - 1);
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.moveCursor(this.choices.length - 1);
	    } else {
	      this.moveCursor(this.cursor - 1);
	    }
	    this.render();
	  }

	  down() {
	    if (this.cursor === this.choices.length - 1) {
	      this.moveCursor(0);
	    } else {
	      this.moveCursor(this.cursor + 1);
	    }
	    this.render();
	  }

	  next() {
	    this.moveCursor((this.cursor + 1) % this.choices.length);
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') return this.submit();
	  }

	  get selection() {
	    return this.choices[this.cursor];
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    let { startIndex, endIndex } = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);

	    // Print prompt
	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.done ? this.selection.title : this.selection.disabled
	          ? color.yellow(this.warn) : color.gray(this.hint)
	    ].join(' ');

	    // Print choices
	    if (!this.done) {
	      this.outputText += '\n';
	      for (let i = startIndex; i < endIndex; i++) {
	        let title, prefix, desc = '', v = this.choices[i];

	        // Determine whether to display "more choices" indicators
	        if (i === startIndex && startIndex > 0) {
	          prefix = figures.arrowUp;
	        } else if (i === endIndex - 1 && endIndex < this.choices.length) {
	          prefix = figures.arrowDown;
	        } else {
	          prefix = ' ';
	        }

	        if (v.disabled) {
	          title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	          prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + ' ' : '  ') + prefix;
	        } else {
	          title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
	          prefix = (this.cursor === i ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
	          if (v.description && this.cursor === i) {
	            desc = ` - ${v.description}`;
	            if (prefix.length + title.length + desc.length >= this.out.columns
	                || v.description.split(/\r?\n/).length > 1) {
	              desc = '\n' + wrap(v.description, { margin: 3, width: this.out.columns });
	            }
	          }
	        }

	        this.outputText += `${prefix} ${title}${color.gray(desc)}\n`;
	      }
	    }

	    this.out.write(this.outputText);
	  }
	}

	select = SelectPrompt;
	return select;
}

var toggle;
var hasRequiredToggle;

function requireToggle () {
	if (hasRequiredToggle) return toggle;
	hasRequiredToggle = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear } = requireUtil$1();
	const { cursor, erase } = requireSrc();

	/**
	 * TogglePrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Boolean} [opts.initial=false] Default value
	 * @param {String} [opts.active='no'] Active label
	 * @param {String} [opts.inactive='off'] Inactive label
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class TogglePrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.value = !!opts.initial;
	    this.active = opts.active || 'on';
	    this.inactive = opts.inactive || 'off';
	    this.initialValue = this.value;
	    this.render();
	  }

	  reset() {
	    this.value = this.initialValue;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  deactivate() {
	    if (this.value === false) return this.bell();
	    this.value = false;
	    this.render();
	  }

	  activate() {
	    if (this.value === true) return this.bell();
	    this.value = true;
	    this.render();
	  }

	  delete() {
	    this.deactivate();
	  }
	  left() {
	    this.deactivate();
	  }
	  right() {
	    this.activate();
	  }
	  down() {
	    this.deactivate();
	  }
	  up() {
	    this.activate();
	  }

	  next() {
	    this.value = !this.value;
	    this.fire();
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.value = !this.value;
	    } else if (c === '1') {
	      this.value = true;
	    } else if (c === '0') {
	      this.value = false;
	    } else return this.bell();
	    this.render();
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      this.value ? this.inactive : color.cyan().underline(this.inactive),
	      color.gray('/'),
	      this.value ? color.cyan().underline(this.active) : this.active
	    ].join(' ');

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	toggle = TogglePrompt;
	return toggle;
}

var datepart;
var hasRequiredDatepart;

function requireDatepart () {
	if (hasRequiredDatepart) return datepart;
	hasRequiredDatepart = 1;

	class DatePart {
	  constructor({token, date, parts, locales}) {
	    this.token = token;
	    this.date = date || new Date();
	    this.parts = parts || [this];
	    this.locales = locales || {};
	  }

	  up() {}

	  down() {}

	  next() {
	    const currentIdx = this.parts.indexOf(this);
	    return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
	  }

	  setTo(val) {}

	  prev() {
	    let parts = [].concat(this.parts).reverse();
	    const currentIdx = parts.indexOf(this);
	    return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
	  }

	  toString() {
	    return String(this.date);
	  }
	}

	datepart = DatePart;
	return datepart;
}

var meridiem;
var hasRequiredMeridiem;

function requireMeridiem () {
	if (hasRequiredMeridiem) return meridiem;
	hasRequiredMeridiem = 1;

	const DatePart = requireDatepart();

	class Meridiem extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setHours((this.date.getHours() + 12) % 24);
	  }

	  down() {
	    this.up();
	  }

	  toString() {
	    let meridiem = this.date.getHours() > 12 ? 'pm' : 'am';
	    return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
	  }
	}

	meridiem = Meridiem;
	return meridiem;
}

var day;
var hasRequiredDay;

function requireDay () {
	if (hasRequiredDay) return day;
	hasRequiredDay = 1;

	const DatePart = requireDatepart();

	const pos = n => {
	  n = n % 10;
	  return n === 1 ? 'st'
	       : n === 2 ? 'nd'
	       : n === 3 ? 'rd'
	       : 'th';
	};

	class Day extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setDate(this.date.getDate() + 1);
	  }

	  down() {
	    this.date.setDate(this.date.getDate() - 1);
	  }

	  setTo(val) {
	    this.date.setDate(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let date = this.date.getDate();
	    let day = this.date.getDay();
	    return this.token === 'DD' ? String(date).padStart(2, '0')
	         : this.token === 'Do' ? date + pos(date)
	         : this.token === 'd' ? day + 1
	         : this.token === 'ddd' ? this.locales.weekdaysShort[day]
	         : this.token === 'dddd' ? this.locales.weekdays[day]
	         : date;
	  }
	}

	day = Day;
	return day;
}

var hours;
var hasRequiredHours;

function requireHours () {
	if (hasRequiredHours) return hours;
	hasRequiredHours = 1;

	const DatePart = requireDatepart();

	class Hours extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setHours(this.date.getHours() + 1);
	  }

	  down() {
	    this.date.setHours(this.date.getHours() - 1);
	  }

	  setTo(val) {
	    this.date.setHours(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let hours = this.date.getHours();
	    if (/h/.test(this.token))
	      hours = (hours % 12) || 12;
	    return this.token.length > 1 ? String(hours).padStart(2, '0') : hours;
	  }
	}

	hours = Hours;
	return hours;
}

var milliseconds;
var hasRequiredMilliseconds;

function requireMilliseconds () {
	if (hasRequiredMilliseconds) return milliseconds;
	hasRequiredMilliseconds = 1;

	const DatePart = requireDatepart();

	class Milliseconds extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
	  }

	  down() {
	    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
	  }

	  setTo(val) {
	    this.date.setMilliseconds(parseInt(val.substr(-(this.token.length))));
	  }

	  toString() {
	    return String(this.date.getMilliseconds()).padStart(4, '0')
	                                              .substr(0, this.token.length);
	  }
	}

	milliseconds = Milliseconds;
	return milliseconds;
}

var minutes;
var hasRequiredMinutes;

function requireMinutes () {
	if (hasRequiredMinutes) return minutes;
	hasRequiredMinutes = 1;

	const DatePart = requireDatepart();

	class Minutes extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMinutes(this.date.getMinutes() + 1);
	  }

	  down() {
	    this.date.setMinutes(this.date.getMinutes() - 1);
	  }

	  setTo(val) {
	    this.date.setMinutes(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let m = this.date.getMinutes();
	    return this.token.length > 1 ? String(m).padStart(2, '0') : m;
	  }
	}

	minutes = Minutes;
	return minutes;
}

var month;
var hasRequiredMonth;

function requireMonth () {
	if (hasRequiredMonth) return month;
	hasRequiredMonth = 1;

	const DatePart = requireDatepart();

	class Month extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setMonth(this.date.getMonth() + 1);
	  }

	  down() {
	    this.date.setMonth(this.date.getMonth() - 1);
	  }

	  setTo(val) {
	    val = parseInt(val.substr(-2)) - 1;
	    this.date.setMonth(val < 0 ? 0 : val);
	  }

	  toString() {
	    let month = this.date.getMonth();
	    let tl = this.token.length;
	    return tl === 2 ? String(month + 1).padStart(2, '0')
	           : tl === 3 ? this.locales.monthsShort[month]
	             : tl === 4 ? this.locales.months[month]
	               : String(month + 1);
	  }
	}

	month = Month;
	return month;
}

var seconds;
var hasRequiredSeconds;

function requireSeconds () {
	if (hasRequiredSeconds) return seconds;
	hasRequiredSeconds = 1;

	const DatePart = requireDatepart();

	class Seconds extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setSeconds(this.date.getSeconds() + 1);
	  }

	  down() {
	    this.date.setSeconds(this.date.getSeconds() - 1);
	  }

	  setTo(val) {
	    this.date.setSeconds(parseInt(val.substr(-2)));
	  }

	  toString() {
	    let s = this.date.getSeconds();
	    return this.token.length > 1 ? String(s).padStart(2, '0') : s;
	  }
	}

	seconds = Seconds;
	return seconds;
}

var year;
var hasRequiredYear;

function requireYear () {
	if (hasRequiredYear) return year;
	hasRequiredYear = 1;

	const DatePart = requireDatepart();

	class Year extends DatePart {
	  constructor(opts={}) {
	    super(opts);
	  }

	  up() {
	    this.date.setFullYear(this.date.getFullYear() + 1);
	  }

	  down() {
	    this.date.setFullYear(this.date.getFullYear() - 1);
	  }

	  setTo(val) {
	    this.date.setFullYear(val.substr(-4));
	  }

	  toString() {
	    let year = String(this.date.getFullYear()).padStart(4, '0');
	    return this.token.length === 2 ? year.substr(-2) : year;
	  }
	}

	year = Year;
	return year;
}

var dateparts;
var hasRequiredDateparts;

function requireDateparts () {
	if (hasRequiredDateparts) return dateparts;
	hasRequiredDateparts = 1;

	dateparts = {
	  DatePart: requireDatepart(),
	  Meridiem: requireMeridiem(),
	  Day: requireDay(),
	  Hours: requireHours(),
	  Milliseconds: requireMilliseconds(),
	  Minutes: requireMinutes(),
	  Month: requireMonth(),
	  Seconds: requireSeconds(),
	  Year: requireYear(),
	};
	return dateparts;
}

var date;
var hasRequiredDate;

function requireDate () {
	if (hasRequiredDate) return date;
	hasRequiredDate = 1;

	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear, figures } = requireUtil$1();
	const { erase, cursor } = requireSrc();
	const { DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year } = requireDateparts();

	const regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
	const regexGroups = {
	  1: ({token}) => token.replace(/\\(.)/g, '$1'),
	  2: (opts) => new Day(opts), // Day // TODO
	  3: (opts) => new Month(opts), // Month
	  4: (opts) => new Year(opts), // Year
	  5: (opts) => new Meridiem(opts), // AM/PM // TODO (special)
	  6: (opts) => new Hours(opts), // Hours
	  7: (opts) => new Minutes(opts), // Minutes
	  8: (opts) => new Seconds(opts), // Seconds
	  9: (opts) => new Milliseconds(opts), // Fractional seconds
	};

	const dfltLocales = {
	  months: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
	  monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
	  weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
	  weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(',')
	};


	/**
	 * DatePrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Number} [opts.initial] Index of default value
	 * @param {String} [opts.mask] The format mask
	 * @param {object} [opts.locales] The date locales
	 * @param {String} [opts.error] The error message shown on invalid value
	 * @param {Function} [opts.validate] Function to validate the submitted value
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class DatePrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.cursor = 0;
	    this.typed = '';
	    this.locales = Object.assign(dfltLocales, opts.locales);
	    this._date = opts.initial || new Date();
	    this.errorMsg = opts.error || 'Please Enter A Valid Value';
	    this.validator = opts.validate || (() => true);
	    this.mask = opts.mask || 'YYYY-MM-DD HH:mm:ss';
	    this.clear = clear('', this.out.columns);
	    this.render();
	  }

	  get value() {
	    return this.date
	  }

	  get date() {
	    return this._date;
	  }

	  set date(date) {
	    if (date) this._date.setTime(date.getTime());
	  }

	  set mask(mask) {
	    let result;
	    this.parts = [];
	    while(result = regex.exec(mask)) {
	      let match = result.shift();
	      let idx = result.findIndex(gr => gr != null);
	      this.parts.push(idx in regexGroups
	        ? regexGroups[idx]({ token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales })
	        : result[idx] || match);
	    }

	    let parts = this.parts.reduce((arr, i) => {
	      if (typeof i === 'string' && typeof arr[arr.length - 1] === 'string')
	        arr[arr.length - 1] += i;
	      else arr.push(i);
	      return arr;
	    }, []);

	    this.parts.splice(0);
	    this.parts.push(...parts);
	    this.reset();
	  }

	  moveCursor(n) {
	    this.typed = '';
	    this.cursor = n;
	    this.fire();
	  }

	  reset() {
	    this.moveCursor(this.parts.findIndex(p => p instanceof DatePart));
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  async validate() {
	    let valid = await this.validator(this.value);
	    if (typeof valid === 'string') {
	      this.errorMsg = valid;
	      valid = false;
	    }
	    this.error = !valid;
	  }

	  async submit() {
	    await this.validate();
	    if (this.error) {
	      this.color = 'red';
	      this.fire();
	      this.render();
	      return;
	    }
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  up() {
	    this.typed = '';
	    this.parts[this.cursor].up();
	    this.render();
	  }

	  down() {
	    this.typed = '';
	    this.parts[this.cursor].down();
	    this.render();
	  }

	  left() {
	    let prev = this.parts[this.cursor].prev();
	    if (prev == null) return this.bell();
	    this.moveCursor(this.parts.indexOf(prev));
	    this.render();
	  }

	  right() {
	    let next = this.parts[this.cursor].next();
	    if (next == null) return this.bell();
	    this.moveCursor(this.parts.indexOf(next));
	    this.render();
	  }

	  next() {
	    let next = this.parts[this.cursor].next();
	    this.moveCursor(next
	      ? this.parts.indexOf(next)
	      : this.parts.findIndex((part) => part instanceof DatePart));
	    this.render();
	  }

	  _(c) {
	    if (/\d/.test(c)) {
	      this.typed += c;
	      this.parts[this.cursor].setTo(this.typed);
	      this.render();
	    }
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    // Print prompt
	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), [])
	          .join('')
	    ].join(' ');

	    // Print error
	    if (this.error) {
	      this.outputText += this.errorMsg.split('\n').reduce(
	          (a, l, i) => a + `\n${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	date = DatePrompt;
	return date;
}

var number;
var hasRequiredNumber;

function requireNumber () {
	if (hasRequiredNumber) return number;
	hasRequiredNumber = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { cursor, erase } = requireSrc();
	const { style, figures, clear, lines } = requireUtil$1();

	const isNumber = /[0-9]/;
	const isDef = any => any !== undefined;
	const round = (number, precision) => {
	  let factor = Math.pow(10, precision);
	  return Math.round(number * factor) / factor;
	};

	/**
	 * NumberPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {String} [opts.style='default'] Render style
	 * @param {Number} [opts.initial] Default value
	 * @param {Number} [opts.max=+Infinity] Max value
	 * @param {Number} [opts.min=-Infinity] Min value
	 * @param {Boolean} [opts.float=false] Parse input as floats
	 * @param {Number} [opts.round=2] Round floats to x decimals
	 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
	 * @param {Function} [opts.validate] Validate function
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.error] The invalid error label
	 */
	class NumberPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.transform = style.render(opts.style);
	    this.msg = opts.message;
	    this.initial = isDef(opts.initial) ? opts.initial : '';
	    this.float = !!opts.float;
	    this.round = opts.round || 2;
	    this.inc = opts.increment || 1;
	    this.min = isDef(opts.min) ? opts.min : -Infinity;
	    this.max = isDef(opts.max) ? opts.max : Infinity;
	    this.errorMsg = opts.error || `Please Enter A Valid Value`;
	    this.validator = opts.validate || (() => true);
	    this.color = `cyan`;
	    this.value = ``;
	    this.typed = ``;
	    this.lastHit = 0;
	    this.render();
	  }

	  set value(v) {
	    if (!v && v !== 0) {
	      this.placeholder = true;
	      this.rendered = color.gray(this.transform.render(`${this.initial}`));
	      this._value = ``;
	    } else {
	      this.placeholder = false;
	      this.rendered = this.transform.render(`${round(v, this.round)}`);
	      this._value = round(v, this.round);
	    }
	    this.fire();
	  }

	  get value() {
	    return this._value;
	  }

	  parse(x) {
	    return this.float ? parseFloat(x) : parseInt(x);
	  }

	  valid(c) {
	    return c === `-` || c === `.` && this.float || isNumber.test(c)
	  }

	  reset() {
	    this.typed = ``;
	    this.value = ``;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    let x = this.value;
	    this.value = x !== `` ? x : this.initial;
	    this.done = this.aborted = true;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write(`\n`);
	    this.close();
	  }

	  async validate() {
	    let valid = await this.validator(this.value);
	    if (typeof valid === `string`) {
	      this.errorMsg = valid;
	      valid = false;
	    }
	    this.error = !valid;
	  }

	  async submit() {
	    await this.validate();
	    if (this.error) {
	      this.color = `red`;
	      this.fire();
	      this.render();
	      return;
	    }
	    let x = this.value;
	    this.value = x !== `` ? x : this.initial;
	    this.done = true;
	    this.aborted = false;
	    this.error = false;
	    this.fire();
	    this.render();
	    this.out.write(`\n`);
	    this.close();
	  }

	  up() {
	    this.typed = ``;
	    if(this.value === '') {
	      this.value = this.min - this.inc;
	    }
	    if (this.value >= this.max) return this.bell();
	    this.value += this.inc;
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  down() {
	    this.typed = ``;
	    if(this.value === '') {
	      this.value = this.min + this.inc;
	    }
	    if (this.value <= this.min) return this.bell();
	    this.value -= this.inc;
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  delete() {
	    let val = this.value.toString();
	    if (val.length === 0) return this.bell();
	    this.value = this.parse((val = val.slice(0, -1))) || ``;
	    if (this.value !== '' && this.value < this.min) {
	      this.value = this.min;
	    }
	    this.color = `cyan`;
	    this.fire();
	    this.render();
	  }

	  next() {
	    this.value = this.initial;
	    this.fire();
	    this.render();
	  }

	  _(c, key) {
	    if (!this.valid(c)) return this.bell();

	    const now = Date.now();
	    if (now - this.lastHit > 1000) this.typed = ``; // 1s elapsed
	    this.typed += c;
	    this.lastHit = now;
	    this.color = `cyan`;

	    if (c === `.`) return this.fire();

	    this.value = Math.min(this.parse(this.typed), this.max);
	    if (this.value > this.max) this.value = this.max;
	    if (this.value < this.min) this.value = this.min;
	    this.fire();
	    this.render();
	  }

	  render() {
	    if (this.closed) return;
	    if (!this.firstRender) {
	      if (this.outputError)
	        this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
	      this.out.write(clear(this.outputText, this.out.columns));
	    }
	    super.render();
	    this.outputError = '';

	    // Print prompt
	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      !this.done || (!this.done && !this.placeholder)
	          ? color[this.color]().underline(this.rendered) : this.rendered
	    ].join(` `);

	    // Print error
	    if (this.error) {
	      this.outputError += this.errorMsg.split(`\n`)
	          .reduce((a, l, i) => a + `\n${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
	  }
	}

	number = NumberPrompt;
	return number;
}

var multiselect;
var hasRequiredMultiselect;

function requireMultiselect () {
	if (hasRequiredMultiselect) return multiselect;
	hasRequiredMultiselect = 1;

	const color = requireKleur();
	const { cursor } = requireSrc();
	const Prompt = requirePrompt();
	const { clear, figures, style, wrap, entriesToDisplay } = requireUtil$1();

	/**
	 * MultiselectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {String} [opts.warn] Hint shown for disabled choices
	 * @param {Number} [opts.max] Max choices
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {Number} [opts.optionsPerPage=10] Max options to display at once
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class MultiselectPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.cursor = opts.cursor || 0;
	    this.scrollIndex = opts.cursor || 0;
	    this.hint = opts.hint || '';
	    this.warn = opts.warn || '- This option is disabled -';
	    this.minSelected = opts.min;
	    this.showMinError = false;
	    this.maxChoices = opts.max;
	    this.instructions = opts.instructions;
	    this.optionsPerPage = opts.optionsPerPage || 10;
	    this.value = opts.choices.map((ch, idx) => {
	      if (typeof ch === 'string')
	        ch = {title: ch, value: idx};
	      return {
	        title: ch && (ch.title || ch.value || ch),
	        description: ch && ch.description,
	        value: ch && (ch.value === undefined ? idx : ch.value),
	        selected: ch && ch.selected,
	        disabled: ch && ch.disabled
	      };
	    });
	    this.clear = clear('', this.out.columns);
	    if (!opts.overrideRender) {
	      this.render();
	    }
	  }

	  reset() {
	    this.value.map(v => !v.selected);
	    this.cursor = 0;
	    this.fire();
	    this.render();
	  }

	  selected() {
	    return this.value.filter(v => v.selected);
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    const selected = this.value
	      .filter(e => e.selected);
	    if (this.minSelected && selected.length < this.minSelected) {
	      this.showMinError = true;
	      this.render();
	    } else {
	      this.done = true;
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    }
	  }

	  first() {
	    this.cursor = 0;
	    this.render();
	  }

	  last() {
	    this.cursor = this.value.length - 1;
	    this.render();
	  }
	  next() {
	    this.cursor = (this.cursor + 1) % this.value.length;
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.cursor = this.value.length - 1;
	    } else {
	      this.cursor--;
	    }
	    this.render();
	  }

	  down() {
	    if (this.cursor === this.value.length - 1) {
	      this.cursor = 0;
	    } else {
	      this.cursor++;
	    }
	    this.render();
	  }

	  left() {
	    this.value[this.cursor].selected = false;
	    this.render();
	  }

	  right() {
	    if (this.value.filter(e => e.selected).length >= this.maxChoices) return this.bell();
	    this.value[this.cursor].selected = true;
	    this.render();
	  }

	  handleSpaceToggle() {
	    const v = this.value[this.cursor];

	    if (v.selected) {
	      v.selected = false;
	      this.render();
	    } else if (v.disabled || this.value.filter(e => e.selected).length >= this.maxChoices) {
	      return this.bell();
	    } else {
	      v.selected = true;
	      this.render();
	    }
	  }

	  toggleAll() {
	    if (this.maxChoices !== undefined || this.value[this.cursor].disabled) {
	      return this.bell();
	    }

	    const newSelected = !this.value[this.cursor].selected;
	    this.value.filter(v => !v.disabled).forEach(v => v.selected = newSelected);
	    this.render();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.handleSpaceToggle();
	    } else if (c === 'a') {
	      this.toggleAll();
	    } else {
	      return this.bell();
	    }
	  }

	  renderInstructions() {
	    if (this.instructions === undefined || this.instructions) {
	      if (typeof this.instructions === 'string') {
	        return this.instructions;
	      }
	      return '\nInstructions:\n'
	        + `    ${figures.arrowUp}/${figures.arrowDown}: Highlight option\n`
	        + `    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection\n`
	        + (this.maxChoices === undefined ? `    a: Toggle all\n` : '')
	        + `    enter/return: Complete answer`;
	    }
	    return '';
	  }

	  renderOption(cursor, v, i, arrowIndicator) {
	    const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + ' ' + arrowIndicator + ' ';
	    let title, desc;

	    if (v.disabled) {
	      title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	    } else {
	      title = cursor === i ? color.cyan().underline(v.title) : v.title;
	      if (cursor === i && v.description) {
	        desc = ` - ${v.description}`;
	        if (prefix.length + title.length + desc.length >= this.out.columns
	          || v.description.split(/\r?\n/).length > 1) {
	          desc = '\n' + wrap(v.description, { margin: prefix.length, width: this.out.columns });
	        }
	      }
	    }

	    return prefix + title + color.gray(desc || '');
	  }

	  // shared with autocompleteMultiselect
	  paginateOptions(options) {
	    if (options.length === 0) {
	      return color.red('No matches for this query.');
	    }

	    let { startIndex, endIndex } = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
	    let prefix, styledOptions = [];

	    for (let i = startIndex; i < endIndex; i++) {
	      if (i === startIndex && startIndex > 0) {
	        prefix = figures.arrowUp;
	      } else if (i === endIndex - 1 && endIndex < options.length) {
	        prefix = figures.arrowDown;
	      } else {
	        prefix = ' ';
	      }
	      styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
	    }

	    return '\n' + styledOptions.join('\n');
	  }

	  // shared with autocomleteMultiselect
	  renderOptions(options) {
	    if (!this.done) {
	      return this.paginateOptions(options);
	    }
	    return '';
	  }

	  renderDoneOrInstructions() {
	    if (this.done) {
	      return this.value
	        .filter(e => e.selected)
	        .map(v => v.title)
	        .join(', ');
	    }

	    const output = [color.gray(this.hint), this.renderInstructions()];

	    if (this.value[this.cursor].disabled) {
	      output.push(color.yellow(this.warn));
	    }
	    return output.join(' ');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    super.render();

	    // print prompt
	    let prompt = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.renderDoneOrInstructions()
	    ].join(' ');
	    if (this.showMinError) {
	      prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
	      this.showMinError = false;
	    }
	    prompt += this.renderOptions(this.value);

	    this.out.write(this.clear + prompt);
	    this.clear = clear(prompt, this.out.columns);
	  }
	}

	multiselect = MultiselectPrompt;
	return multiselect;
}

var autocomplete;
var hasRequiredAutocomplete;

function requireAutocomplete () {
	if (hasRequiredAutocomplete) return autocomplete;
	hasRequiredAutocomplete = 1;

	const color = requireKleur();
	const Prompt = requirePrompt();
	const { erase, cursor } = requireSrc();
	const { style, clear, figures, wrap, entriesToDisplay } = requireUtil$1();

	const getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
	const getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
	const getIndex = (arr, valOrTitle) => {
	  const index = arr.findIndex(el => el.value === valOrTitle || el.title === valOrTitle);
	  return index > -1 ? index : undefined;
	};

	/**
	 * TextPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of auto-complete choices objects
	 * @param {Function} [opts.suggest] Filter function. Defaults to sort by title
	 * @param {Number} [opts.limit=10] Max number of results to show
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {String} [opts.style='default'] Render style
	 * @param {String} [opts.fallback] Fallback message - initial to default value
	 * @param {String} [opts.initial] Index of the default value
	 * @param {Boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.noMatches] The no matches found label
	 */
	class AutocompletePrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.suggest = opts.suggest;
	    this.choices = opts.choices;
	    this.initial = typeof opts.initial === 'number'
	      ? opts.initial
	      : getIndex(opts.choices, opts.initial);
	    this.select = this.initial || opts.cursor || 0;
	    this.i18n = { noMatches: opts.noMatches || 'no matches found' };
	    this.fallback = opts.fallback || this.initial;
	    this.clearFirst = opts.clearFirst || false;
	    this.suggestions = [];
	    this.input = '';
	    this.limit = opts.limit || 10;
	    this.cursor = 0;
	    this.transform = style.render(opts.style);
	    this.scale = this.transform.scale;
	    this.render = this.render.bind(this);
	    this.complete = this.complete.bind(this);
	    this.clear = clear('', this.out.columns);
	    this.complete(this.render);
	    this.render();
	  }

	  set fallback(fb) {
	    this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
	  }

	  get fallback() {
	    let choice;
	    if (typeof this._fb === 'number')
	      choice = this.choices[this._fb];
	    else if (typeof this._fb === 'string')
	      choice = { title: this._fb };
	    return choice || this._fb || { title: this.i18n.noMatches };
	  }

	  moveSelect(i) {
	    this.select = i;
	    if (this.suggestions.length > 0)
	      this.value = getVal(this.suggestions, i);
	    else this.value = this.fallback.value;
	    this.fire();
	  }

	  async complete(cb) {
	    const p = (this.completing = this.suggest(this.input, this.choices));
	    const suggestions = await p;

	    if (this.completing !== p) return;
	    this.suggestions = suggestions
	      .map((s, i, arr) => ({ title: getTitle(arr, i), value: getVal(arr, i), description: s.description }));
	    this.completing = false;
	    const l = Math.max(suggestions.length - 1, 0);
	    this.moveSelect(Math.min(l, this.select));

	    cb && cb();
	  }

	  reset() {
	    this.input = '';
	    this.complete(() => {
	      this.moveSelect(this.initial !== void 0 ? this.initial : 0);
	      this.render();
	    });
	    this.render();
	  }

	  exit() {
	    if (this.clearFirst && this.input.length > 0) {
	      this.reset();
	    } else {
	      this.done = this.exited = true; 
	      this.aborted = false;
	      this.fire();
	      this.render();
	      this.out.write('\n');
	      this.close();
	    }
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.exited = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.done = true;
	    this.aborted = this.exited = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  _(c, key) {
	    let s1 = this.input.slice(0, this.cursor);
	    let s2 = this.input.slice(this.cursor);
	    this.input = `${s1}${c}${s2}`;
	    this.cursor = s1.length+1;
	    this.complete(this.render);
	    this.render();
	  }

	  delete() {
	    if (this.cursor === 0) return this.bell();
	    let s1 = this.input.slice(0, this.cursor-1);
	    let s2 = this.input.slice(this.cursor);
	    this.input = `${s1}${s2}`;
	    this.complete(this.render);
	    this.cursor = this.cursor-1;
	    this.render();
	  }

	  deleteForward() {
	    if(this.cursor*this.scale >= this.rendered.length) return this.bell();
	    let s1 = this.input.slice(0, this.cursor);
	    let s2 = this.input.slice(this.cursor+1);
	    this.input = `${s1}${s2}`;
	    this.complete(this.render);
	    this.render();
	  }

	  first() {
	    this.moveSelect(0);
	    this.render();
	  }

	  last() {
	    this.moveSelect(this.suggestions.length - 1);
	    this.render();
	  }

	  up() {
	    if (this.select === 0) {
	      this.moveSelect(this.suggestions.length - 1);
	    } else {
	      this.moveSelect(this.select - 1);
	    }
	    this.render();
	  }

	  down() {
	    if (this.select === this.suggestions.length - 1) {
	      this.moveSelect(0);
	    } else {
	      this.moveSelect(this.select + 1);
	    }
	    this.render();
	  }

	  next() {
	    if (this.select === this.suggestions.length - 1) {
	      this.moveSelect(0);
	    } else this.moveSelect(this.select + 1);
	    this.render();
	  }

	  nextPage() {
	    this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
	    this.render();
	  }

	  prevPage() {
	    this.moveSelect(Math.max(this.select - this.limit, 0));
	    this.render();
	  }

	  left() {
	    if (this.cursor <= 0) return this.bell();
	    this.cursor = this.cursor-1;
	    this.render();
	  }

	  right() {
	    if (this.cursor*this.scale >= this.rendered.length) return this.bell();
	    this.cursor = this.cursor+1;
	    this.render();
	  }

	  renderOption(v, hovered, isStart, isEnd) {
	    let desc;
	    let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : ' ';
	    let title = hovered ? color.cyan().underline(v.title) : v.title;
	    prefix = (hovered ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
	    if (v.description) {
	      desc = ` - ${v.description}`;
	      if (prefix.length + title.length + desc.length >= this.out.columns
	        || v.description.split(/\r?\n/).length > 1) {
	        desc = '\n' + wrap(v.description, { margin: 3, width: this.out.columns });
	      }
	    }
	    return prefix + ' ' + title + color.gray(desc || '');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    let { startIndex, endIndex } = entriesToDisplay(this.select, this.choices.length, this.limit);

	    this.outputText = [
	      style.symbol(this.done, this.aborted, this.exited),
	      color.bold(this.msg),
	      style.delimiter(this.completing),
	      this.done && this.suggestions[this.select]
	        ? this.suggestions[this.select].title
	        : this.rendered = this.transform.render(this.input)
	    ].join(' ');

	    if (!this.done) {
	      const suggestions = this.suggestions
	        .slice(startIndex, endIndex)
	        .map((item, i) =>  this.renderOption(item,
	          this.select === i + startIndex,
	          i === 0 && startIndex > 0,
	          i + startIndex === endIndex - 1 && endIndex < this.choices.length))
	        .join('\n');
	      this.outputText += `\n` + (suggestions || color.gray(this.fallback.title));
	    }

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	autocomplete = AutocompletePrompt;
	return autocomplete;
}

var autocompleteMultiselect;
var hasRequiredAutocompleteMultiselect;

function requireAutocompleteMultiselect () {
	if (hasRequiredAutocompleteMultiselect) return autocompleteMultiselect;
	hasRequiredAutocompleteMultiselect = 1;

	const color = requireKleur();
	const { cursor } = requireSrc();
	const MultiselectPrompt = requireMultiselect();
	const { clear, style, figures } = requireUtil$1();
	/**
	 * MultiselectPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Array} opts.choices Array of choice objects
	 * @param {String} [opts.hint] Hint to display
	 * @param {String} [opts.warn] Hint shown for disabled choices
	 * @param {Number} [opts.max] Max choices
	 * @param {Number} [opts.cursor=0] Cursor start position
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 */
	class AutocompleteMultiselectPrompt extends MultiselectPrompt {
	  constructor(opts={}) {
	    opts.overrideRender = true;
	    super(opts);
	    this.inputValue = '';
	    this.clear = clear('', this.out.columns);
	    this.filteredOptions = this.value;
	    this.render();
	  }

	  last() {
	    this.cursor = this.filteredOptions.length - 1;
	    this.render();
	  }
	  next() {
	    this.cursor = (this.cursor + 1) % this.filteredOptions.length;
	    this.render();
	  }

	  up() {
	    if (this.cursor === 0) {
	      this.cursor = this.filteredOptions.length - 1;
	    } else {
	      this.cursor--;
	    }
	    this.render();
	  }

	  down() {
	    if (this.cursor === this.filteredOptions.length - 1) {
	      this.cursor = 0;
	    } else {
	      this.cursor++;
	    }
	    this.render();
	  }

	  left() {
	    this.filteredOptions[this.cursor].selected = false;
	    this.render();
	  }

	  right() {
	    if (this.value.filter(e => e.selected).length >= this.maxChoices) return this.bell();
	    this.filteredOptions[this.cursor].selected = true;
	    this.render();
	  }

	  delete() {
	    if (this.inputValue.length) {
	      this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
	      this.updateFilteredOptions();
	    }
	  }

	  updateFilteredOptions() {
	    const currentHighlight = this.filteredOptions[this.cursor];
	    this.filteredOptions = this.value
	      .filter(v => {
	        if (this.inputValue) {
	          if (typeof v.title === 'string') {
	            if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
	              return true;
	            }
	          }
	          if (typeof v.value === 'string') {
	            if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
	              return true;
	            }
	          }
	          return false;
	        }
	        return true;
	      });
	    const newHighlightIndex = this.filteredOptions.findIndex(v => v === currentHighlight);
	    this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
	    this.render();
	  }

	  handleSpaceToggle() {
	    const v = this.filteredOptions[this.cursor];

	    if (v.selected) {
	      v.selected = false;
	      this.render();
	    } else if (v.disabled || this.value.filter(e => e.selected).length >= this.maxChoices) {
	      return this.bell();
	    } else {
	      v.selected = true;
	      this.render();
	    }
	  }

	  handleInputChange(c) {
	    this.inputValue = this.inputValue + c;
	    this.updateFilteredOptions();
	  }

	  _(c, key) {
	    if (c === ' ') {
	      this.handleSpaceToggle();
	    } else {
	      this.handleInputChange(c);
	    }
	  }

	  renderInstructions() {
	    if (this.instructions === undefined || this.instructions) {
	      if (typeof this.instructions === 'string') {
	        return this.instructions;
	      }
	      return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
	    }
	    return '';
	  }

	  renderCurrentInput() {
	    return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray('Enter something to filter')}\n`;
	  }

	  renderOption(cursor, v, i) {
	    let title;
	    if (v.disabled) title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
	    else title = cursor === i ? color.cyan().underline(v.title) : v.title;
	    return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + '  ' + title
	  }

	  renderDoneOrInstructions() {
	    if (this.done) {
	      return this.value
	        .filter(e => e.selected)
	        .map(v => v.title)
	        .join(', ');
	    }

	    const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];

	    if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
	      output.push(color.yellow(this.warn));
	    }
	    return output.join(' ');
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    super.render();

	    // print prompt

	    let prompt = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(false),
	      this.renderDoneOrInstructions()
	    ].join(' ');

	    if (this.showMinError) {
	      prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
	      this.showMinError = false;
	    }
	    prompt += this.renderOptions(this.filteredOptions);

	    this.out.write(this.clear + prompt);
	    this.clear = clear(prompt, this.out.columns);
	  }
	}

	autocompleteMultiselect = AutocompleteMultiselectPrompt;
	return autocompleteMultiselect;
}

var confirm;
var hasRequiredConfirm;

function requireConfirm () {
	if (hasRequiredConfirm) return confirm;
	hasRequiredConfirm = 1;
	const color = requireKleur();
	const Prompt = requirePrompt();
	const { style, clear } = requireUtil$1();
	const { erase, cursor } = requireSrc();

	/**
	 * ConfirmPrompt Base Element
	 * @param {Object} opts Options
	 * @param {String} opts.message Message
	 * @param {Boolean} [opts.initial] Default value (true/false)
	 * @param {Stream} [opts.stdin] The Readable stream to listen to
	 * @param {Stream} [opts.stdout] The Writable stream to write readline data to
	 * @param {String} [opts.yes] The "Yes" label
	 * @param {String} [opts.yesOption] The "Yes" option when choosing between yes/no
	 * @param {String} [opts.no] The "No" label
	 * @param {String} [opts.noOption] The "No" option when choosing between yes/no
	 */
	class ConfirmPrompt extends Prompt {
	  constructor(opts={}) {
	    super(opts);
	    this.msg = opts.message;
	    this.value = opts.initial;
	    this.initialValue = !!opts.initial;
	    this.yesMsg = opts.yes || 'yes';
	    this.yesOption = opts.yesOption || '(Y/n)';
	    this.noMsg = opts.no || 'no';
	    this.noOption = opts.noOption || '(y/N)';
	    this.render();
	  }

	  reset() {
	    this.value = this.initialValue;
	    this.fire();
	    this.render();
	  }

	  exit() {
	    this.abort();
	  }

	  abort() {
	    this.done = this.aborted = true;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  submit() {
	    this.value = this.value || false;
	    this.done = true;
	    this.aborted = false;
	    this.fire();
	    this.render();
	    this.out.write('\n');
	    this.close();
	  }

	  _(c, key) {
	    if (c.toLowerCase() === 'y') {
	      this.value = true;
	      return this.submit();
	    }
	    if (c.toLowerCase() === 'n') {
	      this.value = false;
	      return this.submit();
	    }
	    return this.bell();
	  }

	  render() {
	    if (this.closed) return;
	    if (this.firstRender) this.out.write(cursor.hide);
	    else this.out.write(clear(this.outputText, this.out.columns));
	    super.render();

	    this.outputText = [
	      style.symbol(this.done, this.aborted),
	      color.bold(this.msg),
	      style.delimiter(this.done),
	      this.done ? (this.value ? this.yesMsg : this.noMsg)
	          : color.gray(this.initialValue ? this.yesOption : this.noOption)
	    ].join(' ');

	    this.out.write(erase.line + cursor.to(0) + this.outputText);
	  }
	}

	confirm = ConfirmPrompt;
	return confirm;
}

var elements;
var hasRequiredElements;

function requireElements () {
	if (hasRequiredElements) return elements;
	hasRequiredElements = 1;

	elements = {
	  TextPrompt: requireText(),
	  SelectPrompt: requireSelect(),
	  TogglePrompt: requireToggle(),
	  DatePrompt: requireDate(),
	  NumberPrompt: requireNumber(),
	  MultiselectPrompt: requireMultiselect(),
	  AutocompletePrompt: requireAutocomplete(),
	  AutocompleteMultiselectPrompt: requireAutocompleteMultiselect(),
	  ConfirmPrompt: requireConfirm()
	};
	return elements;
}

var hasRequiredPrompts$1;

function requirePrompts$1 () {
	if (hasRequiredPrompts$1) return prompts$1;
	hasRequiredPrompts$1 = 1;
	(function (exports$1) {
		const $ = exports$1;
		const el = requireElements();
		const noop = v => v;

		function toPrompt(type, args, opts={}) {
		  return new Promise((res, rej) => {
		    const p = new el[type](args);
		    const onAbort = opts.onAbort || noop;
		    const onSubmit = opts.onSubmit || noop;
		    const onExit = opts.onExit || noop;
		    p.on('state', args.onState || noop);
		    p.on('submit', x => res(onSubmit(x)));
		    p.on('exit', x => res(onExit(x)));
		    p.on('abort', x => rej(onAbort(x)));
		  });
		}

		/**
		 * Text prompt
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.text = args => toPrompt('TextPrompt', args);

		/**
		 * Password prompt with masked input
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.password = args => {
		  args.style = 'password';
		  return $.text(args);
		};

		/**
		 * Prompt where input is invisible, like sudo
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {function} [args.onState] On state change callback
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.invisible = args => {
		  args.style = 'invisible';
		  return $.text(args);
		};

		/**
		 * Number prompt
		 * @param {string} args.message Prompt message to display
		 * @param {number} args.initial Default number value
		 * @param {function} [args.onState] On state change callback
		 * @param {number} [args.max] Max value
		 * @param {number} [args.min] Min value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {Boolean} [opts.float=false] Parse input as floats
		 * @param {Number} [opts.round=2] Round floats to x decimals
		 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.number = args => toPrompt('NumberPrompt', args);

		/**
		 * Date prompt
		 * @param {string} args.message Prompt message to display
		 * @param {number} args.initial Default number value
		 * @param {function} [args.onState] On state change callback
		 * @param {number} [args.max] Max value
		 * @param {number} [args.min] Min value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {Boolean} [opts.float=false] Parse input as floats
		 * @param {Number} [opts.round=2] Round floats to x decimals
		 * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
		 * @param {function} [args.validate] Function to validate user input
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.date = args => toPrompt('DatePrompt', args);

		/**
		 * Classic yes/no prompt
		 * @param {string} args.message Prompt message to display
		 * @param {boolean} [args.initial=false] Default value
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.confirm = args => toPrompt('ConfirmPrompt', args);

		/**
		 * List prompt, split intput string by `seperator`
		 * @param {string} args.message Prompt message to display
		 * @param {string} [args.initial] Default string value
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {string} [args.separator] String separator
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input, in form of an `Array`
		 */
		$.list = args => {
		  const sep = args.separator || ',';
		  return toPrompt('TextPrompt', args, {
		    onSubmit: str => str.split(sep).map(s => s.trim())
		  });
		};

		/**
		 * Toggle/switch prompt
		 * @param {string} args.message Prompt message to display
		 * @param {boolean} [args.initial=false] Default value
		 * @param {string} [args.active="on"] Text for `active` state
		 * @param {string} [args.inactive="off"] Text for `inactive` state
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.toggle = args => toPrompt('TogglePrompt', args);

		/**
		 * Interactive select prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of choices objects `[{ title, value }, ...]`
		 * @param {number} [args.initial] Index of default value
		 * @param {String} [args.hint] Hint to display
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.select = args => toPrompt('SelectPrompt', args);

		/**
		 * Interactive multi-select / autocompleteMultiselect prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of choices objects `[{ title, value, [selected] }, ...]`
		 * @param {number} [args.max] Max select
		 * @param {string} [args.hint] Hint to display user
		 * @param {Number} [args.cursor=0] Cursor start position
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.multiselect = args => {
		  args.choices = [].concat(args.choices || []);
		  const toSelected = items => items.filter(item => item.selected).map(item => item.value);
		  return toPrompt('MultiselectPrompt', args, {
		    onAbort: toSelected,
		    onSubmit: toSelected
		  });
		};

		$.autocompleteMultiselect = args => {
		  args.choices = [].concat(args.choices || []);
		  const toSelected = items => items.filter(item => item.selected).map(item => item.value);
		  return toPrompt('AutocompleteMultiselectPrompt', args, {
		    onAbort: toSelected,
		    onSubmit: toSelected
		  });
		};

		const byTitle = (input, choices) => Promise.resolve(
		  choices.filter(item => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase())
		);

		/**
		 * Interactive auto-complete prompt
		 * @param {string} args.message Prompt message to display
		 * @param {Array} args.choices Array of auto-complete choices objects `[{ title, value }, ...]`
		 * @param {Function} [args.suggest] Function to filter results based on user input. Defaults to sort by `title`
		 * @param {number} [args.limit=10] Max number of results to show
		 * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
		 * @param {String} [args.initial] Index of the default value
		 * @param {boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
		 * @param {String} [args.fallback] Fallback message - defaults to initial value
		 * @param {function} [args.onState] On state change callback
		 * @param {Stream} [args.stdin] The Readable stream to listen to
		 * @param {Stream} [args.stdout] The Writable stream to write readline data to
		 * @returns {Promise} Promise with user input
		 */
		$.autocomplete = args => {
		  args.suggest = args.suggest || byTitle;
		  args.choices = [].concat(args.choices || []);
		  return toPrompt('AutocompletePrompt', args);
		}; 
	} (prompts$1));
	return prompts$1;
}

var lib$3;
var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$3;
	hasRequiredLib$3 = 1;

	const prompts = requirePrompts$1();

	const passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];
	const noop = () => {};

	/**
	 * Prompt for a series of questions
	 * @param {Array|Object} questions Single question object or Array of question objects
	 * @param {Function} [onSubmit] Callback function called on prompt submit
	 * @param {Function} [onCancel] Callback function called on cancel/abort
	 * @returns {Object} Object with values from user input
	 */
	async function prompt(questions=[], { onSubmit=noop, onCancel=noop }={}) {
	  const answers = {};
	  const override = prompt._override || {};
	  questions = [].concat(questions);
	  let answer, question, quit, name, type, lastPrompt;

	  const getFormattedAnswer = async (question, answer, skipValidation = false) => {
	    if (!skipValidation && question.validate && question.validate(answer) !== true) {
	      return;
	    }
	    return question.format ? await question.format(answer, answers) : answer
	  };

	  for (question of questions) {
	    ({ name, type } = question);

	    // evaluate type first and skip if type is a falsy value
	    if (typeof type === 'function') {
	      type = await type(answer, { ...answers }, question);
	      question['type'] = type;
	    }
	    if (!type) continue;

	    // if property is a function, invoke it unless it's a special function
	    for (let key in question) {
	      if (passOn.includes(key)) continue;
	      let value = question[key];
	      question[key] = typeof value === 'function' ? await value(answer, { ...answers }, lastPrompt) : value;
	    }

	    lastPrompt = question;

	    if (typeof question.message !== 'string') {
	      throw new Error('prompt message is required');
	    }

	    // update vars in case they changed
	    ({ name, type } = question);

	    if (prompts[type] === void 0) {
	      throw new Error(`prompt type (${type}) is not defined`);
	    }

	    if (override[question.name] !== undefined) {
	      answer = await getFormattedAnswer(question, override[question.name]);
	      if (answer !== undefined) {
	        answers[name] = answer;
	        continue;
	      }
	    }

	    try {
	      // Get the injected answer if there is one or prompt the user
	      answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);
	      answers[name] = answer = await getFormattedAnswer(question, answer, true);
	      quit = await onSubmit(question, answer, answers);
	    } catch (err) {
	      quit = !(await onCancel(question, answers));
	    }

	    if (quit) return answers;
	  }

	  return answers;
	}

	function getInjectedAnswer(injected, deafultValue) {
	  const answer = injected.shift();
	    if (answer instanceof Error) {
	      throw answer;
	    }

	    return (answer === undefined) ? deafultValue : answer;
	}

	function inject(answers) {
	  prompt._injected = (prompt._injected || []).concat(answers);
	}

	function override(answers) {
	  prompt._override = Object.assign({}, answers);
	}

	lib$3 = Object.assign(prompt, { prompt, prompts, inject, override });
	return lib$3;
}

var prompts;
var hasRequiredPrompts;

function requirePrompts () {
	if (hasRequiredPrompts) return prompts;
	hasRequiredPrompts = 1;
	function isNodeLT(tar) {
	  tar = (Array.isArray(tar) ? tar : tar.split('.')).map(Number);
	  let i=0, src=process.versions.node.split('.').map(Number);
	  for (; i < tar.length; i++) {
	    if (src[i] > tar[i]) return false;
	    if (tar[i] > src[i]) return true;
	  }
	  return false;
	}

	prompts =
	  isNodeLT('8.6.0')
	    ? requireDist$1()
	    : requireLib$3();
	return prompts;
}

requirePrompts();

globalThis.fs||Object.defineProperty(globalThis,"fs",{value:require$$0$4});globalThis.process||Object.defineProperties(globalThis,"process",{value:process});globalThis.crypto||Object.defineProperty(globalThis,"crypto",{value:require$$3.webcrypto?require$$3.webcrypto:{getRandomValues(m){return require$$3.randomFillSync(m)}}});globalThis.performance||Object.defineProperty(globalThis,"performance",{value:{now(){let[m,o]=process.hrtime();return m*1e3+o/1e6}}});new TextEncoder$1("utf-8");new TextDecoder$1("utf-8");

function defineConfig(config) {
  return config;
}

const debug = createDebugger('vite-plugin-svelte-inspector');

/** @type {import('./public.d.ts').Options} */
const defaultInspectorOptions = {
	toggleKeyCombo: 'alt-x',
	navKeys: { parent: 'ArrowUp', child: 'ArrowDown', next: 'ArrowRight', prev: 'ArrowLeft' },
	escapeKeys: ['Backspace', 'Escape'],
	openKey: 'Enter',
	holdMode: true,
	showToggleButton: 'active',
	toggleButtonPos: 'top-right',
	customStyles: true
};

/**
 * @param {import('vite').ResolvedConfig} config
 * @returns {Partial<import('./public.d.ts').Options> | boolean | void}
 */
function parseEnvironmentOptions(config) {
	const env = loadEnv(config.mode, config.envDir ?? process$1.cwd(), 'SVELTE_INSPECTOR');
	const options = env?.SVELTE_INSPECTOR_OPTIONS;
	const toggle = env?.SVELTE_INSPECTOR_TOGGLE;
	if (options) {
		try {
			const parsed = JSON.parse(options);
			const parsedType = typeof parsed;
			if (parsedType === 'boolean') {
				return parsed;
			} else if (parsedType === 'object') {
				if (Array.isArray(parsed)) {
					throw new Error('invalid type, expected object map but got array');
				}
				const parsedKeys = Object.keys(parsed);
				const defaultKeys = Object.keys(defaultInspectorOptions);
				const unknownKeys = parsedKeys.filter((k) => !defaultKeys.includes(k));
				if (unknownKeys.length) {
					config.logger.warn(
						`[vite-plugin-svelte-inspector] ignoring unknown options in environment SVELTE_INSPECTOR_OPTIONS: ${unknownKeys.join(
							', '
						)}`
					);
					for (const key of unknownKeys) {
						delete parsed[key];
					}
				}
				debug('loaded environment config', parsed);
				return parsed;
			}
		} catch (e) {
			config.logger.error(
				`[vite-plugin-svelte-inspector] failed to parse inspector options from environment SVELTE_INSPECTOR_OPTIONS="${options}"\n${e}`
			);
		}
	} else if (toggle) {
		const keyConfig = {
			toggleKeyCombo: toggle
		};
		debug('loaded environment config', keyConfig);
		return keyConfig;
	}
}

const postfixRE = /[?#].*$/s;

/**
 * @param {string} url
 */
function cleanUrl(url) {
	return url.replace(postfixRE, '');
}

function getInspectorPath() {
	const pluginPath = normalizePath$3(path$b.dirname(fileURLToPath$1(import.meta.url)));
	return pluginPath.replace(
		/\/vite-plugin-svelte-inspector\/src$/,
		'/vite-plugin-svelte-inspector/src/runtime/'
	);
}

/**
 * @param {Partial<import('./public.d.ts').Options>} [options]
 * @returns {import('vite').Plugin}
 */
function svelteInspector(options) {
	const inspectorPath = getInspectorPath();
	debug(`svelte inspector path: ${inspectorPath}`);

	/** @type {import('vite').ResolvedConfig} */
	let viteConfig;
	/** @type {import('./public.d.ts').Options} */
	let inspectorOptions;
	let disabled = false;

	return {
		name: 'vite-plugin-svelte-inspector',
		apply: 'serve',
		enforce: 'pre',

		configResolved(config) {
			viteConfig = config;
			const environmentOptions = parseEnvironmentOptions(config);
			if (environmentOptions === false) {
				debug('environment options set to false, inspector disabled');
				disabled = true;
				return;
			}

			// Handle config from svelte.config.js through vite-plugin-svelte
			const vps = config.plugins.find((p) => p.name === 'vite-plugin-svelte');
			const configFileOptions = vps?.api?.options?.inspector;

			// vite-plugin-svelte can only pass options through it's `api` instead of `options`.
			// that means this plugin could be created but should be disabled, so we check this case here.
			if (vps && !options && !configFileOptions && !environmentOptions) {
				debug("vite-plugin-svelte didn't pass options, inspector disabled");
				disabled = true;
				return;
			}

			if (environmentOptions === true) {
				inspectorOptions = defaultInspectorOptions;
			} else {
				inspectorOptions = {
					...defaultInspectorOptions,
					...configFileOptions,
					...options,
					...(environmentOptions || {})
				};
			}

			inspectorOptions.__internal = {
				base: config.base?.replace(/\/$/, '') || ''
			};
		},

		async resolveId(importee, _, options) {
			if (options?.ssr || disabled) {
				return;
			}
			if (importee.startsWith('virtual:svelte-inspector-options')) {
				return importee;
			} else if (importee.startsWith('virtual:svelte-inspector-path:')) {
				return importee.replace('virtual:svelte-inspector-path:', inspectorPath);
			}
		},

		async load(id, options) {
			if (options?.ssr || disabled) {
				return;
			}
			if (id === 'virtual:svelte-inspector-options') {
				return `export default ${JSON.stringify(inspectorOptions ?? {})}`;
			} else if (id.startsWith(inspectorPath)) {
				// read file ourselves to avoid getting shut out by vites fs.allow check
				const file = cleanUrl(id);
				if (fs__default.existsSync(id)) {
					return await fs__default.promises.readFile(file, 'utf-8');
				} else {
					viteConfig.logger.error(
						`[vite-plugin-svelte-inspector] failed to find svelte-inspector: ${id}`
					);
				}
			}
		},

		transform(code, id, options) {
			if (options?.ssr || disabled) {
				return;
			}
			if (id.includes('vite/dist/client/client.mjs')) {
				return { code: `${code}\nimport('virtual:svelte-inspector-path:load-inspector.js')` };
			}
		}
	};
}

/* eslint-disable no-console */

/** @type {import('../types/log.d.ts').LogLevel[]} */
const levels = ['debug', 'info', 'warn', 'error', 'silent'];
const prefix = 'vite-plugin-svelte';
/** @type {Record<import('../types/log.d.ts').LogLevel, any>} */
const loggers = {
	debug: {
		log: createDebugger(`${prefix}`),
		enabled: false,
		isDebug: true
	},
	info: {
		color: cyan,
		log: console.log,
		enabled: true
	},
	warn: {
		color: yellow,
		log: console.warn,
		enabled: true
	},
	error: {
		color: red,
		log: console.error,
		enabled: true
	},
	silent: {
		enabled: false
	}
};

/** @type {import('../types/log.d.ts').LogLevel} */
let _level = 'info';
/**
 * @param {import('../types/log.d.ts').LogLevel} level
 * @returns {void}
 */
function setLevel(level) {
	if (level === _level) {
		return;
	}
	const levelIndex = levels.indexOf(level);
	if (levelIndex > -1) {
		_level = level;
		for (let i = 0; i < levels.length; i++) {
			loggers[levels[i]].enabled = i >= levelIndex;
		}
	} else {
		_log(loggers.error, `invalid log level: ${level} `);
	}
}

/**
 * @param {any} logger
 * @param {string} message
 * @param {any} [payload]
 * @param {string} [namespace]
 * @returns
 */
function _log(logger, message, payload, namespace) {
	if (!logger.enabled) {
		return;
	}
	if (logger.isDebug) {
		let log = logger.log;
		if (namespace) {
			if (!isDebugNamespaceEnabled(namespace)) {
				return;
			}
			log = logger.log.extend(namespace);
		}
		if (payload !== undefined) {
			log(message, payload);
		} else {
			log(message);
		}
	} else {
		logger.log(
			logger.color(
				`${new Date().toLocaleTimeString()} [${prefix}${
					namespace ? `:${namespace}` : ''
				}] ${message}`
			)
		);
		if (payload) {
			logger.log(payload);
		}
	}
}

/**
 * @param {import('../types/log.d.ts').LogLevel} level
 * @returns {import('../types/log.d.ts').LogFn}
 */
function createLogger(level) {
	const logger = loggers[level];
	const logFn = /** @type {import('../types/log.d.ts').LogFn} */ (_log.bind(null, logger));
	/** @type {Set<string>} */
	const logged = new Set();
	/** @type {import('../types/log.d.ts').SimpleLogFn} */
	const once = function (message, payload, namespace) {
		if (!logger.enabled || logged.has(message)) {
			return;
		}
		logged.add(message);
		logFn.apply(null, [message, payload, namespace]);
	};
	Object.defineProperty(logFn, 'enabled', {
		get() {
			return logger.enabled;
		}
	});
	Object.defineProperty(logFn, 'once', {
		get() {
			return once;
		}
	});
	return logFn;
}

const log = {
	debug: createLogger('debug'),
	info: createLogger('info'),
	warn: createLogger('warn'),
	error: createLogger('error'),
	setLevel
};

/**
 * @param {import('../types/id.d.ts').SvelteRequest | import('../types/id.d.ts').SvelteModuleRequest} svelteRequest
 * @param {import('svelte/compiler').Warning[]} warnings
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 */
function logCompilerWarnings(svelteRequest, warnings, options) {
	const { emitCss, onwarn, isBuild } = options;
	const sendViaWS = !isBuild && options.experimental?.sendWarningsToBrowser;
	let warn = isBuild ? warnBuild : warnDev;
	/** @type {import('svelte/compiler').Warning[]} */
	const handledByDefaultWarn = [];
	const notIgnored = warnings?.filter((w) => !ignoreCompilerWarning(w, isBuild, emitCss));
	const extra = buildExtraWarnings(warnings, isBuild);
	const allWarnings = [...notIgnored, ...extra];
	if (sendViaWS) {
		const _warn = warn;
		/** @type {(w: import('svelte/compiler').Warning) => void} */
		warn = (w) => {
			handledByDefaultWarn.push(w);
			_warn(w);
		};
	}
	allWarnings.forEach((warning) => {
		if (onwarn) {
			onwarn(warning, warn);
		} else {
			warn(warning);
		}
	});
	if (sendViaWS) {
		/** @type {import('../types/log.d.ts').SvelteWarningsMessage} */
		const message = {
			id: svelteRequest.id,
			filename: svelteRequest.filename,
			normalizedFilename: svelteRequest.normalizedFilename,
			timestamp: svelteRequest.timestamp,
			warnings: handledByDefaultWarn, // allWarnings filtered by warnings where onwarn did not call the default handler
			allWarnings, // includes warnings filtered by onwarn and our extra vite plugin svelte warnings
			rawWarnings: warnings // raw compiler output
		};
		log.debug(`sending svelte:warnings message for ${svelteRequest.normalizedFilename}`);
		options.server?.ws?.send('svelte:warnings', message);
	}
}

/**
 * @param {import('svelte/compiler').Warning} warning
 * @param {boolean} isBuild
 * @param {boolean} [emitCss]
 * @returns {boolean}
 */
function ignoreCompilerWarning(warning, isBuild, emitCss) {
	return (
		(!emitCss && warning.code === 'css_unused_selector') || // same as rollup-plugin-svelte
		(!isBuild && isNoScopableElementWarning(warning))
	);
}

/**
 *
 * @param {import('svelte/compiler').Warning} warning
 * @returns {boolean}
 */
function isNoScopableElementWarning(warning) {
	// see https://github.com/sveltejs/vite-plugin-svelte/issues/153
	return warning.code === 'css_unused_selector' && warning.message.includes('"*"');
}

/**
 *
 * @param {import('svelte/compiler').Warning[]} warnings
 * @param {boolean} isBuild
 * @returns {import('svelte/compiler').Warning[]}
 */
function buildExtraWarnings(warnings, isBuild) {
	const extraWarnings = [];
	if (!isBuild) {
		const noScopableElementWarnings = warnings.filter((w) => isNoScopableElementWarning(w));
		if (noScopableElementWarnings.length > 0) {
			// in case there are multiple, use last one as that is the one caused by our *{} rule
			const noScopableElementWarning =
				noScopableElementWarnings[noScopableElementWarnings.length - 1];
			extraWarnings.push({
				...noScopableElementWarning,
				code: 'vite-plugin-svelte-css-no-scopable-elements',
				message:
					"No scopable elements found in template. If you're using global styles in the style tag, you should move it into an external stylesheet file and import it in JS. See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#where-should-i-put-my-global-styles."
			});
		}
	}
	return extraWarnings;
}

/**
 * @param {import('svelte/compiler').Warning} w
 */
function warnDev(w) {
	if (w.filename?.includes('node_modules')) {
		if (isDebugNamespaceEnabled('node-modules-onwarn')) {
			log.debug(buildExtendedLogMessage(w), undefined, 'node-modules-onwarn');
		}
	} else if (log.info.enabled) {
		log.info(buildExtendedLogMessage(w));
	}
}

/**
 * @param {import('svelte/compiler').Warning & {frame?: string}} w
 */
function warnBuild(w) {
	if (w.filename?.includes('node_modules')) {
		if (isDebugNamespaceEnabled('node-modules-onwarn')) {
			log.debug(buildExtendedLogMessage(w), w.frame, 'node-modules-onwarn');
		}
	} else if (log.warn.enabled) {
		log.warn(buildExtendedLogMessage(w), w.frame);
	}
}

/**
 * @param {import('svelte/compiler').Warning} w
 */
function buildExtendedLogMessage(w) {
	const parts = [];
	if (w.filename) {
		parts.push(w.filename);
	}
	if (w.start) {
		parts.push(':', w.start.line, ':', w.start.column);
	}
	if (w.message) {
		if (parts.length > 0) {
			parts.push(' ');
		}
		parts.push(w.message);
	}
	return parts.join('');
}

/**
 * @param {string} namespace
 * @returns {boolean}
 */
function isDebugNamespaceEnabled(namespace) {
	return createDebugger.enabled(`${prefix}:${namespace}`);
}

/**
 * convert an error thrown by svelte.compile to a RollupError so that vite displays it in a user friendly way
 * @param {import('svelte/compiler').Warning & Error & {frame?: string}} error a svelte compiler error, which is a mix of Warning and an error
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {import('vite').Rollup.RollupError} the converted error
 */
function toRollupError(error, options) {
	const { filename, frame, start, code, name, stack } = error;
	/** @type {import('vite').Rollup.RollupError} */
	const rollupError = {
		name, // needed otherwise sveltekit coalesce_to_error turns it into a string
		id: filename,
		message: buildExtendedLogMessage(error), // include filename:line:column so that it's clickable
		frame: formatFrameForVite(frame),
		code,
		stack: options.isBuild || options.isDebug || !frame ? stack : ''
	};
	if (start) {
		rollupError.loc = {
			line: start.line,
			column: start.column,
			file: filename
		};
	}
	return rollupError;
}

/**
 * convert an error thrown by svelte.compile to an esbuild PartialMessage
 * @param {import('svelte/compiler').Warning & Error  & {frame?: string}} error a svelte compiler error, which is a mix of Warning and an error
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {any} the converted error as esbuild PartialMessage
 *
 * note: typed any to avoid esbuild devDependency for a single internal type import
 */
function toESBuildError(error, options) {
	const { filename, frame, start, stack } = error;
	/** @type any */
	const partialMessage = {
		text: buildExtendedLogMessage(error)
	};
	if (start) {
		partialMessage.location = {
			line: start.line,
			column: start.column,
			file: filename,
			lineText: lineFromFrame(start.line, frame) // needed to get a meaningful error message on cli
		};
	}
	if (options.isBuild || options.isDebug || !frame) {
		partialMessage.detail = stack;
	}
	return partialMessage;
}

/**
 * extract line with number from codeframe
 *
 * @param {number} lineNo
 * @param {string} [frame]
 * @returns {string}
 */
function lineFromFrame(lineNo, frame) {
	if (!frame) {
		return '';
	}
	const lines = frame.split('\n');
	const errorLine = lines.find((line) => line.trimStart().startsWith(`${lineNo}: `));
	return errorLine ? errorLine.substring(errorLine.indexOf(': ') + 3) : '';
}

/**
 * vite error overlay expects a specific format to show frames
 * this reformats svelte frame (colon separated, less whitespace)
 * to one that vite displays on overlay ( pipe separated, more whitespace)
 * e.g.
 * ```
 * 1: foo
 * 2: bar;
 *       ^
 * 3: baz
 * ```
 * to
 * ```
 *  1 | foo
 *  2 | bar;
 *         ^
 *  3 | baz
 * ```
 * @see https://github.com/vitejs/vite/blob/96591bf9989529de839ba89958755eafe4c445ae/packages/vite/src/client/overlay.ts#L116
 * @param {string} [frame]
 * @returns {string}
 */
function formatFrameForVite(frame) {
	if (!frame) {
		return '';
	}
	return frame
		.split('\n')
		.map((line) => (line.match(/^\s+\^/) ? '   ' + line : ' ' + line.replace(':', ' | ')))
		.join('\n');
}

/**
 *
 * @param {string} code the svelte error code
 * @see https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/errors.js
 * @returns {boolean}
 */
function couldBeFixedByCssPreprocessor(code) {
	return code === 'expected_token' || code === 'unexpected_eof' || code?.startsWith('css_');
}

/**
 * @param {import('svelte/compiler').Warning & Error} err a svelte compiler error, which is a mix of Warning and an error
 * @param {string} originalCode
 * @param {import('../public.d.ts').Options['preprocess']} [preprocessors]
 */
function enhanceCompileError(err, originalCode, preprocessors) {
	preprocessors = arraify$1(preprocessors ?? []);

	/** @type {string[]} */
	const additionalMessages = [];

	// Handle incorrect CSS preprocessor usage
	if (couldBeFixedByCssPreprocessor(err.code)) {
		// Reference from Svelte: https://github.com/sveltejs/svelte/blob/9926347ad9dbdd0f3324d5538e25dcb7f5e442f8/packages/svelte/src/compiler/preprocess/index.js#L257
		const styleRe =
			/<!--[^]*?-->|<style((?:\s+[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;

		let m;
		while ((m = styleRe.exec(originalCode))) {
			// Warn missing lang attribute
			if (!m[1]?.includes('lang=')) {
				additionalMessages.push('Did you forget to add a lang attribute to your style tag?');
			}
			// Warn missing style preprocessor
			if (
				preprocessors.every((p) => p.style == null || p.name === 'inject-scope-everything-rule')
			) {
				const preprocessorType = m[1]?.match(/lang="(.+?)"/)?.[1] ?? 'style';
				additionalMessages.push(
					`Did you forget to add a ${preprocessorType} preprocessor? See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/preprocess.md for more information.`
				);
			}
		}
	}

	if (additionalMessages.length) {
		err.message += '\n\n- ' + additionalMessages.join('\n- ');
	}

	return err;
}

/**
 * @param {T | T[]} value
 * @template T
 */
function arraify$1(value) {
	return Array.isArray(value) ? value : [value];
}

/**
 * Vite-specific HMR handling
 *
 * @param {Function} compileSvelte
 * @param {import('vite').HmrContext} ctx
 * @param {import('./types/id.d.ts').SvelteRequest} svelteRequest
 * @param {import('./utils/vite-plugin-svelte-cache.js').VitePluginSvelteCache} cache
 * @param {import('./types/options.d.ts').ResolvedOptions} options
 * @returns {Promise<import('vite').ModuleNode[] | void>}
 */
async function handleHotUpdate(compileSvelte, ctx, svelteRequest, cache, options) {
	if (!cache.has(svelteRequest)) {
		// file hasn't been requested yet (e.g. async component)
		log.debug(
			`handleHotUpdate called before initial transform for ${svelteRequest.id}`,
			undefined,
			'hmr'
		);
		return;
	}
	const { read, server, modules } = ctx;

	const cachedJS = cache.getJS(svelteRequest);
	const cachedCss = cache.getCSS(svelteRequest);

	const content = await read();
	/** @type {import('./types/compile.d.ts').CompileData} */
	let compileData;
	try {
		compileData = await compileSvelte(svelteRequest, content, options);
		cache.update(compileData);
	} catch (e) {
		cache.setError(svelteRequest, e);
		throw toRollupError(e, options);
	}

	const affectedModules = [...modules];

	const cssIdx = modules.findIndex((m) => m.id === svelteRequest.cssId);
	if (cssIdx > -1) {
		const cssUpdated = cssChanged(cachedCss, compileData.compiled.css);
		if (!cssUpdated) {
			log.debug(`skipping unchanged css for ${svelteRequest.cssId}`, undefined, 'hmr');
			affectedModules.splice(cssIdx, 1);
		}
	}
	const jsIdx = modules.findIndex((m) => m.id === svelteRequest.id);
	if (jsIdx > -1) {
		const jsUpdated = jsChanged(cachedJS, compileData.compiled.js, svelteRequest.filename);
		if (!jsUpdated) {
			log.debug(`skipping unchanged js for ${svelteRequest.id}`, undefined, 'hmr');
			affectedModules.splice(jsIdx, 1);
			// transform won't be called, log warnings here
			logCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);
		}
	}

	// TODO is this enough? see also: https://github.com/vitejs/vite/issues/2274
	const ssrModulesToInvalidate = affectedModules.filter((m) => !!m.ssrTransformResult);
	if (ssrModulesToInvalidate.length > 0) {
		log.debug(
			`invalidating modules ${ssrModulesToInvalidate.map((m) => m.id).join(', ')}`,
			undefined,
			'hmr'
		);
		ssrModulesToInvalidate.forEach((moduleNode) => server.moduleGraph.invalidateModule(moduleNode));
	}
	if (affectedModules.length > 0) {
		log.debug(
			`handleHotUpdate for ${svelteRequest.id} result: ${affectedModules
				.map((m) => m.id)
				.join(', ')}`,
			undefined,
			'hmr'
		);
	}
	return affectedModules;
}

/**
 * @param {import('./types/compile.d.ts').Code | null} [prev]
 * @param {import('./types/compile.d.ts').Code | null} [next]
 * @returns {boolean}
 */
function cssChanged(prev, next) {
	return !isCodeEqual(prev?.code, next?.code);
}

/**
 * @param {import('./types/compile.d.ts').Code | null} [prev]
 * @param {import('./types/compile.d.ts').Code | null} [next]
 * @param {string} [filename]
 * @returns {boolean}
 */
function jsChanged(prev, next, filename) {
	const prevJs = prev?.code;
	const nextJs = next?.code;
	const isStrictEqual = isCodeEqual(prevJs, nextJs);
	if (isStrictEqual) {
		return false;
	}
	const isLooseEqual = isCodeEqual(normalizeJsCode(prevJs), normalizeJsCode(nextJs));
	if (!isStrictEqual && isLooseEqual) {
		log.debug(
			`ignoring compiler output js change for ${filename} as it is equal to previous output after normalization`,
			undefined,
			'hmr'
		);
	}
	return !isLooseEqual;
}

/**
 * @param {string} [prev]
 * @param {string} [next]
 * @returns {boolean}
 */
function isCodeEqual(prev, next) {
	if (!prev && !next) {
		return true;
	}
	if ((!prev && next) || (prev && !next)) {
		return false;
	}
	return prev === next;
}

/**
 * remove code that only changes metadata and does not require a js update for the component to keep working
 *
 * 1) add_location() calls. These add location metadata to elements, only used by some dev tools
 * 2) ... maybe more (or less) in the future
 *
 * @param {string} [code]
 * @returns {string | undefined}
 */
function normalizeJsCode(code) {
	if (!code) {
		return code;
	}
	return code.replace(/\s*\badd_location\s*\([^)]*\)\s*;?/g, '');
}

/** @import { Context, Visitor, Visitors } from './types.js' */

/**
 * @template {{ type: string }} T
 * @template {Record<string, any> | null} U
 * @param {T} node
 * @param {U} state
 * @param {Visitors<T, U>} visitors
 */
function walk$1(node, state, visitors) {
	const universal = visitors._;

	let stopped = false;

	/** @type {Visitor<T, U, T>} _ */
	function default_visitor(_, { next, state }) {
		next(state);
	}

	/**
	 * @param {T} node
	 * @param {T[]} path
	 * @param {U} state
	 * @returns {T | undefined}
	 */
	function visit(node, path, state) {
		// Don't return the node here or it could lead to false-positive mutation detection
		if (stopped) return;
		if (!node.type) return;

		/** @type {T | void} */
		let result;

		/** @type {Record<string, any>} */
		const mutations = {};

		/** @type {Context<T, U>} */
		const context = {
			path,
			state,
			next: (next_state = state) => {
				path.push(node);
				for (const key in node) {
					if (key === 'type') continue;

					const child_node = node[key];
					if (child_node && typeof child_node === 'object') {
						if (Array.isArray(child_node)) {
							/** @type {Record<number, T>} */
							const array_mutations = {};
							const len = child_node.length;

							let mutated = false;

							for (let i = 0; i < len; i++) {
								const node = child_node[i];
								if (node && typeof node === 'object') {
									const result = visit(node, path, next_state);
									if (result) {
										array_mutations[i] = result;
										mutated = true;
									}
								}
							}

							if (mutated) {
								mutations[key] = child_node.map(
									(node, i) => array_mutations[i] ?? node
								);
							}
						} else {
							const result = visit(
								/** @type {T} */ (child_node),
								path,
								next_state
							);

							// @ts-ignore
							if (result) {
								mutations[key] = result;
							}
						}
					}
				}
				path.pop();

				if (Object.keys(mutations).length > 0) {
					return apply_mutations(node, mutations);
				}
			},
			stop: () => {
				stopped = true;
			},
			visit: (next_node, next_state = state) => {
				path.push(node);
				const result = visit(next_node, path, next_state) ?? next_node;
				path.pop();
				return result;
			}
		};

		let visitor = /** @type {Visitor<T, U, T>} */ (
			visitors[/** @type {T['type']} */ (node.type)] ?? default_visitor
		);

		if (universal) {
			/** @type {T | void} */
			let inner_result;

			result = universal(node, {
				...context,
				/** @param {U} next_state */
				next: (next_state = state) => {
					state = next_state; // make it the default for subsequent specialised visitors

					inner_result = visitor(node, {
						...context,
						state: next_state
					});

					return inner_result;
				}
			});

			// @ts-expect-error TypeScript doesn't understand that `context.next(...)` is called immediately
			if (!result && inner_result) {
				result = inner_result;
			}
		} else {
			result = visitor(node, context);
		}

		if (!result) {
			if (Object.keys(mutations).length > 0) {
				result = apply_mutations(node, mutations);
			}
		}

		if (result) {
			return result;
		}
	}

	return visit(node, [], state) ?? node;
}

/**
 * @template {Record<string, any>} T
 * @param {T} node
 * @param {Record<string, any>} mutations
 * @returns {T}
 */
function apply_mutations(node, mutations) {
	/** @type {Record<string, any>} */
	const obj = {};

	const descriptors = Object.getOwnPropertyDescriptors(node);

	for (const key in descriptors) {
		Object.defineProperty(obj, key, descriptors[key]);
	}

	for (const key in mutations) {
		obj[key] = mutations[key];
	}

	return /** @type {T} */ (obj);
}

const regex_whitespace = /\s/;
const regex_whitespaces = /\s+/;
const regex_starts_with_newline = /^\r?\n/;
const regex_starts_with_whitespace = /^\s/;
const regex_starts_with_whitespaces = /^[ \t\r\n]+/;
const regex_ends_with_whitespace = /\s$/;
const regex_ends_with_whitespaces = /[ \t\r\n]+$/;
/** Not \S because that also removes explicit whitespace defined through things like `&nbsp;` */
const regex_not_whitespace = /[^ \t\r\n]/;
/** Not \s+ because that also includes explicit whitespace defined through things like `&nbsp;` */
const regex_whitespaces_strict = /[ \t\n\r\f]+/g;

const regex_only_whitespaces = /^[ \t\n\r\f]+$/;

const regex_not_newline_characters = /[^\n]/g;

const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
// used in replace all to remove all invalid chars from a literal identifier
const regex_invalid_identifier_chars = /(^[^a-zA-Z_$]|[^a-zA-Z0-9_$])/g;

const regex_starts_with_vowel = /^[aeiou]/;
const regex_heading_tags = /^h[1-6]$/;
const regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
const regex_bidirectional_control_characters =
	/[\u202a\u202b\u202c\u202d\u202e\u2066\u2067\u2068\u2069]+/g;
const regex_js_prefix = /^\W*javascript:/i;
const regex_redundant_img_alt = /\b(image|picture|photo)\b/i;

/**
 * @param {string} name
 * @param {string[]} names
 * @returns {string | null}
 */
function fuzzymatch(name, names) {
	if (names.length === 0) return null;

	const set = new FuzzySet(names);
	const matches = set.get(name);

	return matches && matches[0][0] > 0.7 ? matches[0][1] : null;
}

// adapted from https://github.com/Glench/fuzzyset.js/blob/master/lib/fuzzyset.js in 2016
// BSD Licensed (see https://github.com/Glench/fuzzyset.js/issues/10)

const GRAM_SIZE_LOWER = 2;
const GRAM_SIZE_UPPER = 3;

// return an edit distance from 0 to 1

/**
 * @param {string} str1
 * @param {string} str2
 */
function _distance(str1, str2) {
	if (str1 === null && str2 === null) {
		throw 'Trying to compare two null values';
	}
	if (str1 === null || str2 === null) return 0;
	str1 = String(str1);
	str2 = String(str2);

	const distance = levenshtein(str1, str2);
	return 1 - distance / Math.max(str1.length, str2.length);
}

// helper functions

/**
 * @param {string} str1
 * @param {string} str2
 */
function levenshtein(str1, str2) {
	/** @type {number[]} */
	const current = [];
	let prev = 0;
	let value = 0;

	for (let i = 0; i <= str2.length; i++) {
		for (let j = 0; j <= str1.length; j++) {
			if (i && j) {
				if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
					value = prev;
				} else {
					value = Math.min(current[j], current[j - 1], prev) + 1;
				}
			} else {
				value = i + j;
			}

			prev = current[j];
			current[j] = value;
		}
	}

	return /** @type {number} */ (current.pop());
}

const non_word_regex = /[^\w, ]+/;

/**
 * @param {string} value
 * @param {any} gram_size
 */
function iterate_grams(value, gram_size = 2) {
	const simplified = '-' + value.toLowerCase().replace(non_word_regex, '') + '-';
	const len_diff = gram_size - simplified.length;
	const results = [];

	if (len_diff > 0) {
		for (let i = 0; i < len_diff; ++i) {
			value += '-';
		}
	}
	for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
		results.push(simplified.slice(i, i + gram_size));
	}
	return results;
}

/**
 * @param {string} value
 * @param {any} gram_size
 */
function gram_counter(value, gram_size = 2) {
	// return an object where key=gram, value=number of occurrences

	/** @type {Record<string, number>} */
	const result = {};
	const grams = iterate_grams(value, gram_size);
	let i = 0;

	for (i; i < grams.length; ++i) {
		if (grams[i] in result) {
			result[grams[i]] += 1;
		} else {
			result[grams[i]] = 1;
		}
	}
	return result;
}

/**
 * @param {MatchTuple} a
 * @param {MatchTuple} b
 */
function sort_descending(a, b) {
	return b[0] - a[0];
}

class FuzzySet {
	/** @type {Record<string, string>} */
	exact_set = {};

	/** @type {Record<string, [number, number][]>} */
	match_dict = {};

	/** @type {Record<string, number[]>} */
	items = {};

	/** @param {string[]} arr */
	constructor(arr) {
		// initialisation
		for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
			this.items[i] = [];
		}

		// add all the items to the set
		for (let i = 0; i < arr.length; ++i) {
			this.add(arr[i]);
		}
	}

	/** @param {string} value */
	add(value) {
		const normalized_value = value.toLowerCase();
		if (normalized_value in this.exact_set) {
			return false;
		}

		let i = GRAM_SIZE_LOWER;
		for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
			this._add(value, i);
		}
	}

	/**
	 * @param {string} value
	 * @param {number} gram_size
	 */
	_add(value, gram_size) {
		const normalized_value = value.toLowerCase();
		const items = this.items[gram_size] || [];
		const index = items.length;

		items.push(0);
		const gram_counts = gram_counter(normalized_value, gram_size);
		let sum_of_square_gram_counts = 0;
		let gram;
		let gram_count;

		for (gram in gram_counts) {
			gram_count = gram_counts[gram];
			sum_of_square_gram_counts += Math.pow(gram_count, 2);
			if (gram in this.match_dict) {
				this.match_dict[gram].push([index, gram_count]);
			} else {
				this.match_dict[gram] = [[index, gram_count]];
			}
		}
		const vector_normal = Math.sqrt(sum_of_square_gram_counts);
		// @ts-ignore no idea what this code is doing
		items[index] = [vector_normal, normalized_value];
		this.items[gram_size] = items;
		this.exact_set[normalized_value] = value;
	}

	/** @param {string} value */
	get(value) {
		const normalized_value = value.toLowerCase();
		const result = this.exact_set[normalized_value];

		if (result) {
			return /** @type {MatchTuple[]} */ ([[1, result]]);
		}

		// start with high gram size and if there are no results, go to lower gram sizes
		for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
			const results = this.__get(value, gram_size);
			if (results.length > 0) return results;
		}
		return null;
	}

	/**
	 * @param {string} value
	 * @param {number} gram_size
	 * @returns {MatchTuple[]}
	 */
	__get(value, gram_size) {
		const normalized_value = value.toLowerCase();

		/** @type {Record<string, number>} */
		const matches = {};
		const gram_counts = gram_counter(normalized_value, gram_size);
		const items = this.items[gram_size];
		let sum_of_square_gram_counts = 0;
		let gram;
		let gram_count;
		let i;
		let index;
		let other_gram_count;

		for (gram in gram_counts) {
			gram_count = gram_counts[gram];
			sum_of_square_gram_counts += Math.pow(gram_count, 2);
			if (gram in this.match_dict) {
				for (i = 0; i < this.match_dict[gram].length; ++i) {
					index = this.match_dict[gram][i][0];
					other_gram_count = this.match_dict[gram][i][1];
					if (index in matches) {
						matches[index] += gram_count * other_gram_count;
					} else {
						matches[index] = gram_count * other_gram_count;
					}
				}
			}
		}

		const vector_normal = Math.sqrt(sum_of_square_gram_counts);

		/** @type {MatchTuple[]} */
		let results = [];
		let match_score;

		// build a results list of [score, str]
		for (const match_index in matches) {
			match_score = matches[match_index];
			// @ts-ignore no idea what this code is doing
			results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
		}

		results.sort(sort_descending);

		/** @type {MatchTuple[]} */
		let new_results = [];
		const end_index = Math.min(50, results.length);
		// truncate somewhat arbitrarily to 50
		for (let i = 0; i < end_index; ++i) {
			// @ts-ignore no idea what this code is doing
			new_results.push([_distance(results[i][1], normalized_value), results[i][1]]);
		}
		results = new_results;
		results.sort(sort_descending);

		new_results = [];
		for (let i = 0; i < results.length; ++i) {
			if (results[i][0] === results[0][0]) {
				// @ts-ignore no idea what this code is doing
				new_results.push([results[i][0], this.exact_set[results[i][1]]]);
			}
		}

		return new_results;
	}
}

/** @typedef {[score: number, match: string]} MatchTuple */

/** @typedef {import('./types').Location} Location */

/**
 * @param {import('./types').Range} range
 * @param {number} index
 */
function rangeContains(range, index) {
	return range.start <= index && index < range.end;
}

/**
 * @param {string} source
 * @param {import('./types').Options} [options]
 */
function getLocator$1(source, options = {}) {
	const { offsetLine = 0, offsetColumn = 0 } = options;

	let start = 0;
	const ranges = source.split('\n').map((line, i) => {
		const end = start + line.length + 1;

		/** @type {import('./types').Range} */
		const range = { start, end, line: i };

		start = end;
		return range;
	});

	let i = 0;

	/**
	 * @param {string | number} search
	 * @param {number} [index]
	 * @returns {Location | undefined}
	 */
	function locator(search, index) {
		if (typeof search === 'string') {
			search = source.indexOf(search, index ?? 0);
		}

		if (search === -1) return undefined;

		let range = ranges[i];

		const d = search >= range.end ? 1 : -1;

		while (range) {
			if (rangeContains(range, search)) {
				return {
					line: offsetLine + range.line,
					column: offsetColumn + search - range.start,
					character: search
				};
			}

			i += d;
			range = ranges[i];
		}
	}

	return locator;
}

/** @import { Location } from 'locate-character' */
/** @import { CompileOptions } from './types' */
/** @import { AST, Warning } from '#compiler' */

/** @typedef {{ start?: number, end?: number }} NodeLike */

/** @type {Warning[]} */
let warnings = [];

/**
 * The filename relative to the rootDir (if specified).
 * This should not be used in the compiler output except in dev mode
 * @type {string}
 */
let filename;

/**
 * This is the fallback used when no filename is specified.
 */
const UNKNOWN_FILENAME = '(unknown)';

/**
 * The name of the component that is used in the `export default function ...` statement.
 */
let component_name = '<unknown>';

/**
 * The original source code
 * @type {string}
 */
let source;

/**
 * True if compiling with `dev: true`
 * @type {boolean}
 */
let dev;

/** @type {(index: number) => Location} */
let locator;

/** @param {string} value */
function set_source(value) {
	source = value;

	const l = getLocator$1(source, { offsetLine: 1 });

	locator = (i) => {
		const loc = l(i);
		if (!loc) throw new Error('An impossible situation occurred');

		return loc;
	};
}

/**
 * @param {AST.SvelteNode & { start?: number | undefined }} node
 */
function locate_node(node) {
	const loc = locator(/** @type {number} */ (node.start));
	return `${sanitize_location(filename)}:${loc?.line}:${loc.column}`;
}

/** @type {NonNullable<CompileOptions['warningFilter']>} */
let warning_filter;

/**
 * The current stack of ignored warnings
 * @type {Set<string>[]}
 */
let ignore_stack = [];

/**
 * For each node the list of warnings that should be ignored for that node.
 * Exists in addition to `ignore_stack` because not all warnings are emitted
 * while the stack is being built.
 * @type {Map<AST.SvelteNode | NodeLike, Set<string>[]>}
 */
let ignore_map = new Map();

/**
 * @param {string[]} ignores
 */
function push_ignore(ignores) {
	const next = new Set([...(ignore_stack.at(-1) || []), ...ignores]);
	ignore_stack.push(next);
}

function pop_ignore() {
	ignore_stack.pop();
}

/**
 * @param {AST.SvelteNode | NodeLike} node
 * @param {typeof import('../constants.js').IGNORABLE_RUNTIME_WARNINGS[number]} code
 * @returns
 */
function is_ignored(node, code) {
	return dev && !!ignore_map.get(node)?.some((codes) => codes.has(code));
}

/**
 * Call this to reset the compiler state. Should be called before each compilation.
 * @param {{ warning?: (warning: Warning) => boolean; filename: string | undefined }} state
 */
function reset(state) {
	dev = false;
	component_name = UNKNOWN_FILENAME;
	source = '';
	filename = (state.filename ?? UNKNOWN_FILENAME).replace(/\\/g, '/');
	warning_filter = state.warning ?? (() => true);
	warnings = [];
}

/**
 * Adjust the compiler state based on the provided state object.
 * Call this after parsing and basic analysis happened.
 * @param {{
 *   dev: boolean;
 *   component_name?: string;
 *   rootDir?: string;
 *   runes: boolean;
 * }} state
 */
function adjust(state) {
	const root_dir = state.rootDir?.replace(/\\/g, '/');

	dev = state.dev;
	state.runes;
	component_name = state.component_name ?? UNKNOWN_FILENAME;

	if (typeof root_dir === 'string' && filename.startsWith(root_dir)) {
		// make filename relative to rootDir
		filename = filename.replace(root_dir, '').replace(/^[/\\]/, '');
	}

	ignore_stack = [];
	ignore_map.clear();
}

/** @import { Location } from 'locate-character' */

const regex_tabs = /^\t+/;

/**
 * @param {string} str
 */
function tabs_to_spaces(str) {
	return str.replace(regex_tabs, (match) => match.split('\t').join('  '));
}

/**
 * @param {string} source
 * @param {number} line
 * @param {number} column
 */
function get_code_frame(source, line, column) {
	const lines = source.split('\n');
	const frame_start = Math.max(0, line - 2);
	const frame_end = Math.min(line + 3, lines.length);
	const digits = String(frame_end + 1).length;
	return lines
		.slice(frame_start, frame_end)
		.map((str, i) => {
			const is_error_line = frame_start + i === line;
			const line_num = String(i + frame_start + 1).padStart(digits, ' ');
			if (is_error_line) {
				const indicator =
					' '.repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + '^';
				return `${line_num}: ${tabs_to_spaces(str)}\n${indicator}`;
			}
			return `${line_num}: ${tabs_to_spaces(str)}`;
		})
		.join('\n');
}

/**
 * @typedef {{
 * 	code: string;
 * 	message: string;
 *  stack?: string;
 * 	filename?: string;
 * 	start?: Location;
 * 	end?: Location;
 * 	position?: [number, number];
 * 	frame?: string;
 * }} ICompileDiagnostic
 */

/** @implements {ICompileDiagnostic} */
class CompileDiagnostic {
	name = 'CompileDiagnostic';

	/**
	 * @param {string} code
	 * @param {string} message
	 * @param {[number, number] | undefined} position
	 */
	constructor(code, message, position) {
		this.code = code;
		this.message = message;

		if (filename !== UNKNOWN_FILENAME) {
			this.filename = filename;
		}

		if (position) {
			this.position = position;
			this.start = locator(position[0]);
			this.end = locator(position[1]);
			if (this.start && this.end) {
				this.frame = get_code_frame(source, this.start.line - 1, this.end.column);
			}
		}
	}

	toString() {
		let out = `${this.code}: ${this.message}`;

		if (this.filename) {
			out += `\n${this.filename}`;

			if (this.start) {
				out += `:${this.start.line}:${this.start.column}`;
			}
		}

		if (this.frame) {
			out += `\n${this.frame}`;
		}

		return out;
	}

	toJSON() {
		return {
			code: this.code,
			message: this.message,
			filename: this.filename,
			start: this.start,
			end: this.end,
			position: this.position,
			frame: this.frame
		};
	}
}

/* This file is generated by scripts/process-messages/index.js. Do not edit! */


/** @typedef {{ start?: number, end?: number }} NodeLike */
class InternalCompileWarning extends CompileDiagnostic {
	name = 'CompileWarning';

	/**
	 * @param {string} code
	 * @param {string} message
	 * @param {[number, number] | undefined} position
	 */
	constructor(code, message, position) {
		super(code, message, position);
	}
}

/**
 * @param {null | NodeLike} node
 * @param {string} code
 * @param {string} message
 */
function w(node, code, message) {
	let stack = ignore_stack;

	if (node) {
		stack = ignore_map.get(node) ?? ignore_stack;
	}

	if (stack && stack.at(-1)?.has(code)) return;

	const warning = new InternalCompileWarning(code, message, node && node.start !== undefined ? [node.start, node.end ?? node.start] : undefined);

	if (!warning_filter(warning)) return;

	warnings.push(warning);
}

const codes$1 = [
	'a11y_accesskey',
	'a11y_aria_activedescendant_has_tabindex',
	'a11y_aria_attributes',
	'a11y_autocomplete_valid',
	'a11y_autofocus',
	'a11y_click_events_have_key_events',
	'a11y_consider_explicit_label',
	'a11y_distracting_elements',
	'a11y_figcaption_index',
	'a11y_figcaption_parent',
	'a11y_hidden',
	'a11y_img_redundant_alt',
	'a11y_incorrect_aria_attribute_type',
	'a11y_incorrect_aria_attribute_type_boolean',
	'a11y_incorrect_aria_attribute_type_id',
	'a11y_incorrect_aria_attribute_type_idlist',
	'a11y_incorrect_aria_attribute_type_integer',
	'a11y_incorrect_aria_attribute_type_token',
	'a11y_incorrect_aria_attribute_type_tokenlist',
	'a11y_incorrect_aria_attribute_type_tristate',
	'a11y_interactive_supports_focus',
	'a11y_invalid_attribute',
	'a11y_label_has_associated_control',
	'a11y_media_has_caption',
	'a11y_misplaced_role',
	'a11y_misplaced_scope',
	'a11y_missing_attribute',
	'a11y_missing_content',
	'a11y_mouse_events_have_key_events',
	'a11y_no_abstract_role',
	'a11y_no_interactive_element_to_noninteractive_role',
	'a11y_no_noninteractive_element_interactions',
	'a11y_no_noninteractive_element_to_interactive_role',
	'a11y_no_noninteractive_tabindex',
	'a11y_no_redundant_roles',
	'a11y_no_static_element_interactions',
	'a11y_positive_tabindex',
	'a11y_role_has_required_aria_props',
	'a11y_role_supports_aria_props',
	'a11y_role_supports_aria_props_implicit',
	'a11y_unknown_aria_attribute',
	'a11y_unknown_role',
	'bidirectional_control_characters',
	'legacy_code',
	'unknown_code',
	'options_deprecated_accessors',
	'options_deprecated_immutable',
	'options_missing_custom_element',
	'options_removed_enable_sourcemap',
	'options_removed_hydratable',
	'options_removed_loop_guard_timeout',
	'options_renamed_ssr_dom',
	'custom_element_props_identifier',
	'export_let_unused',
	'legacy_component_creation',
	'non_reactive_update',
	'perf_avoid_inline_class',
	'perf_avoid_nested_class',
	'reactive_declaration_invalid_placement',
	'reactive_declaration_module_script_dependency',
	'state_referenced_locally',
	'store_rune_conflict',
	'css_unused_selector',
	'attribute_avoid_is',
	'attribute_global_event_reference',
	'attribute_illegal_colon',
	'attribute_invalid_property_name',
	'attribute_quoted',
	'bind_invalid_each_rest',
	'block_empty',
	'component_name_lowercase',
	'element_implicitly_closed',
	'element_invalid_self_closing_tag',
	'event_directive_deprecated',
	'node_invalid_placement_ssr',
	'script_context_deprecated',
	'script_unknown_attribute',
	'slot_element_deprecated',
	'svelte_component_deprecated',
	'svelte_element_invalid_this',
	'svelte_self_deprecated'
];

/**
 * Avoid using accesskey
 * @param {null | NodeLike} node
 */
function a11y_accesskey(node) {
	w(node, 'a11y_accesskey', `Avoid using accesskey\nhttps://svelte.dev/e/a11y_accesskey`);
}

/**
 * An element with an aria-activedescendant attribute should have a tabindex value
 * @param {null | NodeLike} node
 */
function a11y_aria_activedescendant_has_tabindex(node) {
	w(node, 'a11y_aria_activedescendant_has_tabindex', `An element with an aria-activedescendant attribute should have a tabindex value\nhttps://svelte.dev/e/a11y_aria_activedescendant_has_tabindex`);
}

/**
 * `<%name%>` should not have aria-* attributes
 * @param {null | NodeLike} node
 * @param {string} name
 */
function a11y_aria_attributes(node, name) {
	w(node, 'a11y_aria_attributes', `\`<${name}>\` should not have aria-* attributes\nhttps://svelte.dev/e/a11y_aria_attributes`);
}

/**
 * '%value%' is an invalid value for 'autocomplete' on `<input type="%type%">`
 * @param {null | NodeLike} node
 * @param {string} value
 * @param {string} type
 */
function a11y_autocomplete_valid(node, value, type) {
	w(node, 'a11y_autocomplete_valid', `'${value}' is an invalid value for 'autocomplete' on \`<input type="${type}">\`\nhttps://svelte.dev/e/a11y_autocomplete_valid`);
}

/**
 * Avoid using autofocus
 * @param {null | NodeLike} node
 */
function a11y_autofocus(node) {
	w(node, 'a11y_autofocus', `Avoid using autofocus\nhttps://svelte.dev/e/a11y_autofocus`);
}

/**
 * Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as `<button type="button">` or `<a>` might be more appropriate
 * @param {null | NodeLike} node
 */
function a11y_click_events_have_key_events(node) {
	w(node, 'a11y_click_events_have_key_events', `Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as \`<button type="button">\` or \`<a>\` might be more appropriate\nhttps://svelte.dev/e/a11y_click_events_have_key_events`);
}

/**
 * Buttons and links should either contain text or have an `aria-label`, `aria-labelledby` or `title` attribute
 * @param {null | NodeLike} node
 */
function a11y_consider_explicit_label(node) {
	w(node, 'a11y_consider_explicit_label', `Buttons and links should either contain text or have an \`aria-label\`, \`aria-labelledby\` or \`title\` attribute\nhttps://svelte.dev/e/a11y_consider_explicit_label`);
}

/**
 * Avoid `<%name%>` elements
 * @param {null | NodeLike} node
 * @param {string} name
 */
function a11y_distracting_elements$1(node, name) {
	w(node, 'a11y_distracting_elements', `Avoid \`<${name}>\` elements\nhttps://svelte.dev/e/a11y_distracting_elements`);
}

/**
 * `<figcaption>` must be first or last child of `<figure>`
 * @param {null | NodeLike} node
 */
function a11y_figcaption_index(node) {
	w(node, 'a11y_figcaption_index', `\`<figcaption>\` must be first or last child of \`<figure>\`\nhttps://svelte.dev/e/a11y_figcaption_index`);
}

/**
 * `<figcaption>` must be an immediate child of `<figure>`
 * @param {null | NodeLike} node
 */
function a11y_figcaption_parent(node) {
	w(node, 'a11y_figcaption_parent', `\`<figcaption>\` must be an immediate child of \`<figure>\`\nhttps://svelte.dev/e/a11y_figcaption_parent`);
}

/**
 * `<%name%>` element should not be hidden
 * @param {null | NodeLike} node
 * @param {string} name
 */
function a11y_hidden(node, name) {
	w(node, 'a11y_hidden', `\`<${name}>\` element should not be hidden\nhttps://svelte.dev/e/a11y_hidden`);
}

/**
 * Screenreaders already announce `<img>` elements as an image
 * @param {null | NodeLike} node
 */
function a11y_img_redundant_alt(node) {
	w(node, 'a11y_img_redundant_alt', `Screenreaders already announce \`<img>\` elements as an image\nhttps://svelte.dev/e/a11y_img_redundant_alt`);
}

/**
 * The value of '%attribute%' must be a %type%
 * @param {null | NodeLike} node
 * @param {string} attribute
 * @param {string} type
 */
function a11y_incorrect_aria_attribute_type(node, attribute, type) {
	w(node, 'a11y_incorrect_aria_attribute_type', `The value of '${attribute}' must be a ${type}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type`);
}

/**
 * The value of '%attribute%' must be either 'true' or 'false'. It cannot be empty
 * @param {null | NodeLike} node
 * @param {string} attribute
 */
function a11y_incorrect_aria_attribute_type_boolean(node, attribute) {
	w(node, 'a11y_incorrect_aria_attribute_type_boolean', `The value of '${attribute}' must be either 'true' or 'false'. It cannot be empty\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_boolean`);
}

/**
 * The value of '%attribute%' must be a space-separated list of strings that represent DOM element IDs
 * @param {null | NodeLike} node
 * @param {string} attribute
 */
function a11y_incorrect_aria_attribute_type_idlist(node, attribute) {
	w(node, 'a11y_incorrect_aria_attribute_type_idlist', `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_idlist`);
}

/**
 * The value of '%attribute%' must be an integer
 * @param {null | NodeLike} node
 * @param {string} attribute
 */
function a11y_incorrect_aria_attribute_type_integer(node, attribute) {
	w(node, 'a11y_incorrect_aria_attribute_type_integer', `The value of '${attribute}' must be an integer\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_integer`);
}

/**
 * The value of '%attribute%' must be exactly one of %values%
 * @param {null | NodeLike} node
 * @param {string} attribute
 * @param {string} values
 */
function a11y_incorrect_aria_attribute_type_token(node, attribute, values) {
	w(node, 'a11y_incorrect_aria_attribute_type_token', `The value of '${attribute}' must be exactly one of ${values}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_token`);
}

/**
 * The value of '%attribute%' must be a space-separated list of one or more of %values%
 * @param {null | NodeLike} node
 * @param {string} attribute
 * @param {string} values
 */
function a11y_incorrect_aria_attribute_type_tokenlist(node, attribute, values) {
	w(node, 'a11y_incorrect_aria_attribute_type_tokenlist', `The value of '${attribute}' must be a space-separated list of one or more of ${values}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_tokenlist`);
}

/**
 * The value of '%attribute%' must be exactly one of true, false, or mixed
 * @param {null | NodeLike} node
 * @param {string} attribute
 */
function a11y_incorrect_aria_attribute_type_tristate(node, attribute) {
	w(node, 'a11y_incorrect_aria_attribute_type_tristate', `The value of '${attribute}' must be exactly one of true, false, or mixed\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_tristate`);
}

/**
 * Elements with the '%role%' interactive role must have a tabindex value
 * @param {null | NodeLike} node
 * @param {string} role
 */
function a11y_interactive_supports_focus(node, role) {
	w(node, 'a11y_interactive_supports_focus', `Elements with the '${role}' interactive role must have a tabindex value\nhttps://svelte.dev/e/a11y_interactive_supports_focus`);
}

/**
 * '%href_value%' is not a valid %href_attribute% attribute
 * @param {null | NodeLike} node
 * @param {string} href_value
 * @param {string} href_attribute
 */
function a11y_invalid_attribute(node, href_value, href_attribute) {
	w(node, 'a11y_invalid_attribute', `'${href_value}' is not a valid ${href_attribute} attribute\nhttps://svelte.dev/e/a11y_invalid_attribute`);
}

/**
 * A form label must be associated with a control
 * @param {null | NodeLike} node
 */
function a11y_label_has_associated_control(node) {
	w(node, 'a11y_label_has_associated_control', `A form label must be associated with a control\nhttps://svelte.dev/e/a11y_label_has_associated_control`);
}

/**
 * `<video>` elements must have a `<track kind="captions">`
 * @param {null | NodeLike} node
 */
function a11y_media_has_caption(node) {
	w(node, 'a11y_media_has_caption', `\`<video>\` elements must have a \`<track kind="captions">\`\nhttps://svelte.dev/e/a11y_media_has_caption`);
}

/**
 * `<%name%>` should not have role attribute
 * @param {null | NodeLike} node
 * @param {string} name
 */
function a11y_misplaced_role(node, name) {
	w(node, 'a11y_misplaced_role', `\`<${name}>\` should not have role attribute\nhttps://svelte.dev/e/a11y_misplaced_role`);
}

/**
 * The scope attribute should only be used with `<th>` elements
 * @param {null | NodeLike} node
 */
function a11y_misplaced_scope(node) {
	w(node, 'a11y_misplaced_scope', `The scope attribute should only be used with \`<th>\` elements\nhttps://svelte.dev/e/a11y_misplaced_scope`);
}

/**
 * `<%name%>` element should have %article% %sequence% attribute
 * @param {null | NodeLike} node
 * @param {string} name
 * @param {string} article
 * @param {string} sequence
 */
function a11y_missing_attribute(node, name, article, sequence) {
	w(node, 'a11y_missing_attribute', `\`<${name}>\` element should have ${article} ${sequence} attribute\nhttps://svelte.dev/e/a11y_missing_attribute`);
}

/**
 * `<%name%>` element should contain text
 * @param {null | NodeLike} node
 * @param {string} name
 */
function a11y_missing_content(node, name) {
	w(node, 'a11y_missing_content', `\`<${name}>\` element should contain text\nhttps://svelte.dev/e/a11y_missing_content`);
}

/**
 * '%event%' event must be accompanied by '%accompanied_by%' event
 * @param {null | NodeLike} node
 * @param {string} event
 * @param {string} accompanied_by
 */
function a11y_mouse_events_have_key_events(node, event, accompanied_by) {
	w(node, 'a11y_mouse_events_have_key_events', `'${event}' event must be accompanied by '${accompanied_by}' event\nhttps://svelte.dev/e/a11y_mouse_events_have_key_events`);
}

/**
 * Abstract role '%role%' is forbidden
 * @param {null | NodeLike} node
 * @param {string} role
 */
function a11y_no_abstract_role(node, role) {
	w(node, 'a11y_no_abstract_role', `Abstract role '${role}' is forbidden\nhttps://svelte.dev/e/a11y_no_abstract_role`);
}

/**
 * `<%element%>` cannot have role '%role%'
 * @param {null | NodeLike} node
 * @param {string} element
 * @param {string} role
 */
function a11y_no_interactive_element_to_noninteractive_role(node, element, role) {
	w(node, 'a11y_no_interactive_element_to_noninteractive_role', `\`<${element}>\` cannot have role '${role}'\nhttps://svelte.dev/e/a11y_no_interactive_element_to_noninteractive_role`);
}

/**
 * Non-interactive element `<%element%>` should not be assigned mouse or keyboard event listeners
 * @param {null | NodeLike} node
 * @param {string} element
 */
function a11y_no_noninteractive_element_interactions(node, element) {
	w(node, 'a11y_no_noninteractive_element_interactions', `Non-interactive element \`<${element}>\` should not be assigned mouse or keyboard event listeners\nhttps://svelte.dev/e/a11y_no_noninteractive_element_interactions`);
}

/**
 * Non-interactive element `<%element%>` cannot have interactive role '%role%'
 * @param {null | NodeLike} node
 * @param {string} element
 * @param {string} role
 */
function a11y_no_noninteractive_element_to_interactive_role(node, element, role) {
	w(node, 'a11y_no_noninteractive_element_to_interactive_role', `Non-interactive element \`<${element}>\` cannot have interactive role '${role}'\nhttps://svelte.dev/e/a11y_no_noninteractive_element_to_interactive_role`);
}

/**
 * noninteractive element cannot have nonnegative tabIndex value
 * @param {null | NodeLike} node
 */
function a11y_no_noninteractive_tabindex(node) {
	w(node, 'a11y_no_noninteractive_tabindex', `noninteractive element cannot have nonnegative tabIndex value\nhttps://svelte.dev/e/a11y_no_noninteractive_tabindex`);
}

/**
 * Redundant role '%role%'
 * @param {null | NodeLike} node
 * @param {string} role
 */
function a11y_no_redundant_roles(node, role) {
	w(node, 'a11y_no_redundant_roles', `Redundant role '${role}'\nhttps://svelte.dev/e/a11y_no_redundant_roles`);
}

/**
 * `<%element%>` with a %handler% handler must have an ARIA role
 * @param {null | NodeLike} node
 * @param {string} element
 * @param {string} handler
 */
function a11y_no_static_element_interactions(node, element, handler) {
	w(node, 'a11y_no_static_element_interactions', `\`<${element}>\` with a ${handler} handler must have an ARIA role\nhttps://svelte.dev/e/a11y_no_static_element_interactions`);
}

/**
 * Avoid tabindex values above zero
 * @param {null | NodeLike} node
 */
function a11y_positive_tabindex(node) {
	w(node, 'a11y_positive_tabindex', `Avoid tabindex values above zero\nhttps://svelte.dev/e/a11y_positive_tabindex`);
}

/**
 * Elements with the ARIA role "%role%" must have the following attributes defined: %props%
 * @param {null | NodeLike} node
 * @param {string} role
 * @param {string} props
 */
function a11y_role_has_required_aria_props(node, role, props) {
	w(node, 'a11y_role_has_required_aria_props', `Elements with the ARIA role "${role}" must have the following attributes defined: ${props}\nhttps://svelte.dev/e/a11y_role_has_required_aria_props`);
}

/**
 * The attribute '%attribute%' is not supported by the role '%role%'
 * @param {null | NodeLike} node
 * @param {string} attribute
 * @param {string} role
 */
function a11y_role_supports_aria_props(node, attribute, role) {
	w(node, 'a11y_role_supports_aria_props', `The attribute '${attribute}' is not supported by the role '${role}'\nhttps://svelte.dev/e/a11y_role_supports_aria_props`);
}

/**
 * The attribute '%attribute%' is not supported by the role '%role%'. This role is implicit on the element `<%name%>`
 * @param {null | NodeLike} node
 * @param {string} attribute
 * @param {string} role
 * @param {string} name
 */
function a11y_role_supports_aria_props_implicit(node, attribute, role, name) {
	w(node, 'a11y_role_supports_aria_props_implicit', `The attribute '${attribute}' is not supported by the role '${role}'. This role is implicit on the element \`<${name}>\`\nhttps://svelte.dev/e/a11y_role_supports_aria_props_implicit`);
}

/**
 * Unknown aria attribute 'aria-%attribute%'. Did you mean '%suggestion%'?
 * @param {null | NodeLike} node
 * @param {string} attribute
 * @param {string | undefined | null} [suggestion]
 */
function a11y_unknown_aria_attribute(node, attribute, suggestion) {
	w(node, 'a11y_unknown_aria_attribute', `${suggestion
		? `Unknown aria attribute 'aria-${attribute}'. Did you mean '${suggestion}'?`
		: `Unknown aria attribute 'aria-${attribute}'`}\nhttps://svelte.dev/e/a11y_unknown_aria_attribute`);
}

/**
 * Unknown role '%role%'. Did you mean '%suggestion%'?
 * @param {null | NodeLike} node
 * @param {string} role
 * @param {string | undefined | null} [suggestion]
 */
function a11y_unknown_role(node, role, suggestion) {
	w(node, 'a11y_unknown_role', `${suggestion
		? `Unknown role '${role}'. Did you mean '${suggestion}'?`
		: `Unknown role '${role}'`}\nhttps://svelte.dev/e/a11y_unknown_role`);
}

/**
 * A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences
 * @param {null | NodeLike} node
 */
function bidirectional_control_characters(node) {
	w(node, 'bidirectional_control_characters', `A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences\nhttps://svelte.dev/e/bidirectional_control_characters`);
}

/**
 * `%code%` is no longer valid — please use `%suggestion%` instead
 * @param {null | NodeLike} node
 * @param {string} code
 * @param {string} suggestion
 */
function legacy_code(node, code, suggestion) {
	w(node, 'legacy_code', `\`${code}\` is no longer valid — please use \`${suggestion}\` instead\nhttps://svelte.dev/e/legacy_code`);
}

/**
 * `%code%` is not a recognised code (did you mean `%suggestion%`?)
 * @param {null | NodeLike} node
 * @param {string} code
 * @param {string | undefined | null} [suggestion]
 */
function unknown_code(node, code, suggestion) {
	w(node, 'unknown_code', `${suggestion
		? `\`${code}\` is not a recognised code (did you mean \`${suggestion}\`?)`
		: `\`${code}\` is not a recognised code`}\nhttps://svelte.dev/e/unknown_code`);
}

/**
 * The `accessors` option has been deprecated. It will have no effect in runes mode
 * @param {null | NodeLike} node
 */
function options_deprecated_accessors(node) {
	w(node, 'options_deprecated_accessors', `The \`accessors\` option has been deprecated. It will have no effect in runes mode\nhttps://svelte.dev/e/options_deprecated_accessors`);
}

/**
 * The `immutable` option has been deprecated. It will have no effect in runes mode
 * @param {null | NodeLike} node
 */
function options_deprecated_immutable(node) {
	w(node, 'options_deprecated_immutable', `The \`immutable\` option has been deprecated. It will have no effect in runes mode\nhttps://svelte.dev/e/options_deprecated_immutable`);
}

/**
 * The `customElement` option is used when generating a custom element. Did you forget the `customElement: true` compile option?
 * @param {null | NodeLike} node
 */
function options_missing_custom_element(node) {
	w(node, 'options_missing_custom_element', `The \`customElement\` option is used when generating a custom element. Did you forget the \`customElement: true\` compile option?\nhttps://svelte.dev/e/options_missing_custom_element`);
}

/**
 * The `enableSourcemap` option has been removed. Source maps are always generated now, and tooling can choose to ignore them
 * @param {null | NodeLike} node
 */
function options_removed_enable_sourcemap(node) {
	w(node, 'options_removed_enable_sourcemap', `The \`enableSourcemap\` option has been removed. Source maps are always generated now, and tooling can choose to ignore them\nhttps://svelte.dev/e/options_removed_enable_sourcemap`);
}

/**
 * The `hydratable` option has been removed. Svelte components are always hydratable now
 * @param {null | NodeLike} node
 */
function options_removed_hydratable(node) {
	w(node, 'options_removed_hydratable', `The \`hydratable\` option has been removed. Svelte components are always hydratable now\nhttps://svelte.dev/e/options_removed_hydratable`);
}

/**
 * The `loopGuardTimeout` option has been removed
 * @param {null | NodeLike} node
 */
function options_removed_loop_guard_timeout(node) {
	w(node, 'options_removed_loop_guard_timeout', `The \`loopGuardTimeout\` option has been removed\nhttps://svelte.dev/e/options_removed_loop_guard_timeout`);
}

/**
 * `generate: "dom"` and `generate: "ssr"` options have been renamed to "client" and "server" respectively
 * @param {null | NodeLike} node
 */
function options_renamed_ssr_dom(node) {
	w(node, 'options_renamed_ssr_dom', `\`generate: "dom"\` and \`generate: "ssr"\` options have been renamed to "client" and "server" respectively\nhttps://svelte.dev/e/options_renamed_ssr_dom`);
}

/**
 * Using a rest element or a non-destructured declaration with `$props()` means that Svelte can't infer what properties to expose when creating a custom element. Consider destructuring all the props or explicitly specifying the `customElement.props` option.
 * @param {null | NodeLike} node
 */
function custom_element_props_identifier(node) {
	w(node, 'custom_element_props_identifier', `Using a rest element or a non-destructured declaration with \`$props()\` means that Svelte can't infer what properties to expose when creating a custom element. Consider destructuring all the props or explicitly specifying the \`customElement.props\` option.\nhttps://svelte.dev/e/custom_element_props_identifier`);
}

/**
 * Component has unused export property '%name%'. If it is for external reference only, please consider using `export const %name%`
 * @param {null | NodeLike} node
 * @param {string} name
 */
function export_let_unused(node, name) {
	w(node, 'export_let_unused', `Component has unused export property '${name}'. If it is for external reference only, please consider using \`export const ${name}\`\nhttps://svelte.dev/e/export_let_unused`);
}

/**
 * Svelte 5 components are no longer classes. Instantiate them using `mount` or `hydrate` (imported from 'svelte') instead.
 * @param {null | NodeLike} node
 */
function legacy_component_creation(node) {
	w(node, 'legacy_component_creation', `Svelte 5 components are no longer classes. Instantiate them using \`mount\` or \`hydrate\` (imported from 'svelte') instead.\nhttps://svelte.dev/e/legacy_component_creation`);
}

/**
 * `%name%` is updated, but is not declared with `$state(...)`. Changing its value will not correctly trigger updates
 * @param {null | NodeLike} node
 * @param {string} name
 */
function non_reactive_update(node, name) {
	w(node, 'non_reactive_update', `\`${name}\` is updated, but is not declared with \`$state(...)\`. Changing its value will not correctly trigger updates\nhttps://svelte.dev/e/non_reactive_update`);
}

/**
 * Avoid 'new class' — instead, declare the class at the top level scope
 * @param {null | NodeLike} node
 */
function perf_avoid_inline_class(node) {
	w(node, 'perf_avoid_inline_class', `Avoid 'new class' — instead, declare the class at the top level scope\nhttps://svelte.dev/e/perf_avoid_inline_class`);
}

/**
 * Avoid declaring classes below the top level scope
 * @param {null | NodeLike} node
 */
function perf_avoid_nested_class(node) {
	w(node, 'perf_avoid_nested_class', `Avoid declaring classes below the top level scope\nhttps://svelte.dev/e/perf_avoid_nested_class`);
}

/**
 * Reactive declarations only exist at the top level of the instance script
 * @param {null | NodeLike} node
 */
function reactive_declaration_invalid_placement(node) {
	w(node, 'reactive_declaration_invalid_placement', `Reactive declarations only exist at the top level of the instance script\nhttps://svelte.dev/e/reactive_declaration_invalid_placement`);
}

/**
 * Reassignments of module-level declarations will not cause reactive statements to update
 * @param {null | NodeLike} node
 */
function reactive_declaration_module_script_dependency(node) {
	w(node, 'reactive_declaration_module_script_dependency', `Reassignments of module-level declarations will not cause reactive statements to update\nhttps://svelte.dev/e/reactive_declaration_module_script_dependency`);
}

/**
 * This reference only captures the initial value of `%name%`. Did you mean to reference it inside a %type% instead?
 * @param {null | NodeLike} node
 * @param {string} name
 * @param {string} type
 */
function state_referenced_locally(node, name, type) {
	w(node, 'state_referenced_locally', `This reference only captures the initial value of \`${name}\`. Did you mean to reference it inside a ${type} instead?\nhttps://svelte.dev/e/state_referenced_locally`);
}

/**
 * It looks like you're using the `$%name%` rune, but there is a local binding called `%name%`. Referencing a local variable with a `$` prefix will create a store subscription. Please rename `%name%` to avoid the ambiguity
 * @param {null | NodeLike} node
 * @param {string} name
 */
function store_rune_conflict(node, name) {
	w(node, 'store_rune_conflict', `It looks like you're using the \`$${name}\` rune, but there is a local binding called \`${name}\`. Referencing a local variable with a \`$\` prefix will create a store subscription. Please rename \`${name}\` to avoid the ambiguity\nhttps://svelte.dev/e/store_rune_conflict`);
}

/**
 * Unused CSS selector "%name%"
 * @param {null | NodeLike} node
 * @param {string} name
 */
function css_unused_selector(node, name) {
	w(node, 'css_unused_selector', `Unused CSS selector "${name}"\nhttps://svelte.dev/e/css_unused_selector`);
}

/**
 * The "is" attribute is not supported cross-browser and should be avoided
 * @param {null | NodeLike} node
 */
function attribute_avoid_is(node) {
	w(node, 'attribute_avoid_is', `The "is" attribute is not supported cross-browser and should be avoided\nhttps://svelte.dev/e/attribute_avoid_is`);
}

/**
 * You are referencing `globalThis.%name%`. Did you forget to declare a variable with that name?
 * @param {null | NodeLike} node
 * @param {string} name
 */
function attribute_global_event_reference(node, name) {
	w(node, 'attribute_global_event_reference', `You are referencing \`globalThis.${name}\`. Did you forget to declare a variable with that name?\nhttps://svelte.dev/e/attribute_global_event_reference`);
}

/**
 * Attributes should not contain ':' characters to prevent ambiguity with Svelte directives
 * @param {null | NodeLike} node
 */
function attribute_illegal_colon(node) {
	w(node, 'attribute_illegal_colon', `Attributes should not contain ':' characters to prevent ambiguity with Svelte directives\nhttps://svelte.dev/e/attribute_illegal_colon`);
}

/**
 * '%wrong%' is not a valid HTML attribute. Did you mean '%right%'?
 * @param {null | NodeLike} node
 * @param {string} wrong
 * @param {string} right
 */
function attribute_invalid_property_name(node, wrong, right) {
	w(node, 'attribute_invalid_property_name', `'${wrong}' is not a valid HTML attribute. Did you mean '${right}'?\nhttps://svelte.dev/e/attribute_invalid_property_name`);
}

/**
 * Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes
 * @param {null | NodeLike} node
 */
function attribute_quoted(node) {
	w(node, 'attribute_quoted', `Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes\nhttps://svelte.dev/e/attribute_quoted`);
}

/**
 * The rest operator (...) will create a new object and binding '%name%' with the original object will not work
 * @param {null | NodeLike} node
 * @param {string} name
 */
function bind_invalid_each_rest(node, name) {
	w(node, 'bind_invalid_each_rest', `The rest operator (...) will create a new object and binding '${name}' with the original object will not work\nhttps://svelte.dev/e/bind_invalid_each_rest`);
}

/**
 * Empty block
 * @param {null | NodeLike} node
 */
function block_empty(node) {
	w(node, 'block_empty', `Empty block\nhttps://svelte.dev/e/block_empty`);
}

/**
 * `<%name%>` will be treated as an HTML element unless it begins with a capital letter
 * @param {null | NodeLike} node
 * @param {string} name
 */
function component_name_lowercase(node, name) {
	w(node, 'component_name_lowercase', `\`<${name}>\` will be treated as an HTML element unless it begins with a capital letter\nhttps://svelte.dev/e/component_name_lowercase`);
}

/**
 * This element is implicitly closed by the following `%tag%`, which can cause an unexpected DOM structure. Add an explicit `%closing%` to avoid surprises.
 * @param {null | NodeLike} node
 * @param {string} tag
 * @param {string} closing
 */
function element_implicitly_closed(node, tag, closing) {
	w(node, 'element_implicitly_closed', `This element is implicitly closed by the following \`${tag}\`, which can cause an unexpected DOM structure. Add an explicit \`${closing}\` to avoid surprises.\nhttps://svelte.dev/e/element_implicitly_closed`);
}

/**
 * Self-closing HTML tags for non-void elements are ambiguous — use `<%name% ...></%name%>` rather than `<%name% ... />`
 * @param {null | NodeLike} node
 * @param {string} name
 */
function element_invalid_self_closing_tag(node, name) {
	w(node, 'element_invalid_self_closing_tag', `Self-closing HTML tags for non-void elements are ambiguous — use \`<${name} ...></${name}>\` rather than \`<${name} ... />\`\nhttps://svelte.dev/e/element_invalid_self_closing_tag`);
}

/**
 * Using `on:%name%` to listen to the %name% event is deprecated. Use the event attribute `on%name%` instead
 * @param {null | NodeLike} node
 * @param {string} name
 */
function event_directive_deprecated(node, name) {
	w(node, 'event_directive_deprecated', `Using \`on:${name}\` to listen to the ${name} event is deprecated. Use the event attribute \`on${name}\` instead\nhttps://svelte.dev/e/event_directive_deprecated`);
}

/**
 * %message%. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a `hydration_mismatch` warning
 * @param {null | NodeLike} node
 * @param {string} message
 */
function node_invalid_placement_ssr(node, message) {
	w(node, 'node_invalid_placement_ssr', `${message}. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a \`hydration_mismatch\` warning\nhttps://svelte.dev/e/node_invalid_placement_ssr`);
}

/**
 * `context="module"` is deprecated, use the `module` attribute instead
 * @param {null | NodeLike} node
 */
function script_context_deprecated(node) {
	w(node, 'script_context_deprecated', `\`context="module"\` is deprecated, use the \`module\` attribute instead\nhttps://svelte.dev/e/script_context_deprecated`);
}

/**
 * Unrecognized attribute — should be one of `generics`, `lang` or `module`. If this exists for a preprocessor, ensure that the preprocessor removes it
 * @param {null | NodeLike} node
 */
function script_unknown_attribute(node) {
	w(node, 'script_unknown_attribute', `Unrecognized attribute — should be one of \`generics\`, \`lang\` or \`module\`. If this exists for a preprocessor, ensure that the preprocessor removes it\nhttps://svelte.dev/e/script_unknown_attribute`);
}

/**
 * Using `<slot>` to render parent content is deprecated. Use `{@render ...}` tags instead
 * @param {null | NodeLike} node
 */
function slot_element_deprecated(node) {
	w(node, 'slot_element_deprecated', `Using \`<slot>\` to render parent content is deprecated. Use \`{@render ...}\` tags instead\nhttps://svelte.dev/e/slot_element_deprecated`);
}

/**
 * `<svelte:component>` is deprecated in runes mode — components are dynamic by default
 * @param {null | NodeLike} node
 */
function svelte_component_deprecated(node) {
	w(node, 'svelte_component_deprecated', `\`<svelte:component>\` is deprecated in runes mode — components are dynamic by default\nhttps://svelte.dev/e/svelte_component_deprecated`);
}

/**
 * `this` should be an `{expression}`. Using a string attribute value will cause an error in future versions of Svelte
 * @param {null | NodeLike} node
 */
function svelte_element_invalid_this(node) {
	w(node, 'svelte_element_invalid_this', `\`this\` should be an \`{expression}\`. Using a string attribute value will cause an error in future versions of Svelte\nhttps://svelte.dev/e/svelte_element_invalid_this`);
}

/**
 * `<svelte:self>` is deprecated — use self-imports (e.g. `import %name% from './%basename%'`) instead
 * @param {null | NodeLike} node
 * @param {string} name
 * @param {string} basename
 */
function svelte_self_deprecated(node, name, basename) {
	w(node, 'svelte_self_deprecated', `\`<svelte:self>\` is deprecated — use self-imports (e.g. \`import ${name} from './${basename}'\`) instead\nhttps://svelte.dev/e/svelte_self_deprecated`);
}

const regex_svelte_ignore = /^\s*svelte-ignore\s/;

/** @type {Record<string, string>} Map of legacy code -> new code */
const replacements$1 = {
	'non-top-level-reactive-declaration': 'reactive_declaration_invalid_placement',
	'module-script-reactive-declaration': 'reactive_declaration_module_script',
	'empty-block': 'block_empty',
	'avoid-is': 'attribute_avoid_is',
	'invalid-html-attribute': 'attribute_invalid_property_name',
	'a11y-structure': 'a11y_figcaption_parent',
	'illegal-attribute-character': 'attribute_illegal_colon',
	'invalid-rest-eachblock-binding': 'bind_invalid_each_rest',
	'unused-export-let': 'export_let_unused'
};

const codes = codes$1.concat(IGNORABLE_RUNTIME_WARNINGS);

/**
 * @param {number} offset
 * @param {string} text
 * @param {boolean} runes
 * @returns {string[]}
 */
function extract_svelte_ignore(offset, text, runes) {
	const match = regex_svelte_ignore.exec(text);
	if (!match) return [];

	let length = match[0].length;
	offset += length;

	/** @type {string[]} */
	const ignores = [];

	if (runes) {
		// Warnings have to be separated by commas, everything after is interpreted as prose
		for (const match of text.slice(length).matchAll(/([\w$-]+)(,)?/gm)) {
			const code = match[1];

			if (codes.includes(code)) {
				ignores.push(code);
			} else {
				const replacement = replacements$1[code] ?? code.replace(/-/g, '_');

				// The type cast is for some reason necessary to pass the type check in CI
				const start = offset + /** @type {number} */ (match.index);
				const end = start + code.length;

				if (codes.includes(replacement)) {
					legacy_code({ start, end }, code, replacement);
				} else {
					const suggestion = fuzzymatch(code, codes);
					unknown_code({ start, end }, code, suggestion);
				}
			}

			if (!match[2]) {
				break;
			}
		}
	} else {
		// Non-runes mode: lax parsing, backwards compat with old codes
		for (const match of text.slice(length).matchAll(/[\w$-]+/gm)) {
			const code = match[0];

			ignores.push(code);

			if (!codes.includes(code)) {
				const replacement = replacements$1[code] ?? code.replace(/-/g, '_');

				if (codes.includes(replacement)) {
					ignores.push(replacement);
				}
			}
		}
	}

	return ignores;
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import * as Legacy from './types/legacy-nodes.js' */

/**
 * Some of the legacy Svelte AST nodes remove whitespace from the start and end of their children.
 * @param {AST.TemplateNode[]} nodes
 */
function remove_surrounding_whitespace_nodes(nodes) {
	const first = nodes.at(0);
	const last = nodes.at(-1);

	if (first?.type === 'Text') {
		if (!regex_not_whitespace.test(first.data)) {
			nodes.shift();
		} else {
			first.data = first.data.replace(regex_starts_with_whitespaces, '');
		}
	}
	if (last?.type === 'Text') {
		if (!regex_not_whitespace.test(last.data)) {
			nodes.pop();
		} else {
			last.data = last.data.replace(regex_ends_with_whitespaces, '');
		}
	}
}

/**
 * Transform our nice modern AST into the monstrosity emitted by Svelte 4
 * @param {string} source
 * @param {AST.Root} ast
 * @returns {Legacy.LegacyRoot}
 */
function convert(source, ast) {
	const root = /** @type {AST.SvelteNode | Legacy.LegacySvelteNode} */ (ast);

	return /** @type {Legacy.LegacyRoot} */ (
		walk$1(root, null, {
			_(node, { next }) {
				// @ts-ignore
				delete node.metadata;
				next();
			},
			// @ts-ignore
			Root(node, { visit }) {
				const { instance, module, options } = node;

				// Insert svelte:options back into the root nodes
				if (/** @type {any} */ (options)?.__raw__) {
					let idx = node.fragment.nodes.findIndex(
						(node) => /** @type {any} */ (options).end <= node.start
					);
					if (idx === -1) {
						idx = node.fragment.nodes.length;
					}

					node.fragment.nodes.splice(idx, 0, /** @type {any} */ (options).__raw__);
				}

				/** @type {number | null} */
				let start = null;

				/** @type {number | null} */
				let end = null;

				if (node.fragment.nodes.length > 0) {
					const first = /** @type {AST.BaseNode} */ (node.fragment.nodes.at(0));
					const last = /** @type {AST.BaseNode} */ (node.fragment.nodes.at(-1));

					start = first.start;
					end = last.end;

					while (/\s/.test(source[start])) start += 1;
					while (/\s/.test(source[end - 1])) end -= 1;
				}

				if (instance) {
					// @ts-ignore
					delete instance.attributes;
				}

				if (module) {
					// @ts-ignore
					delete module.attributes;
				}

				return {
					html: {
						type: 'Fragment',
						start,
						end,
						children: node.fragment.nodes.map((child) => visit(child))
					},
					instance,
					module,
					css: ast.css ? visit(ast.css) : undefined
				};
			},
			AnimateDirective(node) {
				return { ...node, type: 'Animation' };
			},
			// @ts-ignore
			AwaitBlock(node, { visit }) {
				let pendingblock = {
					type: 'PendingBlock',
					/** @type {number | null} */
					start: null,
					/** @type {number | null} */
					end: null,
					children: node.pending?.nodes.map((child) => visit(child)) ?? [],
					skip: true
				};

				let thenblock = {
					type: 'ThenBlock',
					/** @type {number | null} */
					start: null,
					/** @type {number | null} */
					end: null,
					children: node.then?.nodes.map((child) => visit(child)) ?? [],
					skip: true
				};

				let catchblock = {
					type: 'CatchBlock',
					/** @type {number | null} */
					start: null,
					/** @type {number | null} */
					end: null,
					children: node.catch?.nodes.map((child) => visit(child)) ?? [],
					skip: true
				};

				if (node.pending) {
					const first = node.pending.nodes.at(0);
					const last = node.pending.nodes.at(-1);

					pendingblock.start = first?.start ?? source.indexOf('}', node.expression.end) + 1;
					pendingblock.end = last?.end ?? pendingblock.start;
					pendingblock.skip = false;
				}

				if (node.then) {
					const first = node.then.nodes.at(0);
					const last = node.then.nodes.at(-1);

					thenblock.start =
						pendingblock.end ?? first?.start ?? source.indexOf('}', node.expression.end) + 1;
					thenblock.end =
						last?.end ?? source.lastIndexOf('}', pendingblock.end ?? node.expression.end) + 1;
					thenblock.skip = false;
				}

				if (node.catch) {
					const first = node.catch.nodes.at(0);
					const last = node.catch.nodes.at(-1);

					catchblock.start =
						thenblock.end ??
						pendingblock.end ??
						first?.start ??
						source.indexOf('}', node.expression.end) + 1;
					catchblock.end =
						last?.end ??
						source.lastIndexOf('}', thenblock.end ?? pendingblock.end ?? node.expression.end) + 1;
					catchblock.skip = false;
				}

				return {
					type: 'AwaitBlock',
					start: node.start,
					end: node.end,
					expression: node.expression,
					value: node.value,
					error: node.error,
					pending: pendingblock,
					then: thenblock,
					catch: catchblock
				};
			},
			BindDirective(node) {
				return { ...node, type: 'Binding' };
			},
			ClassDirective(node) {
				return { ...node, type: 'Class' };
			},
			Comment(node) {
				return {
					...node,
					ignores: extract_svelte_ignore(node.start, node.data, false)
				};
			},
			ComplexSelector(node, { next }) {
				next(); // delete inner metadata/parent properties

				const children = [];

				for (const child of node.children) {
					if (child.combinator) {
						children.push(child.combinator);
					}

					children.push(...child.selectors);
				}

				return {
					type: 'Selector',
					start: node.start,
					end: node.end,
					children
				};
			},
			Component(node, { visit }) {
				return {
					type: 'InlineComponent',
					start: node.start,
					end: node.end,
					name: node.name,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			// @ts-ignore
			ConstTag(node) {
				if (/** @type {Legacy.LegacyConstTag} */ (node).expression !== undefined) {
					return node;
				}

				const modern_node = /** @type {AST.ConstTag} */ (node);
				const { id: left } = { ...modern_node.declaration.declarations[0] };
				// @ts-ignore
				delete left.typeAnnotation;
				return {
					type: 'ConstTag',
					start: modern_node.start,
					end: node.end,
					expression: {
						type: 'AssignmentExpression',
						start: (modern_node.declaration.start ?? 0) + 'const '.length,
						end: modern_node.declaration.end ?? 0,
						operator: '=',
						left,
						right: modern_node.declaration.declarations[0].init
					}
				};
			},
			// @ts-ignore
			KeyBlock(node, { visit }) {
				remove_surrounding_whitespace_nodes(node.fragment.nodes);
				return {
					type: 'KeyBlock',
					start: node.start,
					end: node.end,
					expression: node.expression,
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			// @ts-ignore
			EachBlock(node, { visit }) {
				let elseblock = undefined;

				if (node.fallback) {
					const first = node.fallback.nodes.at(0);
					const end = source.lastIndexOf('{', /** @type {number} */ (node.end) - 1);
					const start = first?.start ?? end;

					remove_surrounding_whitespace_nodes(node.fallback.nodes);

					elseblock = {
						type: 'ElseBlock',
						start,
						end,
						children: node.fallback.nodes.map((child) => visit(child))
					};
				}

				remove_surrounding_whitespace_nodes(node.body.nodes);

				return {
					type: 'EachBlock',
					start: node.start,
					end: node.end,
					children: node.body.nodes.map((child) => visit(child)),
					context: node.context,
					expression: node.expression,
					index: node.index,
					key: node.key,
					else: elseblock
				};
			},
			ExpressionTag(node, { path }) {
				const parent = path.at(-1);
				if (parent?.type === 'Attribute') {
					if (source[parent.start] === '{') {
						return {
							type: 'AttributeShorthand',
							start: node.start,
							end: node.end,
							expression: node.expression
						};
					}
				}

				return {
					type: 'MustacheTag',
					start: node.start,
					end: node.end,
					expression: node.expression
				};
			},
			HtmlTag(node) {
				return { ...node, type: 'RawMustacheTag' };
			},
			// @ts-ignore
			IfBlock(node, { visit }) {
				let elseblock = undefined;
				if (node.alternate) {
					let nodes = node.alternate.nodes;
					if (nodes.length === 1 && nodes[0].type === 'IfBlock' && nodes[0].elseif) {
						nodes = nodes[0].consequent.nodes;
					}

					const end = source.lastIndexOf('{', /** @type {number} */ (node.end) - 1);
					const start = nodes.at(0)?.start ?? end;

					remove_surrounding_whitespace_nodes(node.alternate.nodes);

					elseblock = {
						type: 'ElseBlock',
						start,
						end: end,
						children: node.alternate.nodes.map(
							(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
						)
					};
				}

				const start = node.elseif
					? node.consequent.nodes[0]?.start ??
						source.lastIndexOf('{', /** @type {number} */ (node.end) - 1)
					: node.start;

				remove_surrounding_whitespace_nodes(node.consequent.nodes);

				return {
					type: 'IfBlock',
					start,
					end: node.end,
					expression: node.test,
					children: node.consequent.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					),
					else: elseblock,
					elseif: node.elseif ? true : undefined
				};
			},
			OnDirective(node) {
				return { ...node, type: 'EventHandler' };
			},
			// @ts-expect-error
			SnippetBlock(node, { visit }) {
				remove_surrounding_whitespace_nodes(node.body.nodes);
				return {
					type: 'SnippetBlock',
					start: node.start,
					end: node.end,
					expression: node.expression,
					parameters: node.parameters,
					children: node.body.nodes.map((child) => visit(child)),
					typeParams: node.typeParams
				};
			},
			// @ts-expect-error
			SvelteBoundary(node, { visit }) {
				remove_surrounding_whitespace_nodes(node.fragment.nodes);
				return {
					type: 'SvelteBoundary',
					name: 'svelte:boundary',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map((child) => visit(child))
				};
			},
			RegularElement(node, { visit }) {
				return {
					type: 'Element',
					start: node.start,
					end: node.end,
					name: node.name,
					attributes: node.attributes.map((child) => visit(child)),
					children: node.fragment.nodes.map((child) => visit(child))
				};
			},
			SlotElement(node, { visit }) {
				return {
					type: 'Slot',
					start: node.start,
					end: node.end,
					name: node.name,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			Attribute(node, { visit, next, path }) {
				if (node.value !== true && !Array.isArray(node.value)) {
					path.push(node);
					const value = /** @type {Legacy.LegacyAttribute['value']} */ ([visit(node.value)]);
					path.pop();

					return {
						...node,
						value
					};
				} else {
					return next();
				}
			},
			StyleDirective(node, { visit, next, path }) {
				if (node.value !== true && !Array.isArray(node.value)) {
					path.push(node);
					const value = /** @type {Legacy.LegacyStyleDirective['value']} */ ([visit(node.value)]);
					path.pop();

					return {
						...node,
						value
					};
				} else {
					return next();
				}
			},
			SpreadAttribute(node) {
				return { ...node, type: 'Spread' };
			},
			// @ts-ignore
			StyleSheet(node, context) {
				return {
					...node,
					...context.next(),
					type: 'Style'
				};
			},
			SvelteBody(node, { visit }) {
				return {
					type: 'Body',
					name: 'svelte:body',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			SvelteComponent(node, { visit }) {
				return {
					type: 'InlineComponent',
					name: 'svelte:component',
					start: node.start,
					end: node.end,
					expression: node.expression,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			SvelteDocument(node, { visit }) {
				return {
					type: 'Document',
					name: 'svelte:document',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			SvelteElement(node, { visit }) {
				/** @type {Expression | string} */
				let tag = node.tag;
				if (
					tag.type === 'Literal' &&
					typeof tag.value === 'string' &&
					source[/** @type {number} */ (node.tag.start) - 1] !== '{'
				) {
					tag = tag.value;
				}

				return {
					type: 'Element',
					name: 'svelte:element',
					start: node.start,
					end: node.end,
					tag,
					attributes: node.attributes.map((child) => visit(child)),
					children: node.fragment.nodes.map((child) => visit(child))
				};
			},
			SvelteFragment(node, { visit }) {
				return {
					type: 'SlotTemplate',
					name: 'svelte:fragment',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(a) => /** @type {Legacy.LegacyAttributeLike} */ (visit(a))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			SvelteHead(node, { visit }) {
				return {
					type: 'Head',
					name: 'svelte:head',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			SvelteOptions(node, { visit }) {
				return {
					type: 'Options',
					name: 'svelte:options',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					)
				};
			},
			SvelteSelf(node, { visit }) {
				return {
					type: 'InlineComponent',
					name: 'svelte:self',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			SvelteWindow(node, { visit }) {
				return {
					type: 'Window',
					name: 'svelte:window',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			Text(node, { path }) {
				const parent = path.at(-1);
				if (parent?.type === 'RegularElement' && parent.name === 'style') {
					// these text nodes are missing `raw` for some dumb reason
					return /** @type {AST.Text} */ ({
						type: 'Text',
						start: node.start,
						end: node.end,
						data: node.data
					});
				}
			},
			TitleElement(node, { visit }) {
				return {
					type: 'Title',
					name: 'title',
					start: node.start,
					end: node.end,
					attributes: node.attributes.map(
						(child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child))
					),
					children: node.fragment.nodes.map(
						(child) => /** @type {Legacy.LegacyElementLike} */ (visit(child))
					)
				};
			},
			TransitionDirective(node) {
				return { ...node, type: 'Transition' };
			},
			UseDirective(node) {
				return { ...node, type: 'Action' };
			},
			LetDirective(node) {
				return { ...node, type: 'Let' };
			}
		})
	);
}

// This file was generated. Do not modify manually!
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

// This file was generated. Do not modify manually!
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];

// This file was generated. Do not modify manually!
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";

// This file was generated. Do not modify manually!
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range.

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
  return false
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr$1 = {startsExpr: true};

// Map keyword names to token types.

var keywords = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords[name] = new TokenType(name, options)
}

var types$1 = {
  num: new TokenType("num", startsExpr$1),
  regexp: new TokenType("regexp", startsExpr$1),
  string: new TokenType("string", startsExpr$1),
  name: new TokenType("name", startsExpr$1),
  privateId: new TokenType("privateId", startsExpr$1),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr$1),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),
  coalesce: binop("??", 1),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr$1),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr$1),
  _super: kw("super", startsExpr$1),
  _class: kw("class", startsExpr$1),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr$1),
  _null: kw("null", startsExpr$1),
  _true: kw("true", startsExpr$1),
  _false: kw("false", startsExpr$1),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

function nextLineBreak(code, from, end) {
  if ( end === void 0 ) end = code.length;

  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next))
      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
  }
  return -1
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString$1 = ref.toString;

var hasOwn = Object.hasOwn || (function (obj, propName) { return (
  hasOwnProperty.call(obj, propName)
); });

var isArray = Array.isArray || (function (obj) { return (
  toString$1.call(obj) === "[object Array]"
); });

var regexpCache = Object.create(null);

function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
}

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    var nextBreak = nextLineBreak(input, cur, offset);
    if (nextBreak < 0) { return new Position(line, offset - cur) }
    ++line;
    cur = nextBreak;
  }
}

// A second argument must be given to configure the parser process.
// These options are recognized (only `ecmaVersion` is required):

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

var warnedAboutEcmaVersion = false;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (!opts || opts.allowHashBang == null)
    { options.allowHashBang = options.ecmaVersion >= 14; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS_STATIC_BLOCK = 256,
    SCOPE_CLASS_FIELD_INIT = 512,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

function functionFlags$1(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal* and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser$1 = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types$1.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = Object.create(null);

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;

  // The stack of private names.
  // Each element has two properties: 'declared' and 'used'.
  // When it exited from the outermost class definition, all used private names must be declared.
  this.privateNameStack = [];
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

Parser$1.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };

prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };

prototypeAccessors.canAwait.get = function () {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref = this.scopeStack[i];
      var flags = ref.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) { return false }
    if (flags & SCOPE_FUNCTION) { return (flags & SCOPE_ASYNC) > 0 }
  }
  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
};

prototypeAccessors.allowSuper.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod
};

prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

prototypeAccessors.allowNewDotTarget.get = function () {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref = this.scopeStack[i];
      var flags = ref.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) ||
        ((flags & SCOPE_FUNCTION) && !(flags & SCOPE_ARROW))) { return true }
  }
  return false
};

prototypeAccessors.inClassStaticBlock.get = function () {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
};

Parser$1.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser$1.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser$1.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser$1.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser$1.prototype, prototypeAccessors );

var pp$9 = Parser$1.prototype;

// ## Parser utilities

var literal$1 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) { return false }
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace$1.lastIndex = start;
    start += skipWhiteSpace$1.exec(this.input)[0].length;
    var match = literal$1.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace$1.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace$1.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" ||
        (lineBreak.test(spaceAfter[0]) &&
         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
    }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace$1.lastIndex = start;
    start += skipWhiteSpace$1.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof ||
    this.type === types$1.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

var DestructuringErrors$1 = function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
};

pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
};

pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$8 = Parser$1.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$8.parseTopLevel = function(node) {
  var exports$1 = Object.create(null);
  if (!node.body) { node.body = []; }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports$1);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace$1.lastIndex = this.pos;
  var skip = skipWhiteSpace$1.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91 || nextCh === 92) { return true } // '[', '\'
  if (context) { return false }

  if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace$1.lastIndex = this.pos;
  var skip = skipWhiteSpace$1.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length ||
     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
};

pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using"))
    { return false }

  skipWhiteSpace$1.lastIndex = this.pos;
  var skip = skipWhiteSpace$1.exec(this.input);
  var next = this.pos + skip[0].length;

  if (lineBreak.test(this.input.slice(this.pos, next))) { return false }

  if (isAwaitUsing) {
    var awaitEndPos = next + 5 /* await */, after;
    if (this.input.slice(next, awaitEndPos) !== "using" ||
      awaitEndPos === this.input.length ||
      isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) ||
      (after > 0xd7ff && after < 0xdc00)
    ) { return false }

    skipWhiteSpace$1.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace$1.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) { return false }
  }

  if (isFor) {
    var ofEndPos = next + 2 /* of */, after$1;
    if (this.input.slice(next, ofEndPos) === "of") {
      if (ofEndPos === this.input.length ||
        (!isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 0xd7ff && after$1 < 0xdc00))) { return false }
    }
  }

  var ch = this.input.charCodeAt(next);
  return isIdentifierStart(ch, true) || ch === 92 // '\'
};

pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor)
};

pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor)
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$8.parseStatement = function(context, topLevel, exports$1) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types$1._debugger: return this.parseDebuggerStatement(node)
  case types$1._do: return this.parseDoStatement(node)
  case types$1._for: return this.parseForStatement(node)
  case types$1._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types$1._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types$1._if: return this.parseIfStatement(node)
  case types$1._return: return this.parseReturnStatement(node)
  case types$1._switch: return this.parseSwitchStatement(node)
  case types$1._throw: return this.parseThrowStatement(node)
  case types$1._try: return this.parseTryStatement(node)
  case types$1._const: case types$1._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types$1._while: return this.parseWhileStatement(node)
  case types$1._with: return this.parseWithStatement(node)
  case types$1.braceL: return this.parseBlock(true, node)
  case types$1.semi: return this.parseEmptyStatement(node)
  case types$1._export:
  case types$1._import:
    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
      skipWhiteSpace$1.lastIndex = this.pos;
      var skip = skipWhiteSpace$1.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40 || nextCh === 46) // '(' or '.'
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports$1)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
    if (usingKind) {
      if (topLevel && this.options.sourceType === "script") {
        this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
      }
      if (usingKind === "await using") {
        if (!this.canAwait) {
          this.raise(this.start, "Await using cannot appear outside of async function");
        }
        this.next();
      }
      this.next();
      this.parseVar(node, false, usingKind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration")
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types$1.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types$1.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt)
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;

  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") { this.next(); }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt)
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors$1;
  var initPos = this.start;
  var init = awaitAt > -1
    ? this.parseExprSubscripts(refDestructuringErrors, "await")
    : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) { // implies `ecmaVersion >= 9` (see declaration of awaitAt)
      if (this.type === types$1._in) { this.unexpected(awaitAt); }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") { this.unexpected(); }
      else if (this.options.ecmaVersion >= 9) { node.await = false; }
    }
    if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

// Helper method to parse for loop after variable initialization
pp$8.parseForAfterInit = function(node, init, awaitAt) {
  if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    return this.parseForIn(node, init)
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT$1), false, isAsync)
};

pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR;) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty$1 = [];

pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);

  return param
};

pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$8.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) { this.strict = false; }
  this.next();
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, ("Missing initializer in " + kind + " declaration"));
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) { break }
  }
  return node
};

pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using"
    ? this.parseIdent()
    : this.parseBindingAtom();

  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT$1 = 1, FUNC_HANGING_STATEMENT$1 = 2, FUNC_NULLABLE_ID$1 = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT$1))
      { this.unexpected(); }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT$1) {
    node.id = (statement & FUNC_NULLABLE_ID$1) && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT$1))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags$1(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT$1))
    { node.id = this.type === types$1.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT$1) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$8.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted$1(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) { return null }

  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;

  if (this.eatContextual("static")) {
    // Parse static init block
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }

  // Parse element name
  if (keyName) {
    // 'async', 'get', 'set', or 'static' were not a keyword contextually.
    // The last token is any of those. Make it the element name.
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }

  // Parse element value
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName$1(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
    if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }

  return node
};

pp$8.isClassElementNameStart = function() {
  return (
    this.type === types$1.name ||
    this.type === types$1.privateId ||
    this.type === types$1.num ||
    this.type === types$1.string ||
    this.type === types$1.bracketL ||
    this.type.keyword
  )
};

pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};

pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  // Check key and flags
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
  } else if (method.static && checkKeyName$1(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  // Parse value
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

  // Check value
  if (method.kind === "get" && value.params.length !== 0)
    { this.raiseRecoverable(value.start, "getter should have no params"); }
  if (method.kind === "set" && value.params.length !== 1)
    { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && value.params[0].type === "RestElement")
    { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

  return this.finishNode(method, "MethodDefinition")
};

pp$8.parseClassField = function(field) {
  if (checkKeyName$1(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName$1(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }

  if (this.eat(types$1.eq)) {
    // To raise SyntaxError if 'arguments' exists in the initializer.
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();

  return this.finishNode(field, "PropertyDefinition")
};

pp$8.parseClassStaticBlock = function(node) {
  node.body = [];

  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;

  return this.finishNode(node, "StaticBlock")
};

pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};

pp$8.enterClassBody = function() {
  var element = {declared: Object.create(null), used: []};
  this.privateNameStack.push(element);
  return element.declared
};

pp$8.exitClassBody = function() {
  var ref = this.privateNameStack.pop();
  var declared = ref.declared;
  var used = ref.used;
  if (!this.options.checkPrivateFields) { return }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
      }
    }
  }
};

function isPrivateNameConflicted$1(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];

  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }

  // `class { get #a(){}; static set #a(_){} }` is also conflict.
  if (
    curr === "iget" && next === "iset" ||
    curr === "iset" && next === "iget" ||
    curr === "sget" && next === "sset" ||
    curr === "sset" && next === "sget"
  ) {
    privateNameMap[name] = "true";
    return false
  } else if (!curr) {
    privateNameMap[name] = next;
    return false
  } else {
    return true
  }
}

function checkKeyName$1(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (
    key.type === "Identifier" && key.name === name ||
    key.type === "Literal" && key.value === name
  )
}

// Parses module export declaration.

pp$8.parseExportAllDeclaration = function(node, exports$1) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports$1, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16)
    { node.attributes = this.parseWithClause(); }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration")
};

pp$8.parseExport = function(node, exports$1) {
  this.next();
  // export * from '...'
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports$1)
  }
  if (this.eat(types$1._default)) { // export default ...
    this.checkExport(exports$1, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports$1, node.declaration.declarations); }
    else
      { this.checkExport(exports$1, node.declaration.id, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16)
      { node.attributes = []; }
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports$1);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16)
        { node.attributes = this.parseWithClause(); }
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);

        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }

      node.source = null;
      if (this.options.ecmaVersion >= 16)
        { node.attributes = []; }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null)
};

pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) { this.next(); }
    return this.parseFunction(fNode, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, false, isAsync)
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID")
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration
  }
};

pp$8.checkExport = function(exports$1, name, pos) {
  if (!exports$1) { return }
  if (typeof name !== "string")
    { name = name.type === "Identifier" ? name.name : name.value; }
  if (hasOwn(exports$1, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports$1[name] = true;
};

pp$8.checkPatternExport = function(exports$1, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports$1, pat, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports$1, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports$1, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports$1, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports$1, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports$1, pat.argument); }
};

pp$8.checkVariableExport = function(exports$1, decls) {
  if (!exports$1) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports$1, decl.id);
  }
};

pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$8.parseExportSpecifier = function(exports$1) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();

  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports$1,
    node.exported,
    node.exported.start
  );

  return this.finishNode(node, "ExportSpecifier")
};

pp$8.parseExportSpecifiers = function(exports$1) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    nodes.push(this.parseExportSpecifier(exports$1));
  }
  return nodes
};

// Parses import declaration.

pp$8.parseImport = function(node) {
  this.next();

  // import '...'
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16)
    { node.attributes = this.parseWithClause(); }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();

  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);

  return this.finishNode(node, "ImportSpecifier")
};

pp$8.parseImportDefaultSpecifier = function() {
  // import defaultObj, { x, y as z } from '...'
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier")
};

pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier")
};

pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) { return nodes }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    nodes.push(this.parseImportSpecifier());
  }
  return nodes
};

pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName))
      { this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'"); }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes
};

pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute")
};

pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral
  }
  return this.parseIdent(true)
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return (
    this.options.ecmaVersion >= 5 &&
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$7 = Parser$1.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "AssignmentPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "ChainExpression":
      this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types$1.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types$1.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types$1.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types$1.comma); }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts
};

pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem
};

pp$7.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// The following three functions all verify that a node is an lvalue —
// something that can be bound, or assigned to. In order to do so, they perform
// a variety of checks:
//
// - Check that none of the bound/assigned-to identifiers are reserved words.
// - Record name declarations for bindings in the appropriate scope.
// - Check duplicate argument names, if checkClashes is set.
//
// If a complex binding pattern is encountered (e.g., object and array
// destructuring), the entire pattern is recursively checked.
//
// There are three versions of checkLVal*() appropriate for different
// circumstances:
//
// - checkLValSimple() shall be used if the syntactic construct supports
//   nothing other than identifiers and member expressions. Parenthesized
//   expressions are also correctly handled. This is generally appropriate for
//   constructs for which the spec says
//
//   > It is a Syntax Error if AssignmentTargetType of [the production] is not
//   > simple.
//
//   It is also appropriate for checking if an identifier is valid and not
//   defined elsewhere, like import declarations or function/class identifiers.
//
//   Examples where this is used include:
//     a += …;
//     import a from '…';
//   where a is the node to be checked.
//
// - checkLValPattern() shall be used if the syntactic construct supports
//   anything checkLValSimple() supports, as well as object and array
//   destructuring patterns. This is generally appropriate for constructs for
//   which the spec says
//
//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
//   > an ArrayLiteral and AssignmentTargetType of [the production] is not
//   > simple.
//
//   Examples where this is used include:
//     (a = …);
//     const a = …;
//     try { … } catch (a) { … }
//   where a is the node to be checked.
//
// - checkLValInnerPattern() shall be used if the syntactic construct supports
//   anything checkLValPattern() supports, as well as default assignment
//   patterns, rest elements, and other constructs that may appear within an
//   object or array destructuring pattern.
//
//   As a special case, function parameters also use checkLValInnerPattern(),
//   as they also support defaults and rest constructs.
//
// These functions deliberately support both assignment and binding constructs,
// as the logic for both is exceedingly similar. If the node is the target of
// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
// should be set to the appropriate BIND_* constant, like BIND_VAR or
// BIND_LEXICAL.
//
// If the function is called with a non-BIND_NONE bindingType, then
// additionally a checkClashes object may be specified to allow checking for
// duplicate argument names. checkClashes is ignored if the provided construct
// is an assignment (i.e., bindingType is BIND_NONE).

pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  var isBind = bindingType !== BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (isBind) {
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (checkClashes) {
        if (hasOwn(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    }
    break

  case "ChainExpression":
    this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
    break

  case "MemberExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ParenthesizedExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
    return this.checkLValSimple(expr.expression, bindingType, checkClashes)

  default:
    this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};

pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1) {
      var prop = list[i];

    this.checkLValInnerPattern(prop, bindingType, checkClashes);
    }
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
    }
    break

  default:
    this.checkLValSimple(expr, bindingType, checkClashes);
  }
};

pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
    break

  case "AssignmentPattern":
    this.checkLValPattern(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLValPattern(expr.argument, bindingType, checkClashes);
    break

  default:
    this.checkLValPattern(expr, bindingType, checkClashes);
  }
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design


var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$6 = Parser$1.prototype;

pp$6.initialContext = function() {
  return [types.b_stat]
};

pp$6.curContext = function() {
  return this.context[this.context.length - 1]
};

pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat)
    { return true }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
    { return true }
  if (prevType === types$1.braceL)
    { return parent === types.b_stat }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
    { return false }
  return !this.exprAllowed
};

pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Used to handle edge cases when token context could not be inferred correctly during tokenization phase

pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};

// Token-specific context update code

types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

types$1.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else &&
      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
    { this.context.push(types.f_expr); }
  else
    { this.context.push(types.f_stat); }
  this.exprAllowed = false;
};

types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") { this.context.pop(); }
  this.exprAllowed = true;
};

types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types.q_tmpl); }
  this.exprAllowed = false;
};

types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr)
      { this.context[index] = types.f_expr_gen; }
    else
      { this.context[index] = types.f_gen; }
  }
  this.exprAllowed = true;
};

types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


var pp$5 = Parser$1.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(forInit) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors$1;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq)
      { left = this.toAssignable(left, false, refDestructuringErrors); }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start)
      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
    if (this.type === types$1.eq)
      { this.checkLValPattern(left); }
    else
      { this.checkLValSimple(left); }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
    }
  }
  return left
};

pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLValSimple(node.argument); }
    else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument))
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
      { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
    expr = this.parsePrivateIdent();
    // only could be private fields in 'in', such as #x in obj
    if (this.type !== types$1._in) { this.unexpected(); }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary)
      { this.unexpected(this.lastTokStart); }
    else
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
  } else {
    return expr
  }
};

function isLocalVariableAccess(node) {
  return (
    node.type === "Identifier" ||
    node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression)
  )
}

function isPrivateFieldAccess(node) {
  return (
    node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
    node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) ||
    node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression)
  )
}

// Parse call, dot, and `[]`-subscript expressions.

pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
  }
  return result
};

pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
      this.potentialArrowAt === base.start;
  var optionalChained = false;

  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

    if (element.optional) { optionalChained = true; }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element
    }

    base = element;
  }
};

pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow)
};

pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
};

pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

  var computed = this.eat(types$1.bracketL);
  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors$1, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types$1.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types$1._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types$1.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super ( Arguments )
    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types$1._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types$1.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
      this.overrideContext(types.f_expr);
      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
    }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types$1.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
          (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
      }
    }
    return id

  case types$1.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types$1.num: case types$1.string:
    return this.parseLiteral(this.value)

  case types$1._null: case types$1._true: case types$1._false:
    node = this.startNode();
    node.value = this.type === types$1._null ? null : this.type === types$1._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types$1.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types$1.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types$1.braceL:
    this.overrideContext(types.b_expr);
    return this.parseObj(false, refDestructuringErrors)

  case types$1._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types$1._class:
    return this.parseClass(this.startNode(), false)

  case types$1._new:
    return this.parseNew()

  case types$1.backQuote:
    return this.parseTemplate()

  case types$1._import:
    if (this.options.ecmaVersion >= 11) {
      return this.parseExprImport(forNew)
    } else {
      return this.unexpected()
    }

  default:
    return this.parseExprAtomDefault()
  }
};

pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};

pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();

  // Consume `import` as an identifier for `import.meta`.
  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
  this.next();

  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node)
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node)
  } else {
    this.unexpected();
  }
};

pp$5.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    // Verify ending.
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$5.parseImportMeta = function(node) {
  this.next(); // skip `.`

  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);

  if (node.property.name !== "meta")
    { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
  if (containsEsc)
    { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
    { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

  return this.finishNode(node, "MetaProperty")
};

pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110)
    { node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, ""); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val
};

pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon()
};

pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors$1, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);

    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$5.parseParenItem = function(item) {
  return item
};

pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$2 = [];

pp$5.parseNew = function() {
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
    if (!this.allowNewDotTarget)
      { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$2; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$5.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$5.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types$1.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$5.parseGetterSetter = function(prop) {
  var kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  prop.kind = kind;
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get")
      { this.raiseRecoverable(start, "getter should have no params"); }
    else
      { this.raiseRecoverable(start, "setter should have exactly one param"); }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
      { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
  }
};

pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon)
    { this.unexpected(); }

  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
    prop.kind = "init";
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.kind = "init";
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags$1(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags$1(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};

pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types$1.comma)
      { elt = null; }
    else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$5.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments")
    { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
    { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
      (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node
};

pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");

  // For validating existence
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }

  return node
};

// Parses yield expression inside generator.

pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser$1.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$3 = Parser$1.prototype;

var Scope$1 = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope$1(flags));
};

pp$3.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$3.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) &&
        !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$2 = Parser$1.prototype;

pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) { newNode[prop] = node[prop]; }
  return newNode
};

// This file was generated by "bin/generate-unicode-script-values.js". Do not modify manually!
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";

// This file contains Unicode properties extracted from the ECMAScript specification.
// The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;

var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};

// #table-binary-unicode-properties-of-strings
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;

var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}

for (var i = 0, list$2 = [9, 10, 11, 12, 13, 14]; i < list$2.length; i += 1) {
  var ecmaVersion = list$2[i];

  buildUnicodeData(ecmaVersion);
}

var pp$1 = Parser$1.prototype;

// Track disjunction structure to determine whether a duplicate
// capture group name is allowed because it is in a separate branch.
var BranchID = function BranchID(parent, base) {
  // Parent disjunction branch
  this.parent = parent;
  // Identifies this set of sibling branches
  this.base = base || this;
};

BranchID.prototype.separatedFrom = function separatedFrom (alt) {
  // A branch is separate from another branch if they or any of
  // their parents are siblings in a given disjunction
  for (var self = this; self; self = self.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self.base === other.base && self !== other) { return true }
    }
  }
  return false
};

BranchID.prototype.sibling = function sibling () {
  return new BranchID(this.parent, this.base)
};

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.pos, forceU)
};

RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.nextIndex(this.pos, forceU), forceU)
};

RegExpValidationState.prototype.advance = function advance (forceU) {
    if ( forceU === void 0 ) forceU = false;

  this.pos = this.nextIndex(this.pos, forceU);
};

RegExpValidationState.prototype.eat = function eat (ch, forceU) {
    if ( forceU === void 0 ) forceU = false;

  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true
  }
  return false
};

RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var pos = this.pos;
  for (var i = 0, list = chs; i < list.length; i += 1) {
    var ch = list[i];

      var current = this.at(pos, forceU);
    if (current === -1 || current !== ch) {
      return false
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true
};

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  var u = false;
  var v = false;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") { u = true; }
    if (flag === "v") { v = true; }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};

function hasProp(obj) {
  for (var _ in obj) { return true }
  return false
}

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) { state.branchID = new BranchID(state.branchID, null); }
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    if (trackDisjunction) { state.branchID = state.branchID.sibling(); }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) { state.branchID = state.branchID.parent; }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$1.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$1.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */)) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(0x2D /* - */);
        if (addModifiers || hasHyphen) {
          for (var i = 0; i < addModifiers.length; i++) {
            var modifier = addModifiers.charAt(i);
            if (addModifiers.indexOf(modifier, i + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (
                removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 ||
                addModifiers.indexOf(modifier$1) > -1
              ) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(0x3A /* : */)) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          return true
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};
// RegularExpressionModifiers ::
//   [empty]
//   RegularExpressionModifiers RegularExpressionModifier
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers
};
// RegularExpressionModifier :: one of
//   `i` `m` `s`
function isRegularExpressionModifier(ch) {
  return ch === 0x69 /* i */ || ch === 0x6d /* m */ || ch === 0x73 /* s */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$1.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier ::
//   [empty]
//   `?` GroupName
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (!this.regexp_eatGroupName(state)) { state.raise("Invalid group"); }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i = 0, list = known; i < list.length; i += 1) {
          var altID = list[i];

          if (!altID.separatedFrom(state.branchID))
            { state.raise("Duplicate capture group name"); }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};

// GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$1.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$1.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if ( forceU === void 0 ) forceU = false;

  var start = state.pos;
  var switchU = forceU || state.switchU;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// Return values used by character set parsing methods, needed to
// forbid negation of sets that can match strings.
var CharSetNone = 0; // Nothing parsed
var CharSetOk = 1; // Construct parsed, cannot contain strings
var CharSetString = 2; // Construct parsed, can contain strings

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk
  }

  var negate = false;
  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (
      state.eat(0x7B /* { */) &&
      (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
      state.eat(0x7D /* } */)
    ) {
      if (negate && result === CharSetString) { state.raise("Invalid property name"); }
      return result
    }
    state.raise("Invalid property name");
  }

  return CharSetNone
};

function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
  }
  return CharSetNone
};

pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};

pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
  state.raise("Invalid property name");
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};

function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    var negate = state.eat(0x5E /* ^ */);
    var result = this.regexp_classContents(state);
    if (!state.eat(0x5D /* ] */))
      { state.raise("Unterminated character class"); }
    if (negate && result === CharSetString)
      { state.raise("Negated character class may contain strings"); }
    return true
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassContents
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
pp$1.regexp_classContents = function(state) {
  if (state.current() === 0x5D /* ] */) { return CharSetOk }
  if (state.switchV) { return this.regexp_classSetExpression(state) }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* ] */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://tc39.es/ecma262/#prod-ClassSetExpression
// https://tc39.es/ecma262/#prod-ClassUnion
// https://tc39.es/ecma262/#prod-ClassIntersection
// https://tc39.es/ecma262/#prod-ClassSubtraction
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) { result = CharSetString; }
    // https://tc39.es/ecma262/#prod-ClassIntersection
    var start = state.pos;
    while (state.eatChars([0x26, 0x26] /* && */)) {
      if (
        state.current() !== 0x26 /* & */ &&
        (subResult = this.regexp_eatClassSetOperand(state))
      ) {
        if (subResult !== CharSetString) { result = CharSetOk; }
        continue
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) { return result }
    // https://tc39.es/ecma262/#prod-ClassSubtraction
    while (state.eatChars([0x2D, 0x2D] /* -- */)) {
      if (this.regexp_eatClassSetOperand(state)) { continue }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) { return result }
  } else {
    state.raise("Invalid character in character class");
  }
  // https://tc39.es/ecma262/#prod-ClassUnion
  for (;;) {
    if (this.regexp_eatClassSetRange(state)) { continue }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) { return result }
    if (subResult === CharSetString) { result = CharSetString; }
  }
};

// https://tc39.es/ecma262/#prod-ClassSetRange
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true
    }
    state.pos = start;
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassSetOperand
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
};

// https://tc39.es/ecma262/#prod-NestedClass
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(0x5B /* [ */)) {
    var negate = state.eat(0x5E /* ^ */);
    var result = this.regexp_classContents(state);
    if (state.eat(0x5D /* ] */)) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result
    }
    state.pos = start;
  }
  if (state.eat(0x5C /* \ */)) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1
    }
    state.pos = start;
  }
  return null
};

// https://tc39.es/ecma262/#prod-ClassStringDisjunction
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars([0x5C, 0x71] /* \q */)) {
    if (state.eat(0x7B /* { */)) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(0x7D /* } */)) {
        return result
      }
    } else {
      // Make the same message as V8.
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null
};

// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(0x7C /* | */)) {
    if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
  }
  return result
};

// https://tc39.es/ecma262/#prod-ClassString
// https://tc39.es/ecma262/#prod-NonEmptyClassString
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) { count++; }
  return count === 1 ? CharSetOk : CharSetString
};

// https://tc39.es/ecma262/#prod-ClassSetCharacter
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (
      this.regexp_eatCharacterEscape(state) ||
      this.regexp_eatClassSetReservedPunctuator(state)
    ) {
      return true
    }
    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }
    state.pos = start;
    return false
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
  if (isClassSetSyntaxCharacter(ch)) { return false }
  state.advance();
  state.lastIntValue = ch;
  return true
};

// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return (
    ch === 0x21 /* ! */ ||
    ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
    ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
    ch === 0x2E /* . */ ||
    ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
    ch === 0x5E /* ^ */ ||
    ch === 0x60 /* ` */ ||
    ch === 0x7E /* ~ */
  )
}

// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
function isClassSetSyntaxCharacter(ch) {
  return (
    ch === 0x28 /* ( */ ||
    ch === 0x29 /* ) */ ||
    ch === 0x2D /* - */ ||
    ch === 0x2F /* / */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
function isClassSetReservedPunctuator(ch) {
  return (
    ch === 0x21 /* ! */ ||
    ch === 0x23 /* # */ ||
    ch === 0x25 /* % */ ||
    ch === 0x26 /* & */ ||
    ch === 0x2C /* , */ ||
    ch === 0x2D /* - */ ||
    ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
    ch === 0x40 /* @ */ ||
    ch === 0x60 /* ` */ ||
    ch === 0x7E /* ~ */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp = Parser$1.prototype;

// Move to the next token

pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
    { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp[Symbol.iterator] = function() {
    var this$1$1 = this;

    return {
      next: function () {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

// Read a single token, updating the parser object's token-related
// properties.

pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xdc00) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
};

pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types$1.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot)
  }
};

pp.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.slash, 1)
};

pp.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
};

pp.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.bitwiseXOR, 1)
};

pp.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types$1.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.plusMin, 1)
};

pp.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
    return this.finishOp(types$1.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types$1.relational, size)
};

pp.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types$1.arrow)
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
};

pp.readToken_question = function() { // '?'
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
      }
      return this.finishOp(types$1.coalesce, 2)
    }
  }
  return this.finishOp(types$1.question, 1)
};

pp.readToken_numberSign = function() { // '#'
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35; // '#'
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
      return this.finishToken(types$1.privateId, this.readWord1())
    }
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types$1.parenL)
  case 41: ++this.pos; return this.finishToken(types$1.parenR)
  case 59: ++this.pos; return this.finishToken(types$1.semi)
  case 44: ++this.pos; return this.finishToken(types$1.comma)
  case 91: ++this.pos; return this.finishToken(types$1.bracketL)
  case 93: ++this.pos; return this.finishToken(types$1.bracketR)
  case 123: ++this.pos; return this.finishToken(types$1.braceL)
  case 125: ++this.pos; return this.finishToken(types$1.braceR)
  case 58: ++this.pos; return this.finishToken(types$1.colon)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types$1.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.
  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 63: // '?'
    return this.readToken_question()

  case 126: // '~'
    return this.finishOp(types$1.prefix, 1)

  case 35: // '#'
    return this.readToken_numberSign()
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  // `len` is used for character escape sequences. In that case, disallow separators.
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
  // and isn't fraction part nor exponent part. In that case, if the first digit
  // is zero then disallow separators.
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);

    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
      if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
      if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
      lastCode = code;
      continue
    }

    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    lastCode = code;
    total = total * radix + val;
  }

  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8)
  }

  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
  return parseFloat(str.replace(/_/g, ""))
}

function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null
  }

  // `BigInt(value)` throws syntax error if the string contains numeric separators.
  return BigInt(str.replace(/_/g, ""))
}

pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types$1.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types$1.num, val$1)
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 0x2028 || ch === 0x2029) {
      if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") { break }
      // fall through
    case "`":
      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

    case "\r":
      if (this.input[this.pos + 1] === "\n") { ++this.pos; }
      // fall through
    case "\n": case "\u2028": case "\u2029":
      ++this.curLine;
      this.lineStart = this.pos + 1;
      break
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  case 56:
  case 57:
    if (this.strict) {
      this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      );
    }
    if (inTemplate) {
      var codePos = this.pos - 1;

      this.invalidStringToken(
        codePos,
        "Invalid escape sequence in template string"
      );
    }
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues


var version = "8.15.0";

Parser$1.acorn = {
  Parser: Parser$1,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext: TokContext,
  tokContexts: types,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and returns
// an abstract syntax tree as specified by the [ESTree spec][estree].
//
// [estree]: https://github.com/estree/estree

function parse$5(input, options) {
  return Parser$1.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser$1.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser$1.tokenizer(input, options)
}

const acornNamespace = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Node,
  Parser: Parser$1,
  Position,
  SourceLocation,
  TokContext,
  Token,
  TokenType,
  defaultOptions,
  getLineInfo,
  isIdentifierChar,
  isIdentifierStart,
  isNewLine,
  keywordTypes: keywords,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace,
  parse: parse$5,
  parseExpressionAt,
  tokContexts: types,
  tokTypes: types$1,
  tokenizer,
  version
}, Symbol.toStringTag, { value: 'Module' }));

// src/index.ts
var startsExpr = true;
function kwLike(_name, options = {}) {
  return new TokenType("name", options);
}
var acornTypeScriptMap = /* @__PURE__ */ new WeakMap();
var keywordTypeValues = Object.values(keywords);
function generateAcornTypeScript(_acorn) {
  const acorn = _acorn.Parser.acorn || _acorn;
  let acornTypeScript = acornTypeScriptMap.get(acorn);
  if (!acornTypeScript) {
    let tokenIsLiteralPropertyName = function(token) {
      return token === types$1.name || token === types$1.string || token === types$1.num || keywordTypeValues.includes(token) || tsKwTokenTypeValues.includes(token);
    }, tokenIsKeywordOrIdentifier = function(token) {
      return token === types$1.name || keywordTypeValues.includes(token) || tsKwTokenTypeValues.includes(token);
    }, tokenIsIdentifier = function(token) {
      return token === types$1.name || tsKwTokenTypeValues.includes(token);
    }, tokenIsTSDeclarationStart = function(token) {
      return token === tsKwTokenType.abstract || token === tsKwTokenType.declare || token === tsKwTokenType.enum || token === tsKwTokenType.module || token === tsKwTokenType.namespace || token === tsKwTokenType.interface || token === tsKwTokenType.type;
    }, tokenIsTSTypeOperator = function(token) {
      return token === tsKwTokenType.keyof || token === tsKwTokenType.readonly || token === tsKwTokenType.unique;
    }, tokenIsTemplate = function(token) {
      return token === types$1.invalidTemplate;
    };
    const tsKwTokenType = generateTsKwTokenType();
    const tsKwTokenTypeValues = Object.values(tsKwTokenType);
    const tsTokenType = generateTsTokenType();
    const tsTokenContext = generateTsTokenContext();
    const tsKeywordsRegExp = new RegExp(`^(?:${Object.keys(tsKwTokenType).join("|")})$`);
    tsTokenType.jsxTagStart.updateContext = function() {
      this.context.push(tsTokenContext.tc_expr);
      this.context.push(tsTokenContext.tc_oTag);
      this.exprAllowed = false;
    };
    tsTokenType.jsxTagEnd.updateContext = function(prevType) {
      let out = this.context.pop();
      if (out === tsTokenContext.tc_oTag && prevType === types$1.slash || out === tsTokenContext.tc_cTag) {
        this.context.pop();
        this.exprAllowed = this.curContext() === tsTokenContext.tc_expr;
      } else {
        this.exprAllowed = true;
      }
    };
    acornTypeScript = {
      tokTypes: {
        ...tsKwTokenType,
        ...tsTokenType
      },
      tokContexts: {
        ...tsTokenContext
      },
      keywordsRegExp: tsKeywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsKeywordOrIdentifier,
      tokenIsIdentifier,
      tokenIsTSDeclarationStart,
      tokenIsTSTypeOperator,
      tokenIsTemplate
    };
  }
  return acornTypeScript;
}
function generateTsTokenContext() {
  return {
    tc_oTag: new TokContext("<tag", false, false),
    tc_cTag: new TokContext("</tag", false, false),
    tc_expr: new TokContext("<tag>...</tag>", true, true)
  };
}
function generateTsTokenType() {
  return {
    // @ts-expect-error
    at: new TokenType("@"),
    // @ts-expect-error
    jsxName: new TokenType("jsxName"),
    // @ts-expect-error
    jsxText: new TokenType("jsxText", { beforeExpr: true }),
    // @ts-expect-error
    jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
    // @ts-expect-error
    jsxTagEnd: new TokenType("jsxTagEnd")
  };
}
function generateTsKwTokenType() {
  return {
    assert: kwLike("assert", { startsExpr }),
    asserts: kwLike("asserts", { startsExpr }),
    global: kwLike("global", { startsExpr }),
    keyof: kwLike("keyof", { startsExpr }),
    readonly: kwLike("readonly", { startsExpr }),
    unique: kwLike("unique", { startsExpr }),
    abstract: kwLike("abstract", { startsExpr }),
    declare: kwLike("declare", { startsExpr }),
    enum: kwLike("enum", { startsExpr }),
    module: kwLike("module", { startsExpr }),
    namespace: kwLike("namespace", { startsExpr }),
    interface: kwLike("interface", { startsExpr }),
    type: kwLike("type", { startsExpr })
  };
}

// src/scopeflags.ts
var TS_SCOPE_OTHER = 512;
var TS_SCOPE_TS_MODULE = 1024;

// src/whitespace.ts
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
var skipWhiteSpaceToLineBreak = new RegExp(
  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or
  // possessive quantifiers, so we use a trick to prevent backtracking
  // when the look-ahead for line terminator fails.
  "(?=(" + // Capture the whitespace and comments that should be skipped inside
  // a look-ahead assertion, and then re-match the group as a unit.
  skipWhiteSpaceInLine.source + "))\\1" + // Look-ahead for either line terminator, start of multi-line comment,
  // or end of string.
  /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
  "y"
  // sticky
);

// src/parseutil.ts
var DestructuringErrors = class {
  constructor() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  const name = element.key.name;
  const curr = privateNameMap[name];
  let next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  const { computed, key } = node;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}

// src/error.ts
var TypeScriptError = {
  AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  CannotFindName: ({ name }) => `Cannot find name '${name}'.`,
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: (
    // `Accessibility modifier already seen: ${modifier}` would be more helpful.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    () => `Accessibility modifier already seen.`
  ),
  DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,
  // `token` matches the terminology used by typescript:
  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915
  EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
  PrivateMethodsHasAccessibility: ({ modifier }) => `Private methods cannot have an accessibility modifier ('${modifier}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  GenericsEndWithComma: `Trailing comma is not allowed at the end of generics.`,
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
};
var DecoratorsError = {
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  TrailingDecorator: "Decorators must be attached to a class element.",
  SpreadElementDecorator: `Decorators can't be used with SpreadElement`
};

// src/extentions/decorators.ts
function generateParseDecorators(Parse, acornTypeScript, acorn) {
  const { tokTypes: tt } = acorn;
  const { tokTypes: tokTypes2 } = acornTypeScript;
  return class ParseDecorators extends Parse {
    takeDecorators(node) {
      const decorators = this.decoratorStack[this.decoratorStack.length - 1];
      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.decoratorStack[this.decoratorStack.length - 1] = [];
      }
    }
    parseDecorators(allowExport) {
      const currentContextDecorators = this.decoratorStack[this.decoratorStack.length - 1];
      while (this.match(tokTypes2.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }
      if (this.match(tt._export)) {
        if (!allowExport) {
          this.unexpected();
        }
      } else if (!this.canHaveLeadingDecorator()) {
        this.raise(this.start, DecoratorsError.UnexpectedLeadingDecorator);
      }
    }
    parseDecorator() {
      const node = this.startNode();
      this.next();
      this.decoratorStack.push([]);
      const startPos = this.start;
      const startLoc = this.startLoc;
      let expr;
      if (this.match(tt.parenL)) {
        const startPos2 = this.start;
        const startLoc2 = this.startLoc;
        this.next();
        expr = this.parseExpression();
        this.expect(tt.parenR);
        if (this.options.preserveParens) {
          let par = this.startNodeAt(startPos2, startLoc2);
          par.expression = expr;
          expr = this.finishNode(par, "ParenthesizedExpression");
        }
      } else {
        expr = this.parseIdent(false);
        while (this.eat(tt.dot)) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.object = expr;
          node2.property = this.parseIdent(true);
          node2.computed = false;
          expr = this.finishNode(node2, "MemberExpression");
        }
      }
      node.expression = this.parseMaybeDecoratorArguments(expr);
      this.decoratorStack.pop();
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(tt.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseExprList(tt.parenR, false);
        return this.finishNode(node, "CallExpression");
      }
      return expr;
    }
  };
}

// src/extentions/import-assertions.ts
function generateParseImportAssertions(Parse, acornTypeScript, acorn) {
  const { tokTypes: tokTypes2 } = acornTypeScript;
  const { tokTypes: tt } = acorn;
  return class ImportAttributes extends Parse {
    parseMaybeImportAttributes(node) {
      if (this.type === tt._with || this.type === tokTypes2.assert) {
        this.next();
        const attributes = this.parseImportAttributes();
        if (attributes) {
          node.attributes = attributes;
        }
      }
    }
    parseImportAttributes() {
      this.expect(tt.braceL);
      const attrs = this.parseWithEntries();
      this.expect(tt.braceR);
      return attrs;
    }
    parseWithEntries() {
      const attrs = [];
      const attrNames = /* @__PURE__ */ new Set();
      do {
        if (this.type === tt.braceR) {
          break;
        }
        const node = this.startNode();
        let withionKeyNode;
        if (this.type === tt.string) {
          withionKeyNode = this.parseLiteral(this.value);
        } else {
          withionKeyNode = this.parseIdent(true);
        }
        this.next();
        node.key = withionKeyNode;
        if (attrNames.has(node.key.name)) {
          this.raise(this.pos, "Duplicated key in attributes");
        }
        attrNames.add(node.key.name);
        if (this.type !== tt.string) {
          this.raise(this.pos, "Only string is supported as an attribute value");
        }
        node.value = this.parseLiteral(this.value);
        attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(tt.comma));
      return attrs;
    }
  };
}

// src/index.ts
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}
function tsIsClassAccessor(modifier) {
  return modifier === "accessor";
}
function tsIsVarianceAnnotations(modifier) {
  return modifier === "in" || modifier === "out";
}
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
var acornScope = {
  SCOPE_TOP: 1,
  SCOPE_FUNCTION: 2,
  SCOPE_ASYNC: 4,
  SCOPE_GENERATOR: 8,
  SCOPE_ARROW: 16,
  SCOPE_SIMPLE_CATCH: 32,
  SCOPE_SUPER: 64,
  SCOPE_DIRECT_SUPER: 128,
  BIND_NONE: 0,
  // Not a binding
  BIND_VAR: 1,
  // Var-style binding
  BIND_LEXICAL: 2,
  // Let- or const-style binding
  BIND_FUNCTION: 3,
  // Function declaration
  BIND_SIMPLE_CATCH: 4,
  // Special case for function names as bound inside the
  BIND_TS_TYPE: 6,
  BIND_TS_INTERFACE: 7,
  BIND_TS_NAMESPACE: 8,
  BIND_FLAGS_TS_EXPORT_ONLY: 1024,
  BIND_FLAGS_TS_IMPORT: 4096,
  BIND_FLAGS_TS_ENUM: 256,
  BIND_FLAGS_TS_CONST_ENUM: 512,
  BIND_FLAGS_CLASS: 128
  // function
};
function functionFlags(async, generator) {
  return acornScope.SCOPE_FUNCTION | (async ? acornScope.SCOPE_ASYNC : 0) | (generator ? acornScope.SCOPE_GENERATOR : 0);
}
function isPossiblyLiteralEnum(expression) {
  if (expression.type !== "MemberExpression") return false;
  const { computed, property } = expression;
  if (computed && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
    return false;
  }
  return isUncomputedMemberExpressionChain(expression.object);
}
function isUncomputedMemberExpressionChain(expression) {
  if (expression.type === "Identifier") return true;
  if (expression.type !== "MemberExpression") return false;
  if (expression.computed) return false;
  return isUncomputedMemberExpressionChain(expression.object);
}
function tsIsAccessModifier(modifier) {
  return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tokenCanStartExpression(token) {
  return Boolean(token.startsExpr);
}
function nonNull(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`);
  }
  return x;
}
function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return void 0;
  }
}
function tsPlugin(options) {
  const { dts = false } = {};
  const disallowAmbiguousJSXLike = false;
  return function(Parser) {
    const _acorn = Parser.acorn || acornNamespace;
    const acornTypeScript = generateAcornTypeScript(_acorn);
    const tt = _acorn.tokTypes;
    const keywordTypes2 = _acorn.keywordTypes;
    const isIdentifierStart = _acorn.isIdentifierStart;
    const lineBreak = _acorn.lineBreak;
    const isNewLine = _acorn.isNewLine;
    const tokContexts = _acorn.tokContexts;
    const isIdentifierChar = _acorn.isIdentifierChar;
    const {
      tokTypes: tokTypes2,
      tokContexts: tsTokContexts,
      keywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsTemplate,
      tokenIsTSDeclarationStart,
      tokenIsIdentifier,
      tokenIsKeywordOrIdentifier,
      tokenIsTSTypeOperator
    } = acornTypeScript;
    function nextLineBreak(code, from, end = code.length) {
      for (let i = from; i < end; i++) {
        let next = code.charCodeAt(i);
        if (isNewLine(next))
          return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
      }
      return -1;
    }
    Parser = generateParseDecorators(Parser, acornTypeScript, _acorn);
    Parser = generateParseImportAssertions(Parser, acornTypeScript, _acorn);
    class TypeScriptParser extends Parser {
      constructor(options2, input, startPos) {
        super(options2, input, startPos);
        this.preValue = null;
        this.preToken = null;
        this.isLookahead = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.inType = false;
        this.inDisallowConditionalTypesContext = false;
        this.maybeInArrowParameters = false;
        this.shouldParseArrowReturnType = void 0;
        this.shouldParseAsyncArrowReturnType = void 0;
        this.decoratorStack = [[]];
        this.importsStack = [[]];
        /**
         * we will only parse one import node or export node at same time.
         * default kind is undefined
         * */
        this.importOrExportOuterKind = void 0;
        this.tsParseConstModifier = (node) => {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["const"],
            // for better error recovery
            disallowedModifiers: ["in", "out"],
            errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
          });
        };
        this.ecmaVersion = this.options.ecmaVersion;
      }
      // support in Class static
      static get acornTypeScript() {
        return acornTypeScript;
      }
      // support in runtime, get acornTypeScript be this
      get acornTypeScript() {
        return acornTypeScript;
      }
      getTokenFromCodeInType(code) {
        if (code === 62) {
          return this.finishOp(tt.relational, 1);
        }
        if (code === 60) {
          return this.finishOp(tt.relational, 1);
        }
        return super.getTokenFromCode(code);
      }
      readToken(code) {
        if (!this.inType) {
          let context = this.curContext();
          if (context === tsTokContexts.tc_expr) return this.jsx_readToken();
          if (context === tsTokContexts.tc_oTag || context === tsTokContexts.tc_cTag) {
            if (isIdentifierStart(code)) return this.jsx_readWord();
            if (code == 62) {
              ++this.pos;
              return this.finishToken(tokTypes2.jsxTagEnd);
            }
            if ((code === 34 || code === 39) && context == tsTokContexts.tc_oTag)
              return this.jsx_readString(code);
          }
          if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            {
              return this.finishToken(tt.relational, "<");
            }
          }
        }
        return super.readToken(code);
      }
      getTokenFromCode(code) {
        if (this.inType) {
          return this.getTokenFromCodeInType(code);
        }
        if (code === 64) {
          ++this.pos;
          return this.finishToken(tokTypes2.at);
        }
        return super.getTokenFromCode(code);
      }
      isAbstractClass() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._class;
      }
      finishNode(node, type) {
        if (node.type !== "" && node.end !== 0) {
          return node;
        }
        return super.finishNode(node, type);
      }
      // tryParse will clone parser state.
      // It is expensive and should be used with cautions
      tryParse(fn, oldState = this.cloneCurLookaheadState()) {
        const abortSignal = { node: null };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.getCurLookaheadState();
          this.setLookaheadState(oldState);
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        refExpressionErrors.optionalParametersLoc = resultError?.loc ?? this.startLoc;
      }
      // used after we have finished parsing types
      reScan_lt_gt() {
        if (this.type === tt.relational) {
          this.pos -= 1;
          this.readToken_lt_gt(this.fullCharCodeAtPos());
        }
      }
      reScan_lt() {
        const { type } = this;
        if (type === tt.bitShift) {
          this.pos -= 2;
          this.finishOp(tt.relational, 1);
          return tt.relational;
        }
        return type;
      }
      resetEndLocation(node, endPos = this.lastTokEnd, endLoc = this.lastTokEndLoc) {
        node.end = endPos;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endPos;
      }
      startNodeAtNode(type) {
        return super.startNodeAt(type.start, type.loc.start);
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.pos);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual("static") && this.lookaheadCharCode() === 123;
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if (node?.type === "TSTypeCastExpression") {
            this.raise(node.typeAnnotation.start, TypeScriptError.UnexpectedTypeAnnotation);
          }
        });
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.potentialArrowAt;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.type);
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(tt.colon) ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon) : void 0;
      }
      tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit) {
        if (!this.tsMatchLeftRelational()) {
          return void 0;
        }
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(tt.arrow);
          return node;
        });
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) {
          return void 0;
        }
        return super.parseArrowExpression(
          res,
          /* params are already set */
          null,
          /* async */
          true,
          /* forInit */
          forInit
        );
      }
      // Used when parsing type arguments from ES productions, where the first token
      // has been created without state.inType. Thus we need to rescan the lt token.
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== tt.relational) {
          return void 0;
        }
        return this.tsParseTypeArguments();
      }
      tsInNoContext(cb) {
        const oldContext = this.context;
        this.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.context = oldContext;
        }
      }
      tsTryParseTypeAnnotation() {
        return this.match(tt.colon) ? this.tsParseTypeAnnotation() : void 0;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || // check if `nextCh is between 0xd800 - 0xdbff,
          // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function
          // returns true
          (nextCh & 64512) === 55296);
        }
        return false;
      }
      isAbstractConstructorSignature() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._new;
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      compareLookaheadState(state, state2) {
        for (const key of Object.keys(state)) {
          if (state[key] !== state2[key]) return false;
        }
        return true;
      }
      createLookaheadState() {
        this.value = null;
        this.context = [this.curContext()];
      }
      getCurLookaheadState() {
        return {
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context,
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      cloneCurLookaheadState() {
        return {
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context && this.context.slice(),
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      setLookaheadState(state) {
        this.pos = state.pos;
        this.value = state.value;
        this.endLoc = state.endLoc;
        this.lastTokEnd = state.lastTokEnd;
        this.lastTokStart = state.lastTokStart;
        this.lastTokStartLoc = state.lastTokStartLoc;
        this.type = state.type;
        this.start = state.start;
        this.end = state.end;
        this.context = state.context;
        this.startLoc = state.startLoc;
        this.lastTokEndLoc = state.lastTokEndLoc;
        this.curLine = state.curLine;
        this.lineStart = state.lineStart;
        this.curPosition = state.curPosition;
        this.containsEsc = state.containsEsc;
      }
      // Utilities
      tsLookAhead(f) {
        const state = this.getCurLookaheadState();
        const res = f();
        this.setLookaheadState(state);
        return res;
      }
      lookahead(number) {
        const oldState = this.getCurLookaheadState();
        this.createLookaheadState();
        this.isLookahead = true;
        if (number !== void 0) {
          for (let i = 0; i < number; i++) {
            this.nextToken();
          }
        } else {
          this.nextToken();
        }
        this.isLookahead = false;
        const curState = this.getCurLookaheadState();
        this.setLookaheadState(oldState);
        return curState;
      }
      readWord() {
        let word = this.readWord1();
        let type = tt.name;
        if (this.keywords.test(word)) {
          type = keywordTypes2[word];
        } else if (new RegExp(keywordsRegExp).test(word)) {
          type = tokTypes2[word];
        }
        return this.finishToken(type, word);
      }
      skipBlockComment() {
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
        this.pos = end + 2;
        if (this.options.locations) {
          for (let nextBreak, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.isLookahead) return;
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      }
      skipLineComment(startSkip) {
        let start = this.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.isLookahead) return;
        if (this.options.onComment)
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
      }
      finishToken(type, val) {
        this.preValue = this.value;
        this.preToken = this.type;
        this.end = this.pos;
        if (this.options.locations) this.endLoc = this.curPosition();
        let prevType = this.type;
        this.type = type;
        this.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      resetStartLocation(node, start, startLoc) {
        node.start = start;
        node.loc.start = startLoc;
        if (this.options.ranges) node.range[0] = start;
      }
      isLineTerminator() {
        return this.eat(tt.semi) || super.canInsertSemicolon();
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      addExtra(node, key, value, enumerable = true) {
        if (!node) return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, { enumerable, value });
        }
      }
      /**
       * Test if current token is a literal property name
       * https://tc39.es/ecma262/#prod-LiteralPropertyName
       * LiteralPropertyName:
       *   IdentifierName
       *   StringLiteral
       *   NumericLiteral
       *   BigIntLiteral
       */
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.type);
      }
      hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      createIdentifier(node, name) {
        node.name = name;
        return this.finishNode(node, "Identifier");
      }
      /**
       * Reset the start location of node to the start location of locationNode
       */
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
      }
      // This is used in flow and typescript plugin
      // Determine whether a parameter is a this param
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      /**
       * ts type isContextual
       * @param {TokenType} type
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_type_isContextual(type, token) {
        return type === token && !this.containsEsc;
      }
      /**
       * ts isContextual
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_isContextual(token) {
        return this.type === token && !this.containsEsc;
      }
      ts_isContextualWithState(state, token) {
        return state.type === token && !state.containsEsc;
      }
      isContextualWithState(keyword, state) {
        return state.type === tt.name && state.value === keyword && !state.containsEsc;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(tt.plusMin)) {
          return this.ts_isContextual(tokTypes2.readonly);
        }
        if (this.ts_isContextual(tokTypes2.readonly)) {
          this.next();
        }
        if (!this.match(tt.bracketL)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(tt._in);
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(tt.colon);
      }
      /**
       * Whether current token matches given type
       *
       * @param {TokenType} type
       * @returns {boolean}
       * @memberof Tokenizer
       */
      match(type) {
        return this.type === type;
      }
      matchJsx(type) {
        return this.type === acornTypeScript.tokTypes[type];
      }
      ts_eatWithState(type, nextCount, state) {
        const targetType = state.type;
        if (type === targetType) {
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        } else {
          return false;
        }
      }
      ts_eatContextualWithState(name, nextCount, state) {
        if (keywordsRegExp.test(name)) {
          if (this.ts_isContextualWithState(state, tokTypes2[name])) {
            for (let i = 0; i < nextCount; i++) {
              this.next();
            }
            return true;
          }
          return false;
        } else {
          if (!this.isContextualWithState(name, state)) return false;
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        }
      }
      canHaveLeadingDecorator() {
        return this.match(tt._class);
      }
      eatContextual(name) {
        if (keywordsRegExp.test(name)) {
          if (this.ts_isContextual(tokTypes2[name])) {
            this.next();
            return true;
          }
          return false;
        } else {
          return super.eatContextual(name);
        }
      }
      tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual("require");
        this.expect(tt.parenL);
        if (!this.match(tt.string)) {
          this.unexpected();
        }
        node.expression = this.parseExprAtom();
        this.expect(tt.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdent(allowReservedWords);
        while (this.eat(tt.dot)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdent(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(tt.string) ? this.parseLiteral(this.value) : this.parseIdent(
          /* liberal */
          true
        );
        if (this.eat(tt.eq)) {
          node.initializer = this.parseMaybeAssign();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const) node.const = true;
        if (properties.declare) node.declare = true;
        this.expectContextual("enum");
        node.id = this.parseIdent();
        this.checkLValSimple(node.id);
        this.expect(tt.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(tt.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.enterScope(TS_SCOPE_OTHER);
        this.expect(tt.braceL);
        node.body = [];
        while (this.type !== tt.braceR) {
          let stmt = this.parseStatement(null, true);
          node.body.push(stmt);
        }
        this.next();
        super.exitScope();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.ts_isContextual(tokTypes2.global)) {
          node.global = true;
          node.id = this.parseIdent();
        } else if (this.match(tt.string)) {
          node.id = this.parseLiteral(this.value);
        } else {
          this.unexpected();
        }
        if (this.match(tt.braceL)) {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        } else {
          super.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let starttype = this.type;
        let kind;
        if (this.isContextual("let")) {
          starttype = tt._var;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          if (starttype === tt._function) {
            nany.declare = true;
            return this.parseFunctionStatement(
              nany,
              /* async */
              false,
              /* declarationPosition */
              true
            );
          }
          if (starttype === tt._class) {
            nany.declare = true;
            return this.parseClass(nany, true);
          }
          if (starttype === tokTypes2.enum) {
            return this.tsParseEnumDeclaration(nany, { declare: true });
          }
          if (starttype === tokTypes2.global) {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          }
          if (starttype === tt._const || starttype === tt._var) {
            if (!this.match(tt._const) || !this.isLookaheadContextual("enum")) {
              nany.declare = true;
              return this.parseVarStatement(nany, kind || this.value, true);
            }
            this.expect(tt._const);
            return this.tsParseEnumDeclaration(nany, {
              const: true,
              declare: true
            });
          }
          if (starttype === tokTypes2.interface) {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: true
            });
            if (result) return result;
          }
          if (tokenIsIdentifier(starttype)) {
            return this.tsParseDeclaration(
              nany,
              this.value,
              /* next */
              true
            );
          }
        });
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(tt.braceR);
          case "HeritageClauseElement":
            return this.match(tt.braceL);
          case "TupleElementTypes":
            return this.match(tt.bracketR);
          case "TypeParametersOrArguments":
            return this.tsMatchRightRelational();
        }
      }
      /**
       * If !expectSuccess, returns undefined instead of failing to parse.
       * If expectSuccess, parseElement should always return a defined value.
       */
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(tt.comma)) {
            trailingCommaPos = this.lastTokStart;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(tt.comma);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(
          this.tsParseDelimitedListWorker(
            kind,
            parseElement,
            /* expectSuccess */
            true,
            refTrailingCommaPos
          )
        );
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(tt.bracketL);
          } else {
            this.expect(tt.relational);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(tt.bracketR);
        } else {
          this.expect(tt.relational);
        }
        return result;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdent();
        return typeName.name;
      }
      tsEatThenParseType(token) {
        return !this.match(token) ? void 0 : this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.type) || this.match(tt._this)) {
          this.next();
          return true;
        }
        if (this.match(tt.braceL)) {
          try {
            this.parseObj(true);
            return true;
          } catch {
            return false;
          }
        }
        if (this.match(tt.bracketL)) {
          this.next();
          try {
            this.parseBindingList(tt.bracketR, true, true);
            return true;
          } catch {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(tt.parenR) || this.match(tt.ellipsis)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(tt.colon) || this.match(tt.comma) || this.match(tt.question) || this.match(tt.eq)) {
            return true;
          }
          if (this.match(tt.parenR)) {
            this.next();
            if (this.match(tt.arrow)) {
              return true;
            }
          }
        }
        return false;
      }
      tsIsStartOfFunctionType() {
        if (this.tsMatchLeftRelational()) {
          return true;
        }
        return this.match(tt.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsParseBindingListForSignature() {
        return super.parseBindingList(tt.parenR, true, true).map((pattern) => {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            this.raise(
              pattern.start,
              TypeScriptError.UnsupportedSignatureParameterKind({ type: pattern.type })
            );
          }
          return pattern;
        });
      }
      tsParseTypePredicateAsserts() {
        if (this.type !== tokTypes2.asserts) {
          return false;
        }
        const containsEsc = this.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.type) && !this.match(tt._this)) {
          return false;
        }
        if (containsEsc) {
          this.raise(this.lastTokStart, "Escape sequence in keyword asserts");
        }
        return true;
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(tt.colon);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(
          /* eatColon */
          false
        );
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdent();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(tt._this)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(
                /* eatColon */
                false,
                t
              );
            }
            node.parameterName = this.parseIdent();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(
            /* eatColon */
            false
          );
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
      // but here it's always false, because this is only used for types.
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === tt.arrow;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(tt.parenL);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type !== tt._const) return null;
        this.next();
        const typeReference = this.tsParseTypeReference();
        if (typeReference.typeParameters || typeReference.typeArguments) {
          this.raise(
            typeReference.typeName.start,
            TypeScriptError.CannotFindName({
              name: "const"
            })
          );
        }
        return typeReference;
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(tt.arrow, node));
        return this.finishNode(node, type);
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types = [];
        do {
          types.push(parseConstituentType());
        } while (this.eat(operator));
        if (types.length === 1 && !hasLeadingOperator) {
          return types[0];
        }
        node.types = types;
        return this.finishNode(node, kind);
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(node.start, TypeScriptError.UnexpectedReadonly);
        }
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsParseConstraintForInferType() {
        if (this.eat(tt._extends)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.inDisallowConditionalTypesContext || !this.match(tt.question)) {
            return constraint;
          }
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual("infer");
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        node.literal = (() => {
          switch (this.type) {
            case tt.num:
            // we don't need bigint type here
            // case tt.bigint:
            case tt.string:
            case tt._true:
            case tt._false:
              return this.parseExprAtom();
            default:
              this.unexpected();
          }
        })();
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(tt._import);
        this.expect(tt.parenL);
        if (!this.match(tt.string)) {
          this.raise(this.start, TypeScriptError.UnsupportedImportTypeArgument);
        }
        node.argument = this.parseExprAtom();
        this.expect(tt.parenR);
        if (this.eat(tt.dot)) {
          node.qualifier = this.tsParseEntityName();
        }
        if (this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(tt._typeof);
        if (this.match(tt._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(tt._in);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(tt.braceL);
        if (this.match(tt.plusMin)) {
          node.readonly = this.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }
        this.expect(tt.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
        this.expect(tt.bracketR);
        if (this.match(tt.plusMin)) {
          node.optional = this.value;
          this.next();
          this.expect(tt.question);
        } else if (this.eat(tt.question)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(tt.braceR);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseTupleElementType() {
        const startLoc = this.startLoc;
        const startPos = this["start"];
        const rest = this.eat(tt.ellipsis);
        let type = this.tsParseType();
        const optional = this.eat(tt.question);
        const labeled = this.eat(tt.colon);
        if (labeled) {
          const labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          if (type.type === "TSTypeReference" && !type.typeArguments && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(type.start, TypeScriptError.InvalidTupleMemberLabel);
            labeledNode.label = type;
          }
          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList(
          "TupleElementTypes",
          this.tsParseTupleElementType.bind(this),
          /* bracket */
          true,
          /* skipFirstToken */
          false
        );
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const { type } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(elementNode.start, TypeScriptError.OptionalTypeBeforeRequired);
          }
          seenOptionalElement ||= type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = this.parseTemplate({ isTagged: false });
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsMatchLeftRelational() {
        return this.match(tt.relational) && this.value === "<";
      }
      tsMatchRightRelational() {
        return this.match(tt.relational) && this.value === ">";
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(tt.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(tt.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseNonArrayType() {
        switch (this.type) {
          case tt.string:
          case tt.num:
          // we don't need bigint type here
          // case tt.bigint:
          case tt._true:
          case tt._false:
            return this.tsParseLiteralTypeNode();
          case tt.plusMin:
            if (this.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== tt.num) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case tt._this:
            return this.tsParseThisTypeOrThisTypePredicate();
          case tt._typeof:
            return this.tsParseTypeQuery();
          case tt._import:
            return this.tsParseImportType();
          case tt.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case tt.bracketL:
            return this.tsParseTupleType();
          case tt.parenL:
            return this.tsParseParenthesizedType();
          // parse template string here
          case tt.backQuote:
          case tt.dollarBraceL:
            return this.tsParseTemplateLiteralType();
          default: {
            const { type } = this;
            if (tokenIsIdentifier(type) || type === tt._void || type === tt._null) {
              const nodeType = type === tt._void ? "TSVoidKeyword" : type === tt._null ? "TSNullKeyword" : keywordTypeFromName(this.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {
          if (this.match(tt.bracketR)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(tt.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(tt.bracketR);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.type) && !this.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSIntersectionType",
          this.tsParseTypeOperatorOrHigher.bind(this),
          tt.bitwiseAND
        );
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSUnionType",
          this.tsParseIntersectionTypeOrHigher.bind(this),
          tt.bitwiseOR
        );
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(tt._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType(
            "TSConstructorType",
            /* abstract */
            true
          );
        }
        return this.tsParseUnionTypeOrHigher();
      }
      /** Be sure to be in a type context before calling this, using `tsInType`. */
      tsParseType() {
        assert(this.inType);
        const type = this.tsParseNonConditionalType();
        if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(
          () => this.tsParseNonConditionalType()
        );
        this.expect(tt.question);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(tt.colon);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.type)) {
          this.next();
          return this.match(tt.colon);
        }
        return false;
      }
      /**
       * Runs `cb` in a type context.
       * This should be called one token *before* the first type token,
       * so that the call to `next()` is run in type context.
       */
      tsInType(cb) {
        const oldInType = this.inType;
        this.inType = true;
        try {
          return cb();
        } finally {
          this.inType = oldInType;
        }
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(tt.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return void 0;
        }
        this.expect(tt.bracketL);
        const id = this.parseIdent();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(tt.bracketR);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      // for better error recover
      tsParseNoneModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: [],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
      }
      tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(tt._extends);
        node.default = this.tsEatThenParseType(tt.eq);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart")) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = { value: -1 };
        node.params = this.tsParseBracketedList(
          "TypeParametersOrArguments",
          this.tsParseTypeParameter.bind(this, parseModifiers),
          /* bracket */
          false,
          /* skipFirstToken */
          true,
          refTrailingCommaPos
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeParameters);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.tsMatchLeftRelational()) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsTryParse(f) {
        const state = this.getCurLookaheadState();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        } else {
          this.setLookaheadState(state);
          return void 0;
        }
      }
      tsTokenCanFollowModifier() {
        return (this.match(tt.bracketL) || this.match(tt.braceL) || this.match(tt.star) || this.match(tt.ellipsis) || this.match(tt.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next(true);
        return this.tsTokenCanFollowModifier();
      }
      /** Parses a modifier matching one the given modifier names. */
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        const modifier = this.value;
        if (allowedModifiers.indexOf(modifier) !== -1 && !this.containsEsc) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiersByMap({
        modified,
        map
      }) {
        for (const key of Object.keys(map)) {
          modified[key] = map[key];
        }
      }
      /** Parses a list of modifiers, in any order.
       *  If you need a specific order, you must call this function multiple times:
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ['public'] });
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ["abstract", "readonly"] });
       */
      tsParseModifiers({
        modified,
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TypeScriptError.InvalidModifierOnTypeMember
      }) {
        const modifiedMap = {};
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(
              loc.column,
              TypeScriptError.InvalidModifiersOrder({ orderedModifiers: [before, after] })
            );
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(
              loc.column,
              TypeScriptError.IncompatibleModifiers({ modifiers: [mod1, mod2] })
            );
          }
        };
        for (; ; ) {
          const startLoc = this.startLoc;
          const modifier = this.tsParseModifier(
            allowedModifiers.concat(disallowedModifiers ?? []),
            stopOnStartOfClassStaticBlock
          );
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(this.start, TypeScriptError.DuplicateAccessibilityModifier());
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              enforceOrder(startLoc, modifier, modifier, "accessor");
              modifiedMap.accessibility = modifier;
              modified["accessibility"] = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "in", "out");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (tsIsClassAccessor(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              incompatible(startLoc, modifier, "accessor", "readonly");
              incompatible(startLoc, modifier, "accessor", "static");
              incompatible(startLoc, modifier, "accessor", "override");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (modifier === "const") {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          }
          if (disallowedModifiers?.includes(modifier)) {
            this.raise(this.start, errorTemplate);
          }
        }
        return modifiedMap;
      }
      tsParseInOutModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["in", "out"],
          disallowedModifiers: [
            "public",
            "private",
            "protected",
            "readonly",
            "declare",
            "abstract",
            "override"
          ],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameter
        });
      }
      // Handle type assertions
      parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit) {
        if (this.tsMatchLeftRelational()) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit);
        }
      }
      tsParseTypeAssertion() {
        const result = this.tryParse(() => {
          const node = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(tt.relational);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        });
        if (result.error) {
          return this.tsParseTypeParameters(this.tsParseConstModifier);
        } else {
          return result.node;
        }
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(
          () => (
            // Temporarily remove a JSX parsing context, which makes us scan different tokens.
            this.tsInNoContext(() => {
              this.expect(tt.relational);
              return this.tsParseDelimitedList(
                "TypeParametersOrArguments",
                this.tsParseType.bind(this)
              );
            })
          )
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeArguments);
        }
        this.exprAllowed = false;
        this.expect(tt.relational);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsParseHeritageClause(token) {
        const originalStart = this.start;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName();
          if (this.tsMatchLeftRelational()) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(originalStart, TypeScriptError.EmptyHeritageClauseType({ token }));
        }
        return delimitedList;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(tt.comma) && !this.isLineTerminator()) {
          this.expect(tt.semi);
        }
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse(
          (abort) => (
            // @ts-expect-error todo(flow->ts)
            f() || abort()
          )
        );
        if (result.aborted || !result.node) return void 0;
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(tt.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(tt.question)) node.optional = true;
        const nodeAny = node;
        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
          if (readonly) {
            this.raise(node.start, TypeScriptError.ReadonlyForMethodSignature);
          }
          const method = nodeAny;
          if (method.kind && this.tsMatchLeftRelational()) {
            this.raise(this.start, TypeScriptError.AccesorCannotHaveTypeParameters);
          }
          this.tsFillSignature(tt.colon, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveOptionalParameter);
              }
              if (firstParameter.type === "RestElement") {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveRestParameter);
              }
            }
            if (method[returnTypeKey]) {
              this.raise(
                method[returnTypeKey].start,
                TypeScriptError.SetAccesorCannotHaveReturnType
              );
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(tt._new)) {
          const id = this.startNode();
          this.next();
          if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["readonly"],
          disallowedModifiers: [
            "declare",
            "abstract",
            "private",
            "protected",
            "public",
            "static",
            "override"
          ]
        });
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        this.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          this.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseObjectTypeMembers() {
        this.expect(tt.braceL);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(tt.braceR);
        return members;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual("interface");
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.type)) {
          node.id = this.parseIdent();
          this.checkLValSimple(node.id, acornScope.BIND_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(this.start, TypeScriptError.MissingInterfaceName);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (this.eat(tt._extends)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsParseInterfaceBody();
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      /**
       * Parse interface body, ensuring the closing brace is read outside of type context
       * so that decorators following the interface are properly tokenized.
       */
      tsParseInterfaceBody() {
        this.expect(tt.braceL);
        const oldInType = this.inType;
        this.inType = true;
        let members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.inType = oldInType;
        this.expect(tt.braceR);
        return members;
      }
      tsParseAbstractDeclaration(node) {
        if (this.match(tt._class)) {
          node.abstract = true;
          return this.parseClass(node, true);
        } else if (this.ts_isContextual(tokTypes2.interface)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(node.start);
        }
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.type);
      }
      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
              return declaration;
            }
            break;
          }
          case "global":
            if (this.match(tt.braceL)) {
              this.enterScope(TS_SCOPE_TS_MODULE);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              super.exitScope();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(
              node,
              expr.name,
              /* next */
              false
            );
        }
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(
          /* allowReservedWords */
          false
        );
      }
      tsIsExportDefaultSpecifier() {
        const { type } = this;
        const isAsync = this.isAsyncFunction();
        const isLet = this.isLet();
        if (tokenIsIdentifier(type)) {
          if (isAsync && !this.containsEsc || isLet) {
            return false;
          }
          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt._default)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.isAmbientContext;
        this.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.isAmbientContext = oldIsAmbientContext;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdent();
        if (!nested) {
          this.checkLValSimple(node.id, acornScope.BIND_TS_NAMESPACE);
        }
        if (this.eat(tt.dot)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      checkLValSimple(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        if (expr.type === "TSNonNullExpression" || expr.type === "TSAsExpression") {
          expr = expr.expression;
        }
        return super.checkLValSimple(expr, bindingType, checkClashes);
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_TS_TYPE);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(
            this.tsParseInOutModifiers.bind(this)
          );
          this.expect(tt.eq);
          if (this.ts_isContextual(tokTypes2.interface) && this.lookahead().type !== tt.dot) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
      tsParseDeclaration(node, value, next) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(tt._class) || tokenIsIdentifier(this.type))) {
              return this.tsParseAbstractDeclaration(node);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(tt.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      // Note: this won't b·e called unless the keyword is allowed in
      // `shouldParseExportDeclaration`.
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(
          this.startNode(),
          this.value,
          /* next */
          true
        );
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_LEXICAL);
        super.expect(tt.eq);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(moduleReference.start, TypeScriptError.ImportAliasHasImportType);
        }
        node.moduleReference = moduleReference;
        super.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        const { type } = this;
        if (tokenIsIdentifier(type)) {
          if (this.isContextual("async") || this.isContextual("let")) {
            return false;
          }
          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt._default)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseTemplate({ isTagged = false } = {}) {
        let node = this.startNode();
        this.next();
        node.expressions = [];
        let curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === tt.eof) this.raise(this.pos, "Unterminated template literal");
          this.expect(tt.dollarBraceL);
          node.expressions.push(this.inType ? this.tsParseType() : this.parseExpression());
          this.expect(tt.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      }
      parseFunction(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !isAsync) {
          if (this.type === tt.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(tt.star);
        }
        if (this.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== tt.name ? null : this.parseIdent();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = false;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === tt.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        const isDeclaration = statement & FUNC_STATEMENT;
        this.parseFunctionBody(node, allowExpressionBody, false, forInit, {
          isFunctionDeclaration: isDeclaration
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (statement & FUNC_STATEMENT && node.id && !(statement & FUNC_HANGING_STATEMENT)) {
          if (node.body) {
            this.checkLValSimple(
              node.id,
              this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? acornScope.BIND_VAR : acornScope.BIND_LEXICAL : acornScope.BIND_FUNCTION
            );
          } else {
            this.checkLValSimple(node.id, acornScope.BIND_NONE);
          }
        }
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      }
      parseFunctionBody(node, isArrowFunction = false, isMethod = false, forInit = false, tsConfig) {
        if (this.match(tt.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
        }
        const bodilessType = tsConfig?.isFunctionDeclaration ? "TSDeclareFunction" : tsConfig?.isClassMethod ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.isAmbientContext) {
          this.raise(node.start, TypeScriptError.DeclareFunctionHasImplementation);
          if (node.declare) {
            super.parseFunctionBody(node, isArrowFunction, isMethod, false);
            return this.finishNode(node, bodilessType);
          }
        }
        super.parseFunctionBody(node, isArrowFunction, isMethod, forInit);
        return node;
      }
      parseNew() {
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        let node = this.startNode();
        let meta = this.parseIdent(true);
        if (this.ecmaVersion >= 6 && this.eat(tt.dot)) {
          node.meta = meta;
          let containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target")
            this.raiseRecoverable(
              node.property.start,
              "The only valid meta property for new is 'new.target'"
            );
          if (containsEsc)
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          if (!this["allowNewDotTarget"])
            this.raiseRecoverable(
              node.start,
              "'new.target' can only be used in functions and class static block"
            );
          return this.finishNode(node, "MetaProperty");
        }
        let startPos = this.start, startLoc = this.startLoc, isImport = this.type === tt._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        const { callee } = node;
        if (callee.type === "TSInstantiationExpression" && !callee.extra?.parenthesized) {
          node.typeArguments = callee.typeArguments;
          node.callee = callee.expression;
        }
        if (this.eat(tt.parenL))
          node.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false);
        else node.arguments = [];
        return this.finishNode(node, "NewExpression");
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        if (tt._in.binop > minPrec && !this.hasPrecedingLineBreak()) {
          let nodeType;
          if (this.isContextual("as")) {
            nodeType = "TSAsExpression";
          }
          if (this.isContextual("satisfies")) {
            nodeType = "TSSatisfiesExpression";
          }
          if (nodeType) {
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node, nodeType);
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit);
      }
      parseImportSpecifiers() {
        let nodes = [], first = true;
        if (acornTypeScript.tokenIsIdentifier(this.type)) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(tt.comma)) return nodes;
        }
        if (this.type === tt.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(tt.braceL);
        while (!this.eat(tt.braceR)) {
          if (!first) {
            this.expect(tt.comma);
            if (this.afterTrailingComma(tt.braceR)) break;
          } else first = false;
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      }
      /**
       * @param {Node} node this may be ImportDeclaration |
       * TsImportEqualsDeclaration
       * @returns AnyImport
       * */
      parseImport(node) {
        let enterHead = this.lookahead();
        node.importKind = "value";
        this.importOrExportOuterKind = "value";
        if (tokenIsIdentifier(enterHead.type) || this.match(tt.star) || this.match(tt.braceL)) {
          let ahead = this.lookahead(2);
          if (
            // import type, { a } from "b";
            ahead.type !== tt.comma && // import type from "a";
            !this.isContextualWithState("from", ahead) && // import type = require("a");
            ahead.type !== tt.eq && this.ts_eatContextualWithState("type", 1, enterHead)
          ) {
            this.importOrExportOuterKind = "type";
            node.importKind = "type";
            enterHead = this.lookahead();
            ahead = this.lookahead(2);
          }
          if (tokenIsIdentifier(enterHead.type) && ahead.type === tt.eq) {
            this.next();
            const importNode = this.tsParseImportEqualsDeclaration(node);
            this.importOrExportOuterKind = "value";
            return importNode;
          }
        }
        this.next();
        if (this.type === tt.string) {
          node.specifiers = [];
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
        }
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        this.finishNode(node, "ImportDeclaration");
        this.importOrExportOuterKind = "value";
        if (node.importKind === "type" && node.specifiers.length > 1 && node.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(node.start, TypeScriptError.TypeImportCannotSpecifyDefaultAndNamed);
        }
        return node;
      }
      parseExportDefaultDeclaration() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true);
        }
        if (this.match(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultDeclaration();
      }
      parseExportAllDeclaration(node, exports$1) {
        if (this.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports$1, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== tt.string) this.unexpected();
        node.source = this.parseExprAtom();
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      parseDynamicImport(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.eat(tt.comma)) {
          const expr = this.parseExpression();
          node.arguments = [expr];
        }
        if (!this.eat(tt.parenR)) {
          const errorPos = this.start;
          if (this.eat(tt.comma) && this.eat(tt.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      }
      parseExport(node, exports$1) {
        let enterHead = this.lookahead();
        if (this.ts_eatWithState(tt._import, 2, enterHead)) {
          if (this.ts_isContextual(tokTypes2.type) && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.importOrExportOuterKind = "type";
            this.next();
          } else {
            node.importKind = "value";
            this.importOrExportOuterKind = "value";
          }
          const exportEqualsNode = this.tsParseImportEqualsDeclaration(
            node,
            /* isExport */
            true
          );
          this.importOrExportOuterKind = void 0;
          return exportEqualsNode;
        } else if (this.ts_eatWithState(tt.eq, 2, enterHead)) {
          const assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.ts_eatContextualWithState("as", 2, enterHead)) {
          const decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdent();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          const lookahead2 = this.lookahead(2).type;
          if (this.ts_isContextualWithState(enterHead, tokTypes2.type) && (lookahead2 === tt.braceL || // export type { ... }
          lookahead2 === tt.star)) {
            this.next();
            this.importOrExportOuterKind = "type";
            node.exportKind = "type";
          } else {
            this.importOrExportOuterKind = "value";
            node.exportKind = "value";
          }
          this.next();
          if (this.eat(tt.star)) {
            return this.parseExportAllDeclaration(node, exports$1);
          }
          if (this.eat(tt._default)) {
            this.checkExport(exports$1, "default", this.lastTokStart);
            node.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseExportDeclaration(node);
            if (node.declaration.type === "VariableDeclaration")
              this.checkVariableExport(exports$1, node.declaration.declarations);
            else this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
            node.specifiers = [];
            node.source = null;
          } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports$1);
            if (this.eatContextual("from")) {
              if (this.type !== tt.string) this.unexpected();
              node.source = this.parseExprAtom();
              this.parseMaybeImportAttributes(node);
            } else {
              for (let spec of node.specifiers) {
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
                if (spec.local.type === "Literal") {
                  this.raise(
                    spec.local.start,
                    "A string literal cannot be used as an exported binding without `from`."
                  );
                }
              }
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        }
      }
      checkExport(exports$1, name, _) {
        if (!exports$1) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        exports$1[name] = true;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TypeScriptError.TypeAnnotationAfterAssign);
        }
        return node;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(
          node.expression,
          node.typeAnnotation.end,
          node.typeAnnotation.loc?.end
        );
        return node.expression;
      }
      toAssignableList(exprList, isBinding) {
        if (!exprList) exprList = [];
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if (expr?.type === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return super.toAssignableList(exprList, isBinding);
      }
      reportReservedArrowTypeParam(node) {
        if (node.params.length === 1 && !node.extra?.trailingComma && disallowAmbiguousJSXLike) ;
      }
      parseExprAtom(refDestructuringErrors, forInit, forNew) {
        if (this.type === tokTypes2.jsxText) {
          return this.jsx_parseText();
        } else if (this.type === tokTypes2.jsxTagStart) {
          return this.jsx_parseElement();
        } else if (this.type === tokTypes2.at) {
          this.parseDecorators();
          return this.parseExprAtom();
        } else if (tokenIsIdentifier(this.type)) {
          let canBeArrow = this.potentialArrowAt === this.start;
          let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          let id = this.parseIdent(false);
          if (this.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(tt._function)) {
            this.overrideContext(tokContexts.f_expr);
            return this.parseFunction(
              this.startNodeAt(startPos, startLoc),
              0,
              false,
              true,
              forInit
            );
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(tt.arrow))
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id],
                false,
                forInit
              );
            if (this.ecmaVersion >= 8 && id.name === "async" && this.type === tt.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id],
                true,
                forInit
              );
            }
          }
          return id;
        } else {
          return super.parseExprAtom(refDestructuringErrors, forInit, forNew);
        }
      }
      parseExprAtomDefault() {
        if (tokenIsIdentifier(this.type)) {
          const canBeArrow = this["potentialArrowAt"] === this.start;
          const containsEsc = this.containsEsc;
          const id = this.parseIdent();
          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
            const { type } = this;
            if (type === tt._function) {
              this.next();
              return this.parseFunction(this.startNodeAtNode(id), void 0, true, true);
            } else if (tokenIsIdentifier(type)) {
              if (this.lookaheadCharCode() === 61) {
                const paramId = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
                return this.parseArrowExpression(this.startNodeAtNode(id), [paramId], true);
              } else {
                return id;
              }
            }
          }
          if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
          }
          return id;
        } else {
          this.unexpected();
        }
      }
      parseIdentNode() {
        let node = this.startNode();
        if (tokenIsKeywordOrIdentifier(this.type) && // Taken from super-class method
        !((this.type.keyword === "class" || this.type.keyword === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))) {
          node.name = this.value;
        } else {
          return super.parseIdentNode();
        }
        return node;
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const { isAmbientContext } = this;
        this.next();
        super.parseVar(node, false, kind, allowMissingInitializer || isAmbientContext);
        this.semicolon();
        const declaration = this.finishNode(node, "VariableDeclaration");
        if (!isAmbientContext) return declaration;
        for (const { id, init } of declaration.declarations) {
          if (!init) continue;
          if (kind !== "const" || !!id.typeAnnotation) {
            this.raise(init.start, TypeScriptError.InitializerNotAllowedInAmbientContext);
          } else if (init.type !== "StringLiteral" && init.type !== "BooleanLiteral" && init.type !== "NumericLiteral" && init.type !== "BigIntLiteral" && (init.type !== "TemplateLiteral" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {
            this.raise(
              init.start,
              TypeScriptError.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference
            );
          }
        }
        return declaration;
      }
      parseStatement(context, topLevel, exports$1) {
        if (this.match(tokTypes2.at)) {
          this.parseDecorators(true);
        }
        if (this.match(tt._const) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(tt._const);
          return this.tsParseEnumDeclaration(node, { const: true });
        }
        if (this.ts_isContextual(tokTypes2.enum)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.ts_isContextual(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatement(context, topLevel, exports$1);
      }
      // NOTE: unused function
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(tt.question);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(tt.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasReadonly);
        }
        if (methodOrProp.declare && this.match(tt.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasDeclare);
        }
      }
      // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`
      // is that e.g. `type()` is valid JS, so we must try parsing that first.
      // If it's really a type, we will parse `type` as the statement, and can correct it here
      // by parsing the rest.
      parseExpressionStatement(node, expr) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
        return decl || super.parseExpressionStatement(node, expr);
      }
      shouldParseExportStatement() {
        if (this.tsIsDeclarationStart()) return true;
        if (this.match(tokTypes2.at)) {
          return true;
        }
        return super.shouldParseExportStatement();
      }
      parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors) {
        if (this.eat(tt.question)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(tt.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeConditional(forInit, refDestructuringErrors) {
        let startPos = this.start, startLoc = this.startLoc;
        let expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        if (!this.maybeInArrowParameters || !this.match(tt.question)) {
          return this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors);
        }
        const result = this.tryParse(
          () => this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors)
        );
        if (!result.node) {
          if (result.error) {
            this.setOptionalParametersError(refDestructuringErrors, result.error);
          }
          return expr;
        }
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      parseParenItem(node) {
        const startPos = this.start;
        const startLoc = this.startLoc;
        node = super.parseParenItem(node);
        if (this.eat(tt.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(tt.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.isAmbientContext && this.ts_isContextual(tokTypes2.declare)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        const isDeclare = this.eatContextual("declare");
        if (isDeclare && (this.ts_isContextual(tokTypes2.declare) || !this.shouldParseExportStatement())) {
          this.raise(this.start, TypeScriptError.ExpectedAmbientAfterExportDeclare);
        }
        const isIdentifier = tokenIsIdentifier(this.type);
        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || this.parseStatement(null);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement) {
        if (!isStatement && this.isContextual("implements")) {
          return;
        }
        super.parseClassId(node, isStatement);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.value === "!" && this.eat(tt.prefix)) {
            node.definite = true;
          } else if (this.eat(tt.question)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassField(field) {
        const isPrivate = field.key.type === "PrivateIdentifier";
        if (isPrivate) {
          if (field.abstract) {
            this.raise(field.start, TypeScriptError.PrivateElementHasAbstract);
          }
          if (field.accessibility) {
            this.raise(
              field.start,
              TypeScriptError.PrivateElementHasAccessibility({
                modifier: field.accessibility
              })
            );
          }
          this.parseClassPropertyAnnotation(field);
        } else {
          this.parseClassPropertyAnnotation(field);
          if (this.isAmbientContext && !(field.readonly && !field.typeAnnotation) && this.match(tt.eq)) {
            this.raise(this.start, TypeScriptError.DeclareClassFieldHasInitializer);
          }
          if (field.abstract && this.match(tt.eq)) {
            const { key } = field;
            this.raise(
              this.start,
              TypeScriptError.AbstractPropertyHasInitializer({
                propertyName: key.type === "Identifier" && !field.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              })
            );
          }
        }
        return super.parseClassField(field);
      }
      parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper) {
        const isConstructor = method.kind === "constructor";
        const isPrivate = method.key.type === "PrivateIdentifier";
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (isPrivate) {
          if (typeParameters) method.typeParameters = typeParameters;
          if (method.accessibility) {
            this.raise(
              method.start,
              TypeScriptError.PrivateMethodsHasAccessibility({
                modifier: method.accessibility
              })
            );
          }
        } else {
          if (typeParameters && isConstructor) {
            this.raise(typeParameters.start, TypeScriptError.ConstructorHasTypeParameters);
          }
        }
        const { declare = false, kind } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(method.start, TypeScriptError.DeclareAccessor({ kind }));
        }
        if (typeParameters) method.typeParameters = typeParameters;
        const key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
          if (isAsync) this.raise(key.start, "Constructor can't be an async method");
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        const value = method.value = this.parseMethod(
          isGenerator,
          isAsync,
          allowsDirectSuper,
          true,
          method
        );
        if (method.kind === "get" && value["params"].length !== 0)
          this.raiseRecoverable(value.start, "getter should have no params");
        if (method.kind === "set" && value["params"].length !== 1)
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        if (method.kind === "set" && value["params"][0].type === "RestElement")
          this.raiseRecoverable(value["params"][0].start, "Setter cannot use rest params");
        return this.finishNode(method, "MethodDefinition");
      }
      isClassMethod() {
        return this.match(tt.relational);
      }
      parseClassElement(constructorAllowsSuper) {
        if (this.eat(tt.semi)) return null;
        let node = this.startNode();
        let keyName = "";
        let isGenerator = false;
        let isAsync = false;
        let kind = "method";
        let isStatic = false;
        const modifiers = [
          "declare",
          "private",
          "public",
          "protected",
          "accessor",
          "override",
          "abstract",
          "readonly",
          "static"
        ];
        const modifierMap = this.tsParseModifiers({
          modified: node,
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
        isStatic = Boolean(modifierMap.static);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(node, modifiers)) {
              this.raise(this.start, TypeScriptError.StaticBlockCannotHaveModifier);
            }
            if (this.ecmaVersion >= 13) {
              super.parseClassStaticBlock(node);
              return node;
            }
          } else {
            const idx = this.tsTryParseIndexSignature(node);
            if (idx) {
              if (node.abstract) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasAbstract);
              }
              if (node.accessibility) {
                this.raise(
                  node.start,
                  TypeScriptError.IndexSignatureHasAccessibility({
                    modifier: node.accessibility
                  })
                );
              }
              if (node.declare) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasDeclare);
              }
              if (node.override) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasOverride);
              }
              return idx;
            }
            if (!this.inAbstractClass && node.abstract) {
              this.raise(node.start, TypeScriptError.NonAbstractClassHasAbstractMethod);
            }
            if (node.override) {
              if (!constructorAllowsSuper) {
                this.raise(node.start, TypeScriptError.OverrideNotInSubClass);
              }
            }
            node.static = isStatic;
            if (isStatic) {
              if (!(this.isClassElementNameStart() || this.type === tt.star)) {
                keyName = "static";
              }
            }
            if (!keyName && this.ecmaVersion >= 8 && this.eatContextual("async")) {
              if ((this.isClassElementNameStart() || this.type === tt.star) && !this.canInsertSemicolon()) {
                isAsync = true;
              } else {
                keyName = "async";
              }
            }
            if (!keyName && (this.ecmaVersion >= 9 || !isAsync) && this.eat(tt.star)) {
              isGenerator = true;
            }
            if (!keyName && !isAsync && !isGenerator) {
              const lastValue = this.value;
              if (this.eatContextual("get") || this.eatContextual("set")) {
                if (this.isClassElementNameStart()) {
                  kind = lastValue;
                } else {
                  keyName = lastValue;
                }
              }
            }
            if (keyName) {
              node.computed = false;
              node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
              node.key.name = keyName;
              this.finishNode(node.key, "Identifier");
            } else {
              this.parseClassElementName(node);
            }
            this.parsePostMemberNameModifiers(node);
            if (this.isClassMethod() || this.ecmaVersion < 13 || this.type === tt.parenL || kind !== "method" || isGenerator || isAsync) {
              const isConstructor = !node.static && checkKeyName(node, "constructor");
              const allowsDirectSuper = isConstructor && constructorAllowsSuper;
              if (isConstructor && kind !== "method")
                this.raise(node.key.start, "Constructor can't have get/set modifier");
              node.kind = isConstructor ? "constructor" : kind;
              this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
            } else {
              this.parseClassField(node);
            }
            return node;
          }
        };
        if (node.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
        return node;
      }
      isClassElementNameStart() {
        if (this.tsIsIdentifier()) {
          return true;
        }
        return super.isClassElementNameStart();
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.tsMatchLeftRelational() || this.match(tt.bitShift))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual("implements")) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseFunctionParams(node) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node);
      }
      // `let x: number;`
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.value === "!" && this.eat(tt.prefix)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      // parse the return type of an async arrow function - let foo = (async (): number => {});
      parseArrowExpression(node, params, isAsync, forInit) {
        if (this.match(tt.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | acornScope.SCOPE_ARROW);
        this.initFunction(node);
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.maybeInArrowParameters = true;
        node.params = this.toAssignableList(params, true);
        this.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      parseMaybeAssignOrigin(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) return this.parseYield(forInit);
          else this.exprAllowed = false;
        }
        let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        let startPos = this.start, startLoc = this.startLoc;
        if (this.type === tt.parenL || tokenIsIdentifier(this.type)) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        let left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
        if (this.type.isAssign) {
          let node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === tt.eq) left = this.toAssignable(left, true, refDestructuringErrors);
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start)
            refDestructuringErrors.shorthandAssign = -1;
          if (!this.maybeInArrowParameters) {
            if (this.type === tt.eq) this.checkLValPattern(left);
            else this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
        return left;
      }
      parseMaybeAssign(forInit, refExpressionErrors, afterLeftParse) {
        let state;
        let typeCast;
        if (!this.tsMatchLeftRelational()) {
          return this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
        }
        if (!state || this.compareLookaheadState(state, this.getCurLookaheadState())) {
          state = this.cloneCurLookaheadState();
        }
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || expr.extra?.parenthesized) {
            abort();
          }
          if (typeParameters?.params.length !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        {
          assert(true);
          typeCast = this.tryParse(
            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),
            state
          );
          if (!typeCast.error) return typeCast.node;
        }
        if (arrow.node) {
          this.setLookaheadState(arrow.failState);
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (typeCast?.node) {
          this.setLookaheadState(typeCast.failState);
          return typeCast.node;
        }
        if (arrow.thrown) throw arrow.error;
        if (typeCast?.thrown) throw typeCast.error;
        throw arrow.error || typeCast?.error;
      }
      parseAssignableListItem(allowModifiers) {
        const decorators = [];
        while (this.match(tokTypes2.at)) {
          decorators.push(this.parseDecorator());
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        let accessibility;
        let readonly = false;
        let override = false;
        if (allowModifiers !== void 0) {
          const modified = {};
          this.tsParseModifiers({
            modified,
            allowedModifiers: ["public", "private", "protected", "override", "readonly"]
          });
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;
          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(startLoc.column, TypeScriptError.UnexpectedParameterModifier);
          }
        }
        const left = this.parseMaybeDefault(startPos, startLoc);
        this.parseBindingListItem(left);
        const elt = this.parseMaybeDefault(left["start"], left["loc"], left);
        if (decorators.length) {
          elt.decorators = decorators;
        }
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startPos, startLoc);
          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp.start, TypeScriptError.UnsupportedParameterPropertyKind);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        return elt;
      }
      // AssignmentPattern
      checkLValInnerPattern(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        switch (expr.type) {
          case "TSParameterProperty":
            this.checkLValInnerPattern(expr.parameter, bindingType, checkClashes);
            break;
          default: {
            super.checkLValInnerPattern(expr, bindingType, checkClashes);
            break;
          }
        }
      }
      // Allow type annotations inside of a parameter list.
      parseBindingListItem(param) {
        if (this.eat(tt.question)) {
          if (param.type !== "Identifier" && !this.isAmbientContext && !this.inType) {
            this.raise(param.start, TypeScriptError.PatternIsOptional);
          }
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "Property":
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every(
              (element) => element === null || this.isAssignable(element)
            );
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toAssignable(node, isBinding = false, refDestructuringErrors = new DestructuringErrors()) {
        switch (node.type) {
          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(
              node,
              isBinding,
              refDestructuringErrors
            );
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isBinding) ; else {
              this.raise(node.start, TypeScriptError.UnexpectedTypeCastInParameter);
            }
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          case "MemberExpression":
            break;
          case "AssignmentExpression":
            if (!isBinding && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
            return super.toAssignable(node, isBinding, refDestructuringErrors);
          case "TSTypeCastExpression": {
            return this.typeCastToParameter(node);
          }
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
        return node;
      }
      toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
      }
      parseBindingAtom() {
        switch (this.type) {
          case tt._this:
            return this.parseIdent(
              /* liberal */
              true
            );
          default:
            return super.parseBindingAtom();
        }
      }
      shouldParseArrow(exprList) {
        let shouldParseArrowRes;
        if (this.match(tt.colon)) {
          shouldParseArrowRes = exprList.every((expr) => this.isAssignable(expr, true));
        } else {
          shouldParseArrowRes = !this.canInsertSemicolon();
        }
        if (shouldParseArrowRes) {
          if (this.match(tt.colon)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
              if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
              return returnType;
            });
            if (result.aborted) {
              this.shouldParseArrowReturnType = void 0;
              return false;
            }
            if (!result.thrown) {
              if (result.error) this.setLookaheadState(result.failState);
              this.shouldParseArrowReturnType = result.node;
            }
          }
          if (!this.match(tt.arrow)) {
            this.shouldParseArrowReturnType = void 0;
            return false;
          }
          return true;
        }
        this.shouldParseArrowReturnType = void 0;
        return shouldParseArrowRes;
      }
      parseParenArrowList(startPos, startLoc, exprList, forInit) {
        const node = this.startNodeAt(startPos, startLoc);
        node.returnType = this.shouldParseArrowReturnType;
        this.shouldParseArrowReturnType = void 0;
        return this.parseArrowExpression(node, exprList, false, forInit);
      }
      parseParenAndDistinguishExpression(canBeArrow, forInit) {
        let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.ecmaVersion >= 8;
        if (this.ecmaVersion >= 6) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          this.next();
          let innerStartPos = this.start, innerStartLoc = this.startLoc;
          let exprList = [], first = true, lastIsComma = false;
          let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== tt.parenR) {
            first ? first = false : this.expect(tt.comma);
            if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === tt.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === tt.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(
                this.parseMaybeAssign(forInit, refDestructuringErrors, this.parseParenItem)
              );
            }
          }
          let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(tt.parenR);
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
          if (spreadStart) this.unexpected(spreadStart);
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          let par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      }
      parseTaggedTemplateExpression(base, startPos, startLoc, optionalChainMember) {
        const node = this.startNodeAt(startPos, startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate({ isTagged: true });
        if (optionalChainMember) {
          this.raise(
            startPos,
            "Tagged Template Literals are not allowed in optionalChain."
          );
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      shouldParseAsyncArrow() {
        if (this.match(tt.colon)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
            if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
            return returnType;
          });
          if (result.aborted) {
            this.shouldParseAsyncArrowReturnType = void 0;
            return false;
          }
          if (!result.thrown) {
            if (result.error) this.setLookaheadState(result.failState);
            this.shouldParseAsyncArrowReturnType = result.node;
            return !this.canInsertSemicolon() && this.eat(tt.arrow);
          }
        } else {
          return !this.canInsertSemicolon() && this.eat(tt.arrow);
        }
      }
      parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit) {
        const arrN = this.startNodeAt(startPos, startLoc);
        arrN.returnType = this.shouldParseAsyncArrowReturnType;
        this.shouldParseAsyncArrowReturnType = void 0;
        return this.parseArrowExpression(arrN, exprList, true, forInit);
      }
      parseExprList(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        let elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(tt.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) break;
          } else first = false;
          let elt;
          if (allowEmpty && this.type === tt.comma) elt = null;
          else if (this.type === tt.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (this.maybeInArrowParameters && this.match(tt.colon)) {
              elt.typeAnnotation = this.tsParseTypeAnnotation();
            }
            if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0)
              refDestructuringErrors.trailingComma = this.start;
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem);
          }
          elts.push(elt);
        }
        return elts;
      }
      parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        let _optionalChained = optionalChained;
        if (!this.hasPrecedingLineBreak() && // NODE: replace bang
        this.value === "!" && this.match(tt.prefix)) {
          this.exprAllowed = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          base = this.finishNode(nonNullExpression, "TSNonNullExpression");
          return base;
        }
        let isOptionalCall = false;
        if (this.match(tt.questionDot) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            return base;
          }
          base.optional = true;
          _optionalChained = isOptionalCall = true;
          this.next();
        }
        if (this.tsMatchLeftRelational() || this.match(tt.bitShift)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(
                startPos,
                startLoc,
                forInit
              );
              if (asyncArrowFn) {
                base = asyncArrowFn;
                return base;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return base;
            if (isOptionalCall && !this.match(tt.parenL)) {
              missingParenErrorLoc = this.curPosition();
              return base;
            }
            if (tokenIsTemplate(this.type) || this.type === tt.backQuote) {
              const result2 = this.parseTaggedTemplateExpression(
                base,
                startPos,
                startLoc,
                _optionalChained
              );
              result2.typeArguments = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(tt.parenL)) {
              let refDestructuringErrors = new DestructuringErrors();
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              node2.arguments = this.parseExprList(
                tt.parenR,
                this.ecmaVersion >= 8,
                false,
                refDestructuringErrors
              );
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeArguments = typeArguments;
              if (_optionalChained) {
                node2.optional = isOptionalCall;
              }
              this.checkExpressionErrors(refDestructuringErrors, true);
              base = this.finishNode(node2, "CallExpression");
              return base;
            }
            const tokenType = this.type;
            if (
              // a<b>>c is not (a<b>)>c, but a<(b>>c)
              this.tsMatchRightRelational() || // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)
              tokenType === tt.bitShift || // a<b>c is (a<b)>c
              tokenType !== tt.parenL && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()
            ) {
              return;
            }
            const node = this.startNodeAt(startPos, startLoc);
            node.expression = base;
            node.typeArguments = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(tt.dot) || this.match(tt.questionDot) && this.lookaheadCharCode() !== 40)) {
              this.raise(
                this.start,
                TypeScriptError.InvalidPropertyAccessAfterInstantiationExpression
              );
            }
            base = result;
            return base;
          }
        }
        let optionalSupported = this.ecmaVersion >= 11;
        let optional = optionalSupported && this.eat(tt.questionDot);
        if (noCalls && optional)
          this.raise(
            this.lastTokStart,
            "Optional chaining cannot appear in the callee of new expressions"
          );
        let computed = this.eat(tt.bracketL);
        if (computed || optional && this.type !== tt.parenL && this.type !== tt.backQuote || this.eat(tt.dot)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(tt.bracketR);
          } else if (this.type === tt.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(tt.parenL)) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          let exprList = this.parseExprList(
            tt.parenR,
            this.ecmaVersion >= 8,
            false,
            refDestructuringErrors
          );
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0)
              this.raise(
                this.awaitIdentPos,
                "Cannot use 'await' as identifier inside an async function"
              );
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            base = this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            let node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = exprList;
            if (optionalSupported) {
              node.optional = optional;
            }
            base = this.finishNode(node, "CallExpression");
          }
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
        } else if (this.type === tt.backQuote) {
          if (optional || _optionalChained) {
            this.raise(
              this.start,
              "Optional chaining cannot appear in the tag of tagged template expressions"
            );
          }
          let node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node, "TaggedTemplateExpression");
        }
        return base;
      }
      parseGetterSetter(prop) {
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        let paramCount = prop.kind === "get" ? 0 : 1;
        const firstParam = prop.value.params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        paramCount = hasContextParam ? paramCount + 1 : paramCount;
        if (prop.value.params.length !== paramCount) {
          let start = prop.value.start;
          if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
          else this.raiseRecoverable(start, "setter should have exactly one param");
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
        }
      }
      parseProperty(isPattern, refDestructuringErrors) {
        if (!isPattern) {
          let decorators = [];
          if (this.match(tokTypes2.at)) {
            while (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
            }
          }
          const property = super.parseProperty(isPattern, refDestructuringErrors);
          if (property.type === "SpreadElement") {
            if (decorators.length)
              this.raise(property.start, DecoratorsError.SpreadElementDecorator);
          }
          if (decorators.length) {
            property.decorators = decorators;
            decorators = [];
          }
          return property;
        }
        return super.parseProperty(isPattern, refDestructuringErrors);
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        let simple = param.type === "Identifier";
        this.enterScope(simple ? acornScope.SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(
          param,
          simple ? acornScope.BIND_SIMPLE_CATCH : acornScope.BIND_LEXICAL
        );
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        this.expect(tt.parenR);
        return param;
      }
      parseClass(node, isStatement) {
        const oldInAbstractClass = this.inAbstractClass;
        this.inAbstractClass = !!node.abstract;
        try {
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.strict;
          this.strict = true;
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          const privateNameMap = this.enterClassBody();
          const classBody = this.startNode();
          let hadConstructor = false;
          classBody.body = [];
          let decorators = [];
          this.expect(tt.braceL);
          while (this.type !== tt.braceR) {
            if (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const element = this.parseClassElement(node.superClass !== null);
            if (decorators.length) {
              element.decorators = decorators;
              this.resetStartLocationFromNode(element, decorators[0]);
              decorators = [];
            }
            if (element) {
              classBody.body.push(element);
              if (element.type === "MethodDefinition" && element.kind === "constructor" && element.value.type === "FunctionExpression") {
                if (hadConstructor) {
                  this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
                }
                hadConstructor = true;
                if (element.decorators && element.decorators.length > 0) {
                  this.raise(element.start, DecoratorsError.DecoratorConstructor);
                }
              } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
                this.raiseRecoverable(
                  element.key.start,
                  `Identifier '#${element.key.name}' has already been declared`
                );
              }
            }
          }
          this.strict = oldStrict;
          this.next();
          if (decorators.length) {
            this.raise(this.start, DecoratorsError.TrailingDecorator);
          }
          node.body = this.finishNode(classBody, "ClassBody");
          this.exitClassBody();
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        } finally {
          this.inAbstractClass = oldInAbstractClass;
        }
      }
      parseClassFunctionParams() {
        const typeParameters = this.tsTryParseTypeParameters();
        let params = this.parseBindingList(tt.parenR, false, this.ecmaVersion >= 8, true);
        if (typeParameters) params.typeParameters = typeParameters;
        return params;
      }
      parseMethod(isGenerator, isAsync, allowDirectSuper, inClassScope, method) {
        let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.ecmaVersion >= 6) node.generator = isGenerator;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(
          functionFlags(isAsync, node.generator) | acornScope.SCOPE_SUPER | (allowDirectSuper ? acornScope.SCOPE_DIRECT_SUPER : 0)
        );
        this.expect(tt.parenL);
        node.params = this.parseClassFunctionParams();
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false, {
          isClassMethod: inClassScope
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (method && method.abstract) {
          const hasBody = !!node.body;
          if (hasBody) {
            const { key } = method;
            this.raise(
              method.start,
              TypeScriptError.AbstractMethodHasImplementation({
                methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              })
            );
          }
        }
        return this.finishNode(node, "FunctionExpression");
      }
      static parse(input, options2) {
        if (options2.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options2.locations = true;
        }
        const parser = new this(options2, input);
        if (dts) {
          parser.isAmbientContext = true;
        }
        return parser.parse();
      }
      static parseExpressionAt(input, pos, options2) {
        if (options2.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options2.locations = true;
        }
        const parser = new this(options2, input, pos);
        if (dts) {
          parser.isAmbientContext = true;
        }
        parser.nextToken();
        return parser.parseExpression();
      }
      parseImportSpecifier() {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        if (isMaybeTypeOnly) {
          let node = this.startNode();
          node.imported = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            true,
            this.importOrExportOuterKind === "type"
          );
          return this.finishNode(node, "ImportSpecifier");
        } else {
          const node = super.parseImportSpecifier();
          node.importKind = "value";
          return node;
        }
      }
      parseExportSpecifier(exports$1) {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        const isString = this.match(tt.string);
        if (!isString && isMaybeTypeOnly) {
          let node = this.startNode();
          node.local = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            false,
            this.importOrExportOuterKind === "type"
          );
          this.finishNode(node, "ExportSpecifier");
          this.checkExport(exports$1, node.exported, node.exported.start);
          return node;
        } else {
          const node = super.parseExportSpecifier(exports$1);
          node.exportKind = "value";
          return node;
        }
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.start;
        if (this.isContextual("as")) {
          const firstAs = this.parseIdent();
          if (this.isContextual("as")) {
            const secondAs = this.parseIdent();
            if (tokenIsKeywordOrIdentifier(this.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = super.parseIdent(true);
            if (!this.isContextual("as")) {
              this.checkUnreserved(leftOfAs);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(
            loc,
            isImport ? TypeScriptError.TypeModifierIsUsedInTypeImports : TypeScriptError.TypeModifierIsUsedInTypeExports
          );
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual("as")) {
          node[rightOfAsKey] = isImport ? this.parseIdent() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = this.copyNode(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkLValSimple(node[rightOfAsKey], acornScope.BIND_LEXICAL);
        }
      }
      raiseCommonCheck(pos, message, recoverable) {
        switch (message) {
          case "Comma is not permitted after the rest element": {
            if (this.isAmbientContext && this.match(tt.comma) && this.lookaheadCharCode() === 41) {
              this.next();
              return;
            } else {
              return super.raise(pos, message);
            }
          }
        }
        return recoverable ? super.raiseRecoverable(pos, message) : super.raise(pos, message);
      }
      raiseRecoverable(pos, message) {
        return this.raiseCommonCheck(pos, message, true);
      }
      raise(pos, message) {
        return this.raiseCommonCheck(pos, message, true);
      }
      updateContext(prevType) {
        const { type } = this;
        if (type == tt.braceL) {
          var curContext = this.curContext();
          if (curContext == tsTokContexts.tc_oTag) this.context.push(tokContexts.b_expr);
          else if (curContext == tsTokContexts.tc_expr) this.context.push(tokContexts.b_tmpl);
          else super.updateContext(prevType);
          this.exprAllowed = true;
        } else if (type === tt.slash && prevType === tokTypes2.jsxTagStart) {
          this.context.length -= 2;
          this.context.push(tsTokContexts.tc_cTag);
          this.exprAllowed = false;
        } else {
          return super.updateContext(prevType);
        }
      }
      // Parses JSX opening tag starting after '<'.
      jsx_parseOpeningElementAt(startPos, startLoc) {
        let node = this.startNodeAt(startPos, startLoc);
        let nodeName = this.jsx_parseElementName();
        if (nodeName) node.name = nodeName;
        if (this.match(tt.relational) || this.match(tt.bitShift)) {
          const typeArguments = this.tsTryParseAndCatch(
            () => this.tsParseTypeArgumentsInExpression()
          );
          if (typeArguments) node.typeArguments = typeArguments;
        }
        node.attributes = [];
        while (this.type !== tt.slash && this.type !== tokTypes2.jsxTagEnd)
          node.attributes.push(this.jsx_parseAttribute());
        node.selfClosing = this.eat(tt.slash);
        this.expect(tokTypes2.jsxTagEnd);
        return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      enterScope(flags) {
        if (flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.push([]);
        }
        super.enterScope(flags);
        const scope = super.currentScope();
        scope.types = [];
        scope.enums = [];
        scope.constEnums = [];
        scope.classes = [];
        scope.exportOnlyBindings = [];
      }
      exitScope() {
        const scope = super.currentScope();
        if (scope.flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.pop();
        }
        super.exitScope();
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].indexOf(name) > -1) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].indexOf(name) > -1) return true;
          }
        }
        return false;
      }
      maybeExportDefined(scope, name) {
        if (this.inModule && scope.flags & acornScope.SCOPE_TOP) {
          this.undefinedExports.delete(name);
        }
      }
      declareName(name, bindingType, pos) {
        if (bindingType & acornScope.BIND_FLAGS_TS_IMPORT) {
          if (this.hasImport(name, true)) {
            this.raise(pos, `Identifier '${name}' has already been declared.`);
          }
          this.importsStack[this.importsStack.length - 1].push(name);
          return;
        }
        const scope = this.currentScope();
        if (bindingType & acornScope.BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name);
          scope.exportOnlyBindings.push(name);
          return;
        }
        if (bindingType === acornScope.BIND_TS_TYPE || bindingType === acornScope.BIND_TS_INTERFACE) {
          if (bindingType === acornScope.BIND_TS_TYPE && scope.types.includes(name)) {
            this.raise(pos, `type '${name}' has already been declared.`);
          }
          scope.types.push(name);
        } else {
          super.declareName(name, bindingType, pos);
        }
        if (bindingType & acornScope.BIND_FLAGS_TS_ENUM) scope.enums.push(name);
        if (bindingType & acornScope.BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
        if (bindingType & acornScope.BIND_FLAGS_CLASS) scope.classes.push(name);
      }
      checkLocalExport(id) {
        const { name } = id;
        if (this.hasImport(name)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          if (scope.types.indexOf(name) > -1 || scope.exportOnlyBindings.indexOf(name) > -1) return;
        }
        super.checkLocalExport(id);
      }
    }
    return TypeScriptParser;
  };
}

/** @import { Comment, Program } from 'estree' */
/** @import { AST } from '#compiler' */

const ParserWithTS = Parser$1.extend(tsPlugin());

/**
 * @typedef {Comment & {
 *   start: number;
 *   end: number;
 * }} CommentWithLocation
 */

/**
 * @param {string} source
 * @param {AST.JSComment[]} comments
 * @param {boolean} typescript
 * @param {boolean} [is_script]
 */
function parse$4(source, comments, typescript, is_script) {
	const parser = typescript ? ParserWithTS : Parser$1;

	const { onComment, add_comments } = get_comment_handlers(
		source,
		/** @type {CommentWithLocation[]} */ (comments)
	);

	// @ts-ignore
	const parse_statement = parser.prototype.parseStatement;

	// If we're dealing with a <script> then it might contain an export
	// for something that doesn't exist directly inside but is inside the
	// component instead, so we need to ensure that Acorn doesn't throw
	// an error in these cases
	if (is_script) {
		// @ts-ignore
		parser.prototype.parseStatement = function (...args) {
			const v = parse_statement.call(this, ...args);
			// @ts-ignore
			this.undefinedExports = {};
			return v;
		};
	}

	let ast;

	try {
		ast = parser.parse(source, {
			onComment,
			sourceType: 'module',
			ecmaVersion: 16,
			locations: true
		});
	} finally {
		if (is_script) {
			// @ts-ignore
			parser.prototype.parseStatement = parse_statement;
		}
	}

	add_comments(ast);

	return /** @type {Program} */ (ast);
}

/**
 * @param {string} source
 * @param {Comment[]} comments
 * @param {boolean} typescript
 * @param {number} index
 * @returns {acorn.Expression & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }}
 */
function parse_expression_at(source, comments, typescript, index) {
	const parser = typescript ? ParserWithTS : Parser$1;

	const { onComment, add_comments } = get_comment_handlers(
		source,
		/** @type {CommentWithLocation[]} */ (comments),
		index
	);

	const ast = parser.parseExpressionAt(source, index, {
		onComment,
		sourceType: 'module',
		ecmaVersion: 16,
		locations: true
	});

	add_comments(ast);

	return ast;
}

/**
 * Acorn doesn't add comments to the AST by itself. This factory returns the capabilities
 * to add them after the fact. They are needed in order to support `svelte-ignore` comments
 * in JS code and so that `prettier-plugin-svelte` doesn't remove all comments when formatting.
 * @param {string} source
 * @param {CommentWithLocation[]} comments
 * @param {number} index
 */
function get_comment_handlers(source, comments, index = 0) {
	return {
		/**
		 * @param {boolean} block
		 * @param {string} value
		 * @param {number} start
		 * @param {number} end
		 * @param {import('acorn').Position} [start_loc]
		 * @param {import('acorn').Position} [end_loc]
		 */
		onComment: (block, value, start, end, start_loc, end_loc) => {
			if (block && /\n/.test(value)) {
				let a = start;
				while (a > 0 && source[a - 1] !== '\n') a -= 1;

				let b = a;
				while (/[ \t]/.test(source[b])) b += 1;

				const indentation = source.slice(a, b);
				value = value.replace(new RegExp(`^${indentation}`, 'gm'), '');
			}

			comments.push({
				type: block ? 'Block' : 'Line',
				value,
				start,
				end,
				loc: {
					start: /** @type {import('acorn').Position} */ (start_loc),
					end: /** @type {import('acorn').Position} */ (end_loc)
				}
			});
		},

		/** @param {acorn.Node & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} ast */
		add_comments(ast) {
			if (comments.length === 0) return;

			comments = comments
				.filter((comment) => comment.start >= index)
				.map(({ type, value, start, end }) => ({ type, value, start, end }));

			walk$1(ast, null, {
				_(node, { next, path }) {
					let comment;

					while (comments[0] && comments[0].start < node.start) {
						comment = /** @type {CommentWithLocation} */ (comments.shift());
						(node.leadingComments ||= []).push(comment);
					}

					next();

					if (comments[0]) {
						const parent = /** @type {any} */ (path.at(-1));

						if (parent === undefined || node.end !== parent.end) {
							const slice = source.slice(node.end, comments[0].start);
							const is_last_in_body =
								((parent?.type === 'BlockStatement' || parent?.type === 'Program') &&
									parent.body.indexOf(node) === parent.body.length - 1) ||
								(parent?.type === 'ArrayExpression' &&
									parent.elements.indexOf(node) === parent.elements.length - 1) ||
								(parent?.type === 'ObjectExpression' &&
									parent.properties.indexOf(node) === parent.properties.length - 1);

							if (is_last_in_body) {
								// Special case: There can be multiple trailing comments after the last node in a block,
								// and they can be separated by newlines
								node.end;

								while (comments.length) {
									const comment = comments[0];
									if (parent && comment.start >= parent.end) break;

									(node.trailingComments ||= []).push(comment);
									comments.shift();
									comment.end;
								}
							} else if (node.end <= comments[0].start && /^[,) \t]*$/.test(slice)) {
								node.trailingComments = [/** @type {CommentWithLocation} */ (comments.shift())];
							}
						}
					}
				}
			});

			// Special case: Trailing comments after the root node (which can only happen for expression tags or for Program nodes).
			// Adding them ensures that we can later detect the end of the expression tag correctly.
			if (comments.length > 0 && (comments[0].start >= ast.end || ast.type === 'Program')) {
				(ast.trailingComments ||= []).push(...comments.splice(0));
			}
		}
	};
}

/* This file is generated by scripts/process-messages/index.js. Do not edit! */


/** @typedef {{ start?: number, end?: number }} NodeLike */
class InternalCompileError extends Error {
	message = ''; // ensure this property is enumerable
	#diagnostic;

	/**
	 * @param {string} code
	 * @param {string} message
	 * @param {[number, number] | undefined} position
	 */
	constructor(code, message, position) {
		super(message);
		this.stack = ''; // avoid unnecessary noise; don't set it as a class property or it becomes enumerable

		// We want to extend from Error so that various bundler plugins properly handle it.
		// But we also want to share the same object shape with that of warnings, therefore
		// we create an instance of the shared class an copy over its properties.
		this.#diagnostic = new CompileDiagnostic(code, message, position);

		Object.assign(this, this.#diagnostic);
		this.name = 'CompileError';
	}

	toString() {
		return this.#diagnostic.toString();
	}

	toJSON() {
		return this.#diagnostic.toJSON();
	}
}

/**
 * @param {null | number | NodeLike} node
 * @param {string} code
 * @param {string} message
 * @returns {never}
 */
function e(node, code, message) {
	const start = typeof node === 'number' ? node : node?.start;
	const end = typeof node === 'number' ? node : node?.end;

	throw new InternalCompileError(code, message, start !== undefined ? [start, end ?? start] : undefined);
}

/**
 * Invalid compiler option: %details%
 * @param {null | number | NodeLike} node
 * @param {string} details
 * @returns {never}
 */
function options_invalid_value(node, details) {
	e(node, 'options_invalid_value', `Invalid compiler option: ${details}\nhttps://svelte.dev/e/options_invalid_value`);
}

/**
 * Invalid compiler option: %details%
 * @param {null | number | NodeLike} node
 * @param {string} details
 * @returns {never}
 */
function options_removed(node, details) {
	e(node, 'options_removed', `Invalid compiler option: ${details}\nhttps://svelte.dev/e/options_removed`);
}

/**
 * Unrecognised compiler option %keypath%
 * @param {null | number | NodeLike} node
 * @param {string} keypath
 * @returns {never}
 */
function options_unrecognised(node, keypath) {
	e(node, 'options_unrecognised', `Unrecognised compiler option ${keypath}\nhttps://svelte.dev/e/options_unrecognised`);
}

/**
 * `$bindable()` can only be used inside a `$props()` declaration
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function bindable_invalid_location(node) {
	e(node, 'bindable_invalid_location', `\`$bindable()\` can only be used inside a \`$props()\` declaration\nhttps://svelte.dev/e/bindable_invalid_location`);
}

/**
 * Cannot assign to %thing%
 * @param {null | number | NodeLike} node
 * @param {string} thing
 * @returns {never}
 */
function constant_assignment(node, thing) {
	e(node, 'constant_assignment', `Cannot assign to ${thing}\nhttps://svelte.dev/e/constant_assignment`);
}

/**
 * Cannot bind to %thing%
 * @param {null | number | NodeLike} node
 * @param {string} thing
 * @returns {never}
 */
function constant_binding(node, thing) {
	e(node, 'constant_binding', `Cannot bind to ${thing}\nhttps://svelte.dev/e/constant_binding`);
}

/**
 * `%name%` has already been declared
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function declaration_duplicate(node, name) {
	e(node, 'declaration_duplicate', `\`${name}\` has already been declared\nhttps://svelte.dev/e/declaration_duplicate`);
}

/**
 * Cannot declare a variable with the same name as an import inside `<script module>`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function declaration_duplicate_module_import(node) {
	e(node, 'declaration_duplicate_module_import', `Cannot declare a variable with the same name as an import inside \`<script module>\`\nhttps://svelte.dev/e/declaration_duplicate_module_import`);
}

/**
 * Cannot export derived state from a module. To expose the current derived value, export a function returning its value
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function derived_invalid_export(node) {
	e(node, 'derived_invalid_export', `Cannot export derived state from a module. To expose the current derived value, export a function returning its value\nhttps://svelte.dev/e/derived_invalid_export`);
}

/**
 * The $ name is reserved, and cannot be used for variables and imports
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function dollar_binding_invalid(node) {
	e(node, 'dollar_binding_invalid', `The $ name is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_binding_invalid`);
}

/**
 * The $ prefix is reserved, and cannot be used for variables and imports
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function dollar_prefix_invalid(node) {
	e(node, 'dollar_prefix_invalid', `The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid`);
}

/**
 * `%name%` has already been declared
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function duplicate_class_field(node, name) {
	e(node, 'duplicate_class_field', `\`${name}\` has already been declared\nhttps://svelte.dev/e/duplicate_class_field`);
}

/**
 * Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. `array[i] = value` instead of `entry = value`, or `bind:value={array[i]}` instead of `bind:value={entry}`)
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function each_item_invalid_assignment(node) {
	e(node, 'each_item_invalid_assignment', `Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. \`array[i] = value\` instead of \`entry = value\`, or \`bind:value={array[i]}\` instead of \`bind:value={entry}\`)\nhttps://svelte.dev/e/each_item_invalid_assignment`);
}

/**
 * `$effect()` can only be used as an expression statement
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function effect_invalid_placement(node) {
	e(node, 'effect_invalid_placement', `\`$effect()\` can only be used as an expression statement\nhttps://svelte.dev/e/effect_invalid_placement`);
}

/**
 * Cannot use `await` in deriveds and template expressions, or at the top level of a component, unless the `experimental.async` compiler option is `true`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function experimental_async(node) {
	e(node, 'experimental_async', `Cannot use \`await\` in deriveds and template expressions, or at the top level of a component, unless the \`experimental.async\` compiler option is \`true\`\nhttps://svelte.dev/e/experimental_async`);
}

/**
 * `%name%` is not defined
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function export_undefined(node, name) {
	e(node, 'export_undefined', `\`${name}\` is not defined\nhttps://svelte.dev/e/export_undefined`);
}

/**
 * `%name%` is an illegal variable name. To reference a global variable called `%name%`, use `globalThis.%name%`
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function global_reference_invalid(node, name) {
	e(node, 'global_reference_invalid', `\`${name}\` is an illegal variable name. To reference a global variable called \`${name}\`, use \`globalThis.${name}\`\nhttps://svelte.dev/e/global_reference_invalid`);
}

/**
 * `$host()` can only be used inside custom element component instances
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function host_invalid_placement(node) {
	e(node, 'host_invalid_placement', `\`$host()\` can only be used inside custom element component instances\nhttps://svelte.dev/e/host_invalid_placement`);
}

/**
 * Imports of `svelte/internal/*` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from `svelte/internal/*` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function import_svelte_internal_forbidden(node) {
	e(node, 'import_svelte_internal_forbidden', `Imports of \`svelte/internal/*\` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from \`svelte/internal/*\` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case\nhttps://svelte.dev/e/import_svelte_internal_forbidden`);
}

/**
 * `$inspect.trace(...)` cannot be used inside a generator function
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function inspect_trace_generator(node) {
	e(node, 'inspect_trace_generator', `\`$inspect.trace(...)\` cannot be used inside a generator function\nhttps://svelte.dev/e/inspect_trace_generator`);
}

/**
 * `$inspect.trace(...)` must be the first statement of a function body
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function inspect_trace_invalid_placement(node) {
	e(node, 'inspect_trace_invalid_placement', `\`$inspect.trace(...)\` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement`);
}

/**
 * The arguments keyword cannot be used within the template or at the top level of a component
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function invalid_arguments_usage(node) {
	e(node, 'invalid_arguments_usage', `The arguments keyword cannot be used within the template or at the top level of a component\nhttps://svelte.dev/e/invalid_arguments_usage`);
}

/**
 * Cannot use `await` in deriveds and template expressions, or at the top level of a component, unless in runes mode
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function legacy_await_invalid(node) {
	e(node, 'legacy_await_invalid', `Cannot use \`await\` in deriveds and template expressions, or at the top level of a component, unless in runes mode\nhttps://svelte.dev/e/legacy_await_invalid`);
}

/**
 * Cannot use `export let` in runes mode — use `$props()` instead
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function legacy_export_invalid(node) {
	e(node, 'legacy_export_invalid', `Cannot use \`export let\` in runes mode — use \`$props()\` instead\nhttps://svelte.dev/e/legacy_export_invalid`);
}

/**
 * Cannot use `$$props` in runes mode
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function legacy_props_invalid(node) {
	e(node, 'legacy_props_invalid', `Cannot use \`$$props\` in runes mode\nhttps://svelte.dev/e/legacy_props_invalid`);
}

/**
 * `$:` is not allowed in runes mode, use `$derived` or `$effect` instead
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function legacy_reactive_statement_invalid(node) {
	e(node, 'legacy_reactive_statement_invalid', `\`$:\` is not allowed in runes mode, use \`$derived\` or \`$effect\` instead\nhttps://svelte.dev/e/legacy_reactive_statement_invalid`);
}

/**
 * Cannot use `$$restProps` in runes mode
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function legacy_rest_props_invalid(node) {
	e(node, 'legacy_rest_props_invalid', `Cannot use \`$$restProps\` in runes mode\nhttps://svelte.dev/e/legacy_rest_props_invalid`);
}

/**
 * A component cannot have a default export
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function module_illegal_default_export(node) {
	e(node, 'module_illegal_default_export', `A component cannot have a default export\nhttps://svelte.dev/e/module_illegal_default_export`);
}

/**
 * Cannot use `%rune%()` more than once
 * @param {null | number | NodeLike} node
 * @param {string} rune
 * @returns {never}
 */
function props_duplicate(node, rune) {
	e(node, 'props_duplicate', `Cannot use \`${rune}()\` more than once\nhttps://svelte.dev/e/props_duplicate`);
}

/**
 * `$props.id()` can only be used at the top level of components as a variable declaration initializer
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function props_id_invalid_placement(node) {
	e(node, 'props_id_invalid_placement', `\`$props.id()\` can only be used at the top level of components as a variable declaration initializer\nhttps://svelte.dev/e/props_id_invalid_placement`);
}

/**
 * Declaring or accessing a prop starting with `$$` is illegal (they are reserved for Svelte internals)
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function props_illegal_name(node) {
	e(node, 'props_illegal_name', `Declaring or accessing a prop starting with \`$$\` is illegal (they are reserved for Svelte internals)\nhttps://svelte.dev/e/props_illegal_name`);
}

/**
 * `$props()` can only be used with an object destructuring pattern
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function props_invalid_identifier(node) {
	e(node, 'props_invalid_identifier', `\`$props()\` can only be used with an object destructuring pattern\nhttps://svelte.dev/e/props_invalid_identifier`);
}

/**
 * `$props()` assignment must not contain nested properties or computed keys
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function props_invalid_pattern(node) {
	e(node, 'props_invalid_pattern', `\`$props()\` assignment must not contain nested properties or computed keys\nhttps://svelte.dev/e/props_invalid_pattern`);
}

/**
 * `$props()` can only be used at the top level of components as a variable declaration initializer
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function props_invalid_placement(node) {
	e(node, 'props_invalid_placement', `\`$props()\` can only be used at the top level of components as a variable declaration initializer\nhttps://svelte.dev/e/props_invalid_placement`);
}

/**
 * Cyclical dependency detected: %cycle%
 * @param {null | number | NodeLike} node
 * @param {string} cycle
 * @returns {never}
 */
function reactive_declaration_cycle(node, cycle) {
	e(node, 'reactive_declaration_cycle', `Cyclical dependency detected: ${cycle}\nhttps://svelte.dev/e/reactive_declaration_cycle`);
}

/**
 * `%rune%` cannot be called with arguments
 * @param {null | number | NodeLike} node
 * @param {string} rune
 * @returns {never}
 */
function rune_invalid_arguments(node, rune) {
	e(node, 'rune_invalid_arguments', `\`${rune}\` cannot be called with arguments\nhttps://svelte.dev/e/rune_invalid_arguments`);
}

/**
 * `%rune%` must be called with %args%
 * @param {null | number | NodeLike} node
 * @param {string} rune
 * @param {string} args
 * @returns {never}
 */
function rune_invalid_arguments_length(node, rune, args) {
	e(node, 'rune_invalid_arguments_length', `\`${rune}\` must be called with ${args}\nhttps://svelte.dev/e/rune_invalid_arguments_length`);
}

/**
 * Cannot access a computed property of a rune
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function rune_invalid_computed_property(node) {
	e(node, 'rune_invalid_computed_property', `Cannot access a computed property of a rune\nhttps://svelte.dev/e/rune_invalid_computed_property`);
}

/**
 * `%name%` is not a valid rune
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function rune_invalid_name(node, name) {
	e(node, 'rune_invalid_name', `\`${name}\` is not a valid rune\nhttps://svelte.dev/e/rune_invalid_name`);
}

/**
 * `%rune%` cannot be called with a spread argument
 * @param {null | number | NodeLike} node
 * @param {string} rune
 * @returns {never}
 */
function rune_invalid_spread(node, rune) {
	e(node, 'rune_invalid_spread', `\`${rune}\` cannot be called with a spread argument\nhttps://svelte.dev/e/rune_invalid_spread`);
}

/**
 * Cannot use `%rune%` rune in non-runes mode
 * @param {null | number | NodeLike} node
 * @param {string} rune
 * @returns {never}
 */
function rune_invalid_usage(node, rune) {
	e(node, 'rune_invalid_usage', `Cannot use \`${rune}\` rune in non-runes mode\nhttps://svelte.dev/e/rune_invalid_usage`);
}

/**
 * Cannot use rune without parentheses
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function rune_missing_parentheses(node) {
	e(node, 'rune_missing_parentheses', `Cannot use rune without parentheses\nhttps://svelte.dev/e/rune_missing_parentheses`);
}

/**
 * The `%name%` rune has been removed
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function rune_removed(node, name) {
	e(node, 'rune_removed', `The \`${name}\` rune has been removed\nhttps://svelte.dev/e/rune_removed`);
}

/**
 * `%name%` is now `%replacement%`
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @param {string} replacement
 * @returns {never}
 */
function rune_renamed(node, name, replacement) {
	e(node, 'rune_renamed', `\`${name}\` is now \`${replacement}\`\nhttps://svelte.dev/e/rune_renamed`);
}

/**
 * %name% cannot be used in runes mode
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function runes_mode_invalid_import(node, name) {
	e(node, 'runes_mode_invalid_import', `${name} cannot be used in runes mode\nhttps://svelte.dev/e/runes_mode_invalid_import`);
}

/**
 * An exported snippet can only reference things declared in a `<script module>`, or other exportable snippets
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function snippet_invalid_export(node) {
	e(node, 'snippet_invalid_export', `An exported snippet can only reference things declared in a \`<script module>\`, or other exportable snippets\nhttps://svelte.dev/e/snippet_invalid_export`);
}

/**
 * Cannot reassign or bind to snippet parameter
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function snippet_parameter_assignment(node) {
	e(node, 'snippet_parameter_assignment', `Cannot reassign or bind to snippet parameter\nhttps://svelte.dev/e/snippet_parameter_assignment`);
}

/**
 * `%name%` has already been declared on this class
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function state_field_duplicate(node, name) {
	e(node, 'state_field_duplicate', `\`${name}\` has already been declared on this class\nhttps://svelte.dev/e/state_field_duplicate`);
}

/**
 * Cannot assign to a state field before its declaration
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function state_field_invalid_assignment(node) {
	e(node, 'state_field_invalid_assignment', `Cannot assign to a state field before its declaration\nhttps://svelte.dev/e/state_field_invalid_assignment`);
}

/**
 * Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function state_invalid_export(node) {
	e(node, 'state_invalid_export', `Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties\nhttps://svelte.dev/e/state_invalid_export`);
}

/**
 * `%rune%(...)` can only be used as a variable declaration initializer, a class field declaration, or the first assignment to a class field at the top level of the constructor.
 * @param {null | number | NodeLike} node
 * @param {string} rune
 * @returns {never}
 */
function state_invalid_placement(node, rune) {
	e(node, 'state_invalid_placement', `\`${rune}(...)\` can only be used as a variable declaration initializer, a class field declaration, or the first assignment to a class field at the top level of the constructor.\nhttps://svelte.dev/e/state_invalid_placement`);
}

/**
 * Cannot subscribe to stores that are not declared at the top level of the component
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function store_invalid_scoped_subscription(node) {
	e(node, 'store_invalid_scoped_subscription', `Cannot subscribe to stores that are not declared at the top level of the component\nhttps://svelte.dev/e/store_invalid_scoped_subscription`);
}

/**
 * Cannot reference store value inside `<script module>`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function store_invalid_subscription(node) {
	e(node, 'store_invalid_subscription', `Cannot reference store value inside \`<script module>\`\nhttps://svelte.dev/e/store_invalid_subscription`);
}

/**
 * Cannot reference store value outside a `.svelte` file
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function store_invalid_subscription_module(node) {
	e(node, 'store_invalid_subscription_module', `Cannot reference store value outside a \`.svelte\` file\nhttps://svelte.dev/e/store_invalid_subscription_module`);
}

/**
 * TypeScript language features like %feature% are not natively supported, and their use is generally discouraged. Outside of `<script>` tags, these features are not supported. For use within `<script>` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using `vitePreprocess`, make sure to specifically enable preprocessing script tags (`vitePreprocess({ script: true })`)
 * @param {null | number | NodeLike} node
 * @param {string} feature
 * @returns {never}
 */
function typescript_invalid_feature(node, feature) {
	e(node, 'typescript_invalid_feature', `TypeScript language features like ${feature} are not natively supported, and their use is generally discouraged. Outside of \`<script>\` tags, these features are not supported. For use within \`<script>\` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using \`vitePreprocess\`, make sure to specifically enable preprocessing script tags (\`vitePreprocess({ script: true })\`)\nhttps://svelte.dev/e/typescript_invalid_feature`);
}

/**
 * Declaration cannot be empty
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_empty_declaration(node) {
	e(node, 'css_empty_declaration', `Declaration cannot be empty\nhttps://svelte.dev/e/css_empty_declaration`);
}

/**
 * Expected a valid CSS identifier
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_expected_identifier(node) {
	e(node, 'css_expected_identifier', `Expected a valid CSS identifier\nhttps://svelte.dev/e/css_expected_identifier`);
}

/**
 * A `:global` selector cannot follow a `%name%` combinator
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function css_global_block_invalid_combinator(node, name) {
	e(node, 'css_global_block_invalid_combinator', `A \`:global\` selector cannot follow a \`${name}\` combinator\nhttps://svelte.dev/e/css_global_block_invalid_combinator`);
}

/**
 * A top-level `:global {...}` block can only contain rules, not declarations
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_block_invalid_declaration(node) {
	e(node, 'css_global_block_invalid_declaration', `A top-level \`:global {...}\` block can only contain rules, not declarations\nhttps://svelte.dev/e/css_global_block_invalid_declaration`);
}

/**
 * A `:global` selector cannot be part of a selector list with entries that don't contain `:global`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_block_invalid_list(node) {
	e(node, 'css_global_block_invalid_list', `A \`:global\` selector cannot be part of a selector list with entries that don't contain \`:global\`\nhttps://svelte.dev/e/css_global_block_invalid_list`);
}

/**
 * A `:global` selector cannot modify an existing selector
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_block_invalid_modifier(node) {
	e(node, 'css_global_block_invalid_modifier', `A \`:global\` selector cannot modify an existing selector\nhttps://svelte.dev/e/css_global_block_invalid_modifier`);
}

/**
 * A `:global` selector can only be modified if it is a descendant of other selectors
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_block_invalid_modifier_start(node) {
	e(node, 'css_global_block_invalid_modifier_start', `A \`:global\` selector can only be modified if it is a descendant of other selectors\nhttps://svelte.dev/e/css_global_block_invalid_modifier_start`);
}

/**
 * A `:global` selector cannot be inside a pseudoclass
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_block_invalid_placement(node) {
	e(node, 'css_global_block_invalid_placement', `A \`:global\` selector cannot be inside a pseudoclass\nhttps://svelte.dev/e/css_global_block_invalid_placement`);
}

/**
 * `:global(...)` can be at the start or end of a selector sequence, but not in the middle
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_invalid_placement(node) {
	e(node, 'css_global_invalid_placement', `\`:global(...)\` can be at the start or end of a selector sequence, but not in the middle\nhttps://svelte.dev/e/css_global_invalid_placement`);
}

/**
 * `:global(...)` must contain exactly one selector
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_invalid_selector(node) {
	e(node, 'css_global_invalid_selector', `\`:global(...)\` must contain exactly one selector\nhttps://svelte.dev/e/css_global_invalid_selector`);
}

/**
 * `:global(...)` must not contain type or universal selectors when used in a compound selector
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_global_invalid_selector_list(node) {
	e(node, 'css_global_invalid_selector_list', `\`:global(...)\` must not contain type or universal selectors when used in a compound selector\nhttps://svelte.dev/e/css_global_invalid_selector_list`);
}

/**
 * Nesting selectors can only be used inside a rule or as the first selector inside a lone `:global(...)`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_nesting_selector_invalid_placement(node) {
	e(node, 'css_nesting_selector_invalid_placement', `Nesting selectors can only be used inside a rule or as the first selector inside a lone \`:global(...)\`\nhttps://svelte.dev/e/css_nesting_selector_invalid_placement`);
}

/**
 * Invalid selector
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_selector_invalid(node) {
	e(node, 'css_selector_invalid', `Invalid selector\nhttps://svelte.dev/e/css_selector_invalid`);
}

/**
 * `:global(...)` must not be followed by a type selector
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function css_type_selector_invalid_placement(node) {
	e(node, 'css_type_selector_invalid_placement', `\`:global(...)\` must not be followed by a type selector\nhttps://svelte.dev/e/css_type_selector_invalid_placement`);
}

/**
 * An element can only have one 'animate' directive
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function animation_duplicate(node) {
	e(node, 'animation_duplicate', `An element can only have one 'animate' directive\nhttps://svelte.dev/e/animation_duplicate`);
}

/**
 * An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function animation_invalid_placement(node) {
	e(node, 'animation_invalid_placement', `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block\nhttps://svelte.dev/e/animation_invalid_placement`);
}

/**
 * An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block. Did you forget to add a key to your each block?
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function animation_missing_key(node) {
	e(node, 'animation_missing_key', `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block. Did you forget to add a key to your each block?\nhttps://svelte.dev/e/animation_missing_key`);
}

/**
 * 'contenteditable' attribute cannot be dynamic if element uses two-way binding
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_contenteditable_dynamic(node) {
	e(node, 'attribute_contenteditable_dynamic', `'contenteditable' attribute cannot be dynamic if element uses two-way binding\nhttps://svelte.dev/e/attribute_contenteditable_dynamic`);
}

/**
 * 'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_contenteditable_missing(node) {
	e(node, 'attribute_contenteditable_missing', `'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings\nhttps://svelte.dev/e/attribute_contenteditable_missing`);
}

/**
 * Attributes need to be unique
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_duplicate(node) {
	e(node, 'attribute_duplicate', `Attributes need to be unique\nhttps://svelte.dev/e/attribute_duplicate`);
}

/**
 * Attribute shorthand cannot be empty
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_empty_shorthand(node) {
	e(node, 'attribute_empty_shorthand', `Attribute shorthand cannot be empty\nhttps://svelte.dev/e/attribute_empty_shorthand`);
}

/**
 * Event attribute must be a JavaScript expression, not a string
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_invalid_event_handler(node) {
	e(node, 'attribute_invalid_event_handler', `Event attribute must be a JavaScript expression, not a string\nhttps://svelte.dev/e/attribute_invalid_event_handler`);
}

/**
 * 'multiple' attribute must be static if select uses two-way binding
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_invalid_multiple(node) {
	e(node, 'attribute_invalid_multiple', `'multiple' attribute must be static if select uses two-way binding\nhttps://svelte.dev/e/attribute_invalid_multiple`);
}

/**
 * '%name%' is not a valid attribute name
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function attribute_invalid_name(node, name) {
	e(node, 'attribute_invalid_name', `'${name}' is not a valid attribute name\nhttps://svelte.dev/e/attribute_invalid_name`);
}

/**
 * Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_invalid_sequence_expression(node) {
	e(node, 'attribute_invalid_sequence_expression', `Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses\nhttps://svelte.dev/e/attribute_invalid_sequence_expression`);
}

/**
 * 'type' attribute must be a static text value if input uses two-way binding
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_invalid_type(node) {
	e(node, 'attribute_invalid_type', `'type' attribute must be a static text value if input uses two-way binding\nhttps://svelte.dev/e/attribute_invalid_type`);
}

/**
 * Attribute values containing `{...}` must be enclosed in quote marks, unless the value only contains the expression
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function attribute_unquoted_sequence(node) {
	e(node, 'attribute_unquoted_sequence', `Attribute values containing \`{...}\` must be enclosed in quote marks, unless the value only contains the expression\nhttps://svelte.dev/e/attribute_unquoted_sequence`);
}

/**
 * `bind:group` can only bind to an Identifier or MemberExpression
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function bind_group_invalid_expression(node) {
	e(node, 'bind_group_invalid_expression', `\`bind:group\` can only bind to an Identifier or MemberExpression\nhttps://svelte.dev/e/bind_group_invalid_expression`);
}

/**
 * Cannot `bind:group` to a snippet parameter
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function bind_group_invalid_snippet_parameter(node) {
	e(node, 'bind_group_invalid_snippet_parameter', `Cannot \`bind:group\` to a snippet parameter\nhttps://svelte.dev/e/bind_group_invalid_snippet_parameter`);
}

/**
 * Can only bind to an Identifier or MemberExpression or a `{get, set}` pair
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function bind_invalid_expression(node) {
	e(node, 'bind_invalid_expression', `Can only bind to an Identifier or MemberExpression or a \`{get, set}\` pair\nhttps://svelte.dev/e/bind_invalid_expression`);
}

/**
 * `bind:%name%` is not a valid binding. %explanation%
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @param {string | undefined | null} [explanation]
 * @returns {never}
 */
function bind_invalid_name(node, name, explanation) {
	e(node, 'bind_invalid_name', `${explanation
		? `\`bind:${name}\` is not a valid binding. ${explanation}`
		: `\`bind:${name}\` is not a valid binding`}\nhttps://svelte.dev/e/bind_invalid_name`);
}

/**
 * `bind:%name%={get, set}` must not have surrounding parentheses
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function bind_invalid_parens(node, name) {
	e(node, 'bind_invalid_parens', `\`bind:${name}={get, set}\` must not have surrounding parentheses\nhttps://svelte.dev/e/bind_invalid_parens`);
}

/**
 * `bind:%name%` can only be used with %elements%
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @param {string} elements
 * @returns {never}
 */
function bind_invalid_target(node, name, elements) {
	e(node, 'bind_invalid_target', `\`bind:${name}\` can only be used with ${elements}\nhttps://svelte.dev/e/bind_invalid_target`);
}

/**
 * Can only bind to state or props
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function bind_invalid_value(node) {
	e(node, 'bind_invalid_value', `Can only bind to state or props\nhttps://svelte.dev/e/bind_invalid_value`);
}

/**
 * %name% cannot appear more than once within a block
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function block_duplicate_clause(node, name) {
	e(node, 'block_duplicate_clause', `${name} cannot appear more than once within a block\nhttps://svelte.dev/e/block_duplicate_clause`);
}

/**
 * {:...} block is invalid at this position (did you forget to close the preceding element or block?)
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function block_invalid_continuation_placement(node) {
	e(node, 'block_invalid_continuation_placement', `{:...} block is invalid at this position (did you forget to close the preceding element or block?)\nhttps://svelte.dev/e/block_invalid_continuation_placement`);
}

/**
 * 'elseif' should be 'else if'
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function block_invalid_elseif(node) {
	e(node, 'block_invalid_elseif', `'elseif' should be 'else if'\nhttps://svelte.dev/e/block_invalid_elseif`);
}

/**
 * {#%name% ...} block cannot be %location%
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @param {string} location
 * @returns {never}
 */
function block_invalid_placement(node, name, location) {
	e(node, 'block_invalid_placement', `{#${name} ...} block cannot be ${location}\nhttps://svelte.dev/e/block_invalid_placement`);
}

/**
 * Block was left open
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function block_unclosed(node) {
	e(node, 'block_unclosed', `Block was left open\nhttps://svelte.dev/e/block_unclosed`);
}

/**
 * Expected a `%character%` character immediately following the opening bracket
 * @param {null | number | NodeLike} node
 * @param {string} character
 * @returns {never}
 */
function block_unexpected_character(node, character) {
	e(node, 'block_unexpected_character', `Expected a \`${character}\` character immediately following the opening bracket\nhttps://svelte.dev/e/block_unexpected_character`);
}

/**
 * Unexpected block closing tag
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function block_unexpected_close(node) {
	e(node, 'block_unexpected_close', `Unexpected block closing tag\nhttps://svelte.dev/e/block_unexpected_close`);
}

/**
 * This type of directive is not valid on components
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function component_invalid_directive(node) {
	e(node, 'component_invalid_directive', `This type of directive is not valid on components\nhttps://svelte.dev/e/component_invalid_directive`);
}

/**
 * Cyclical dependency detected: %cycle%
 * @param {null | number | NodeLike} node
 * @param {string} cycle
 * @returns {never}
 */
function const_tag_cycle(node, cycle) {
	e(node, 'const_tag_cycle', `Cyclical dependency detected: ${cycle}\nhttps://svelte.dev/e/const_tag_cycle`);
}

/**
 * {@const ...} must consist of a single variable declaration
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function const_tag_invalid_expression(node) {
	e(node, 'const_tag_invalid_expression', `{@const ...} must consist of a single variable declaration\nhttps://svelte.dev/e/const_tag_invalid_expression`);
}

/**
 * `{@const}` must be the immediate child of `{#snippet}`, `{#if}`, `{:else if}`, `{:else}`, `{#each}`, `{:then}`, `{:catch}`, `<svelte:fragment>`, `<svelte:boundary` or `<Component>`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function const_tag_invalid_placement(node) {
	e(node, 'const_tag_invalid_placement', `\`{@const}\` must be the immediate child of \`{#snippet}\`, \`{#if}\`, \`{:else if}\`, \`{:else}\`, \`{#each}\`, \`{:then}\`, \`{:catch}\`, \`<svelte:fragment>\`, \`<svelte:boundary\` or \`<Component>\`\nhttps://svelte.dev/e/const_tag_invalid_placement`);
}

/**
 * The `{@const %name% = ...}` declaration is not available in this snippet
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function const_tag_invalid_reference(node, name) {
	e(node, 'const_tag_invalid_reference', `The \`{@const ${name} = ...}\` declaration is not available in this snippet\nhttps://svelte.dev/e/const_tag_invalid_reference`);
}

/**
 * {@debug ...} arguments must be identifiers, not arbitrary expressions
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function debug_tag_invalid_arguments(node) {
	e(node, 'debug_tag_invalid_arguments', `{@debug ...} arguments must be identifiers, not arbitrary expressions\nhttps://svelte.dev/e/debug_tag_invalid_arguments`);
}

/**
 * Directive value must be a JavaScript expression enclosed in curly braces
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function directive_invalid_value(node) {
	e(node, 'directive_invalid_value', `Directive value must be a JavaScript expression enclosed in curly braces\nhttps://svelte.dev/e/directive_invalid_value`);
}

/**
 * `%type%` name cannot be empty
 * @param {null | number | NodeLike} node
 * @param {string} type
 * @returns {never}
 */
function directive_missing_name(node, type) {
	e(node, 'directive_missing_name', `\`${type}\` name cannot be empty\nhttps://svelte.dev/e/directive_missing_name`);
}

/**
 * An `{#each ...}` block without an `as` clause cannot have a key
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function each_key_without_as(node) {
	e(node, 'each_key_without_as', `An \`{#each ...}\` block without an \`as\` clause cannot have a key\nhttps://svelte.dev/e/each_key_without_as`);
}

/**
 * `</%name%>` attempted to close an element that was not open
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function element_invalid_closing_tag(node, name) {
	e(node, 'element_invalid_closing_tag', `\`</${name}>\` attempted to close an element that was not open\nhttps://svelte.dev/e/element_invalid_closing_tag`);
}

/**
 * `</%name%>` attempted to close element that was already automatically closed by `<%reason%>` (cannot nest `<%reason%>` inside `<%name%>`)
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @param {string} reason
 * @returns {never}
 */
function element_invalid_closing_tag_autoclosed(node, name, reason) {
	e(node, 'element_invalid_closing_tag_autoclosed', `\`</${name}>\` attempted to close element that was already automatically closed by \`<${reason}>\` (cannot nest \`<${reason}>\` inside \`<${name}>\`)\nhttps://svelte.dev/e/element_invalid_closing_tag_autoclosed`);
}

/**
 * `<%name%>` was left open
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function element_unclosed(node, name) {
	e(node, 'element_unclosed', `\`<${name}>\` was left open\nhttps://svelte.dev/e/element_unclosed`);
}

/**
 * Event modifiers other than 'once' can only be used on DOM elements
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function event_handler_invalid_component_modifier(node) {
	e(node, 'event_handler_invalid_component_modifier', `Event modifiers other than 'once' can only be used on DOM elements\nhttps://svelte.dev/e/event_handler_invalid_component_modifier`);
}

/**
 * Valid event modifiers are %list%
 * @param {null | number | NodeLike} node
 * @param {string} list
 * @returns {never}
 */
function event_handler_invalid_modifier(node, list) {
	e(node, 'event_handler_invalid_modifier', `Valid event modifiers are ${list}\nhttps://svelte.dev/e/event_handler_invalid_modifier`);
}

/**
 * The '%modifier1%' and '%modifier2%' modifiers cannot be used together
 * @param {null | number | NodeLike} node
 * @param {string} modifier1
 * @param {string} modifier2
 * @returns {never}
 */
function event_handler_invalid_modifier_combination(node, modifier1, modifier2) {
	e(node, 'event_handler_invalid_modifier_combination', `The '${modifier1}' and '${modifier2}' modifiers cannot be used together\nhttps://svelte.dev/e/event_handler_invalid_modifier_combination`);
}

/**
 * Expected attribute value
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function expected_attribute_value(node) {
	e(node, 'expected_attribute_value', `Expected attribute value\nhttps://svelte.dev/e/expected_attribute_value`);
}

/**
 * Expected 'if', 'each', 'await', 'key' or 'snippet'
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function expected_block_type(node) {
	e(node, 'expected_block_type', `Expected 'if', 'each', 'await', 'key' or 'snippet'\nhttps://svelte.dev/e/expected_block_type`);
}

/**
 * Expected an identifier
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function expected_identifier(node) {
	e(node, 'expected_identifier', `Expected an identifier\nhttps://svelte.dev/e/expected_identifier`);
}

/**
 * Expected identifier or destructure pattern
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function expected_pattern(node) {
	e(node, 'expected_pattern', `Expected identifier or destructure pattern\nhttps://svelte.dev/e/expected_pattern`);
}

/**
 * Expected 'html', 'render', 'attach', 'const', or 'debug'
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function expected_tag(node) {
	e(node, 'expected_tag', `Expected 'html', 'render', 'attach', 'const', or 'debug'\nhttps://svelte.dev/e/expected_tag`);
}

/**
 * Expected token %token%
 * @param {null | number | NodeLike} node
 * @param {string} token
 * @returns {never}
 */
function expected_token(node, token) {
	e(node, 'expected_token', `Expected token ${token}\nhttps://svelte.dev/e/expected_token`);
}

/**
 * Expected whitespace
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function expected_whitespace(node) {
	e(node, 'expected_whitespace', `Expected whitespace\nhttps://svelte.dev/e/expected_whitespace`);
}

/**
 * `use:`, `transition:` and `animate:` directives, attachments and bindings do not support await expressions
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function illegal_await_expression(node) {
	e(node, 'illegal_await_expression', `\`use:\`, \`transition:\` and \`animate:\` directives, attachments and bindings do not support await expressions\nhttps://svelte.dev/e/illegal_await_expression`);
}

/**
 * `<%name%>` does not support non-event attributes or spread attributes
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function illegal_element_attribute(node, name) {
	e(node, 'illegal_element_attribute', `\`<${name}>\` does not support non-event attributes or spread attributes\nhttps://svelte.dev/e/illegal_element_attribute`);
}

/**
 * %message%
 * @param {null | number | NodeLike} node
 * @param {string} message
 * @returns {never}
 */
function js_parse_error(node, message) {
	e(node, 'js_parse_error', `${message}\nhttps://svelte.dev/e/js_parse_error`);
}

/**
 * `let:` directive at invalid position
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function let_directive_invalid_placement(node) {
	e(node, 'let_directive_invalid_placement', `\`let:\` directive at invalid position\nhttps://svelte.dev/e/let_directive_invalid_placement`);
}

/**
 * Mixing old (on:%name%) and new syntaxes for event handling is not allowed. Use only the on%name% syntax
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function mixed_event_handler_syntaxes(node, name) {
	e(node, 'mixed_event_handler_syntaxes', `Mixing old (on:${name}) and new syntaxes for event handling is not allowed. Use only the on${name} syntax\nhttps://svelte.dev/e/mixed_event_handler_syntaxes`);
}

/**
 * %message%. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.
 * @param {null | number | NodeLike} node
 * @param {string} message
 * @returns {never}
 */
function node_invalid_placement(node, message) {
	e(node, 'node_invalid_placement', `${message}. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.\nhttps://svelte.dev/e/node_invalid_placement`);
}

/**
 * Calling a snippet function using apply, bind or call is not allowed
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function render_tag_invalid_call_expression(node) {
	e(node, 'render_tag_invalid_call_expression', `Calling a snippet function using apply, bind or call is not allowed\nhttps://svelte.dev/e/render_tag_invalid_call_expression`);
}

/**
 * `{@render ...}` tags can only contain call expressions
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function render_tag_invalid_expression(node) {
	e(node, 'render_tag_invalid_expression', `\`{@render ...}\` tags can only contain call expressions\nhttps://svelte.dev/e/render_tag_invalid_expression`);
}

/**
 * cannot use spread arguments in `{@render ...}` tags
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function render_tag_invalid_spread_argument(node) {
	e(node, 'render_tag_invalid_spread_argument', `cannot use spread arguments in \`{@render ...}\` tags\nhttps://svelte.dev/e/render_tag_invalid_spread_argument`);
}

/**
 * A component can have a single top-level `<script>` element and/or a single top-level `<script module>` element
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function script_duplicate(node) {
	e(node, 'script_duplicate', `A component can have a single top-level \`<script>\` element and/or a single top-level \`<script module>\` element\nhttps://svelte.dev/e/script_duplicate`);
}

/**
 * If the `%name%` attribute is supplied, it must be a boolean attribute
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function script_invalid_attribute_value(node, name) {
	e(node, 'script_invalid_attribute_value', `If the \`${name}\` attribute is supplied, it must be a boolean attribute\nhttps://svelte.dev/e/script_invalid_attribute_value`);
}

/**
 * If the context attribute is supplied, its value must be "module"
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function script_invalid_context(node) {
	e(node, 'script_invalid_context', `If the context attribute is supplied, its value must be "module"\nhttps://svelte.dev/e/script_invalid_context`);
}

/**
 * The `%name%` attribute is reserved and cannot be used
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function script_reserved_attribute(node, name) {
	e(node, 'script_reserved_attribute', `The \`${name}\` attribute is reserved and cannot be used\nhttps://svelte.dev/e/script_reserved_attribute`);
}

/**
 * Duplicate slot name '%name%' in <%component%>
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @param {string} component
 * @returns {never}
 */
function slot_attribute_duplicate(node, name, component) {
	e(node, 'slot_attribute_duplicate', `Duplicate slot name '${name}' in <${component}>\nhttps://svelte.dev/e/slot_attribute_duplicate`);
}

/**
 * slot attribute must be a static value
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function slot_attribute_invalid(node) {
	e(node, 'slot_attribute_invalid', `slot attribute must be a static value\nhttps://svelte.dev/e/slot_attribute_invalid`);
}

/**
 * Element with a slot='...' attribute must be a child of a component or a descendant of a custom element
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function slot_attribute_invalid_placement(node) {
	e(node, 'slot_attribute_invalid_placement', `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element\nhttps://svelte.dev/e/slot_attribute_invalid_placement`);
}

/**
 * Found default slot content alongside an explicit slot="default"
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function slot_default_duplicate(node) {
	e(node, 'slot_default_duplicate', `Found default slot content alongside an explicit slot="default"\nhttps://svelte.dev/e/slot_default_duplicate`);
}

/**
 * `<slot>` can only receive attributes and (optionally) let directives
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function slot_element_invalid_attribute(node) {
	e(node, 'slot_element_invalid_attribute', `\`<slot>\` can only receive attributes and (optionally) let directives\nhttps://svelte.dev/e/slot_element_invalid_attribute`);
}

/**
 * slot attribute must be a static value
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function slot_element_invalid_name(node) {
	e(node, 'slot_element_invalid_name', `slot attribute must be a static value\nhttps://svelte.dev/e/slot_element_invalid_name`);
}

/**
 * `default` is a reserved word — it cannot be used as a slot name
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function slot_element_invalid_name_default(node) {
	e(node, 'slot_element_invalid_name_default', `\`default\` is a reserved word — it cannot be used as a slot name\nhttps://svelte.dev/e/slot_element_invalid_name_default`);
}

/**
 * Cannot use `<slot>` syntax and `{@render ...}` tags in the same component. Migrate towards `{@render ...}` tags completely
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function slot_snippet_conflict(node) {
	e(node, 'slot_snippet_conflict', `Cannot use \`<slot>\` syntax and \`{@render ...}\` tags in the same component. Migrate towards \`{@render ...}\` tags completely\nhttps://svelte.dev/e/slot_snippet_conflict`);
}

/**
 * Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function snippet_conflict(node) {
	e(node, 'snippet_conflict', `Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block\nhttps://svelte.dev/e/snippet_conflict`);
}

/**
 * Snippets do not support rest parameters; use an array instead
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function snippet_invalid_rest_parameter(node) {
	e(node, 'snippet_invalid_rest_parameter', `Snippets do not support rest parameters; use an array instead\nhttps://svelte.dev/e/snippet_invalid_rest_parameter`);
}

/**
 * This snippet is shadowing the prop `%prop%` with the same name
 * @param {null | number | NodeLike} node
 * @param {string} prop
 * @returns {never}
 */
function snippet_shadowing_prop(node, prop) {
	e(node, 'snippet_shadowing_prop', `This snippet is shadowing the prop \`${prop}\` with the same name\nhttps://svelte.dev/e/snippet_shadowing_prop`);
}

/**
 * `style:` directive can only use the `important` modifier
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function style_directive_invalid_modifier(node) {
	e(node, 'style_directive_invalid_modifier', `\`style:\` directive can only use the \`important\` modifier\nhttps://svelte.dev/e/style_directive_invalid_modifier`);
}

/**
 * A component can have a single top-level `<style>` element
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function style_duplicate(node) {
	e(node, 'style_duplicate', `A component can have a single top-level \`<style>\` element\nhttps://svelte.dev/e/style_duplicate`);
}

/**
 * `<svelte:body>` does not support non-event attributes or spread attributes
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_body_illegal_attribute(node) {
	e(node, 'svelte_body_illegal_attribute', `\`<svelte:body>\` does not support non-event attributes or spread attributes\nhttps://svelte.dev/e/svelte_body_illegal_attribute`);
}

/**
 * Valid attributes on `<svelte:boundary>` are `onerror` and `failed`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_boundary_invalid_attribute(node) {
	e(node, 'svelte_boundary_invalid_attribute', `Valid attributes on \`<svelte:boundary>\` are \`onerror\` and \`failed\`\nhttps://svelte.dev/e/svelte_boundary_invalid_attribute`);
}

/**
 * Attribute value must be a non-string expression
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_boundary_invalid_attribute_value(node) {
	e(node, 'svelte_boundary_invalid_attribute_value', `Attribute value must be a non-string expression\nhttps://svelte.dev/e/svelte_boundary_invalid_attribute_value`);
}

/**
 * Invalid component definition — must be an `{expression}`
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_component_invalid_this(node) {
	e(node, 'svelte_component_invalid_this', `Invalid component definition — must be an \`{expression}\`\nhttps://svelte.dev/e/svelte_component_invalid_this`);
}

/**
 * `<svelte:component>` must have a 'this' attribute
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_component_missing_this(node) {
	e(node, 'svelte_component_missing_this', `\`<svelte:component>\` must have a 'this' attribute\nhttps://svelte.dev/e/svelte_component_missing_this`);
}

/**
 * `<svelte:element>` must have a 'this' attribute with a value
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_element_missing_this(node) {
	e(node, 'svelte_element_missing_this', `\`<svelte:element>\` must have a 'this' attribute with a value\nhttps://svelte.dev/e/svelte_element_missing_this`);
}

/**
 * `<svelte:fragment>` can only have a slot attribute and (optionally) a let: directive
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_fragment_invalid_attribute(node) {
	e(node, 'svelte_fragment_invalid_attribute', `\`<svelte:fragment>\` can only have a slot attribute and (optionally) a let: directive\nhttps://svelte.dev/e/svelte_fragment_invalid_attribute`);
}

/**
 * `<svelte:fragment>` must be the direct child of a component
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_fragment_invalid_placement(node) {
	e(node, 'svelte_fragment_invalid_placement', `\`<svelte:fragment>\` must be the direct child of a component\nhttps://svelte.dev/e/svelte_fragment_invalid_placement`);
}

/**
 * `<svelte:head>` cannot have attributes nor directives
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_head_illegal_attribute(node) {
	e(node, 'svelte_head_illegal_attribute', `\`<svelte:head>\` cannot have attributes nor directives\nhttps://svelte.dev/e/svelte_head_illegal_attribute`);
}

/**
 * A component can only have one `<%name%>` element
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function svelte_meta_duplicate(node, name) {
	e(node, 'svelte_meta_duplicate', `A component can only have one \`<${name}>\` element\nhttps://svelte.dev/e/svelte_meta_duplicate`);
}

/**
 * <%name%> cannot have children
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function svelte_meta_invalid_content(node, name) {
	e(node, 'svelte_meta_invalid_content', `<${name}> cannot have children\nhttps://svelte.dev/e/svelte_meta_invalid_content`);
}

/**
 * `<%name%>` tags cannot be inside elements or blocks
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function svelte_meta_invalid_placement(node, name) {
	e(node, 'svelte_meta_invalid_placement', `\`<${name}>\` tags cannot be inside elements or blocks\nhttps://svelte.dev/e/svelte_meta_invalid_placement`);
}

/**
 * Valid `<svelte:...>` tag names are %list%
 * @param {null | number | NodeLike} node
 * @param {string} list
 * @returns {never}
 */
function svelte_meta_invalid_tag(node, list) {
	e(node, 'svelte_meta_invalid_tag', `Valid \`<svelte:...>\` tag names are ${list}\nhttps://svelte.dev/e/svelte_meta_invalid_tag`);
}

/**
 * "tag" option is deprecated — use "customElement" instead
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_options_deprecated_tag(node) {
	e(node, 'svelte_options_deprecated_tag', `"tag" option is deprecated — use "customElement" instead\nhttps://svelte.dev/e/svelte_options_deprecated_tag`);
}

/**
 * `<svelte:options>` can only receive static attributes
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_options_invalid_attribute(node) {
	e(node, 'svelte_options_invalid_attribute', `\`<svelte:options>\` can only receive static attributes\nhttps://svelte.dev/e/svelte_options_invalid_attribute`);
}

/**
 * Value must be %list%, if specified
 * @param {null | number | NodeLike} node
 * @param {string} list
 * @returns {never}
 */
function svelte_options_invalid_attribute_value(node, list) {
	e(node, 'svelte_options_invalid_attribute_value', `Value must be ${list}, if specified\nhttps://svelte.dev/e/svelte_options_invalid_attribute_value`);
}

/**
 * "customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_options_invalid_customelement(node) {
	e(node, 'svelte_options_invalid_customelement', `"customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }\nhttps://svelte.dev/e/svelte_options_invalid_customelement`);
}

/**
 * "props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_options_invalid_customelement_props(node) {
	e(node, 'svelte_options_invalid_customelement_props', `"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"\nhttps://svelte.dev/e/svelte_options_invalid_customelement_props`);
}

/**
 * "shadow" must be either "open" or "none"
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_options_invalid_customelement_shadow(node) {
	e(node, 'svelte_options_invalid_customelement_shadow', `"shadow" must be either "open" or "none"\nhttps://svelte.dev/e/svelte_options_invalid_customelement_shadow`);
}

/**
 * Tag name must be lowercase and hyphenated
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_options_invalid_tagname(node) {
	e(node, 'svelte_options_invalid_tagname', `Tag name must be lowercase and hyphenated\nhttps://svelte.dev/e/svelte_options_invalid_tagname`);
}

/**
 * Tag name is reserved
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_options_reserved_tagname(node) {
	e(node, 'svelte_options_reserved_tagname', `Tag name is reserved\nhttps://svelte.dev/e/svelte_options_reserved_tagname`);
}

/**
 * `<svelte:options>` unknown attribute '%name%'
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @returns {never}
 */
function svelte_options_unknown_attribute(node, name) {
	e(node, 'svelte_options_unknown_attribute', `\`<svelte:options>\` unknown attribute '${name}'\nhttps://svelte.dev/e/svelte_options_unknown_attribute`);
}

/**
 * `<svelte:self>` components can only exist inside `{#if}` blocks, `{#each}` blocks, `{#snippet}` blocks or slots passed to components
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function svelte_self_invalid_placement(node) {
	e(node, 'svelte_self_invalid_placement', `\`<svelte:self>\` components can only exist inside \`{#if}\` blocks, \`{#each}\` blocks, \`{#snippet}\` blocks or slots passed to components\nhttps://svelte.dev/e/svelte_self_invalid_placement`);
}

/**
 * Expected a valid element or component name. Components must have a valid variable name or dot notation expression
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function tag_invalid_name(node) {
	e(node, 'tag_invalid_name', `Expected a valid element or component name. Components must have a valid variable name or dot notation expression\nhttps://svelte.dev/e/tag_invalid_name`);
}

/**
 * {@%name% ...} tag cannot be %location%
 * @param {null | number | NodeLike} node
 * @param {string} name
 * @param {string} location
 * @returns {never}
 */
function tag_invalid_placement(node, name, location) {
	e(node, 'tag_invalid_placement', `{@${name} ...} tag cannot be ${location}\nhttps://svelte.dev/e/tag_invalid_placement`);
}

/**
 * A `<textarea>` can have either a value attribute or (equivalently) child content, but not both
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function textarea_invalid_content(node) {
	e(node, 'textarea_invalid_content', `A \`<textarea>\` can have either a value attribute or (equivalently) child content, but not both\nhttps://svelte.dev/e/textarea_invalid_content`);
}

/**
 * `<title>` cannot have attributes nor directives
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function title_illegal_attribute(node) {
	e(node, 'title_illegal_attribute', `\`<title>\` cannot have attributes nor directives\nhttps://svelte.dev/e/title_illegal_attribute`);
}

/**
 * `<title>` can only contain text and {tags}
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function title_invalid_content(node) {
	e(node, 'title_invalid_content', `\`<title>\` can only contain text and {tags}\nhttps://svelte.dev/e/title_invalid_content`);
}

/**
 * Cannot use `%type%:` alongside existing `%existing%:` directive
 * @param {null | number | NodeLike} node
 * @param {string} type
 * @param {string} existing
 * @returns {never}
 */
function transition_conflict(node, type, existing) {
	e(node, 'transition_conflict', `Cannot use \`${type}:\` alongside existing \`${existing}:\` directive\nhttps://svelte.dev/e/transition_conflict`);
}

/**
 * Cannot use multiple `%type%:` directives on a single element
 * @param {null | number | NodeLike} node
 * @param {string} type
 * @returns {never}
 */
function transition_duplicate(node, type) {
	e(node, 'transition_duplicate', `Cannot use multiple \`${type}:\` directives on a single element\nhttps://svelte.dev/e/transition_duplicate`);
}

/**
 * Unexpected end of input
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function unexpected_eof(node) {
	e(node, 'unexpected_eof', `Unexpected end of input\nhttps://svelte.dev/e/unexpected_eof`);
}

/**
 * '%word%' is a reserved word in JavaScript and cannot be used here
 * @param {null | number | NodeLike} node
 * @param {string} word
 * @returns {never}
 */
function unexpected_reserved_word(node, word) {
	e(node, 'unexpected_reserved_word', `'${word}' is a reserved word in JavaScript and cannot be used here\nhttps://svelte.dev/e/unexpected_reserved_word`);
}

/**
 * Unterminated string constant
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function unterminated_string_constant(node) {
	e(node, 'unterminated_string_constant', `Unterminated string constant\nhttps://svelte.dev/e/unterminated_string_constant`);
}

/**
 * Void elements cannot have children or closing tags
 * @param {null | number | NodeLike} node
 * @returns {never}
 */
function void_element_invalid_content(node) {
	e(node, 'void_element_invalid_content', `Void elements cannot have children or closing tags\nhttps://svelte.dev/e/void_element_invalid_content`);
}

/** @import { Parser } from '../index.js' */

/**
 * @param {number} num
 * @returns {number} Infinity if {@link num} is negative, else {@link num}.
 */
function infinity_if_negative(num) {
	if (num < 0) {
		return Infinity;
	}
	return num;
}

/**
 * @param {string} string The string to search.
 * @param {number} search_start_index The index to start searching at.
 * @param {"'" | '"' | '`'} string_start_char The character that started this string.
 * @returns {number} The index of the end of this string expression, or `Infinity` if not found.
 */
function find_string_end(string, search_start_index, string_start_char) {
	let string_to_search;
	if (string_start_char === '`') {
		string_to_search = string;
	} else {
		// we could slice at the search start index, but this way the index remains valid
		string_to_search = string.slice(
			0,
			infinity_if_negative(string.indexOf('\n', search_start_index))
		);
	}

	return find_unescaped_char(string_to_search, search_start_index, string_start_char);
}

/**
 * @param {string} string The string to search.
 * @param {number} search_start_index The index to start searching at.
 * @returns {number} The index of the end of this regex expression, or `Infinity` if not found.
 */
function find_regex_end(string, search_start_index) {
	return find_unescaped_char(string, search_start_index, '/');
}

/**
 *
 * @param {string} string The string to search.
 * @param {number} search_start_index The index to begin the search at.
 * @param {string} char The character to search for.
 * @returns {number} The index of the first unescaped instance of {@link char}, or `Infinity` if not found.
 */
function find_unescaped_char(string, search_start_index, char) {
	let i = search_start_index;
	while (true) {
		const found_index = string.indexOf(char, i);
		if (found_index === -1) {
			return Infinity;
		}
		if (count_leading_backslashes(string, found_index - 1) % 2 === 0) {
			return found_index;
		}
		i = found_index + 1;
	}
}

/**
 * Count consecutive leading backslashes before {@link search_start_index}.
 *
 * @example
 * ```js
 * count_leading_backslashes('\\\\\\foo', 2); // 3 (the backslashes have to be escaped in the string literal, there are three in reality)
 * ```
 *
 * @param {string} string The string to search.
 * @param {number} search_start_index The index to begin the search at.
 */
function count_leading_backslashes(string, search_start_index) {
	let i = search_start_index;
	let count = 0;
	while (string[i] === '\\') {
		count++;
		i--;
	}
	return count;
}

/**
 * Finds the corresponding closing bracket, ignoring brackets found inside comments, strings, or regex expressions.
 * @param {string} template The string to search.
 * @param {number} index The index to begin the search at.
 * @param {string} open The opening bracket (ex: `'{'` will search for `'}'`).
 * @returns {number | undefined} The index of the closing bracket, or undefined if not found.
 */
function find_matching_bracket(template, index, open) {
	const close = default_brackets[open];
	let brackets = 1;
	let i = index;
	while (brackets > 0 && i < template.length) {
		const char = template[i];
		switch (char) {
			case "'":
			case '"':
			case '`':
				i = find_string_end(template, i + 1, char) + 1;
				continue;
			case '/': {
				const next_char = template[i + 1];
				if (!next_char) continue;
				if (next_char === '/') {
					i = infinity_if_negative(template.indexOf('\n', i + 1)) + '\n'.length;
					continue;
				}
				if (next_char === '*') {
					i = infinity_if_negative(template.indexOf('*/', i + 1)) + '*/'.length;
					continue;
				}
				i = find_regex_end(template, i + 1) + '/'.length;
				continue;
			}
			default: {
				const char = template[i];
				if (char === open) {
					brackets++;
				} else if (char === close) {
					brackets--;
				}
				if (brackets === 0) {
					return i;
				}
				i++;
			}
		}
	}
	return undefined;
}

/** @type {Record<string, string>} */
const default_brackets = {
	'{': '}',
	'(': ')',
	'[': ']'
};

/**
 * @param {Parser} parser
 * @param {number} start
 * @param {Record<string, string>} brackets
 */
function match_bracket(parser, start, brackets = default_brackets) {
	const close = Object.values(brackets);
	const bracket_stack = [];

	let i = start;

	while (i < parser.template.length) {
		let char = parser.template[i++];

		if (char === "'" || char === '"' || char === '`') {
			i = match_quote(parser, i, char);
			continue;
		}

		if (char in brackets) {
			bracket_stack.push(char);
		} else if (close.includes(char)) {
			const popped = /** @type {string} */ (bracket_stack.pop());
			const expected = /** @type {string} */ (brackets[popped]);

			if (char !== expected) {
				expected_token(i - 1, expected);
			}

			if (bracket_stack.length === 0) {
				return i;
			}
		}
	}

	unexpected_eof(parser.template.length);
}

/**
 * @param {Parser} parser
 * @param {number} start
 * @param {string} quote
 */
function match_quote(parser, start, quote) {
	let is_escaped = false;
	let i = start;

	while (i < parser.template.length) {
		const char = parser.template[i++];

		if (is_escaped) {
			is_escaped = false;
			continue;
		}

		if (char === quote) {
			return i;
		}

		if (char === '\\') {
			is_escaped = true;
		}

		if (quote === '`' && char === '$' && parser.template[i] === '{') {
			i = match_bracket(parser, i);
		}
	}

	unterminated_string_constant(start);
}

/** @import { Expression } from 'estree' */
/** @import { Parser } from '../index.js' */

/**
 * @param {Parser} parser
 * @param {string} [opening_token]
 * @returns {Expression | undefined}
 */
function get_loose_identifier(parser, opening_token) {
	// Find the next } and treat it as the end of the expression
	const end = find_matching_bracket(parser.template, parser.index, opening_token ?? '{');
	if (end) {
		const start = parser.index;
		parser.index = end;
		// We don't know what the expression is and signal this by returning an empty identifier
		return {
			type: 'Identifier',
			start,
			end,
			name: ''
		};
	}
}

/**
 * @param {Parser} parser
 * @param {string} [opening_token]
 * @param {boolean} [disallow_loose]
 * @returns {Expression}
 */
function read_expression(parser, opening_token, disallow_loose) {
	try {
		let comment_index = parser.root.comments.length;

		const node = parse_expression_at(
			parser.template,
			parser.root.comments,
			parser.ts,
			parser.index
		);

		let num_parens = 0;

		let i = parser.root.comments.length;
		while (i-- > comment_index) {
			const comment = parser.root.comments[i];
			if (comment.end < node.start) {
				parser.index = comment.end;
				break;
			}
		}

		for (let i = parser.index; i < /** @type {number} */ (node.start); i += 1) {
			if (parser.template[i] === '(') num_parens += 1;
		}

		let index = /** @type {number} */ (node.end);

		const last_comment = parser.root.comments.at(-1);
		if (last_comment && last_comment.end > index) index = last_comment.end;

		while (num_parens > 0) {
			const char = parser.template[index];

			if (char === ')') {
				num_parens -= 1;
			} else if (!regex_whitespace.test(char)) {
				expected_token(index, ')');
			}

			index += 1;
		}

		parser.index = index;

		return /** @type {Expression} */ (node);
	} catch (err) {
		// If we are in an each loop we need the error to be thrown in cases like
		// `as { y = z }` so we still throw and handle the error there
		if (parser.loose && !disallow_loose) {
			const expression = get_loose_identifier(parser, opening_token);
			if (expression) {
				return expression;
			}
		}

		parser.acorn_error(err);
	}
}

/**
 * @param {string} str
 * @returns {string}
 */
function sanitize_template_string(str) {
	return str.replace(/(`|\${|\\)/g, '\\$1');
}

/** @import * as ESTree from 'estree' */

/**
 * @param {Array<ESTree.Expression | ESTree.SpreadElement | null>} elements
 * @returns {ESTree.ArrayExpression}
 */
function array(elements = []) {
	return { type: 'ArrayExpression', elements };
}

/**
 * @param {Array<ESTree.Pattern | null>} elements
 * @returns {ESTree.ArrayPattern}
 */
function array_pattern(elements) {
	return { type: 'ArrayPattern', elements };
}

/**
 * @param {ESTree.Pattern} left
 * @param {ESTree.Expression} right
 * @returns {ESTree.AssignmentPattern}
 */
function assignment_pattern(left, right) {
	return { type: 'AssignmentPattern', left, right };
}

/**
 * @param {Array<ESTree.Pattern>} params
 * @param {ESTree.BlockStatement | ESTree.Expression} body
 * @param {boolean} async
 * @returns {ESTree.ArrowFunctionExpression}
 */
function arrow(params, body, async = false) {
	return {
		type: 'ArrowFunctionExpression',
		params,
		body,
		expression: body.type !== 'BlockStatement',
		generator: false,
		async
	};
}

/**
 * @param {ESTree.AssignmentOperator} operator
 * @param {ESTree.Pattern} left
 * @param {ESTree.Expression} right
 * @returns {ESTree.AssignmentExpression}
 */
function assignment(operator, left, right) {
	return { type: 'AssignmentExpression', operator, left, right };
}

/**
 * @param {ESTree.Expression} argument
 * @returns {ESTree.AwaitExpression}
 */
function await_builder(argument) {
	return { type: 'AwaitExpression', argument };
}

/**
 * @param {ESTree.BinaryOperator} operator
 * @param {ESTree.Expression} left
 * @param {ESTree.Expression} right
 * @returns {ESTree.BinaryExpression}
 */
function binary$1(operator, left, right) {
	return { type: 'BinaryExpression', operator, left, right };
}

/**
 * @param {ESTree.Statement[]} body
 * @returns {ESTree.BlockStatement}
 */
function block(body) {
	return { type: 'BlockStatement', body };
}

/**
 * @param {string} name
 * @param {ESTree.Statement} body
 * @returns {ESTree.LabeledStatement}
 */
function labeled(name, body) {
	return { type: 'LabeledStatement', label: id$2(name), body };
}

/**
 * @param {string | ESTree.Expression} callee
 * @param {...(ESTree.Expression | ESTree.SpreadElement | false | undefined | null)} args
 * @returns {ESTree.CallExpression}
 */
function call(callee, ...args) {
	if (typeof callee === 'string') callee = id$2(callee);
	args = args.slice();

	// replacing missing arguments with `void(0)`, unless they're at the end in which case remove them
	let i = args.length;
	let popping = true;
	while (i--) {
		if (!args[i]) {
			if (popping) {
				args.pop();
			} else {
				args[i] = void0;
			}
		} else {
			popping = false;
		}
	}

	return {
		type: 'CallExpression',
		callee,
		arguments: /** @type {Array<ESTree.Expression | ESTree.SpreadElement>} */ (args),
		optional: false
	};
}

/**
 * @param {string | ESTree.Expression} callee
 * @param {...ESTree.Expression} args
 * @returns {ESTree.ChainExpression}
 */
function maybe_call(callee, ...args) {
	const expression = /** @type {ESTree.SimpleCallExpression} */ (call(callee, ...args));
	expression.optional = true;

	return {
		type: 'ChainExpression',
		expression
	};
}

/**
 * @param {ESTree.UnaryOperator} operator
 * @param {ESTree.Expression} argument
 * @returns {ESTree.UnaryExpression}
 */
function unary$1(operator, argument) {
	return { type: 'UnaryExpression', argument, operator, prefix: true };
}

const void0 = unary$1('void', literal(0));

/**
 * @param {ESTree.LogicalOperator} operator
 * @param {ESTree.Expression} left
 * @param {ESTree.Expression} right
 * @returns {ESTree.LogicalExpression}
 */
function logical$1(operator, left, right) {
	return { type: 'LogicalExpression', operator, left, right };
}

/**
 * @param {ESTree.VariableDeclaration['kind']} kind
 * @param {ESTree.VariableDeclarator[]} declarations
 * @returns {ESTree.VariableDeclaration}
 */
function declaration$2(kind, declarations) {
	return {
		type: 'VariableDeclaration',
		kind,
		declarations
	};
}

/**
 * @param {ESTree.Pattern | string} pattern
 * @param {ESTree.Expression | null} [init]
 * @returns {ESTree.VariableDeclarator}
 */
function declarator(pattern, init) {
	if (typeof pattern === 'string') pattern = id$2(pattern);
	return { type: 'VariableDeclarator', id: pattern, init };
}

/** @type {ESTree.EmptyStatement} */
const empty = {
	type: 'EmptyStatement'
};

/**
 * @param {ESTree.Expression | ESTree.MaybeNamedClassDeclaration | ESTree.MaybeNamedFunctionDeclaration} declaration
 * @returns {ESTree.ExportDefaultDeclaration}
 */
function export_default(declaration) {
	return { type: 'ExportDefaultDeclaration', declaration };
}

/**
 * @param {ESTree.VariableDeclaration | ESTree.Pattern} left
 * @param {ESTree.Expression} right
 * @param {ESTree.Statement} body
 * @param {boolean} [_await]
 * @returns {ESTree.ForOfStatement}
 */
function for_of(left, right, body, _await = false) {
	return {
		type: 'ForOfStatement',
		left,
		right,
		body,
		await: _await
	};
}

/**
 * @param {ESTree.Identifier} id
 * @param {ESTree.Pattern[]} params
 * @param {ESTree.BlockStatement} body
 * @param {boolean} async
 * @returns {ESTree.FunctionDeclaration}
 */
function function_declaration(id, params, body, async = false) {
	return {
		type: 'FunctionDeclaration',
		id,
		params,
		body,
		generator: false,
		async
	};
}

/**
 * @param {string} name
 * @param {ESTree.Statement[]} body
 * @returns {ESTree.Property & { value: ESTree.FunctionExpression}}}
 */
function get$1(name, body) {
	return prop('get', key(name), function_builder(null, [], block(body)));
}

/**
 * @param {string} name
 * @param {ESTree.SourceLocation | null} [loc]
 * @returns {ESTree.Identifier}
 */
function id$2(name, loc) {
	const node = /** @type {ESTree.Identifier} */ ({ type: 'Identifier', name });
	if (loc) node.loc = loc;

	return node;
}

/**
 * @param {string} name
 * @returns {ESTree.PrivateIdentifier}
 */
function private_id(name) {
	return { type: 'PrivateIdentifier', name };
}

/**
 * @param {string} local
 * @returns {ESTree.ImportNamespaceSpecifier}
 */
function import_namespace(local) {
	return {
		type: 'ImportNamespaceSpecifier',
		local: id$2(local)
	};
}

/**
 * @param {string} name
 * @param {ESTree.Expression} value
 * @returns {ESTree.Property}
 */
function init(name, value) {
	return prop('init', key(name), value);
}

/**
 * @param {string | boolean | null | number | RegExp} value
 * @returns {ESTree.Literal}
 */
function literal(value) {
	// @ts-expect-error we don't want to muck around with bigint here
	return { type: 'Literal', value };
}

/**
 * @param {ESTree.Expression | ESTree.Super} object
 * @param {string | ESTree.Expression | ESTree.PrivateIdentifier} property
 * @param {boolean} computed
 * @param {boolean} optional
 * @returns {ESTree.MemberExpression}
 */
function member(object, property, computed = false, optional = false) {
	if (typeof property === 'string') {
		property = id$2(property);
	}

	return { type: 'MemberExpression', object, property, computed, optional };
}

/**
 * @param {string} path
 * @returns {ESTree.Identifier | ESTree.MemberExpression}
 */
function member_id(path) {
	const parts = path.split('.');

	/** @type {ESTree.Identifier | ESTree.MemberExpression} */
	let expression = id$2(parts[0]);

	for (let i = 1; i < parts.length; i += 1) {
		expression = member(expression, id$2(parts[i]));
	}
	return expression;
}

/**
 * @param {Array<ESTree.Property | ESTree.SpreadElement>} properties
 * @returns {ESTree.ObjectExpression}
 */
function object$2(properties) {
	return { type: 'ObjectExpression', properties };
}

/**
 * @param {Array<ESTree.RestElement | ESTree.AssignmentProperty | ESTree.Property>} properties
 * @returns {ESTree.ObjectPattern}
 */
function object_pattern(properties) {
	// @ts-expect-error the types appear to be wrong
	return { type: 'ObjectPattern', properties };
}

/**
 * @template {ESTree.Expression} Value
 * @param {'init' | 'get' | 'set'} kind
 * @param {ESTree.Expression} key
 * @param {Value} value
 * @param {boolean} computed
 * @returns {ESTree.Property & { value: Value }}
 */
function prop(kind, key, value, computed = false) {
	return { type: 'Property', kind, key, value, method: false, shorthand: false, computed };
}

/**
 * @param {ESTree.Expression | ESTree.PrivateIdentifier} key
 * @param {ESTree.Expression | null | undefined} value
 * @param {boolean} computed
 * @param {boolean} is_static
 * @returns {ESTree.PropertyDefinition}
 */
function prop_def(key, value, computed = false, is_static = false) {
	return {
		type: 'PropertyDefinition',
		decorators: [],
		key,
		value,
		computed,
		static: is_static
	};
}

/**
 * @param {string} cooked
 * @param {boolean} tail
 * @returns {ESTree.TemplateElement}
 */
function quasi(cooked, tail = false) {
	const raw = sanitize_template_string(cooked);
	return { type: 'TemplateElement', value: { raw, cooked }, tail };
}

/**
 * @param {ESTree.Pattern} argument
 * @returns {ESTree.RestElement}
 */
function rest(argument) {
	return { type: 'RestElement', argument };
}

/**
 * @param {ESTree.Expression[]} expressions
 * @returns {ESTree.SequenceExpression}
 */
function sequence(expressions) {
	return { type: 'SequenceExpression', expressions };
}

/**
 * @param {string} name
 * @param {ESTree.Statement[]} body
 * @returns {ESTree.Property & { value: ESTree.FunctionExpression}}
 */
function set(name, body) {
	return prop('set', key(name), function_builder(null, [id$2('$$value')], block(body)));
}

/**
 * @param {ESTree.Expression} argument
 * @returns {ESTree.SpreadElement}
 */
function spread(argument) {
	return { type: 'SpreadElement', argument };
}

/**
 * @param {ESTree.Expression} expression
 * @returns {ESTree.ExpressionStatement}
 */
function stmt(expression) {
	return { type: 'ExpressionStatement', expression };
}

/**
 * @param {ESTree.TemplateElement[]} elements
 * @param {ESTree.Expression[]} expressions
 * @returns {ESTree.TemplateLiteral}
 */
function template(elements, expressions) {
	return { type: 'TemplateLiteral', quasis: elements, expressions };
}

/**
 * @param {ESTree.Expression | ESTree.BlockStatement} expression
 * @param {boolean} [async]
 * @returns {ESTree.Expression}
 */
function thunk(expression, async = false) {
	return unthunk(arrow([], expression, async));
}

/**
 * Replace "(arg) => func(arg)" to "func"
 * @param {ESTree.ArrowFunctionExpression} expression
 * @returns {ESTree.Expression}
 */
function unthunk(expression) {
	// optimize `async () => await x()`, but not `async () => await x(await y)`
	if (expression.async && expression.body.type === 'AwaitExpression') {
		if (!has_await_expression(expression.body.argument)) {
			return unthunk(arrow(expression.params, expression.body.argument));
		}
	}

	if (
		expression.async === false &&
		expression.body.type === 'CallExpression' &&
		expression.body.callee.type === 'Identifier' &&
		expression.params.length === expression.body.arguments.length &&
		expression.params.every((param, index) => {
			const arg = /** @type {ESTree.SimpleCallExpression} */ (expression.body).arguments[index];
			return param.type === 'Identifier' && arg.type === 'Identifier' && param.name === arg.name;
		})
	) {
		return expression.body.callee;
	}
	return expression;
}

/**
 *
 * @param {string | ESTree.Expression} expression
 * @param  {...ESTree.Expression} args
 * @returns {ESTree.NewExpression}
 */
function new_builder(expression, ...args) {
	if (typeof expression === 'string') expression = id$2(expression);

	return {
		callee: expression,
		arguments: args,
		type: 'NewExpression'
	};
}

/**
 * @param {ESTree.UpdateOperator} operator
 * @param {ESTree.Expression} argument
 * @param {boolean} prefix
 * @returns {ESTree.UpdateExpression}
 */
function update(operator, argument, prefix = false) {
	return { type: 'UpdateExpression', operator, argument, prefix };
}

/**
 * @param {ESTree.Expression} test
 * @param {ESTree.Statement} body
 * @returns {ESTree.DoWhileStatement}
 */
function do_while(test, body) {
	return { type: 'DoWhileStatement', test, body };
}

const true_instance = literal(true);
const false_instance = literal(false);
const null_instance = literal(null);

/** @type {ESTree.DebuggerStatement} */
const debugger_builder = {
	type: 'DebuggerStatement'
};

/** @type {ESTree.ThisExpression} */
const this_instance = {
	type: 'ThisExpression'
};

/**
 * @param {string | ESTree.Pattern} pattern
 * @param {ESTree.Expression | null} [init]
 * @returns {ESTree.VariableDeclaration}
 */
function let_builder(pattern, init) {
	return declaration$2('let', [declarator(pattern, init)]);
}

/**
 * @param {string | ESTree.Pattern} pattern
 * @param {ESTree.Expression | null} init
 * @returns {ESTree.VariableDeclaration}
 */
function const_builder(pattern, init) {
	return declaration$2('const', [declarator(pattern, init)]);
}

/**
 * @param {string | ESTree.Pattern} pattern
 * @param {ESTree.Expression | null} [init]
 * @returns {ESTree.VariableDeclaration}
 */
function var_builder(pattern, init) {
	return declaration$2('var', [declarator(pattern, init)]);
}

/**
 *
 * @param {ESTree.VariableDeclaration | ESTree.Expression | null} init
 * @param {ESTree.Expression} test
 * @param {ESTree.Expression} update
 * @param {ESTree.Statement} body
 * @returns {ESTree.ForStatement}
 */
function for_builder(init, test, update, body) {
	return { type: 'ForStatement', init, test, update, body };
}

/**
 *
 * @param {'constructor' | 'method' | 'get' | 'set'} kind
 * @param {ESTree.Expression | ESTree.PrivateIdentifier} key
 * @param {ESTree.Pattern[]} params
 * @param {ESTree.Statement[]} body
 * @param {boolean} computed
 * @param {boolean} is_static
 * @returns {ESTree.MethodDefinition}
 */
function method(kind, key, params, body, computed = false, is_static = false) {
	return {
		type: 'MethodDefinition',
		decorators: [],
		key,
		kind,
		value: function_builder(null, params, block(body)),
		computed,
		static: is_static
	};
}

/**
 *
 * @param {ESTree.Identifier | null} id
 * @param {ESTree.Pattern[]} params
 * @param {ESTree.BlockStatement} body
 * @returns {ESTree.FunctionExpression}
 */
function function_builder(id, params, body, async = false) {
	return {
		type: 'FunctionExpression',
		id,
		params,
		body,
		generator: false,
		async
	};
}

/**
 * @param {ESTree.Expression} test
 * @param {ESTree.Statement} consequent
 * @param {ESTree.Statement} [alternate]
 * @returns {ESTree.IfStatement}
 */
function if_builder(test, consequent, alternate) {
	return { type: 'IfStatement', test, consequent, alternate };
}

/**
 * @param {string} as
 * @param {string} source
 * @returns {ESTree.ImportDeclaration}
 */
function import_all(as, source) {
	return {
		type: 'ImportDeclaration',
		attributes: [],
		source: literal(source),
		specifiers: [import_namespace(as)]
	};
}

/**
 * @param {Array<[string, string]>} parts
 * @param {string} source
 * @returns {ESTree.ImportDeclaration}
 */
function imports(parts, source) {
	return {
		type: 'ImportDeclaration',
		attributes: [],
		source: literal(source),
		specifiers: parts.map((p) => ({
			type: 'ImportSpecifier',
			imported: id$2(p[0]),
			local: id$2(p[1])
		}))
	};
}

/**
 * @param {ESTree.Expression | null} argument
 * @returns {ESTree.ReturnStatement}
 */
function return_builder(argument = null) {
	return { type: 'ReturnStatement', argument };
}

/**
 * @param {string} str
 * @returns {ESTree.ThrowStatement}
 */
function throw_error$1(str) {
	return {
		type: 'ThrowStatement',
		argument: new_builder('Error', literal(str))
	};
}

/**
 * @param {string} name
 * @returns {ESTree.Expression}
 */
function key(name) {
	return regex_is_valid_identifier.test(name) ? id$2(name) : literal(name);
}

/** @import { AST, Scope } from '#compiler' */
/** @import * as ESTree from 'estree' */

/**
 * Gets the left-most identifier of a member expression or identifier.
 * @param {ESTree.MemberExpression | ESTree.Identifier} expression
 * @returns {ESTree.Identifier | null}
 */
function object$1(expression) {
	while (expression.type === 'MemberExpression') {
		expression = /** @type {ESTree.MemberExpression | ESTree.Identifier} */ (expression.object);
	}

	if (expression.type !== 'Identifier') {
		return null;
	}

	return expression;
}

/**
 * Returns true if the attribute contains a single static text node.
 * @param {AST.Attribute} attribute
 * @returns {attribute is AST.Attribute & { value: [AST.Text] }}
 */
function is_text_attribute(attribute) {
	return (
		Array.isArray(attribute.value) &&
		attribute.value.length === 1 &&
		attribute.value[0].type === 'Text'
	);
}

/**
 * Returns true if the attribute contains a single expression node.
 * In Svelte 5, this also includes a single expression node wrapped in an array.
 * TODO change that in a future version
 * @param {AST.Attribute} attribute
 * @returns {attribute is AST.Attribute & { value: [AST.ExpressionTag] | AST.ExpressionTag }}
 */
function is_expression_attribute(attribute) {
	return (
		(attribute.value !== true && !Array.isArray(attribute.value)) ||
		(Array.isArray(attribute.value) &&
			attribute.value.length === 1 &&
			attribute.value[0].type === 'ExpressionTag')
	);
}

/**
 * Returns the single attribute expression node.
 * In Svelte 5, this also includes a single expression node wrapped in an array.
 * TODO change that in a future version
 * @param { AST.Attribute & { value: [AST.ExpressionTag] | AST.ExpressionTag }} attribute
 * @returns {ESTree.Expression}
 */
function get_attribute_expression(attribute) {
	return Array.isArray(attribute.value)
		? /** @type {AST.ExpressionTag} */ (attribute.value[0]).expression
		: attribute.value.expression;
}

/**
 * Returns the expression chunks of an attribute value
 * @param {AST.Attribute['value']} value
 * @returns {Array<AST.Text | AST.ExpressionTag>}
 */
function get_attribute_chunks(value) {
	return Array.isArray(value) ? value : typeof value === 'boolean' ? [] : [value];
}

/**
 * Returns true if the attribute starts with `on` and contains a single expression node.
 * @param {AST.Attribute} attribute
 * @returns {attribute is AST.Attribute & { value: [AST.ExpressionTag] | AST.ExpressionTag }}
 */
function is_event_attribute(attribute) {
	return is_expression_attribute(attribute) && attribute.name.startsWith('on');
}

/**
 * Extracts all identifiers and member expressions from a pattern.
 * @param {ESTree.Pattern} pattern
 * @param {Array<ESTree.Identifier | ESTree.MemberExpression>} [nodes]
 * @returns {Array<ESTree.Identifier | ESTree.MemberExpression>}
 */
function unwrap_pattern(pattern, nodes = []) {
	switch (pattern.type) {
		case 'Identifier':
			nodes.push(pattern);
			break;

		case 'MemberExpression':
			// member expressions can be part of an assignment pattern, but not a binding pattern
			// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#binding_and_assignment
			nodes.push(pattern);
			break;

		case 'ObjectPattern':
			for (const prop of pattern.properties) {
				if (prop.type === 'RestElement') {
					unwrap_pattern(prop.argument, nodes);
				} else {
					unwrap_pattern(prop.value, nodes);
				}
			}

			break;

		case 'ArrayPattern':
			for (const element of pattern.elements) {
				if (element) unwrap_pattern(element, nodes);
			}

			break;

		case 'RestElement':
			unwrap_pattern(pattern.argument, nodes);
			break;

		case 'AssignmentPattern':
			unwrap_pattern(pattern.left, nodes);
			break;
	}

	return nodes;
}

/**
 * Extracts all identifiers from a pattern.
 * @param {ESTree.Pattern} pattern
 * @returns {ESTree.Identifier[]}
 */
function extract_identifiers(pattern) {
	return unwrap_pattern(pattern, []).filter((node) => node.type === 'Identifier');
}

/**
 * Extracts all identifiers and a stringified keypath from an expression.
 * TODO replace this with `expression.dependencies`
 * @param {ESTree.Expression} expr
 * @returns {[keypath: string, ids: ESTree.Identifier[]]}
 */
function extract_all_identifiers_from_expression(expr) {
	/** @type {ESTree.Identifier[]} */
	let nodes = [];
	/** @type {string[]} */
	let keypath = [];

	walk$1(
		expr,
		{},
		{
			Identifier(node, { path }) {
				const parent = path.at(-1);
				if (parent?.type !== 'MemberExpression' || parent.property !== node || parent.computed) {
					nodes.push(node);
				}

				if (parent?.type === 'MemberExpression' && parent.computed && parent.property === node) {
					keypath.push(`[${node.name}]`);
				} else {
					keypath.push(node.name);
				}
			},
			Literal(node, { path }) {
				const value = typeof node.value === 'string' ? `"${node.value}"` : String(node.value);
				const parent = path.at(-1);
				if (parent?.type === 'MemberExpression' && parent.computed && parent.property === node) {
					keypath.push(`[${value}]`);
				} else {
					keypath.push(value);
				}
			},
			ThisExpression(_, { next }) {
				keypath.push('this');
				next();
			}
		}
	);

	return [keypath.join('.'), nodes];
}

/**
 * Extracts all leaf identifiers from a destructuring expression.
 * @param {ESTree.Identifier | ESTree.ObjectExpression | ESTree.ArrayExpression} node
 * @param {ESTree.Identifier[]} [nodes]
 * @returns
 */
function extract_identifiers_from_destructuring(node, nodes = []) {
	// TODO This isn't complete, but it should be enough for our purposes
	switch (node.type) {
		case 'Identifier':
			nodes.push(node);
			break;

		case 'ObjectExpression':
			for (const prop of node.properties) {
				if (prop.type === 'Property') {
					extract_identifiers_from_destructuring(/** @type {any} */ (prop.value), nodes);
				} else {
					extract_identifiers_from_destructuring(/** @type {any} */ (prop.argument), nodes);
				}
			}

			break;

		case 'ArrayExpression':
			for (const element of node.elements) {
				if (element) extract_identifiers_from_destructuring(/** @type {any} */ (element), nodes);
			}

			break;
	}

	return nodes;
}

/**
 * Represents the path of a destructured assignment from either a declaration
 * or assignment expression. For example, given `const { foo: { bar: baz } } = quux`,
 * the path of `baz` is `foo.bar`
 * @typedef {Object} DestructuredAssignment
 * @property {ESTree.Identifier | ESTree.MemberExpression} node The node the destructuring path end in. Can be a member expression only for assignment expressions
 * @property {boolean} is_rest `true` if this is a `...rest` destructuring
 * @property {boolean} has_default_value `true` if this has a fallback value like `const { foo = 'bar } = ..`
 * @property {ESTree.Expression} expression The value of the current path
 * This will be a call expression if a rest element or default is involved — e.g. `const { foo: { bar: baz = 42 }, ...rest } = quux` — since we can't represent `baz` or `rest` purely as a path
 * Will be an await expression in case of an async default value (`const { foo = await bar } = ...`)
 * @property {ESTree.Expression} update_expression Like `expression` but without default values.
 */

/**
 * Extracts all destructured assignments from a pattern.
 * For each `id` in the returned `inserts`, make sure to adjust the `name`.
 * @param {ESTree.Node} param
 * @param {ESTree.Expression} initial
 * @returns {{ inserts: Array<{ id: ESTree.Identifier, value: ESTree.Expression }>, paths: DestructuredAssignment[] }}
 */
function extract_paths(param, initial) {
	/**
	 * When dealing with array destructuring patterns (`let [a, b, c] = $derived(blah())`)
	 * we need an intermediate declaration that creates an array, since `blah()` could
	 * return a non-array-like iterator
	 * @type {Array<{ id: ESTree.Identifier, value: ESTree.Expression }>}
	 */
	const inserts = [];

	/** @type {DestructuredAssignment[]} */
	const paths = [];

	_extract_paths(paths, inserts, param, initial, initial, false);

	return { inserts, paths };
}

/**
 * @param {DestructuredAssignment[]} paths
 * @param {Array<{ id: ESTree.Identifier, value: ESTree.Expression }>} inserts
 * @param {ESTree.Node} param
 * @param {ESTree.Expression} expression
 * @param {ESTree.Expression} update_expression
 * @param {boolean} has_default_value
 * @returns {DestructuredAssignment[]}
 */
function _extract_paths(paths, inserts, param, expression, update_expression, has_default_value) {
	switch (param.type) {
		case 'Identifier':
		case 'MemberExpression':
			paths.push({
				node: param,
				is_rest: false,
				has_default_value,
				expression,
				update_expression
			});
			break;

		case 'ObjectPattern':
			for (const prop of param.properties) {
				if (prop.type === 'RestElement') {
					/** @type {ESTree.Expression[]} */
					const props = [];

					for (const p of param.properties) {
						if (p.type === 'Property' && p.key.type !== 'PrivateIdentifier') {
							if (p.key.type === 'Identifier' && !p.computed) {
								props.push(literal(p.key.name));
							} else if (p.key.type === 'Literal') {
								props.push(literal(String(p.key.value)));
							} else {
								props.push(call('String', p.key));
							}
						}
					}

					const rest_expression = call('$.exclude_from_object', expression, array(props));

					if (prop.argument.type === 'Identifier') {
						paths.push({
							node: prop.argument,
							is_rest: true,
							has_default_value,
							expression: rest_expression,
							update_expression: rest_expression
						});
					} else {
						_extract_paths(
							paths,
							inserts,
							prop.argument,
							rest_expression,
							rest_expression,
							has_default_value
						);
					}
				} else {
					const object_expression = member(
						expression,
						prop.key,
						prop.computed || prop.key.type !== 'Identifier'
					);

					_extract_paths(
						paths,
						inserts,
						prop.value,
						object_expression,
						object_expression,
						has_default_value
					);
				}
			}

			break;

		case 'ArrayPattern': {
			// we create an intermediate declaration to convert iterables to arrays if necessary.
			// the consumer is responsible for setting the name of the identifier
			const id = id$2('#');

			const value = call(
				'$.to_array',
				expression,
				param.elements.at(-1)?.type === 'RestElement' ? undefined : literal(param.elements.length)
			);

			inserts.push({ id, value });

			for (let i = 0; i < param.elements.length; i += 1) {
				const element = param.elements[i];
				if (element) {
					if (element.type === 'RestElement') {
						const rest_expression = call(member(id, 'slice'), literal(i));

						if (element.argument.type === 'Identifier') {
							paths.push({
								node: element.argument,
								is_rest: true,
								has_default_value,
								expression: rest_expression,
								update_expression: rest_expression
							});
						} else {
							_extract_paths(
								paths,
								inserts,
								element.argument,
								rest_expression,
								rest_expression,
								has_default_value
							);
						}
					} else {
						const array_expression = member(id, literal(i), true);

						_extract_paths(
							paths,
							inserts,
							element,
							array_expression,
							array_expression,
							has_default_value
						);
					}
				}
			}

			break;
		}

		case 'AssignmentPattern': {
			const fallback_expression = build_fallback(expression, param.right);

			if (param.left.type === 'Identifier') {
				paths.push({
					node: param.left,
					is_rest: false,
					has_default_value: true,
					expression: fallback_expression,
					update_expression
				});
			} else {
				_extract_paths(paths, inserts, param.left, fallback_expression, update_expression, true);
			}

			break;
		}
	}

	return paths;
}

/**
 * Like `path.at(x)`, but skips over `TSNonNullExpression` and `TSAsExpression` nodes and eases assertions a bit
 * by removing the `| undefined` from the resulting type.
 *
 * @template {AST.SvelteNode} T
 * @param {T[]} path
 * @param {number} at
 */
function get_parent(path, at) {
	let node = path.at(at);
	// @ts-expect-error
	if (node.type === 'TSNonNullExpression' || node.type === 'TSAsExpression') {
		return /** @type {T} */ (path.at(at < 0 ? at - 1 : at + 1));
	}
	return /** @type {T} */ (node);
}

/**
 * Returns `true` if the expression is an identifier, a literal, a function expression,
 * or a logical expression that only contains simple expressions. Used to determine whether
 * something needs to be treated as though accessing it could have side-effects (i.e.
 * reading signals prematurely)
 * @param {ESTree.Expression} node
 * @returns {boolean}
 */
function is_simple_expression(node) {
	if (
		node.type === 'Literal' ||
		node.type === 'Identifier' ||
		node.type === 'ArrowFunctionExpression' ||
		node.type === 'FunctionExpression'
	) {
		return true;
	}

	if (node.type === 'ConditionalExpression') {
		return (
			is_simple_expression(node.test) &&
			is_simple_expression(node.consequent) &&
			is_simple_expression(node.alternate)
		);
	}

	if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
		return (
			node.left.type !== 'PrivateIdentifier' &&
			is_simple_expression(node.left) &&
			is_simple_expression(node.right)
		);
	}

	return false;
}

/**
 * @template {ESTree.SimpleCallExpression | ESTree.MemberExpression} T
 * @param {ESTree.ChainExpression & { expression : T } | T} node
 * @returns {T}
 */
function unwrap_optional(node) {
	return node.type === 'ChainExpression' ? node.expression : node;
}

/**
 * @param {ESTree.Expression | ESTree.Pattern} expression
 * @returns {boolean}
 */
function is_expression_async(expression) {
	switch (expression.type) {
		case 'AwaitExpression': {
			return true;
		}
		case 'ArrayPattern': {
			return expression.elements.some((element) => element && is_expression_async(element));
		}
		case 'ArrayExpression': {
			return expression.elements.some((element) => {
				if (!element) {
					return false;
				} else if (element.type === 'SpreadElement') {
					return is_expression_async(element.argument);
				} else {
					return is_expression_async(element);
				}
			});
		}
		case 'AssignmentPattern':
		case 'AssignmentExpression':
		case 'BinaryExpression':
		case 'LogicalExpression': {
			return (
				(expression.left.type !== 'PrivateIdentifier' && is_expression_async(expression.left)) ||
				is_expression_async(expression.right)
			);
		}
		case 'CallExpression':
		case 'NewExpression': {
			return (
				(expression.callee.type !== 'Super' && is_expression_async(expression.callee)) ||
				expression.arguments.some((element) => {
					if (element.type === 'SpreadElement') {
						return is_expression_async(element.argument);
					} else {
						return is_expression_async(element);
					}
				})
			);
		}
		case 'ChainExpression': {
			return is_expression_async(expression.expression);
		}
		case 'ConditionalExpression': {
			return (
				is_expression_async(expression.test) ||
				is_expression_async(expression.alternate) ||
				is_expression_async(expression.consequent)
			);
		}
		case 'ImportExpression': {
			return is_expression_async(expression.source);
		}
		case 'MemberExpression': {
			return (
				(expression.object.type !== 'Super' && is_expression_async(expression.object)) ||
				(expression.property.type !== 'PrivateIdentifier' &&
					is_expression_async(expression.property))
			);
		}
		case 'ObjectPattern':
		case 'ObjectExpression': {
			return expression.properties.some((property) => {
				if (property.type === 'SpreadElement') {
					return is_expression_async(property.argument);
				} else if (property.type === 'Property') {
					return (
						(property.key.type !== 'PrivateIdentifier' && is_expression_async(property.key)) ||
						is_expression_async(property.value)
					);
				}
			});
		}
		case 'RestElement': {
			return is_expression_async(expression.argument);
		}
		case 'SequenceExpression':
		case 'TemplateLiteral': {
			return expression.expressions.some((subexpression) => is_expression_async(subexpression));
		}
		case 'TaggedTemplateExpression': {
			return is_expression_async(expression.tag) || is_expression_async(expression.quasi);
		}
		case 'UnaryExpression':
		case 'UpdateExpression': {
			return is_expression_async(expression.argument);
		}
		case 'YieldExpression': {
			return expression.argument ? is_expression_async(expression.argument) : false;
		}
		default:
			return false;
	}
}

/**
 *
 * @param {ESTree.Expression} expression
 * @param {ESTree.Expression} fallback
 */
function build_fallback(expression, fallback) {
	if (is_simple_expression(fallback)) {
		return call('$.fallback', expression, fallback);
	}

	if (fallback.type === 'AwaitExpression' && is_simple_expression(fallback.argument)) {
		return await_builder(call('$.fallback', expression, fallback.argument));
	}

	return is_expression_async(fallback)
		? await_builder(call('$.fallback', expression, thunk(fallback, true), true_instance))
		: call('$.fallback', expression, thunk(fallback), true_instance);
}

/**
 * @param {ESTree.AssignmentOperator} operator
 * @param {ESTree.Identifier | ESTree.MemberExpression} left
 * @param {ESTree.Expression} right
 */
function build_assignment_value(operator, left, right) {
	return operator === '='
		? right
		: // turn something like x += 1 into x = x + 1
			['||=', '&&=', '??='].includes(operator)
			? logical$1(/** @type {ESTree.LogicalOperator} */ (operator.slice(0, -1)), left, right)
			: binary$1(/** @type {ESTree.BinaryOperator} */ (operator.slice(0, -1)), left, right);
}

/**
 * @param {ESTree.Node} node
 */
function has_await_expression(node) {
	let has_await = false;

	walk$1(node, null, {
		AwaitExpression(_node, context) {
			has_await = true;
			context.stop();
		},
		// don't traverse into these
		FunctionDeclaration() {},
		FunctionExpression() {},
		ArrowFunctionExpression() {}
	});

	return has_await;
}

/**
 * Turns `await ...` to `(await $.save(...))()`
 * @param {ESTree.Expression} expression
 */
function save(expression) {
	return call(await_builder(call('$.save', expression)));
}

/** @import { Program } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { Parser } from '../index.js' */

const regex_closing_script_tag = /<\/script\s*>/;
const regex_starts_with_closing_script_tag = /^<\/script\s*>/;

const RESERVED_ATTRIBUTES = ['server', 'client', 'worker', 'test', 'default'];
const ALLOWED_ATTRIBUTES = ['context', 'generics', 'lang', 'module'];

/**
 * @param {Parser} parser
 * @param {number} start
 * @param {Array<AST.Attribute | AST.SpreadAttribute | AST.Directive | AST.AttachTag>} attributes
 * @returns {AST.Script}
 */
function read_script(parser, start, attributes) {
	const script_start = parser.index;
	const data = parser.read_until(regex_closing_script_tag);
	if (parser.index >= parser.template.length) {
		element_unclosed(parser.template.length, 'script');
	}

	const source =
		parser.template.slice(0, script_start).replace(regex_not_newline_characters, ' ') + data;
	parser.read(regex_starts_with_closing_script_tag);

	/** @type {Program} */
	let ast;

	try {
		ast = parse$4(source, parser.root.comments, parser.ts, true);
	} catch (err) {
		parser.acorn_error(err);
	}

	// TODO is this necessary?
	ast.start = script_start;

	/** @type {'default' | 'module'} */
	let context = 'default';

	for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) {
		if (RESERVED_ATTRIBUTES.includes(attribute.name)) {
			script_reserved_attribute(attribute, attribute.name);
		}

		if (!ALLOWED_ATTRIBUTES.includes(attribute.name)) {
			script_unknown_attribute(attribute);
		}

		if (attribute.name === 'module') {
			if (attribute.value !== true) {
				// Deliberately a generic code to future-proof for potential other attributes
				script_invalid_attribute_value(attribute, attribute.name);
			}

			context = 'module';
		}

		if (attribute.name === 'context') {
			if (attribute.value === true || !is_text_attribute(attribute)) {
				script_invalid_context(attribute);
			}

			const value = attribute.value[0].data;

			if (value !== 'module') {
				script_invalid_context(attribute);
			}

			context = 'module';
		}
	}

	return {
		type: 'Script',
		start,
		end: parser.index,
		context,
		content: ast,
		// @ts-ignore
		attributes
	};
}

/** @import { AST } from '#compiler' */
/** @import { Parser } from '../index.js' */

const REGEX_MATCHER = /^[~^$*|]?=/;
const REGEX_CLOSING_BRACKET = /[\s\]]/;
const REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/; // only `i` and `s` are valid today, but make it future-proof
const REGEX_COMBINATOR = /^(\+|~|>|\|\|)/;
const REGEX_PERCENTAGE = /^\d+(\.\d+)?%/;
const REGEX_NTH_OF =
	/^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/;
const REGEX_WHITESPACE_OR_COLON = /[\s:]/;
const REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/;
const REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/;
const REGEX_UNICODE_SEQUENCE = /^\\[0-9a-fA-F]{1,6}(\r\n|\s)?/;
const REGEX_COMMENT_CLOSE = /\*\//;
const REGEX_HTML_COMMENT_CLOSE = /-->/;

/**
 * @param {Parser} parser
 * @param {number} start
 * @param {Array<AST.Attribute | AST.SpreadAttribute | AST.Directive | AST.AttachTag>} attributes
 * @returns {AST.CSS.StyleSheet}
 */
function read_style(parser, start, attributes) {
	const content_start = parser.index;
	const children = read_body(parser, '</style');
	const content_end = parser.index;

	parser.read(/^<\/style\s*>/);

	return {
		type: 'StyleSheet',
		start,
		end: parser.index,
		attributes,
		children,
		content: {
			start: content_start,
			end: content_end,
			styles: parser.template.slice(content_start, content_end),
			comment: null
		}
	};
}

/**
 * @param {Parser} parser
 * @param {string} close
 * @returns {any[]}
 */
function read_body(parser, close) {
	/** @type {Array<AST.CSS.Rule | AST.CSS.Atrule>} */
	const children = [];

	while (parser.index < parser.template.length) {
		allow_comment_or_whitespace(parser);

		if (parser.match(close)) {
			return children;
		}

		if (parser.match('@')) {
			children.push(read_at_rule(parser));
		} else {
			children.push(read_rule(parser));
		}
	}

	expected_token(parser.template.length, close);
}

/**
 * @param {Parser} parser
 * @returns {AST.CSS.Atrule}
 */
function read_at_rule(parser) {
	const start = parser.index;
	parser.eat('@', true);

	const name = read_identifier(parser);

	const prelude = read_value(parser);

	/** @type {AST.CSS.Block | null} */
	let block = null;

	if (parser.match('{')) {
		// e.g. `@media (...) {...}`
		block = read_block(parser);
	} else {
		// e.g. `@import '...'`
		parser.eat(';', true);
	}

	return {
		type: 'Atrule',
		start,
		end: parser.index,
		name,
		prelude,
		block
	};
}

/**
 * @param {Parser} parser
 * @returns {AST.CSS.Rule}
 */
function read_rule(parser) {
	const start = parser.index;

	return {
		type: 'Rule',
		prelude: read_selector_list(parser),
		block: read_block(parser),
		start,
		end: parser.index,
		metadata: {
			parent_rule: null,
			has_local_selectors: false,
			has_global_selectors: false,
			is_global_block: false
		}
	};
}

/**
 * @param {Parser} parser
 * @param {boolean} [inside_pseudo_class]
 * @returns {AST.CSS.SelectorList}
 */
function read_selector_list(parser, inside_pseudo_class = false) {
	/** @type {AST.CSS.ComplexSelector[]} */
	const children = [];

	allow_comment_or_whitespace(parser);

	const start = parser.index;

	while (parser.index < parser.template.length) {
		children.push(read_selector(parser, inside_pseudo_class));

		const end = parser.index;

		allow_comment_or_whitespace(parser);

		if (inside_pseudo_class ? parser.match(')') : parser.match('{')) {
			return {
				type: 'SelectorList',
				start,
				end,
				children
			};
		} else {
			parser.eat(',', true);
			allow_comment_or_whitespace(parser);
		}
	}

	unexpected_eof(parser.template.length);
}

/**
 * @param {Parser} parser
 * @param {boolean} [inside_pseudo_class]
 * @returns {AST.CSS.ComplexSelector}
 */
function read_selector(parser, inside_pseudo_class = false) {
	const list_start = parser.index;

	/** @type {AST.CSS.RelativeSelector[]} */
	const children = [];

	/**
	 * @param {AST.CSS.Combinator | null} combinator
	 * @param {number} start
	 * @returns {AST.CSS.RelativeSelector}
	 */
	function create_selector(combinator, start) {
		return {
			type: 'RelativeSelector',
			combinator,
			selectors: [],
			start,
			end: -1,
			metadata: {
				is_global: false,
				is_global_like: false,
				scoped: false
			}
		};
	}

	/** @type {AST.CSS.RelativeSelector} */
	let relative_selector = create_selector(null, parser.index);

	while (parser.index < parser.template.length) {
		let start = parser.index;

		if (parser.eat('&')) {
			relative_selector.selectors.push({
				type: 'NestingSelector',
				name: '&',
				start,
				end: parser.index
			});
		} else if (parser.eat('*')) {
			let name = '*';

			if (parser.eat('|')) {
				// * is the namespace (which we ignore)
				name = read_identifier(parser);
			}

			relative_selector.selectors.push({
				type: 'TypeSelector',
				name,
				start,
				end: parser.index
			});
		} else if (parser.eat('#')) {
			relative_selector.selectors.push({
				type: 'IdSelector',
				name: read_identifier(parser),
				start,
				end: parser.index
			});
		} else if (parser.eat('.')) {
			relative_selector.selectors.push({
				type: 'ClassSelector',
				name: read_identifier(parser),
				start,
				end: parser.index
			});
		} else if (parser.eat('::')) {
			relative_selector.selectors.push({
				type: 'PseudoElementSelector',
				name: read_identifier(parser),
				start,
				end: parser.index
			});
			// We read the inner selectors of a pseudo element to ensure it parses correctly,
			// but we don't do anything with the result.
			if (parser.eat('(')) {
				read_selector_list(parser, true);
				parser.eat(')', true);
			}
		} else if (parser.eat(':')) {
			const name = read_identifier(parser);

			/** @type {null | AST.CSS.SelectorList} */
			let args = null;

			if (parser.eat('(')) {
				args = read_selector_list(parser, true);
				parser.eat(')', true);
			}

			relative_selector.selectors.push({
				type: 'PseudoClassSelector',
				name,
				args,
				start,
				end: parser.index
			});
		} else if (parser.eat('[')) {
			parser.allow_whitespace();
			const name = read_identifier(parser);
			parser.allow_whitespace();

			/** @type {string | null} */
			let value = null;

			const matcher = parser.read(REGEX_MATCHER);

			if (matcher) {
				parser.allow_whitespace();
				value = read_attribute_value$1(parser);
			}

			parser.allow_whitespace();

			const flags = parser.read(REGEX_ATTRIBUTE_FLAGS);

			parser.allow_whitespace();
			parser.eat(']', true);

			relative_selector.selectors.push({
				type: 'AttributeSelector',
				start,
				end: parser.index,
				name,
				matcher,
				value,
				flags
			});
		} else if (inside_pseudo_class && parser.match_regex(REGEX_NTH_OF)) {
			// nth of matcher must come before combinator matcher to prevent collision else the '+' in '+2n-1' would be parsed as a combinator

			relative_selector.selectors.push({
				type: 'Nth',
				value: /**@type {string} */ (parser.read(REGEX_NTH_OF)),
				start,
				end: parser.index
			});
		} else if (parser.match_regex(REGEX_PERCENTAGE)) {
			relative_selector.selectors.push({
				type: 'Percentage',
				value: /** @type {string} */ (parser.read(REGEX_PERCENTAGE)),
				start,
				end: parser.index
			});
		} else if (!parser.match_regex(REGEX_COMBINATOR)) {
			let name = read_identifier(parser);

			if (parser.eat('|')) {
				// we ignore the namespace when trying to find matching element classes
				name = read_identifier(parser);
			}

			relative_selector.selectors.push({
				type: 'TypeSelector',
				name,
				start,
				end: parser.index
			});
		}

		const index = parser.index;
		allow_comment_or_whitespace(parser);

		if (parser.match(',') || (inside_pseudo_class ? parser.match(')') : parser.match('{'))) {
			// rewind, so we know whether to continue building the selector list
			parser.index = index;

			relative_selector.end = index;
			children.push(relative_selector);

			return {
				type: 'ComplexSelector',
				start: list_start,
				end: index,
				children,
				metadata: {
					rule: null,
					is_global: false,
					used: false
				}
			};
		}

		parser.index = index;
		const combinator = read_combinator(parser);

		if (combinator) {
			if (relative_selector.selectors.length > 0) {
				relative_selector.end = index;
				children.push(relative_selector);
			}

			// ...and start a new one
			relative_selector = create_selector(combinator, combinator.start);

			parser.allow_whitespace();

			if (parser.match(',') || (inside_pseudo_class ? parser.match(')') : parser.match('{'))) {
				css_selector_invalid(parser.index);
			}
		}
	}

	unexpected_eof(parser.template.length);
}

/**
 * @param {Parser} parser
 * @returns {AST.CSS.Combinator | null}
 */
function read_combinator(parser) {
	const start = parser.index;
	parser.allow_whitespace();

	const index = parser.index;
	const name = parser.read(REGEX_COMBINATOR);

	if (name) {
		const end = parser.index;
		parser.allow_whitespace();

		return {
			type: 'Combinator',
			name,
			start: index,
			end
		};
	}

	if (parser.index !== start) {
		return {
			type: 'Combinator',
			name: ' ',
			start,
			end: parser.index
		};
	}

	return null;
}

/**
 * @param {Parser} parser
 * @returns {AST.CSS.Block}
 */
function read_block(parser) {
	const start = parser.index;

	parser.eat('{', true);

	/** @type {Array<AST.CSS.Declaration | AST.CSS.Rule | AST.CSS.Atrule>} */
	const children = [];

	while (parser.index < parser.template.length) {
		allow_comment_or_whitespace(parser);

		if (parser.match('}')) {
			break;
		} else {
			children.push(read_block_item(parser));
		}
	}

	parser.eat('}', true);

	return {
		type: 'Block',
		start,
		end: parser.index,
		children
	};
}

/**
 * Reads a declaration, rule or at-rule
 *
 * @param {Parser} parser
 * @returns {AST.CSS.Declaration | AST.CSS.Rule | AST.CSS.Atrule}
 */
function read_block_item(parser) {
	if (parser.match('@')) {
		return read_at_rule(parser);
	}

	// read ahead to understand whether we're dealing with a declaration or a nested rule.
	// this involves some duplicated work, but avoids a try-catch that would disguise errors
	const start = parser.index;
	read_value(parser);
	const char = parser.template[parser.index];
	parser.index = start;

	return char === '{' ? read_rule(parser) : read_declaration(parser);
}

/**
 * @param {Parser} parser
 * @returns {AST.CSS.Declaration}
 */
function read_declaration(parser) {
	const start = parser.index;

	const property = parser.read_until(REGEX_WHITESPACE_OR_COLON);
	parser.allow_whitespace();
	parser.eat(':');
	let index = parser.index;
	parser.allow_whitespace();

	const value = read_value(parser);

	if (!value && !property.startsWith('--')) {
		css_empty_declaration({ start, end: index });
	}

	const end = parser.index;

	if (!parser.match('}')) {
		parser.eat(';', true);
	}

	return {
		type: 'Declaration',
		start,
		end,
		property,
		value
	};
}

/**
 * @param {Parser} parser
 * @returns {string}
 */
function read_value(parser) {
	let value = '';
	let escaped = false;
	let in_url = false;

	/** @type {null | '"' | "'"} */
	let quote_mark = null;

	while (parser.index < parser.template.length) {
		const char = parser.template[parser.index];

		if (escaped) {
			value += '\\' + char;
			escaped = false;
		} else if (char === '\\') {
			escaped = true;
		} else if (char === quote_mark) {
			quote_mark = null;
		} else if (char === ')') {
			in_url = false;
		} else if (quote_mark === null && (char === '"' || char === "'")) {
			quote_mark = char;
		} else if (char === '(' && value.slice(-3) === 'url') {
			in_url = true;
		} else if ((char === ';' || char === '{' || char === '}') && !in_url && !quote_mark) {
			return value.trim();
		}

		value += char;

		parser.index++;
	}

	unexpected_eof(parser.template.length);
}

/**
 * Read a property that may or may not be quoted, e.g.
 * `foo` or `'foo bar'` or `"foo bar"`
 * @param {Parser} parser
 */
function read_attribute_value$1(parser) {
	let value = '';
	let escaped = false;
	const quote_mark = parser.eat('"') ? '"' : parser.eat("'") ? "'" : null;

	while (parser.index < parser.template.length) {
		const char = parser.template[parser.index];
		if (escaped) {
			value += '\\' + char;
			escaped = false;
		} else if (char === '\\') {
			escaped = true;
		} else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) {
			if (quote_mark) {
				parser.eat(quote_mark, true);
			}

			return value.trim();
		} else {
			value += char;
		}

		parser.index++;
	}

	unexpected_eof(parser.template.length);
}

/**
 * https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
 * @param {Parser} parser
 */
function read_identifier(parser) {
	const start = parser.index;

	let identifier = '';

	if (parser.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) {
		css_expected_identifier(start);
	}

	while (parser.index < parser.template.length) {
		const char = parser.template[parser.index];
		if (char === '\\') {
			const sequence = parser.match_regex(REGEX_UNICODE_SEQUENCE);
			if (sequence) {
				identifier += String.fromCodePoint(parseInt(sequence.slice(1), 16));
				parser.index += sequence.length;
			} else {
				identifier += '\\' + parser.template[parser.index + 1];
				parser.index += 2;
			}
		} else if (
			/** @type {number} */ (char.codePointAt(0)) >= 160 ||
			REGEX_VALID_IDENTIFIER_CHAR.test(char)
		) {
			identifier += char;
			parser.index++;
		} else {
			break;
		}
	}

	if (identifier === '') {
		css_expected_identifier(start);
	}

	return identifier;
}

/** @param {Parser} parser */
function allow_comment_or_whitespace(parser) {
	parser.allow_whitespace();
	while (parser.match('/*') || parser.match('<!--')) {
		if (parser.eat('/*')) {
			parser.read_until(REGEX_COMMENT_CLOSE);
			parser.eat('*/', true);
		}

		if (parser.eat('<!--')) {
			parser.read_until(REGEX_HTML_COMMENT_CLOSE);
			parser.eat('-->', true);
		}

		parser.allow_whitespace();
	}
}

// https://html.spec.whatwg.org/entities.json from https://dev.w3.org/html5/html-author/charref
const entities = {
	'CounterClockwiseContourIntegral;': 8755,
	'ClockwiseContourIntegral;': 8754,
	'DoubleLongLeftRightArrow;': 10234,
	'NotNestedGreaterGreater;': 10914,
	'DiacriticalDoubleAcute;': 733,
	'NotSquareSupersetEqual;': 8931,
	'CloseCurlyDoubleQuote;': 8221,
	'DoubleContourIntegral;': 8751,
	'FilledVerySmallSquare;': 9642,
	'NegativeVeryThinSpace;': 8203,
	'NotPrecedesSlantEqual;': 8928,
	'NotRightTriangleEqual;': 8941,
	'NotSucceedsSlantEqual;': 8929,
	'CapitalDifferentialD;': 8517,
	'DoubleLeftRightArrow;': 8660,
	'DoubleLongRightArrow;': 10233,
	'EmptyVerySmallSquare;': 9643,
	'NestedGreaterGreater;': 8811,
	'NotDoubleVerticalBar;': 8742,
	'NotGreaterSlantEqual;': 10878,
	'NotLeftTriangleEqual;': 8940,
	'NotSquareSubsetEqual;': 8930,
	'OpenCurlyDoubleQuote;': 8220,
	'ReverseUpEquilibrium;': 10607,
	'DoubleLongLeftArrow;': 10232,
	'DownLeftRightVector;': 10576,
	'LeftArrowRightArrow;': 8646,
	'NegativeMediumSpace;': 8203,
	'NotGreaterFullEqual;': 8807,
	'NotRightTriangleBar;': 10704,
	'RightArrowLeftArrow;': 8644,
	'SquareSupersetEqual;': 8850,
	'leftrightsquigarrow;': 8621,
	'DownRightTeeVector;': 10591,
	'DownRightVectorBar;': 10583,
	'LongLeftRightArrow;': 10231,
	'Longleftrightarrow;': 10234,
	'NegativeThickSpace;': 8203,
	'NotLeftTriangleBar;': 10703,
	'PrecedesSlantEqual;': 8828,
	'ReverseEquilibrium;': 8651,
	'RightDoubleBracket;': 10215,
	'RightDownTeeVector;': 10589,
	'RightDownVectorBar;': 10581,
	'RightTriangleEqual;': 8885,
	'SquareIntersection;': 8851,
	'SucceedsSlantEqual;': 8829,
	'blacktriangleright;': 9656,
	'longleftrightarrow;': 10231,
	'DoubleUpDownArrow;': 8661,
	'DoubleVerticalBar;': 8741,
	'DownLeftTeeVector;': 10590,
	'DownLeftVectorBar;': 10582,
	'FilledSmallSquare;': 9724,
	'GreaterSlantEqual;': 10878,
	'LeftDoubleBracket;': 10214,
	'LeftDownTeeVector;': 10593,
	'LeftDownVectorBar;': 10585,
	'LeftTriangleEqual;': 8884,
	'NegativeThinSpace;': 8203,
	'NotGreaterGreater;': 8811,
	'NotLessSlantEqual;': 10877,
	'NotNestedLessLess;': 10913,
	'NotReverseElement;': 8716,
	'NotSquareSuperset;': 8848,
	'NotTildeFullEqual;': 8775,
	'RightAngleBracket;': 10217,
	'RightUpDownVector;': 10575,
	'SquareSubsetEqual;': 8849,
	'VerticalSeparator;': 10072,
	'blacktriangledown;': 9662,
	'blacktriangleleft;': 9666,
	'leftrightharpoons;': 8651,
	'rightleftharpoons;': 8652,
	'twoheadrightarrow;': 8608,
	'DiacriticalAcute;': 180,
	'DiacriticalGrave;': 96,
	'DiacriticalTilde;': 732,
	'DoubleRightArrow;': 8658,
	'DownArrowUpArrow;': 8693,
	'EmptySmallSquare;': 9723,
	'GreaterEqualLess;': 8923,
	'GreaterFullEqual;': 8807,
	'LeftAngleBracket;': 10216,
	'LeftUpDownVector;': 10577,
	'LessEqualGreater;': 8922,
	'NonBreakingSpace;': 160,
	'NotPrecedesEqual;': 10927,
	'NotRightTriangle;': 8939,
	'NotSucceedsEqual;': 10928,
	'NotSucceedsTilde;': 8831,
	'NotSupersetEqual;': 8841,
	'RightTriangleBar;': 10704,
	'RightUpTeeVector;': 10588,
	'RightUpVectorBar;': 10580,
	'UnderParenthesis;': 9181,
	'UpArrowDownArrow;': 8645,
	'circlearrowright;': 8635,
	'downharpoonright;': 8642,
	'ntrianglerighteq;': 8941,
	'rightharpoondown;': 8641,
	'rightrightarrows;': 8649,
	'twoheadleftarrow;': 8606,
	'vartriangleright;': 8883,
	'CloseCurlyQuote;': 8217,
	'ContourIntegral;': 8750,
	'DoubleDownArrow;': 8659,
	'DoubleLeftArrow;': 8656,
	'DownRightVector;': 8641,
	'LeftRightVector;': 10574,
	'LeftTriangleBar;': 10703,
	'LeftUpTeeVector;': 10592,
	'LeftUpVectorBar;': 10584,
	'LowerRightArrow;': 8600,
	'NotGreaterEqual;': 8817,
	'NotGreaterTilde;': 8821,
	'NotHumpDownHump;': 8782,
	'NotLeftTriangle;': 8938,
	'NotSquareSubset;': 8847,
	'OverParenthesis;': 9180,
	'RightDownVector;': 8642,
	'ShortRightArrow;': 8594,
	'UpperRightArrow;': 8599,
	'bigtriangledown;': 9661,
	'circlearrowleft;': 8634,
	'curvearrowright;': 8631,
	'downharpoonleft;': 8643,
	'leftharpoondown;': 8637,
	'leftrightarrows;': 8646,
	'nLeftrightarrow;': 8654,
	'nleftrightarrow;': 8622,
	'ntrianglelefteq;': 8940,
	'rightleftarrows;': 8644,
	'rightsquigarrow;': 8605,
	'rightthreetimes;': 8908,
	'straightepsilon;': 1013,
	'trianglerighteq;': 8885,
	'vartriangleleft;': 8882,
	'DiacriticalDot;': 729,
	'DoubleRightTee;': 8872,
	'DownLeftVector;': 8637,
	'GreaterGreater;': 10914,
	'HorizontalLine;': 9472,
	'InvisibleComma;': 8291,
	'InvisibleTimes;': 8290,
	'LeftDownVector;': 8643,
	'LeftRightArrow;': 8596,
	'Leftrightarrow;': 8660,
	'LessSlantEqual;': 10877,
	'LongRightArrow;': 10230,
	'Longrightarrow;': 10233,
	'LowerLeftArrow;': 8601,
	'NestedLessLess;': 8810,
	'NotGreaterLess;': 8825,
	'NotLessGreater;': 8824,
	'NotSubsetEqual;': 8840,
	'NotVerticalBar;': 8740,
	'OpenCurlyQuote;': 8216,
	'ReverseElement;': 8715,
	'RightTeeVector;': 10587,
	'RightVectorBar;': 10579,
	'ShortDownArrow;': 8595,
	'ShortLeftArrow;': 8592,
	'SquareSuperset;': 8848,
	'TildeFullEqual;': 8773,
	'UpperLeftArrow;': 8598,
	'ZeroWidthSpace;': 8203,
	'curvearrowleft;': 8630,
	'doublebarwedge;': 8966,
	'downdownarrows;': 8650,
	'hookrightarrow;': 8618,
	'leftleftarrows;': 8647,
	'leftrightarrow;': 8596,
	'leftthreetimes;': 8907,
	'longrightarrow;': 10230,
	'looparrowright;': 8620,
	'nshortparallel;': 8742,
	'ntriangleright;': 8939,
	'rightarrowtail;': 8611,
	'rightharpoonup;': 8640,
	'trianglelefteq;': 8884,
	'upharpoonright;': 8638,
	'ApplyFunction;': 8289,
	'DifferentialD;': 8518,
	'DoubleLeftTee;': 10980,
	'DoubleUpArrow;': 8657,
	'LeftTeeVector;': 10586,
	'LeftVectorBar;': 10578,
	'LessFullEqual;': 8806,
	'LongLeftArrow;': 10229,
	'Longleftarrow;': 10232,
	'NotEqualTilde;': 8770,
	'NotTildeEqual;': 8772,
	'NotTildeTilde;': 8777,
	'Poincareplane;': 8460,
	'PrecedesEqual;': 10927,
	'PrecedesTilde;': 8830,
	'RightArrowBar;': 8677,
	'RightTeeArrow;': 8614,
	'RightTriangle;': 8883,
	'RightUpVector;': 8638,
	'SucceedsEqual;': 10928,
	'SucceedsTilde;': 8831,
	'SupersetEqual;': 8839,
	'UpEquilibrium;': 10606,
	'VerticalTilde;': 8768,
	'VeryThinSpace;': 8202,
	'bigtriangleup;': 9651,
	'blacktriangle;': 9652,
	'divideontimes;': 8903,
	'fallingdotseq;': 8786,
	'hookleftarrow;': 8617,
	'leftarrowtail;': 8610,
	'leftharpoonup;': 8636,
	'longleftarrow;': 10229,
	'looparrowleft;': 8619,
	'measuredangle;': 8737,
	'ntriangleleft;': 8938,
	'shortparallel;': 8741,
	'smallsetminus;': 8726,
	'triangleright;': 9657,
	'upharpoonleft;': 8639,
	'varsubsetneqq;': 10955,
	'varsupsetneqq;': 10956,
	'DownArrowBar;': 10515,
	'DownTeeArrow;': 8615,
	'ExponentialE;': 8519,
	'GreaterEqual;': 8805,
	'GreaterTilde;': 8819,
	'HilbertSpace;': 8459,
	'HumpDownHump;': 8782,
	'Intersection;': 8898,
	'LeftArrowBar;': 8676,
	'LeftTeeArrow;': 8612,
	'LeftTriangle;': 8882,
	'LeftUpVector;': 8639,
	'NotCongruent;': 8802,
	'NotHumpEqual;': 8783,
	'NotLessEqual;': 8816,
	'NotLessTilde;': 8820,
	'Proportional;': 8733,
	'RightCeiling;': 8969,
	'RoundImplies;': 10608,
	'ShortUpArrow;': 8593,
	'SquareSubset;': 8847,
	'UnderBracket;': 9141,
	'VerticalLine;': 124,
	'blacklozenge;': 10731,
	'exponentiale;': 8519,
	'risingdotseq;': 8787,
	'triangledown;': 9663,
	'triangleleft;': 9667,
	'varsubsetneq;': 8842,
	'varsupsetneq;': 8843,
	'CircleMinus;': 8854,
	'CircleTimes;': 8855,
	'Equilibrium;': 8652,
	'GreaterLess;': 8823,
	'LeftCeiling;': 8968,
	'LessGreater;': 8822,
	'MediumSpace;': 8287,
	'NotLessLess;': 8810,
	'NotPrecedes;': 8832,
	'NotSucceeds;': 8833,
	'NotSuperset;': 8835,
	'OverBracket;': 9140,
	'RightVector;': 8640,
	'Rrightarrow;': 8667,
	'RuleDelayed;': 10740,
	'SmallCircle;': 8728,
	'SquareUnion;': 8852,
	'SubsetEqual;': 8838,
	'UpDownArrow;': 8597,
	'Updownarrow;': 8661,
	'VerticalBar;': 8739,
	'backepsilon;': 1014,
	'blacksquare;': 9642,
	'circledcirc;': 8858,
	'circleddash;': 8861,
	'curlyeqprec;': 8926,
	'curlyeqsucc;': 8927,
	'diamondsuit;': 9830,
	'eqslantless;': 10901,
	'expectation;': 8496,
	'nRightarrow;': 8655,
	'nrightarrow;': 8603,
	'preccurlyeq;': 8828,
	'precnapprox;': 10937,
	'quaternions;': 8461,
	'straightphi;': 981,
	'succcurlyeq;': 8829,
	'succnapprox;': 10938,
	'thickapprox;': 8776,
	'updownarrow;': 8597,
	'Bernoullis;': 8492,
	'CirclePlus;': 8853,
	'EqualTilde;': 8770,
	'Fouriertrf;': 8497,
	'ImaginaryI;': 8520,
	'Laplacetrf;': 8466,
	'LeftVector;': 8636,
	'Lleftarrow;': 8666,
	'NotElement;': 8713,
	'NotGreater;': 8815,
	'Proportion;': 8759,
	'RightArrow;': 8594,
	'RightFloor;': 8971,
	'Rightarrow;': 8658,
	'ThickSpace;': 8287,
	'TildeEqual;': 8771,
	'TildeTilde;': 8776,
	'UnderBrace;': 9183,
	'UpArrowBar;': 10514,
	'UpTeeArrow;': 8613,
	'circledast;': 8859,
	'complement;': 8705,
	'curlywedge;': 8911,
	'eqslantgtr;': 10902,
	'gtreqqless;': 10892,
	'lessapprox;': 10885,
	'lesseqqgtr;': 10891,
	'lmoustache;': 9136,
	'longmapsto;': 10236,
	'mapstodown;': 8615,
	'mapstoleft;': 8612,
	'nLeftarrow;': 8653,
	'nleftarrow;': 8602,
	'nsubseteqq;': 10949,
	'nsupseteqq;': 10950,
	'precapprox;': 10935,
	'rightarrow;': 8594,
	'rmoustache;': 9137,
	'sqsubseteq;': 8849,
	'sqsupseteq;': 8850,
	'subsetneqq;': 10955,
	'succapprox;': 10936,
	'supsetneqq;': 10956,
	'upuparrows;': 8648,
	'varepsilon;': 1013,
	'varnothing;': 8709,
	'Backslash;': 8726,
	'CenterDot;': 183,
	'CircleDot;': 8857,
	'Congruent;': 8801,
	'Coproduct;': 8720,
	'DoubleDot;': 168,
	'DownArrow;': 8595,
	'DownBreve;': 785,
	'Downarrow;': 8659,
	'HumpEqual;': 8783,
	'LeftArrow;': 8592,
	'LeftFloor;': 8970,
	'Leftarrow;': 8656,
	'LessTilde;': 8818,
	'Mellintrf;': 8499,
	'MinusPlus;': 8723,
	'NotCupCap;': 8813,
	'NotExists;': 8708,
	'NotSubset;': 8834,
	'OverBrace;': 9182,
	'PlusMinus;': 177,
	'Therefore;': 8756,
	'ThinSpace;': 8201,
	'TripleDot;': 8411,
	'UnionPlus;': 8846,
	'backprime;': 8245,
	'backsimeq;': 8909,
	'bigotimes;': 10754,
	'centerdot;': 183,
	'checkmark;': 10003,
	'complexes;': 8450,
	'dotsquare;': 8865,
	'downarrow;': 8595,
	'gtrapprox;': 10886,
	'gtreqless;': 8923,
	'gvertneqq;': 8809,
	'heartsuit;': 9829,
	'leftarrow;': 8592,
	'lesseqgtr;': 8922,
	'lvertneqq;': 8808,
	'ngeqslant;': 10878,
	'nleqslant;': 10877,
	'nparallel;': 8742,
	'nshortmid;': 8740,
	'nsubseteq;': 8840,
	'nsupseteq;': 8841,
	'pitchfork;': 8916,
	'rationals;': 8474,
	'spadesuit;': 9824,
	'subseteqq;': 10949,
	'subsetneq;': 8842,
	'supseteqq;': 10950,
	'supsetneq;': 8843,
	'therefore;': 8756,
	'triangleq;': 8796,
	'varpropto;': 8733,
	'DDotrahd;': 10513,
	'DotEqual;': 8784,
	'Integral;': 8747,
	'LessLess;': 10913,
	'NotEqual;': 8800,
	'NotTilde;': 8769,
	'PartialD;': 8706,
	'Precedes;': 8826,
	'RightTee;': 8866,
	'Succeeds;': 8827,
	'SuchThat;': 8715,
	'Superset;': 8835,
	'Uarrocir;': 10569,
	'UnderBar;': 95,
	'andslope;': 10840,
	'angmsdaa;': 10664,
	'angmsdab;': 10665,
	'angmsdac;': 10666,
	'angmsdad;': 10667,
	'angmsdae;': 10668,
	'angmsdaf;': 10669,
	'angmsdag;': 10670,
	'angmsdah;': 10671,
	'angrtvbd;': 10653,
	'approxeq;': 8778,
	'awconint;': 8755,
	'backcong;': 8780,
	'barwedge;': 8965,
	'bbrktbrk;': 9142,
	'bigoplus;': 10753,
	'bigsqcup;': 10758,
	'biguplus;': 10756,
	'bigwedge;': 8896,
	'boxminus;': 8863,
	'boxtimes;': 8864,
	'bsolhsub;': 10184,
	'capbrcup;': 10825,
	'circledR;': 174,
	'circledS;': 9416,
	'cirfnint;': 10768,
	'clubsuit;': 9827,
	'cupbrcap;': 10824,
	'curlyvee;': 8910,
	'cwconint;': 8754,
	'doteqdot;': 8785,
	'dotminus;': 8760,
	'drbkarow;': 10512,
	'dzigrarr;': 10239,
	'elinters;': 9191,
	'emptyset;': 8709,
	'eqvparsl;': 10725,
	'fpartint;': 10765,
	'geqslant;': 10878,
	'gesdotol;': 10884,
	'gnapprox;': 10890,
	'hksearow;': 10533,
	'hkswarow;': 10534,
	'imagline;': 8464,
	'imagpart;': 8465,
	'infintie;': 10717,
	'integers;': 8484,
	'intercal;': 8890,
	'intlarhk;': 10775,
	'laemptyv;': 10676,
	'ldrushar;': 10571,
	'leqslant;': 10877,
	'lesdotor;': 10883,
	'llcorner;': 8990,
	'lnapprox;': 10889,
	'lrcorner;': 8991,
	'lurdshar;': 10570,
	'mapstoup;': 8613,
	'multimap;': 8888,
	'naturals;': 8469,
	'ncongdot;': 10861,
	'notindot;': 8949,
	'otimesas;': 10806,
	'parallel;': 8741,
	'plusacir;': 10787,
	'pointint;': 10773,
	'precneqq;': 10933,
	'precnsim;': 8936,
	'profalar;': 9006,
	'profline;': 8978,
	'profsurf;': 8979,
	'raemptyv;': 10675,
	'realpart;': 8476,
	'rppolint;': 10770,
	'rtriltri;': 10702,
	'scpolint;': 10771,
	'setminus;': 8726,
	'shortmid;': 8739,
	'smeparsl;': 10724,
	'sqsubset;': 8847,
	'sqsupset;': 8848,
	'subseteq;': 8838,
	'succneqq;': 10934,
	'succnsim;': 8937,
	'supseteq;': 8839,
	'thetasym;': 977,
	'thicksim;': 8764,
	'timesbar;': 10801,
	'triangle;': 9653,
	'triminus;': 10810,
	'trpezium;': 9186,
	'ulcorner;': 8988,
	'urcorner;': 8989,
	'varkappa;': 1008,
	'varsigma;': 962,
	'vartheta;': 977,
	'Because;': 8757,
	'Cayleys;': 8493,
	'Cconint;': 8752,
	'Cedilla;': 184,
	'Diamond;': 8900,
	'DownTee;': 8868,
	'Element;': 8712,
	'Epsilon;': 917,
	'Implies;': 8658,
	'LeftTee;': 8867,
	'NewLine;': 10,
	'NoBreak;': 8288,
	'NotLess;': 8814,
	'Omicron;': 927,
	'OverBar;': 8254,
	'Product;': 8719,
	'UpArrow;': 8593,
	'Uparrow;': 8657,
	'Upsilon;': 933,
	'alefsym;': 8501,
	'angrtvb;': 8894,
	'angzarr;': 9084,
	'asympeq;': 8781,
	'backsim;': 8765,
	'because;': 8757,
	'bemptyv;': 10672,
	'between;': 8812,
	'bigcirc;': 9711,
	'bigodot;': 10752,
	'bigstar;': 9733,
	'bnequiv;': 8801,
	'boxplus;': 8862,
	'ccupssm;': 10832,
	'cemptyv;': 10674,
	'cirscir;': 10690,
	'coloneq;': 8788,
	'congdot;': 10861,
	'cudarrl;': 10552,
	'cudarrr;': 10549,
	'cularrp;': 10557,
	'curarrm;': 10556,
	'dbkarow;': 10511,
	'ddagger;': 8225,
	'ddotseq;': 10871,
	'demptyv;': 10673,
	'diamond;': 8900,
	'digamma;': 989,
	'dotplus;': 8724,
	'dwangle;': 10662,
	'epsilon;': 949,
	'eqcolon;': 8789,
	'equivDD;': 10872,
	'gesdoto;': 10882,
	'gtquest;': 10876,
	'gtrless;': 8823,
	'harrcir;': 10568,
	'intprod;': 10812,
	'isindot;': 8949,
	'larrbfs;': 10527,
	'larrsim;': 10611,
	'lbrksld;': 10639,
	'lbrkslu;': 10637,
	'ldrdhar;': 10599,
	'lesdoto;': 10881,
	'lessdot;': 8918,
	'lessgtr;': 8822,
	'lesssim;': 8818,
	'lotimes;': 10804,
	'lozenge;': 9674,
	'ltquest;': 10875,
	'luruhar;': 10598,
	'maltese;': 10016,
	'minusdu;': 10794,
	'napprox;': 8777,
	'natural;': 9838,
	'nearrow;': 8599,
	'nexists;': 8708,
	'notinva;': 8713,
	'notinvb;': 8951,
	'notinvc;': 8950,
	'notniva;': 8716,
	'notnivb;': 8958,
	'notnivc;': 8957,
	'npolint;': 10772,
	'npreceq;': 10927,
	'nsqsube;': 8930,
	'nsqsupe;': 8931,
	'nsubset;': 8834,
	'nsucceq;': 10928,
	'nsupset;': 8835,
	'nvinfin;': 10718,
	'nvltrie;': 8884,
	'nvrtrie;': 8885,
	'nwarrow;': 8598,
	'olcross;': 10683,
	'omicron;': 959,
	'orderof;': 8500,
	'orslope;': 10839,
	'pertenk;': 8241,
	'planckh;': 8462,
	'pluscir;': 10786,
	'plussim;': 10790,
	'plustwo;': 10791,
	'precsim;': 8830,
	'quatint;': 10774,
	'questeq;': 8799,
	'rarrbfs;': 10528,
	'rarrsim;': 10612,
	'rbrksld;': 10638,
	'rbrkslu;': 10640,
	'rdldhar;': 10601,
	'realine;': 8475,
	'rotimes;': 10805,
	'ruluhar;': 10600,
	'searrow;': 8600,
	'simplus;': 10788,
	'simrarr;': 10610,
	'subedot;': 10947,
	'submult;': 10945,
	'subplus;': 10943,
	'subrarr;': 10617,
	'succsim;': 8831,
	'supdsub;': 10968,
	'supedot;': 10948,
	'suphsol;': 10185,
	'suphsub;': 10967,
	'suplarr;': 10619,
	'supmult;': 10946,
	'supplus;': 10944,
	'swarrow;': 8601,
	'topfork;': 10970,
	'triplus;': 10809,
	'tritime;': 10811,
	'uparrow;': 8593,
	'upsilon;': 965,
	'uwangle;': 10663,
	'vzigzag;': 10650,
	'zigrarr;': 8669,
	'Aacute;': 193,
	'Abreve;': 258,
	'Agrave;': 192,
	'Assign;': 8788,
	'Atilde;': 195,
	'Barwed;': 8966,
	'Bumpeq;': 8782,
	'Cacute;': 262,
	'Ccaron;': 268,
	'Ccedil;': 199,
	'Colone;': 10868,
	'Conint;': 8751,
	'CupCap;': 8781,
	'Dagger;': 8225,
	'Dcaron;': 270,
	'DotDot;': 8412,
	'Dstrok;': 272,
	'Eacute;': 201,
	'Ecaron;': 282,
	'Egrave;': 200,
	'Exists;': 8707,
	'ForAll;': 8704,
	'Gammad;': 988,
	'Gbreve;': 286,
	'Gcedil;': 290,
	'HARDcy;': 1066,
	'Hstrok;': 294,
	'Iacute;': 205,
	'Igrave;': 204,
	'Itilde;': 296,
	'Jsercy;': 1032,
	'Kcedil;': 310,
	'Lacute;': 313,
	'Lambda;': 923,
	'Lcaron;': 317,
	'Lcedil;': 315,
	'Lmidot;': 319,
	'Lstrok;': 321,
	'Nacute;': 323,
	'Ncaron;': 327,
	'Ncedil;': 325,
	'Ntilde;': 209,
	'Oacute;': 211,
	'Odblac;': 336,
	'Ograve;': 210,
	'Oslash;': 216,
	'Otilde;': 213,
	'Otimes;': 10807,
	'Racute;': 340,
	'Rarrtl;': 10518,
	'Rcaron;': 344,
	'Rcedil;': 342,
	'SHCHcy;': 1065,
	'SOFTcy;': 1068,
	'Sacute;': 346,
	'Scaron;': 352,
	'Scedil;': 350,
	'Square;': 9633,
	'Subset;': 8912,
	'Supset;': 8913,
	'Tcaron;': 356,
	'Tcedil;': 354,
	'Tstrok;': 358,
	'Uacute;': 218,
	'Ubreve;': 364,
	'Udblac;': 368,
	'Ugrave;': 217,
	'Utilde;': 360,
	'Vdashl;': 10982,
	'Verbar;': 8214,
	'Vvdash;': 8874,
	'Yacute;': 221,
	'Zacute;': 377,
	'Zcaron;': 381,
	'aacute;': 225,
	'abreve;': 259,
	'agrave;': 224,
	'andand;': 10837,
	'angmsd;': 8737,
	'angsph;': 8738,
	'apacir;': 10863,
	'approx;': 8776,
	'atilde;': 227,
	'barvee;': 8893,
	'barwed;': 8965,
	'becaus;': 8757,
	'bernou;': 8492,
	'bigcap;': 8898,
	'bigcup;': 8899,
	'bigvee;': 8897,
	'bkarow;': 10509,
	'bottom;': 8869,
	'bowtie;': 8904,
	'boxbox;': 10697,
	'bprime;': 8245,
	'brvbar;': 166,
	'bullet;': 8226,
	'bumpeq;': 8783,
	'cacute;': 263,
	'capand;': 10820,
	'capcap;': 10827,
	'capcup;': 10823,
	'capdot;': 10816,
	'ccaron;': 269,
	'ccedil;': 231,
	'circeq;': 8791,
	'cirmid;': 10991,
	'colone;': 8788,
	'commat;': 64,
	'compfn;': 8728,
	'conint;': 8750,
	'coprod;': 8720,
	'copysr;': 8471,
	'cularr;': 8630,
	'cupcap;': 10822,
	'cupcup;': 10826,
	'cupdot;': 8845,
	'curarr;': 8631,
	'curren;': 164,
	'cylcty;': 9005,
	'dagger;': 8224,
	'daleth;': 8504,
	'dcaron;': 271,
	'dfisht;': 10623,
	'divide;': 247,
	'divonx;': 8903,
	'dlcorn;': 8990,
	'dlcrop;': 8973,
	'dollar;': 36,
	'drcorn;': 8991,
	'drcrop;': 8972,
	'dstrok;': 273,
	'eacute;': 233,
	'easter;': 10862,
	'ecaron;': 283,
	'ecolon;': 8789,
	'egrave;': 232,
	'egsdot;': 10904,
	'elsdot;': 10903,
	'emptyv;': 8709,
	'emsp13;': 8196,
	'emsp14;': 8197,
	'eparsl;': 10723,
	'eqcirc;': 8790,
	'equals;': 61,
	'equest;': 8799,
	'female;': 9792,
	'ffilig;': 64259,
	'ffllig;': 64260,
	'forall;': 8704,
	'frac12;': 189,
	'frac13;': 8531,
	'frac14;': 188,
	'frac15;': 8533,
	'frac16;': 8537,
	'frac18;': 8539,
	'frac23;': 8532,
	'frac25;': 8534,
	'frac34;': 190,
	'frac35;': 8535,
	'frac38;': 8540,
	'frac45;': 8536,
	'frac56;': 8538,
	'frac58;': 8541,
	'frac78;': 8542,
	'gacute;': 501,
	'gammad;': 989,
	'gbreve;': 287,
	'gesdot;': 10880,
	'gesles;': 10900,
	'gtlPar;': 10645,
	'gtrarr;': 10616,
	'gtrdot;': 8919,
	'gtrsim;': 8819,
	'hairsp;': 8202,
	'hamilt;': 8459,
	'hardcy;': 1098,
	'hearts;': 9829,
	'hellip;': 8230,
	'hercon;': 8889,
	'homtht;': 8763,
	'horbar;': 8213,
	'hslash;': 8463,
	'hstrok;': 295,
	'hybull;': 8259,
	'hyphen;': 8208,
	'iacute;': 237,
	'igrave;': 236,
	'iiiint;': 10764,
	'iinfin;': 10716,
	'incare;': 8453,
	'inodot;': 305,
	'intcal;': 8890,
	'iquest;': 191,
	'isinsv;': 8947,
	'itilde;': 297,
	'jsercy;': 1112,
	'kappav;': 1008,
	'kcedil;': 311,
	'kgreen;': 312,
	'lAtail;': 10523,
	'lacute;': 314,
	'lagran;': 8466,
	'lambda;': 955,
	'langle;': 10216,
	'larrfs;': 10525,
	'larrhk;': 8617,
	'larrlp;': 8619,
	'larrpl;': 10553,
	'larrtl;': 8610,
	'latail;': 10521,
	'lbrace;': 123,
	'lbrack;': 91,
	'lcaron;': 318,
	'lcedil;': 316,
	'ldquor;': 8222,
	'lesdot;': 10879,
	'lesges;': 10899,
	'lfisht;': 10620,
	'lfloor;': 8970,
	'lharul;': 10602,
	'llhard;': 10603,
	'lmidot;': 320,
	'lmoust;': 9136,
	'loplus;': 10797,
	'lowast;': 8727,
	'lowbar;': 95,
	'lparlt;': 10643,
	'lrhard;': 10605,
	'lsaquo;': 8249,
	'lsquor;': 8218,
	'lstrok;': 322,
	'lthree;': 8907,
	'ltimes;': 8905,
	'ltlarr;': 10614,
	'ltrPar;': 10646,
	'mapsto;': 8614,
	'marker;': 9646,
	'mcomma;': 10793,
	'midast;': 42,
	'midcir;': 10992,
	'middot;': 183,
	'minusb;': 8863,
	'minusd;': 8760,
	'mnplus;': 8723,
	'models;': 8871,
	'mstpos;': 8766,
	'nVDash;': 8879,
	'nVdash;': 8878,
	'nacute;': 324,
	'nbumpe;': 8783,
	'ncaron;': 328,
	'ncedil;': 326,
	'nearhk;': 10532,
	'nequiv;': 8802,
	'nesear;': 10536,
	'nexist;': 8708,
	'nltrie;': 8940,
	'notinE;': 8953,
	'nparsl;': 11005,
	'nprcue;': 8928,
	'nrarrc;': 10547,
	'nrarrw;': 8605,
	'nrtrie;': 8941,
	'nsccue;': 8929,
	'nsimeq;': 8772,
	'ntilde;': 241,
	'numero;': 8470,
	'nvDash;': 8877,
	'nvHarr;': 10500,
	'nvdash;': 8876,
	'nvlArr;': 10498,
	'nvrArr;': 10499,
	'nwarhk;': 10531,
	'nwnear;': 10535,
	'oacute;': 243,
	'odblac;': 337,
	'odsold;': 10684,
	'ograve;': 242,
	'ominus;': 8854,
	'origof;': 8886,
	'oslash;': 248,
	'otilde;': 245,
	'otimes;': 8855,
	'parsim;': 10995,
	'percnt;': 37,
	'period;': 46,
	'permil;': 8240,
	'phmmat;': 8499,
	'planck;': 8463,
	'plankv;': 8463,
	'plusdo;': 8724,
	'plusdu;': 10789,
	'plusmn;': 177,
	'preceq;': 10927,
	'primes;': 8473,
	'prnsim;': 8936,
	'propto;': 8733,
	'prurel;': 8880,
	'puncsp;': 8200,
	'qprime;': 8279,
	'rAtail;': 10524,
	'racute;': 341,
	'rangle;': 10217,
	'rarrap;': 10613,
	'rarrfs;': 10526,
	'rarrhk;': 8618,
	'rarrlp;': 8620,
	'rarrpl;': 10565,
	'rarrtl;': 8611,
	'ratail;': 10522,
	'rbrace;': 125,
	'rbrack;': 93,
	'rcaron;': 345,
	'rcedil;': 343,
	'rdquor;': 8221,
	'rfisht;': 10621,
	'rfloor;': 8971,
	'rharul;': 10604,
	'rmoust;': 9137,
	'roplus;': 10798,
	'rpargt;': 10644,
	'rsaquo;': 8250,
	'rsquor;': 8217,
	'rthree;': 8908,
	'rtimes;': 8906,
	'sacute;': 347,
	'scaron;': 353,
	'scedil;': 351,
	'scnsim;': 8937,
	'searhk;': 10533,
	'seswar;': 10537,
	'sfrown;': 8994,
	'shchcy;': 1097,
	'sigmaf;': 962,
	'sigmav;': 962,
	'simdot;': 10858,
	'smashp;': 10803,
	'softcy;': 1100,
	'solbar;': 9023,
	'spades;': 9824,
	'sqcaps;': 8851,
	'sqcups;': 8852,
	'sqsube;': 8849,
	'sqsupe;': 8850,
	'square;': 9633,
	'squarf;': 9642,
	'ssetmn;': 8726,
	'ssmile;': 8995,
	'sstarf;': 8902,
	'subdot;': 10941,
	'subset;': 8834,
	'subsim;': 10951,
	'subsub;': 10965,
	'subsup;': 10963,
	'succeq;': 10928,
	'supdot;': 10942,
	'supset;': 8835,
	'supsim;': 10952,
	'supsub;': 10964,
	'supsup;': 10966,
	'swarhk;': 10534,
	'swnwar;': 10538,
	'target;': 8982,
	'tcaron;': 357,
	'tcedil;': 355,
	'telrec;': 8981,
	'there4;': 8756,
	'thetav;': 977,
	'thinsp;': 8201,
	'thksim;': 8764,
	'timesb;': 8864,
	'timesd;': 10800,
	'topbot;': 9014,
	'topcir;': 10993,
	'tprime;': 8244,
	'tridot;': 9708,
	'tstrok;': 359,
	'uacute;': 250,
	'ubreve;': 365,
	'udblac;': 369,
	'ufisht;': 10622,
	'ugrave;': 249,
	'ulcorn;': 8988,
	'ulcrop;': 8975,
	'urcorn;': 8989,
	'urcrop;': 8974,
	'utilde;': 361,
	'vangrt;': 10652,
	'varphi;': 981,
	'varrho;': 1009,
	'veebar;': 8891,
	'vellip;': 8942,
	'verbar;': 124,
	'vsubnE;': 10955,
	'vsubne;': 8842,
	'vsupnE;': 10956,
	'vsupne;': 8843,
	'wedbar;': 10847,
	'wedgeq;': 8793,
	'weierp;': 8472,
	'wreath;': 8768,
	'xoplus;': 10753,
	'xotime;': 10754,
	'xsqcup;': 10758,
	'xuplus;': 10756,
	'xwedge;': 8896,
	'yacute;': 253,
	'zacute;': 378,
	'zcaron;': 382,
	'zeetrf;': 8488,
	'AElig;': 198,
	Aacute: 193,
	'Acirc;': 194,
	Agrave: 192,
	'Alpha;': 913,
	'Amacr;': 256,
	'Aogon;': 260,
	'Aring;': 197,
	Atilde: 195,
	'Breve;': 728,
	Ccedil: 199,
	'Ccirc;': 264,
	'Colon;': 8759,
	'Cross;': 10799,
	'Dashv;': 10980,
	'Delta;': 916,
	Eacute: 201,
	'Ecirc;': 202,
	Egrave: 200,
	'Emacr;': 274,
	'Eogon;': 280,
	'Equal;': 10869,
	'Gamma;': 915,
	'Gcirc;': 284,
	'Hacek;': 711,
	'Hcirc;': 292,
	'IJlig;': 306,
	Iacute: 205,
	'Icirc;': 206,
	Igrave: 204,
	'Imacr;': 298,
	'Iogon;': 302,
	'Iukcy;': 1030,
	'Jcirc;': 308,
	'Jukcy;': 1028,
	'Kappa;': 922,
	Ntilde: 209,
	'OElig;': 338,
	Oacute: 211,
	'Ocirc;': 212,
	Ograve: 210,
	'Omacr;': 332,
	'Omega;': 937,
	Oslash: 216,
	Otilde: 213,
	'Prime;': 8243,
	'RBarr;': 10512,
	'Scirc;': 348,
	'Sigma;': 931,
	'THORN;': 222,
	'TRADE;': 8482,
	'TSHcy;': 1035,
	'Theta;': 920,
	'Tilde;': 8764,
	Uacute: 218,
	'Ubrcy;': 1038,
	'Ucirc;': 219,
	Ugrave: 217,
	'Umacr;': 362,
	'Union;': 8899,
	'Uogon;': 370,
	'UpTee;': 8869,
	'Uring;': 366,
	'VDash;': 8875,
	'Vdash;': 8873,
	'Wcirc;': 372,
	'Wedge;': 8896,
	Yacute: 221,
	'Ycirc;': 374,
	aacute: 225,
	'acirc;': 226,
	'acute;': 180,
	'aelig;': 230,
	agrave: 224,
	'aleph;': 8501,
	'alpha;': 945,
	'amacr;': 257,
	'amalg;': 10815,
	'angle;': 8736,
	'angrt;': 8735,
	'angst;': 197,
	'aogon;': 261,
	'aring;': 229,
	'asymp;': 8776,
	atilde: 227,
	'awint;': 10769,
	'bcong;': 8780,
	'bdquo;': 8222,
	'bepsi;': 1014,
	'blank;': 9251,
	'blk12;': 9618,
	'blk14;': 9617,
	'blk34;': 9619,
	'block;': 9608,
	'boxDL;': 9559,
	'boxDR;': 9556,
	'boxDl;': 9558,
	'boxDr;': 9555,
	'boxHD;': 9574,
	'boxHU;': 9577,
	'boxHd;': 9572,
	'boxHu;': 9575,
	'boxUL;': 9565,
	'boxUR;': 9562,
	'boxUl;': 9564,
	'boxUr;': 9561,
	'boxVH;': 9580,
	'boxVL;': 9571,
	'boxVR;': 9568,
	'boxVh;': 9579,
	'boxVl;': 9570,
	'boxVr;': 9567,
	'boxdL;': 9557,
	'boxdR;': 9554,
	'boxdl;': 9488,
	'boxdr;': 9484,
	'boxhD;': 9573,
	'boxhU;': 9576,
	'boxhd;': 9516,
	'boxhu;': 9524,
	'boxuL;': 9563,
	'boxuR;': 9560,
	'boxul;': 9496,
	'boxur;': 9492,
	'boxvH;': 9578,
	'boxvL;': 9569,
	'boxvR;': 9566,
	'boxvh;': 9532,
	'boxvl;': 9508,
	'boxvr;': 9500,
	'breve;': 728,
	brvbar: 166,
	'bsemi;': 8271,
	'bsime;': 8909,
	'bsolb;': 10693,
	'bumpE;': 10926,
	'bumpe;': 8783,
	'caret;': 8257,
	'caron;': 711,
	'ccaps;': 10829,
	ccedil: 231,
	'ccirc;': 265,
	'ccups;': 10828,
	'cedil;': 184,
	'check;': 10003,
	'clubs;': 9827,
	'colon;': 58,
	'comma;': 44,
	'crarr;': 8629,
	'cross;': 10007,
	'csube;': 10961,
	'csupe;': 10962,
	'ctdot;': 8943,
	'cuepr;': 8926,
	'cuesc;': 8927,
	'cupor;': 10821,
	curren: 164,
	'cuvee;': 8910,
	'cuwed;': 8911,
	'cwint;': 8753,
	'dashv;': 8867,
	'dblac;': 733,
	'ddarr;': 8650,
	'delta;': 948,
	'dharl;': 8643,
	'dharr;': 8642,
	'diams;': 9830,
	'disin;': 8946,
	divide: 247,
	'doteq;': 8784,
	'dtdot;': 8945,
	'dtrif;': 9662,
	'duarr;': 8693,
	'duhar;': 10607,
	'eDDot;': 10871,
	eacute: 233,
	'ecirc;': 234,
	'efDot;': 8786,
	egrave: 232,
	'emacr;': 275,
	'empty;': 8709,
	'eogon;': 281,
	'eplus;': 10865,
	'epsiv;': 1013,
	'eqsim;': 8770,
	'equiv;': 8801,
	'erDot;': 8787,
	'erarr;': 10609,
	'esdot;': 8784,
	'exist;': 8707,
	'fflig;': 64256,
	'filig;': 64257,
	'fjlig;': 102,
	'fllig;': 64258,
	'fltns;': 9649,
	'forkv;': 10969,
	frac12: 189,
	frac14: 188,
	frac34: 190,
	'frasl;': 8260,
	'frown;': 8994,
	'gamma;': 947,
	'gcirc;': 285,
	'gescc;': 10921,
	'gimel;': 8503,
	'gneqq;': 8809,
	'gnsim;': 8935,
	'grave;': 96,
	'gsime;': 10894,
	'gsiml;': 10896,
	'gtcir;': 10874,
	'gtdot;': 8919,
	'harrw;': 8621,
	'hcirc;': 293,
	'hoarr;': 8703,
	iacute: 237,
	'icirc;': 238,
	'iexcl;': 161,
	igrave: 236,
	'iiint;': 8749,
	'iiota;': 8489,
	'ijlig;': 307,
	'imacr;': 299,
	'image;': 8465,
	'imath;': 305,
	'imped;': 437,
	'infin;': 8734,
	'iogon;': 303,
	'iprod;': 10812,
	iquest: 191,
	'isinE;': 8953,
	'isins;': 8948,
	'isinv;': 8712,
	'iukcy;': 1110,
	'jcirc;': 309,
	'jmath;': 567,
	'jukcy;': 1108,
	'kappa;': 954,
	'lAarr;': 8666,
	'lBarr;': 10510,
	'langd;': 10641,
	'laquo;': 171,
	'larrb;': 8676,
	'lates;': 10925,
	'lbarr;': 10508,
	'lbbrk;': 10098,
	'lbrke;': 10635,
	'lceil;': 8968,
	'ldquo;': 8220,
	'lescc;': 10920,
	'lhard;': 8637,
	'lharu;': 8636,
	'lhblk;': 9604,
	'llarr;': 8647,
	'lltri;': 9722,
	'lneqq;': 8808,
	'lnsim;': 8934,
	'loang;': 10220,
	'loarr;': 8701,
	'lobrk;': 10214,
	'lopar;': 10629,
	'lrarr;': 8646,
	'lrhar;': 8651,
	'lrtri;': 8895,
	'lsime;': 10893,
	'lsimg;': 10895,
	'lsquo;': 8216,
	'ltcir;': 10873,
	'ltdot;': 8918,
	'ltrie;': 8884,
	'ltrif;': 9666,
	'mDDot;': 8762,
	'mdash;': 8212,
	'micro;': 181,
	middot: 183,
	'minus;': 8722,
	'mumap;': 8888,
	'nabla;': 8711,
	'napid;': 8779,
	'napos;': 329,
	'natur;': 9838,
	'nbump;': 8782,
	'ncong;': 8775,
	'ndash;': 8211,
	'neArr;': 8663,
	'nearr;': 8599,
	'nedot;': 8784,
	'nesim;': 8770,
	'ngeqq;': 8807,
	'ngsim;': 8821,
	'nhArr;': 8654,
	'nharr;': 8622,
	'nhpar;': 10994,
	'nlArr;': 8653,
	'nlarr;': 8602,
	'nleqq;': 8806,
	'nless;': 8814,
	'nlsim;': 8820,
	'nltri;': 8938,
	'notin;': 8713,
	'notni;': 8716,
	'npart;': 8706,
	'nprec;': 8832,
	'nrArr;': 8655,
	'nrarr;': 8603,
	'nrtri;': 8939,
	'nsime;': 8772,
	'nsmid;': 8740,
	'nspar;': 8742,
	'nsubE;': 10949,
	'nsube;': 8840,
	'nsucc;': 8833,
	'nsupE;': 10950,
	'nsupe;': 8841,
	ntilde: 241,
	'numsp;': 8199,
	'nvsim;': 8764,
	'nwArr;': 8662,
	'nwarr;': 8598,
	oacute: 243,
	'ocirc;': 244,
	'odash;': 8861,
	'oelig;': 339,
	'ofcir;': 10687,
	ograve: 242,
	'ohbar;': 10677,
	'olarr;': 8634,
	'olcir;': 10686,
	'oline;': 8254,
	'omacr;': 333,
	'omega;': 969,
	'operp;': 10681,
	'oplus;': 8853,
	'orarr;': 8635,
	'order;': 8500,
	oslash: 248,
	otilde: 245,
	'ovbar;': 9021,
	'parsl;': 11005,
	'phone;': 9742,
	'plusb;': 8862,
	'pluse;': 10866,
	plusmn: 177,
	'pound;': 163,
	'prcue;': 8828,
	'prime;': 8242,
	'prnap;': 10937,
	'prsim;': 8830,
	'quest;': 63,
	'rAarr;': 8667,
	'rBarr;': 10511,
	'radic;': 8730,
	'rangd;': 10642,
	'range;': 10661,
	'raquo;': 187,
	'rarrb;': 8677,
	'rarrc;': 10547,
	'rarrw;': 8605,
	'ratio;': 8758,
	'rbarr;': 10509,
	'rbbrk;': 10099,
	'rbrke;': 10636,
	'rceil;': 8969,
	'rdquo;': 8221,
	'reals;': 8477,
	'rhard;': 8641,
	'rharu;': 8640,
	'rlarr;': 8644,
	'rlhar;': 8652,
	'rnmid;': 10990,
	'roang;': 10221,
	'roarr;': 8702,
	'robrk;': 10215,
	'ropar;': 10630,
	'rrarr;': 8649,
	'rsquo;': 8217,
	'rtrie;': 8885,
	'rtrif;': 9656,
	'sbquo;': 8218,
	'sccue;': 8829,
	'scirc;': 349,
	'scnap;': 10938,
	'scsim;': 8831,
	'sdotb;': 8865,
	'sdote;': 10854,
	'seArr;': 8664,
	'searr;': 8600,
	'setmn;': 8726,
	'sharp;': 9839,
	'sigma;': 963,
	'simeq;': 8771,
	'simgE;': 10912,
	'simlE;': 10911,
	'simne;': 8774,
	'slarr;': 8592,
	'smile;': 8995,
	'smtes;': 10924,
	'sqcap;': 8851,
	'sqcup;': 8852,
	'sqsub;': 8847,
	'sqsup;': 8848,
	'srarr;': 8594,
	'starf;': 9733,
	'strns;': 175,
	'subnE;': 10955,
	'subne;': 8842,
	'supnE;': 10956,
	'supne;': 8843,
	'swArr;': 8665,
	'swarr;': 8601,
	'szlig;': 223,
	'theta;': 952,
	'thkap;': 8776,
	'thorn;': 254,
	'tilde;': 732,
	'times;': 215,
	'trade;': 8482,
	'trisb;': 10701,
	'tshcy;': 1115,
	'twixt;': 8812,
	uacute: 250,
	'ubrcy;': 1118,
	'ucirc;': 251,
	'udarr;': 8645,
	'udhar;': 10606,
	ugrave: 249,
	'uharl;': 8639,
	'uharr;': 8638,
	'uhblk;': 9600,
	'ultri;': 9720,
	'umacr;': 363,
	'uogon;': 371,
	'uplus;': 8846,
	'upsih;': 978,
	'uring;': 367,
	'urtri;': 9721,
	'utdot;': 8944,
	'utrif;': 9652,
	'uuarr;': 8648,
	'vBarv;': 10985,
	'vDash;': 8872,
	'varpi;': 982,
	'vdash;': 8866,
	'veeeq;': 8794,
	'vltri;': 8882,
	'vnsub;': 8834,
	'vnsup;': 8835,
	'vprop;': 8733,
	'vrtri;': 8883,
	'wcirc;': 373,
	'wedge;': 8743,
	'xcirc;': 9711,
	'xdtri;': 9661,
	'xhArr;': 10234,
	'xharr;': 10231,
	'xlArr;': 10232,
	'xlarr;': 10229,
	'xodot;': 10752,
	'xrArr;': 10233,
	'xrarr;': 10230,
	'xutri;': 9651,
	yacute: 253,
	'ycirc;': 375,
	AElig: 198,
	Acirc: 194,
	'Aopf;': 120120,
	Aring: 197,
	'Ascr;': 119964,
	'Auml;': 196,
	'Barv;': 10983,
	'Beta;': 914,
	'Bopf;': 120121,
	'Bscr;': 8492,
	'CHcy;': 1063,
	'COPY;': 169,
	'Cdot;': 266,
	'Copf;': 8450,
	'Cscr;': 119966,
	'DJcy;': 1026,
	'DScy;': 1029,
	'DZcy;': 1039,
	'Darr;': 8609,
	'Dopf;': 120123,
	'Dscr;': 119967,
	Ecirc: 202,
	'Edot;': 278,
	'Eopf;': 120124,
	'Escr;': 8496,
	'Esim;': 10867,
	'Euml;': 203,
	'Fopf;': 120125,
	'Fscr;': 8497,
	'GJcy;': 1027,
	'Gdot;': 288,
	'Gopf;': 120126,
	'Gscr;': 119970,
	'Hopf;': 8461,
	'Hscr;': 8459,
	'IEcy;': 1045,
	'IOcy;': 1025,
	Icirc: 206,
	'Idot;': 304,
	'Iopf;': 120128,
	'Iota;': 921,
	'Iscr;': 8464,
	'Iuml;': 207,
	'Jopf;': 120129,
	'Jscr;': 119973,
	'KHcy;': 1061,
	'KJcy;': 1036,
	'Kopf;': 120130,
	'Kscr;': 119974,
	'LJcy;': 1033,
	'Lang;': 10218,
	'Larr;': 8606,
	'Lopf;': 120131,
	'Lscr;': 8466,
	'Mopf;': 120132,
	'Mscr;': 8499,
	'NJcy;': 1034,
	'Nopf;': 8469,
	'Nscr;': 119977,
	Ocirc: 212,
	'Oopf;': 120134,
	'Oscr;': 119978,
	'Ouml;': 214,
	'Popf;': 8473,
	'Pscr;': 119979,
	'QUOT;': 34,
	'Qopf;': 8474,
	'Qscr;': 119980,
	'Rang;': 10219,
	'Rarr;': 8608,
	'Ropf;': 8477,
	'Rscr;': 8475,
	'SHcy;': 1064,
	'Sopf;': 120138,
	'Sqrt;': 8730,
	'Sscr;': 119982,
	'Star;': 8902,
	THORN: 222,
	'TScy;': 1062,
	'Topf;': 120139,
	'Tscr;': 119983,
	'Uarr;': 8607,
	Ucirc: 219,
	'Uopf;': 120140,
	'Upsi;': 978,
	'Uscr;': 119984,
	'Uuml;': 220,
	'Vbar;': 10987,
	'Vert;': 8214,
	'Vopf;': 120141,
	'Vscr;': 119985,
	'Wopf;': 120142,
	'Wscr;': 119986,
	'Xopf;': 120143,
	'Xscr;': 119987,
	'YAcy;': 1071,
	'YIcy;': 1031,
	'YUcy;': 1070,
	'Yopf;': 120144,
	'Yscr;': 119988,
	'Yuml;': 376,
	'ZHcy;': 1046,
	'Zdot;': 379,
	'Zeta;': 918,
	'Zopf;': 8484,
	'Zscr;': 119989,
	acirc: 226,
	acute: 180,
	aelig: 230,
	'andd;': 10844,
	'andv;': 10842,
	'ange;': 10660,
	'aopf;': 120146,
	'apid;': 8779,
	'apos;': 39,
	aring: 229,
	'ascr;': 119990,
	'auml;': 228,
	'bNot;': 10989,
	'bbrk;': 9141,
	'beta;': 946,
	'beth;': 8502,
	'bnot;': 8976,
	'bopf;': 120147,
	'boxH;': 9552,
	'boxV;': 9553,
	'boxh;': 9472,
	'boxv;': 9474,
	'bscr;': 119991,
	'bsim;': 8765,
	'bsol;': 92,
	'bull;': 8226,
	'bump;': 8782,
	'caps;': 8745,
	'cdot;': 267,
	cedil: 184,
	'cent;': 162,
	'chcy;': 1095,
	'cirE;': 10691,
	'circ;': 710,
	'cire;': 8791,
	'comp;': 8705,
	'cong;': 8773,
	'copf;': 120148,
	'copy;': 169,
	'cscr;': 119992,
	'csub;': 10959,
	'csup;': 10960,
	'cups;': 8746,
	'dArr;': 8659,
	'dHar;': 10597,
	'darr;': 8595,
	'dash;': 8208,
	'diam;': 8900,
	'djcy;': 1106,
	'dopf;': 120149,
	'dscr;': 119993,
	'dscy;': 1109,
	'dsol;': 10742,
	'dtri;': 9663,
	'dzcy;': 1119,
	'eDot;': 8785,
	'ecir;': 8790,
	ecirc: 234,
	'edot;': 279,
	'emsp;': 8195,
	'ensp;': 8194,
	'eopf;': 120150,
	'epar;': 8917,
	'epsi;': 949,
	'escr;': 8495,
	'esim;': 8770,
	'euml;': 235,
	'euro;': 8364,
	'excl;': 33,
	'flat;': 9837,
	'fnof;': 402,
	'fopf;': 120151,
	'fork;': 8916,
	'fscr;': 119995,
	'gdot;': 289,
	'geqq;': 8807,
	'gesl;': 8923,
	'gjcy;': 1107,
	'gnap;': 10890,
	'gneq;': 10888,
	'gopf;': 120152,
	'gscr;': 8458,
	'gsim;': 8819,
	'gtcc;': 10919,
	'gvnE;': 8809,
	'hArr;': 8660,
	'half;': 189,
	'harr;': 8596,
	'hbar;': 8463,
	'hopf;': 120153,
	'hscr;': 119997,
	icirc: 238,
	'iecy;': 1077,
	iexcl: 161,
	'imof;': 8887,
	'iocy;': 1105,
	'iopf;': 120154,
	'iota;': 953,
	'iscr;': 119998,
	'isin;': 8712,
	'iuml;': 239,
	'jopf;': 120155,
	'jscr;': 119999,
	'khcy;': 1093,
	'kjcy;': 1116,
	'kopf;': 120156,
	'kscr;': 120000,
	'lArr;': 8656,
	'lHar;': 10594,
	'lang;': 10216,
	laquo: 171,
	'larr;': 8592,
	'late;': 10925,
	'lcub;': 123,
	'ldca;': 10550,
	'ldsh;': 8626,
	'leqq;': 8806,
	'lesg;': 8922,
	'ljcy;': 1113,
	'lnap;': 10889,
	'lneq;': 10887,
	'lopf;': 120157,
	'lozf;': 10731,
	'lpar;': 40,
	'lscr;': 120001,
	'lsim;': 8818,
	'lsqb;': 91,
	'ltcc;': 10918,
	'ltri;': 9667,
	'lvnE;': 8808,
	'macr;': 175,
	'male;': 9794,
	'malt;': 10016,
	micro: 181,
	'mlcp;': 10971,
	'mldr;': 8230,
	'mopf;': 120158,
	'mscr;': 120002,
	'nGtv;': 8811,
	'nLtv;': 8810,
	'nang;': 8736,
	'napE;': 10864,
	'nbsp;': 160,
	'ncap;': 10819,
	'ncup;': 10818,
	'ngeq;': 8817,
	'nges;': 10878,
	'ngtr;': 8815,
	'nisd;': 8954,
	'njcy;': 1114,
	'nldr;': 8229,
	'nleq;': 8816,
	'nles;': 10877,
	'nmid;': 8740,
	'nopf;': 120159,
	'npar;': 8742,
	'npre;': 10927,
	'nsce;': 10928,
	'nscr;': 120003,
	'nsim;': 8769,
	'nsub;': 8836,
	'nsup;': 8837,
	'ntgl;': 8825,
	'ntlg;': 8824,
	'nvap;': 8781,
	'nvge;': 8805,
	'nvgt;': 62,
	'nvle;': 8804,
	'nvlt;': 60,
	'oast;': 8859,
	'ocir;': 8858,
	ocirc: 244,
	'odiv;': 10808,
	'odot;': 8857,
	'ogon;': 731,
	'oint;': 8750,
	'omid;': 10678,
	'oopf;': 120160,
	'opar;': 10679,
	'ordf;': 170,
	'ordm;': 186,
	'oror;': 10838,
	'oscr;': 8500,
	'osol;': 8856,
	'ouml;': 246,
	'para;': 182,
	'part;': 8706,
	'perp;': 8869,
	'phiv;': 981,
	'plus;': 43,
	'popf;': 120161,
	pound: 163,
	'prap;': 10935,
	'prec;': 8826,
	'prnE;': 10933,
	'prod;': 8719,
	'prop;': 8733,
	'pscr;': 120005,
	'qint;': 10764,
	'qopf;': 120162,
	'qscr;': 120006,
	'quot;': 34,
	'rArr;': 8658,
	'rHar;': 10596,
	'race;': 8765,
	'rang;': 10217,
	raquo: 187,
	'rarr;': 8594,
	'rcub;': 125,
	'rdca;': 10551,
	'rdsh;': 8627,
	'real;': 8476,
	'rect;': 9645,
	'rhov;': 1009,
	'ring;': 730,
	'ropf;': 120163,
	'rpar;': 41,
	'rscr;': 120007,
	'rsqb;': 93,
	'rtri;': 9657,
	'scap;': 10936,
	'scnE;': 10934,
	'sdot;': 8901,
	'sect;': 167,
	'semi;': 59,
	'sext;': 10038,
	'shcy;': 1096,
	'sime;': 8771,
	'simg;': 10910,
	'siml;': 10909,
	'smid;': 8739,
	'smte;': 10924,
	'solb;': 10692,
	'sopf;': 120164,
	'spar;': 8741,
	'squf;': 9642,
	'sscr;': 120008,
	'star;': 9734,
	'subE;': 10949,
	'sube;': 8838,
	'succ;': 8827,
	'sung;': 9834,
	'sup1;': 185,
	'sup2;': 178,
	'sup3;': 179,
	'supE;': 10950,
	'supe;': 8839,
	szlig: 223,
	'tbrk;': 9140,
	'tdot;': 8411,
	thorn: 254,
	times: 215,
	'tint;': 8749,
	'toea;': 10536,
	'topf;': 120165,
	'tosa;': 10537,
	'trie;': 8796,
	'tscr;': 120009,
	'tscy;': 1094,
	'uArr;': 8657,
	'uHar;': 10595,
	'uarr;': 8593,
	ucirc: 251,
	'uopf;': 120166,
	'upsi;': 965,
	'uscr;': 120010,
	'utri;': 9653,
	'uuml;': 252,
	'vArr;': 8661,
	'vBar;': 10984,
	'varr;': 8597,
	'vert;': 124,
	'vopf;': 120167,
	'vscr;': 120011,
	'wopf;': 120168,
	'wscr;': 120012,
	'xcap;': 8898,
	'xcup;': 8899,
	'xmap;': 10236,
	'xnis;': 8955,
	'xopf;': 120169,
	'xscr;': 120013,
	'xvee;': 8897,
	'yacy;': 1103,
	'yicy;': 1111,
	'yopf;': 120170,
	'yscr;': 120014,
	'yucy;': 1102,
	'yuml;': 255,
	'zdot;': 380,
	'zeta;': 950,
	'zhcy;': 1078,
	'zopf;': 120171,
	'zscr;': 120015,
	'zwnj;': 8204,
	'AMP;': 38,
	'Acy;': 1040,
	'Afr;': 120068,
	'And;': 10835,
	Auml: 196,
	'Bcy;': 1041,
	'Bfr;': 120069,
	COPY: 169,
	'Cap;': 8914,
	'Cfr;': 8493,
	'Chi;': 935,
	'Cup;': 8915,
	'Dcy;': 1044,
	'Del;': 8711,
	'Dfr;': 120071,
	'Dot;': 168,
	'ENG;': 330,
	'ETH;': 208,
	'Ecy;': 1069,
	'Efr;': 120072,
	'Eta;': 919,
	Euml: 203,
	'Fcy;': 1060,
	'Ffr;': 120073,
	'Gcy;': 1043,
	'Gfr;': 120074,
	'Hat;': 94,
	'Hfr;': 8460,
	'Icy;': 1048,
	'Ifr;': 8465,
	'Int;': 8748,
	Iuml: 207,
	'Jcy;': 1049,
	'Jfr;': 120077,
	'Kcy;': 1050,
	'Kfr;': 120078,
	'Lcy;': 1051,
	'Lfr;': 120079,
	'Lsh;': 8624,
	'Map;': 10501,
	'Mcy;': 1052,
	'Mfr;': 120080,
	'Ncy;': 1053,
	'Nfr;': 120081,
	'Not;': 10988,
	'Ocy;': 1054,
	'Ofr;': 120082,
	Ouml: 214,
	'Pcy;': 1055,
	'Pfr;': 120083,
	'Phi;': 934,
	'Psi;': 936,
	QUOT: 34,
	'Qfr;': 120084,
	'REG;': 174,
	'Rcy;': 1056,
	'Rfr;': 8476,
	'Rho;': 929,
	'Rsh;': 8625,
	'Scy;': 1057,
	'Sfr;': 120086,
	'Sub;': 8912,
	'Sum;': 8721,
	'Sup;': 8913,
	'Tab;': 9,
	'Tau;': 932,
	'Tcy;': 1058,
	'Tfr;': 120087,
	'Ucy;': 1059,
	'Ufr;': 120088,
	Uuml: 220,
	'Vcy;': 1042,
	'Vee;': 8897,
	'Vfr;': 120089,
	'Wfr;': 120090,
	'Xfr;': 120091,
	'Ycy;': 1067,
	'Yfr;': 120092,
	'Zcy;': 1047,
	'Zfr;': 8488,
	'acE;': 8766,
	'acd;': 8767,
	'acy;': 1072,
	'afr;': 120094,
	'amp;': 38,
	'and;': 8743,
	'ang;': 8736,
	'apE;': 10864,
	'ape;': 8778,
	'ast;': 42,
	auml: 228,
	'bcy;': 1073,
	'bfr;': 120095,
	'bne;': 61,
	'bot;': 8869,
	'cap;': 8745,
	cent: 162,
	'cfr;': 120096,
	'chi;': 967,
	'cir;': 9675,
	copy: 169,
	'cup;': 8746,
	'dcy;': 1076,
	'deg;': 176,
	'dfr;': 120097,
	'die;': 168,
	'div;': 247,
	'dot;': 729,
	'ecy;': 1101,
	'efr;': 120098,
	'egs;': 10902,
	'ell;': 8467,
	'els;': 10901,
	'eng;': 331,
	'eta;': 951,
	'eth;': 240,
	euml: 235,
	'fcy;': 1092,
	'ffr;': 120099,
	'gEl;': 10892,
	'gap;': 10886,
	'gcy;': 1075,
	'gel;': 8923,
	'geq;': 8805,
	'ges;': 10878,
	'gfr;': 120100,
	'ggg;': 8921,
	'glE;': 10898,
	'gla;': 10917,
	'glj;': 10916,
	'gnE;': 8809,
	'gne;': 10888,
	'hfr;': 120101,
	'icy;': 1080,
	'iff;': 8660,
	'ifr;': 120102,
	'int;': 8747,
	iuml: 239,
	'jcy;': 1081,
	'jfr;': 120103,
	'kcy;': 1082,
	'kfr;': 120104,
	'lEg;': 10891,
	'lap;': 10885,
	'lat;': 10923,
	'lcy;': 1083,
	'leg;': 8922,
	'leq;': 8804,
	'les;': 10877,
	'lfr;': 120105,
	'lgE;': 10897,
	'lnE;': 8808,
	'lne;': 10887,
	'loz;': 9674,
	'lrm;': 8206,
	'lsh;': 8624,
	macr: 175,
	'map;': 8614,
	'mcy;': 1084,
	'mfr;': 120106,
	'mho;': 8487,
	'mid;': 8739,
	'nGg;': 8921,
	'nGt;': 8811,
	'nLl;': 8920,
	'nLt;': 8810,
	'nap;': 8777,
	nbsp: 160,
	'ncy;': 1085,
	'nfr;': 120107,
	'ngE;': 8807,
	'nge;': 8817,
	'ngt;': 8815,
	'nis;': 8956,
	'niv;': 8715,
	'nlE;': 8806,
	'nle;': 8816,
	'nlt;': 8814,
	'not;': 172,
	'npr;': 8832,
	'nsc;': 8833,
	'num;': 35,
	'ocy;': 1086,
	'ofr;': 120108,
	'ogt;': 10689,
	'ohm;': 937,
	'olt;': 10688,
	'ord;': 10845,
	ordf: 170,
	ordm: 186,
	'orv;': 10843,
	ouml: 246,
	'par;': 8741,
	para: 182,
	'pcy;': 1087,
	'pfr;': 120109,
	'phi;': 966,
	'piv;': 982,
	'prE;': 10931,
	'pre;': 10927,
	'psi;': 968,
	'qfr;': 120110,
	quot: 34,
	'rcy;': 1088,
	'reg;': 174,
	'rfr;': 120111,
	'rho;': 961,
	'rlm;': 8207,
	'rsh;': 8625,
	'scE;': 10932,
	'sce;': 10928,
	'scy;': 1089,
	sect: 167,
	'sfr;': 120112,
	'shy;': 173,
	'sim;': 8764,
	'smt;': 10922,
	'sol;': 47,
	'squ;': 9633,
	'sub;': 8834,
	'sum;': 8721,
	sup1: 185,
	sup2: 178,
	sup3: 179,
	'sup;': 8835,
	'tau;': 964,
	'tcy;': 1090,
	'tfr;': 120113,
	'top;': 8868,
	'ucy;': 1091,
	'ufr;': 120114,
	'uml;': 168,
	uuml: 252,
	'vcy;': 1074,
	'vee;': 8744,
	'vfr;': 120115,
	'wfr;': 120116,
	'xfr;': 120117,
	'ycy;': 1099,
	'yen;': 165,
	'yfr;': 120118,
	yuml: 255,
	'zcy;': 1079,
	'zfr;': 120119,
	'zwj;': 8205,
	AMP: 38,
	'DD;': 8517,
	ETH: 208,
	'GT;': 62,
	'Gg;': 8921,
	'Gt;': 8811,
	'Im;': 8465,
	'LT;': 60,
	'Ll;': 8920,
	'Lt;': 8810,
	'Mu;': 924,
	'Nu;': 925,
	'Or;': 10836,
	'Pi;': 928,
	'Pr;': 10939,
	REG: 174,
	'Re;': 8476,
	'Sc;': 10940,
	'Xi;': 926,
	'ac;': 8766,
	'af;': 8289,
	amp: 38,
	'ap;': 8776,
	'dd;': 8518,
	deg: 176,
	'ee;': 8519,
	'eg;': 10906,
	'el;': 10905,
	eth: 240,
	'gE;': 8807,
	'ge;': 8805,
	'gg;': 8811,
	'gl;': 8823,
	'gt;': 62,
	'ic;': 8291,
	'ii;': 8520,
	'in;': 8712,
	'it;': 8290,
	'lE;': 8806,
	'le;': 8804,
	'lg;': 8822,
	'll;': 8810,
	'lt;': 60,
	'mp;': 8723,
	'mu;': 956,
	'ne;': 8800,
	'ni;': 8715,
	not: 172,
	'nu;': 957,
	'oS;': 9416,
	'or;': 8744,
	'pi;': 960,
	'pm;': 177,
	'pr;': 8826,
	reg: 174,
	'rx;': 8478,
	'sc;': 8827,
	shy: 173,
	uml: 168,
	'wp;': 8472,
	'wr;': 8768,
	'xi;': 958,
	yen: 165,
	GT: 62,
	LT: 60,
	gt: 62,
	lt: 60
};

const windows_1252 = [
	8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216,
	8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376
];

/**
 * @param {string} entity_name
 * @param {boolean} is_attribute_value
 */
function reg_exp_entity(entity_name, is_attribute_value) {
	// https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
	// doesn't decode the html entity which not ends with ; and next character is =, number or alphabet in attribute value.
	if (is_attribute_value && !entity_name.endsWith(';')) {
		return `${entity_name}\\b(?!=)`;
	}
	return entity_name;
}

/** @param {boolean} is_attribute_value */
function get_entity_pattern(is_attribute_value) {
	const reg_exp_num = '#(?:x[a-fA-F\\d]+|\\d+)(?:;)?';
	const reg_exp_entities = Object.keys(entities).map(
		/** @param {any} entity_name */ (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
	);

	const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join('|')})`, 'g');

	return entity_pattern;
}

const entity_pattern_content = get_entity_pattern(false);
const entity_pattern_attr_value = get_entity_pattern(true);

/**
 * @param {string} html
 * @param {boolean} is_attribute_value
 */
function decode_character_references(html, is_attribute_value) {
	const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
	return html.replace(
		entity_pattern,
		/**
		 * @param {any} match
		 * @param {keyof typeof entities} entity
		 */ (match, entity) => {
			let code;

			// Handle named entities
			if (entity[0] !== '#') {
				code = entities[entity];
			} else if (entity[1] === 'x') {
				code = parseInt(entity.substring(2), 16);
			} else {
				code = parseInt(entity.substring(1), 10);
			}

			if (!code) {
				return match;
			}

			return String.fromCodePoint(validate_code(code));
		}
	);
}

const NUL = 0;

// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
// code points with alternatives in some cases - since we're bypassing that mechanism, we need
// to replace them ourselves
//
// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
// Also see: https://en.wikipedia.org/wiki/Plane_(Unicode)
// Also see: https://html.spec.whatwg.org/multipage/parsing.html#preprocessing-the-input-stream

/** @param {number} code */
function validate_code(code) {
	// line feed becomes generic whitespace
	if (code === 10) {
		return 32;
	}

	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
	if (code < 128) {
		return code;
	}

	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
	// to correct the mistake or we'll end up with missing € signs and so on
	if (code <= 159) {
		return windows_1252[code - 128];
	}

	// basic multilingual plane
	if (code < 55296) {
		return code;
	}

	// UTF-16 surrogate halves
	if (code <= 57343) {
		return NUL;
	}

	// rest of the basic multilingual plane
	if (code <= 65535) {
		return code;
	}

	// supplementary multilingual plane 0x10000 - 0x1ffff
	if (code >= 65536 && code <= 131071) {
		return code;
	}

	// supplementary ideographic plane 0x20000 - 0x2ffff
	if (code >= 131072 && code <= 196607) {
		return code;
	}

	// supplementary special-purpose plane 0xe0000 - 0xe07f and 0xe0100 - 0xe01ef
	if ((code >= 917504 && code <= 917631) || (code >= 917760 && code <= 917999)) {
		return code;
	}

	return NUL;
}

/** @import { AST } from '#compiler' */

/**
 * @param {any} transparent
 * @returns {AST.Fragment}
 */
function create_fragment(transparent = false) {
	return {
		type: 'Fragment',
		nodes: [],
		metadata: {
			transparent,
			dynamic: false
		}
	};
}

/** @import { Expression, PrivateIdentifier, SourceLocation } from 'estree' */
/** @import { AST, Binding } from '#compiler' */

/**
 * All nodes that can appear elsewhere than the top level, have attributes and can contain children
 */
const element_nodes = [
	'SvelteElement',
	'RegularElement',
	'SvelteFragment',
	'Component',
	'SvelteComponent',
	'SvelteSelf',
	'SlotElement'
];

/**
 * Returns true for all nodes that can appear elsewhere than the top level, have attributes and can contain children
 * @param {AST.SvelteNode} node
 * @returns {node is AST.Component | AST.RegularElement | AST.SlotElement | AST.SvelteComponent | AST.SvelteElement | AST.SvelteFragment | AST.SvelteSelf}
 */
function is_element_node(node) {
	return element_nodes.includes(node.type);
}

/**
 * Returns true for all component-like nodes
 * @param {AST.SvelteNode} node
 * @returns {node is AST.Component |  AST.SvelteComponent | AST.SvelteSelf}
 */
function is_component_node(node) {
	return ['Component', 'SvelteComponent', 'SvelteSelf'].includes(node.type);
}

/**
 * @param {AST.RegularElement | AST.SvelteElement} node
 * @returns {boolean}
 */
function is_custom_element_node(node) {
	return (
		node.type === 'RegularElement' &&
		(node.name.includes('-') ||
			node.attributes.some((attr) => attr.type === 'Attribute' && attr.name === 'is'))
	);
}

/**
 * @param {string} name
 * @param {SourceLocation | null} name_loc
 * @param {number} start
 * @param {number} end
 * @param {AST.Attribute['value']} value
 * @returns {AST.Attribute}
 */
function create_attribute(name, name_loc, start, end, value) {
	return {
		type: 'Attribute',
		start,
		end,
		name,
		name_loc,
		value,
		metadata: {
			delegated: false,
			needs_clsx: false
		}
	};
}
class ExpressionMetadata {
	/** True if the expression references state directly, or _might_ (via member/call expressions) */
	has_state = false;

	/** True if the expression involves a call expression (often, it will need to be wrapped in a derived) */
	has_call = false;

	/** True if the expression contains `await` */
	has_await = false;

	/** True if the expression includes a member expression */
	has_member_expression = false;

	/** True if the expression includes an assignment or an update */
	has_assignment = false;

	/**
	 * All the bindings that are referenced eagerly (not inside functions) in this expression
	 * @type {Set<Binding>}
	 */
	dependencies = new Set();

	/**
	 * True if the expression references state directly, or _might_ (via member/call expressions)
	 * @type {Set<Binding>}
	 */
	references = new Set();

	/** @type {null | Set<Expression>} */
	#blockers = null;

	#get_blockers() {
		if (!this.#blockers) {
			this.#blockers = new Set();

			for (const d of this.dependencies) {
				if (d.blocker) this.#blockers.add(d.blocker);
			}
		}

		return this.#blockers;
	}

	blockers() {
		return array([...this.#get_blockers()]);
	}

	has_blockers() {
		return this.#get_blockers().size > 0;
	}

	is_async() {
		return this.has_await || this.#get_blockers().size > 0;
	}

	/**
	 * @param {ExpressionMetadata} source
	 */
	merge(source) {
		this.has_state ||= source.has_state;
		this.has_call ||= source.has_call;
		this.has_await ||= source.has_await;
		this.has_member_expression ||= source.has_member_expression;
		this.has_assignment ||= source.has_assignment;
		this.#blockers = null; // so that blockers are recalculated

		for (const r of source.references) this.references.add(r);
		for (const b of source.dependencies) this.dependencies.add(b);
	}
}

/**
 * @param {Expression | PrivateIdentifier} node
 */
function get_name(node) {
	if (node.type === 'Literal') return String(node.value);
	if (node.type === 'PrivateIdentifier') return '#' + node.name;
	if (node.type === 'Identifier') return node.name;

	return null;
}

/**
 * @param {string[]} strings
 * @param {string} conjunction
 */
function list$1(strings, conjunction = 'or') {
	if (strings.length === 1) return strings[0];
	if (strings.length === 2) return `${strings[0]} ${conjunction} ${strings[1]}`;
	return `${strings.slice(0, -1).join(', ')} ${conjunction} ${strings[strings.length - 1]}`;
}

/** @import { Expression, Identifier, SourceLocation } from 'estree' */
/** @import { Location } from 'locate-character' */
/** @import { AST } from '#compiler' */
/** @import { Parser } from '../index.js' */

const regex_invalid_unquoted_attribute_value = /^(\/>|[\s"'=<>`])/;
const regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
const regex_closing_comment = /-->/;
const regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
const regex_token_ending_character = /[\s=/>"']/;
const regex_starts_with_quote_characters = /^["']/;
const regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
const regex_valid_element_name =
	/^(?:![a-zA-Z]+|[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])$/;
const regex_valid_component_name =
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers adjusted for our needs
	// (must start with uppercase letter if no dots, can contain dots)
	/^(?:\p{Lu}[$\u200c\u200d\p{ID_Continue}.]*|\p{ID_Start}[$\u200c\u200d\p{ID_Continue}]*(?:\.[$\u200c\u200d\p{ID_Continue}]+)+)$/u;

/** @type {Map<string, AST.ElementLike['type']>} */
const root_only_meta_tags = new Map([
	['svelte:head', 'SvelteHead'],
	['svelte:options', 'SvelteOptions'],
	['svelte:window', 'SvelteWindow'],
	['svelte:document', 'SvelteDocument'],
	['svelte:body', 'SvelteBody']
]);

/** @type {Map<string, AST.ElementLike['type']>} */
const meta_tags = new Map([
	...root_only_meta_tags,
	['svelte:element', 'SvelteElement'],
	['svelte:component', 'SvelteComponent'],
	['svelte:self', 'SvelteSelf'],
	['svelte:fragment', 'SvelteFragment'],
	['svelte:boundary', 'SvelteBoundary']
]);

/** @param {Parser} parser */
function element(parser) {
	const start = parser.index++;

	let parent = parser.current();

	if (parser.eat('!--')) {
		const data = parser.read_until(regex_closing_comment);
		parser.eat('-->', true);

		parser.append({
			type: 'Comment',
			start,
			end: parser.index,
			data
		});

		return;
	}

	if (parser.eat('/')) {
		const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);

		parser.allow_whitespace();
		parser.eat('>', true);

		if (is_void(name)) {
			void_element_invalid_content(start);
		}

		// close any elements that don't have their own closing tags, e.g. <div><p></div>
		while (/** @type {AST.RegularElement} */ (parent).name !== name) {
			if (parser.loose) {
				// If the previous element did interpret the next opening tag as an attribute, backtrack
				if (is_element_node(parent)) {
					const last = parent.attributes.at(-1);
					if (last?.type === 'Attribute' && last.name === `<${name}`) {
						parser.index = last.start;
						parent.attributes.pop();
						break;
					}
				}
			}

			if (parent.type === 'RegularElement') {
				if (!parser.last_auto_closed_tag || parser.last_auto_closed_tag.tag !== name) {
					const end = parent.fragment.nodes[0]?.start ?? start;
					element_implicitly_closed(
						{ start: parent.start, end },
						`</${name}>`,
						`</${parent.name}>`
					);
				}
			} else if (!parser.loose) {
				if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name) {
					element_invalid_closing_tag_autoclosed(start, name, parser.last_auto_closed_tag.reason);
				} else {
					element_invalid_closing_tag(start, name);
				}
			}

			parent.end = start;
			parser.pop();

			parent = parser.current();
		}

		parent.end = parser.index;
		parser.pop();

		if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
			parser.last_auto_closed_tag = undefined;
		}

		return;
	}

	const tag = read_tag(parser, regex_whitespace_or_slash_or_closing_tag);

	if (tag.name.startsWith('svelte:') && !meta_tags.has(tag.name)) {
		const bounds = { start: start + 1, end: start + 1 + tag.name.length };
		svelte_meta_invalid_tag(bounds, list$1(Array.from(meta_tags.keys())));
	}

	if (!regex_valid_element_name.test(tag.name) && !regex_valid_component_name.test(tag.name)) {
		// <div. -> in the middle of typing -> allow in loose mode
		if (!parser.loose || !tag.name.endsWith('.')) {
			const bounds = { start: start + 1, end: start + 1 + tag.name.length };
			tag_invalid_name(bounds);
		}
	}

	if (root_only_meta_tags.has(tag.name)) {
		if (tag.name in parser.meta_tags) {
			svelte_meta_duplicate(start, tag.name);
		}

		if (parent.type !== 'Root') {
			svelte_meta_invalid_placement(start, tag.name);
		}

		parser.meta_tags[tag.name] = true;
	}

	const type = meta_tags.has(tag.name)
		? meta_tags.get(tag.name)
		: regex_valid_component_name.test(tag.name) || (parser.loose && tag.name.endsWith('.'))
			? 'Component'
			: tag.name === 'title' && parent_is_head(parser.stack)
				? 'TitleElement'
				: // TODO Svelte 6/7: once slots are removed in favor of snippets, always keep slot as a regular element
					tag.name === 'slot' && !parent_is_shadowroot_template(parser.stack)
					? 'SlotElement'
					: 'RegularElement';

	/** @type {AST.ElementLike} */
	const element =
		type === 'RegularElement'
			? {
					type,
					start,
					end: -1,
					name: tag.name,
					name_loc: tag.loc,
					attributes: [],
					fragment: create_fragment(true),
					metadata: {
						svg: false,
						mathml: false,
						scoped: false,
						has_spread: false,
						path: [],
						synthetic_value_node: null
					}
				}
			: /** @type {AST.ElementLike} */ ({
					type,
					start,
					end: -1,
					name: tag.name,
					name_loc: tag.loc,
					attributes: [],
					fragment: create_fragment(true),
					metadata: {
						// unpopulated at first, differs between types
					}
				});

	parser.allow_whitespace();

	if (parent.type === 'RegularElement' && closing_tag_omitted(parent.name, tag.name)) {
		const end = parent.fragment.nodes[0]?.start ?? start;
		element_implicitly_closed({ start: parent.start, end }, `<${tag.name}>`, `</${parent.name}>`);
		parent.end = start;
		parser.pop();
		parser.last_auto_closed_tag = {
			tag: parent.name,
			reason: tag.name,
			depth: parser.stack.length
		};
	}

	/** @type {string[]} */
	const unique_names = [];

	const current = parser.current();
	const is_top_level_script_or_style =
		(tag.name === 'script' || tag.name === 'style') && current.type === 'Root';

	const read = is_top_level_script_or_style ? read_static_attribute : read_attribute;

	let attribute;
	while ((attribute = read(parser))) {
		// animate and transition can only be specified once per element so no need
		// to check here, use can be used multiple times, same for the on directive
		// finally let already has error handling in case of duplicate variable names
		if (
			attribute.type === 'Attribute' ||
			attribute.type === 'BindDirective' ||
			attribute.type === 'StyleDirective' ||
			attribute.type === 'ClassDirective'
		) {
			// `bind:attribute` and `attribute` are just the same but `class:attribute`,
			// `style:attribute` and `attribute` are different and should be allowed together
			// so we concatenate the type while normalizing the type for BindDirective
			const type = attribute.type === 'BindDirective' ? 'Attribute' : attribute.type;
			if (unique_names.includes(type + attribute.name)) {
				attribute_duplicate(attribute);
				// <svelte:element bind:this this=..> is allowed
			} else if (attribute.name !== 'this') {
				unique_names.push(type + attribute.name);
			}
		}

		element.attributes.push(attribute);
		parser.allow_whitespace();
	}

	if (element.type === 'Component') {
		element.metadata.expression = new ExpressionMetadata();
	}

	if (element.type === 'SvelteComponent') {
		const index = element.attributes.findIndex(
			/** @param {any} attr */
			(attr) => attr.type === 'Attribute' && attr.name === 'this'
		);
		if (index === -1) {
			svelte_component_missing_this(start);
		}

		const definition = /** @type {AST.Attribute} */ (element.attributes.splice(index, 1)[0]);
		if (!is_expression_attribute(definition)) {
			svelte_component_invalid_this(definition.start);
		}

		element.expression = get_attribute_expression(definition);
		element.metadata.expression = new ExpressionMetadata();
	}

	if (element.type === 'SvelteElement') {
		const index = element.attributes.findIndex(
			/** @param {any} attr */
			(attr) => attr.type === 'Attribute' && attr.name === 'this'
		);
		if (index === -1) {
			svelte_element_missing_this(start);
		}

		const definition = /** @type {AST.Attribute} */ (element.attributes.splice(index, 1)[0]);

		if (definition.value === true) {
			svelte_element_missing_this(definition);
		}

		if (!is_expression_attribute(definition)) {
			svelte_element_invalid_this(definition);

			// note that this is wrong, in the case of e.g. `this="h{n}"` — it will result in `<h>`.
			// it would be much better to just error here, but we are preserving the existing buggy
			// Svelte 4 behaviour out of an overabundance of caution regarding breaking changes.
			// TODO in 6.0, error
			const chunk = /** @type {Array<AST.ExpressionTag | AST.Text>} */ (definition.value)[0];
			element.tag =
				chunk.type === 'Text'
					? {
							type: 'Literal',
							value: chunk.data,
							raw: `'${chunk.raw}'`,
							start: chunk.start,
							end: chunk.end
						}
					: chunk.expression;
		} else {
			element.tag = get_attribute_expression(definition);
		}

		element.metadata.expression = new ExpressionMetadata();
	}

	if (is_top_level_script_or_style) {
		parser.eat('>', true);

		/** @type {AST.Comment | null} */
		let prev_comment = null;
		for (let i = current.fragment.nodes.length - 1; i >= 0; i--) {
			const node = current.fragment.nodes[i];

			if (i === current.fragment.nodes.length - 1 && node.end !== start) {
				break;
			}

			if (node.type === 'Comment') {
				prev_comment = node;
				break;
			} else if (node.type !== 'Text' || node.data.trim()) {
				break;
			}
		}

		if (tag.name === 'script') {
			const content = read_script(parser, start, element.attributes);
			if (prev_comment) {
				// We take advantage of the fact that the root will never have leadingComments set,
				// and set the previous comment to it so that the warning mechanism can later
				// inspect the root and see if there was a html comment before it silencing specific warnings.
				content.content.leadingComments = [{ type: 'Line', value: prev_comment.data }];
			}

			if (content.context === 'module') {
				if (current.module) script_duplicate(start);
				current.module = content;
			} else {
				if (current.instance) script_duplicate(start);
				current.instance = content;
			}
		} else {
			const content = read_style(parser, start, element.attributes);
			content.content.comment = prev_comment;

			if (current.css) style_duplicate(start);
			current.css = content;
		}
		return;
	}

	parser.append(element);

	const self_closing = parser.eat('/') || is_void(tag.name);
	const closed = parser.eat('>', true, false);

	// Loose parsing mode
	if (!closed) {
		// We may have eaten an opening `<` of the next element and treated it as an attribute...
		const last = element.attributes.at(-1);
		if (last?.type === 'Attribute' && last.name === '<') {
			parser.index = last.start;
			element.attributes.pop();
		} else {
			// ... or we may have eaten part of a following block ...
			const prev_1 = parser.template[parser.index - 1];
			const prev_2 = parser.template[parser.index - 2];
			const current = parser.template[parser.index];
			if (prev_2 === '{' && prev_1 === '/') {
				parser.index -= 2;
			} else if (prev_1 === '{' && (current === '#' || current === '@' || current === ':')) {
				parser.index -= 1;
			} else {
				// ... or we're followed by whitespace, for example near the end of the template,
				// which we want to take in so that language tools has more room to work with
				parser.allow_whitespace();
			}
		}
	}

	if (self_closing || !closed) {
		// don't push self-closing elements onto the stack
		element.end = parser.index;
	} else if (tag.name === 'textarea') {
		// special case
		element.fragment.nodes = read_sequence(
			parser,
			() => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
			'inside <textarea>'
		);
		parser.read(regex_closing_textarea_tag);
		element.end = parser.index;
	} else if (tag.name === 'script' || tag.name === 'style') {
		// special case
		const start = parser.index;
		const data = parser.read_until(new RegExp(`</${tag.name}>`));
		const end = parser.index;

		/** @type {AST.Text} */
		const node = {
			start,
			end,
			type: 'Text',
			data,
			raw: data
		};

		element.fragment.nodes.push(node);
		parser.eat(`</${tag.name}>`, true);
		element.end = parser.index;
	} else {
		parser.stack.push(element);
		parser.fragments.push(element.fragment);
	}
}

/** @param {AST.TemplateNode[]} stack */
function parent_is_head(stack) {
	let i = stack.length;
	while (i--) {
		const { type } = stack[i];
		if (type === 'SvelteHead') return true;
		if (type === 'RegularElement' || type === 'Component') return false;
	}
	return false;
}

/** @param {AST.TemplateNode[]} stack */
function parent_is_shadowroot_template(stack) {
	// https://developer.chrome.com/docs/css-ui/declarative-shadow-dom#building_a_declarative_shadow_root
	let i = stack.length;
	while (i--) {
		if (
			stack[i].type === 'RegularElement' &&
			/** @type {AST.RegularElement} */ (stack[i]).attributes.some(
				(a) => a.type === 'Attribute' && a.name === 'shadowrootmode'
			)
		) {
			return true;
		}
	}
	return false;
}

/**
 * @param {Parser} parser
 * @returns {AST.Attribute | null}
 */
function read_static_attribute(parser) {
	const start = parser.index;

	const tag = read_tag(parser, regex_token_ending_character);
	if (!tag.name) return null;

	/** @type {true | Array<AST.Text | AST.ExpressionTag>} */
	let value = true;

	if (parser.eat('=')) {
		parser.allow_whitespace();
		let raw = parser.match_regex(regex_attribute_value);
		if (!raw) {
			expected_attribute_value(parser.index);
		}

		parser.index += raw.length;

		const quoted = raw[0] === '"' || raw[0] === "'";
		if (quoted) {
			raw = raw.slice(1, -1);
		}

		value = [
			{
				start: parser.index - raw.length - (quoted ? 1 : 0),
				end: quoted ? parser.index - 1 : parser.index,
				type: 'Text',
				raw: raw,
				data: decode_character_references(raw, true)
			}
		];
	}

	if (parser.match_regex(regex_starts_with_quote_characters)) {
		expected_token(parser.index, '=');
	}

	return create_attribute(tag.name, tag.loc, start, parser.index, value);
}

/**
 * @param {Parser} parser
 * @returns {AST.Attribute | AST.SpreadAttribute | AST.Directive | AST.AttachTag | null}
 */
function read_attribute(parser) {
	const start = parser.index;

	if (parser.eat('{')) {
		parser.allow_whitespace();

		if (parser.eat('@attach')) {
			parser.require_whitespace();

			const expression = read_expression(parser);
			parser.allow_whitespace();
			parser.eat('}', true);

			/** @type {AST.AttachTag} */
			const attachment = {
				type: 'AttachTag',
				start,
				end: parser.index,
				expression,
				metadata: {
					expression: new ExpressionMetadata()
				}
			};

			return attachment;
		}

		if (parser.eat('...')) {
			const expression = read_expression(parser);

			parser.allow_whitespace();
			parser.eat('}', true);

			/** @type {AST.SpreadAttribute} */
			const spread = {
				type: 'SpreadAttribute',
				start,
				end: parser.index,
				expression,
				metadata: {
					expression: new ExpressionMetadata()
				}
			};

			return spread;
		} else {
			const id = parser.read_identifier();

			if (id.name === '') {
				if (
					parser.loose &&
					(parser.match('#') || parser.match('/') || parser.match('@') || parser.match(':'))
				) {
					// We're likely in an unclosed opening tag and did read part of a block.
					// Return null to not crash the parser so it can continue with closing the tag.
					return null;
				} else if (parser.loose && parser.match('}')) ; else {
					attribute_empty_shorthand(start);
				}
			}

			parser.allow_whitespace();
			parser.eat('}', true);

			/** @type {AST.ExpressionTag} */
			const expression = {
				type: 'ExpressionTag',
				start: id.start,
				end: id.end,
				expression: id,
				metadata: {
					expression: new ExpressionMetadata()
				}
			};

			return create_attribute(id.name, id.loc, start, parser.index, expression);
		}
	}

	const tag = read_tag(parser, regex_token_ending_character);

	if (!tag.name) return null;

	let end = parser.index;

	parser.allow_whitespace();

	const colon_index = tag.name.indexOf(':');
	const type = colon_index !== -1 && get_directive_type(tag.name.slice(0, colon_index));

	/** @type {true | AST.ExpressionTag | Array<AST.Text | AST.ExpressionTag>} */
	let value = true;
	if (parser.eat('=')) {
		parser.allow_whitespace();

		if (parser.template[parser.index] === '/' && parser.template[parser.index + 1] === '>') {
			const char_start = parser.index;
			parser.index++; // consume '/'
			value = [
				{
					start: char_start,
					end: char_start + 1,
					type: 'Text',
					raw: '/',
					data: '/'
				}
			];
			end = parser.index;
		} else {
			value = read_attribute_value(parser);
			end = parser.index;
		}
	} else if (parser.match_regex(regex_starts_with_quote_characters)) {
		expected_token(parser.index, '=');
	}

	if (type) {
		const [directive_name, ...modifiers] = tag.name.slice(colon_index + 1).split('|');

		if (directive_name === '') {
			directive_missing_name({ start, end: start + colon_index + 1 }, tag.name);
		}

		if (type === 'StyleDirective') {
			return {
				start,
				end,
				type,
				name: directive_name,
				name_loc: tag.loc,
				modifiers: /** @type {Array<'important'>} */ (modifiers),
				value,
				metadata: {
					expression: new ExpressionMetadata()
				}
			};
		}

		const first_value = value === true ? undefined : Array.isArray(value) ? value[0] : value;

		/** @type {Expression | null} */
		let expression = null;

		if (first_value) {
			const attribute_contains_text =
				/** @type {any[]} */ (value).length > 1 || first_value.type === 'Text';
			if (attribute_contains_text) {
				directive_invalid_value(/** @type {number} */ (first_value.start));
			} else {
				// TODO throw a parser error in a future version here if this `[ExpressionTag]` instead of `ExpressionTag`,
				// which means stringified value, which isn't allowed for some directives?
				expression = first_value.expression;
			}
		}

		const directive = /** @type {AST.Directive} */ ({
			start,
			end,
			type,
			name: directive_name,
			name_loc: tag.loc,
			expression,
			metadata: {
				expression: new ExpressionMetadata()
			}
		});

		// @ts-expect-error we do this separately from the declaration to avoid upsetting typescript
		directive.modifiers = modifiers;

		if (directive.type === 'TransitionDirective') {
			const direction = tag.name.slice(0, colon_index);
			directive.intro = direction === 'in' || direction === 'transition';
			directive.outro = direction === 'out' || direction === 'transition';
		}

		// Directive name is expression, e.g. <p class:isRed />
		if (
			(directive.type === 'BindDirective' || directive.type === 'ClassDirective') &&
			!directive.expression
		) {
			directive.expression = /** @type {any} */ ({
				start: start + colon_index + 1,
				end,
				type: 'Identifier',
				name: directive.name
			});
		}

		return directive;
	}

	return create_attribute(tag.name, tag.loc, start, end, value);
}

/**
 * @param {string} name
 * @returns {any}
 */
function get_directive_type(name) {
	if (name === 'use') return 'UseDirective';
	if (name === 'animate') return 'AnimateDirective';
	if (name === 'bind') return 'BindDirective';
	if (name === 'class') return 'ClassDirective';
	if (name === 'style') return 'StyleDirective';
	if (name === 'on') return 'OnDirective';
	if (name === 'let') return 'LetDirective';
	if (name === 'in' || name === 'out' || name === 'transition') return 'TransitionDirective';
	return false;
}

/**
 * @param {Parser} parser
 * @return {AST.ExpressionTag | Array<AST.ExpressionTag | AST.Text>}
 */
function read_attribute_value(parser) {
	const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
	if (quote_mark && parser.eat(quote_mark)) {
		return [
			{
				start: parser.index - 1,
				end: parser.index - 1,
				type: 'Text',
				raw: '',
				data: ''
			}
		];
	}

	/** @type {Array<AST.ExpressionTag | AST.Text>} */
	let value;
	try {
		value = read_sequence(
			parser,
			() => {
				// handle common case of quote marks existing outside of regex for performance reasons
				if (quote_mark) return parser.match(quote_mark);
				return !!parser.match_regex(regex_invalid_unquoted_attribute_value);
			},
			'in attribute value'
		);
	} catch (/** @type {any} */ error) {
		if (error.code === 'js_parse_error') {
			// if the attribute value didn't close + self-closing tag
			// eg: `<Component test={{a:1} />`
			// acorn may throw a `Unterminated regular expression` because of `/>`
			const pos = error.position?.[0];
			if (pos !== undefined && parser.template.slice(pos - 1, pos + 1) === '/>') {
				parser.index = pos;
				expected_token(pos, quote_mark || '}');
			}
		}
		throw error;
	}

	if (value.length === 0 && !quote_mark) {
		expected_attribute_value(parser.index);
	}

	if (quote_mark) parser.index += 1;

	if (quote_mark || value.length > 1 || value[0].type === 'Text') {
		return value;
	} else {
		return value[0];
	}
}

/**
 * @param {Parser} parser
 * @param {() => boolean} done
 * @param {string} location
 * @returns {any[]}
 */
function read_sequence(parser, done, location) {
	/** @type {AST.Text} */
	let current_chunk = {
		start: parser.index,
		end: -1,
		type: 'Text',
		raw: '',
		data: ''
	};

	/** @type {Array<AST.Text | AST.ExpressionTag>} */
	const chunks = [];

	/** @param {number} end */
	function flush(end) {
		if (current_chunk.raw) {
			current_chunk.data = decode_character_references(current_chunk.raw, true);
			current_chunk.end = end;
			chunks.push(current_chunk);
		}
	}

	while (parser.index < parser.template.length) {
		const index = parser.index;

		if (done()) {
			flush(parser.index);
			return chunks;
		} else if (parser.eat('{')) {
			if (parser.match('#')) {
				const index = parser.index - 1;
				parser.eat('#');
				const name = parser.read_until(/[^a-z]/);
				block_invalid_placement(index, name, location);
			} else if (parser.match('@')) {
				const index = parser.index - 1;
				parser.eat('@');
				const name = parser.read_until(/[^a-z]/);
				tag_invalid_placement(index, name, location);
			}

			flush(parser.index - 1);

			parser.allow_whitespace();
			const expression = read_expression(parser);
			parser.allow_whitespace();
			parser.eat('}', true);

			/** @type {AST.ExpressionTag} */
			const chunk = {
				type: 'ExpressionTag',
				start: index,
				end: parser.index,
				expression,
				metadata: {
					expression: new ExpressionMetadata()
				}
			};

			chunks.push(chunk);

			current_chunk = {
				start: parser.index,
				end: -1,
				type: 'Text',
				raw: '',
				data: ''
			};
		} else {
			current_chunk.raw += parser.template[parser.index++];
		}
	}

	if (parser.loose) {
		return chunks;
	} else {
		unexpected_eof(parser.template.length);
	}
}

/**
 * @param {Parser} parser
 * @param {RegExp} regex
 * @returns {Identifier & { start: number, end: number, loc: SourceLocation }}
 */
function read_tag(parser, regex) {
	const start = parser.index;
	const name = parser.read_until(regex);
	const end = parser.index;

	return {
		type: 'Identifier',
		name,
		start,
		end,
		loc: {
			start: locator(start),
			end: locator(end)
		}
	};
}

/** @import { Pattern } from 'estree' */
/** @import { Parser } from '../index.js' */

/**
 * @param {Parser} parser
 * @returns {Pattern}
 */
function read_pattern(parser) {
	const start = parser.index;
	let i = parser.index;

	const id = parser.read_identifier();

	if (id.name !== '') {
		const annotation = read_type_annotation(parser);

		return {
			...id,
			typeAnnotation: annotation
		};
	}

	const char = parser.template[i];

	if (char !== '{' && char !== '[') {
		expected_pattern(i);
	}

	i = match_bracket(parser, start);
	parser.index = i;

	const pattern_string = parser.template.slice(start, i);

	try {
		// the length of the `space_with_newline` has to be start - 1
		// because we added a `(` in front of the pattern_string,
		// which shifted the entire string to right by 1
		// so we offset it by removing 1 character in the `space_with_newline`
		// to achieve that, we remove the 1st space encountered,
		// so it will not affect the `column` of the node
		let space_with_newline = parser.template
			.slice(0, start)
			.replace(regex_not_newline_characters, ' ');
		const first_space = space_with_newline.indexOf(' ');
		space_with_newline =
			space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);

		const expression = /** @type {any} */ (
			parse_expression_at(
				`${space_with_newline}(${pattern_string} = 1)`,
				parser.root.comments,
				parser.ts,
				start - 1
			)
		).left;

		expression.typeAnnotation = read_type_annotation(parser);
		if (expression.typeAnnotation) {
			expression.end = expression.typeAnnotation.end;
		}

		return expression;
	} catch (error) {
		parser.acorn_error(error);
	}
}

/**
 * @param {Parser} parser
 * @returns {any}
 */
function read_type_annotation(parser) {
	const start = parser.index;
	parser.allow_whitespace();

	if (!parser.eat(':')) {
		parser.index = start;
		return undefined;
	}

	// we need to trick Acorn into parsing the type annotation
	const insert = '_ as ';
	let a = parser.index - insert.length;
	const template =
		parser.template.slice(0, a).replace(/[^\n]/g, ' ') +
		insert +
		// If this is a type annotation for a function parameter, Acorn-TS will treat subsequent
		// parameters as part of a sequence expression instead, and will then error on optional
		// parameters (`?:`). Therefore replace that sequence with something that will not error.
		parser.template.slice(parser.index).replace(/\?\s*:/g, ':');
	let expression = parse_expression_at(template, parser.root.comments, parser.ts, a);

	// `foo: bar = baz` gets mangled — fix it
	if (expression.type === 'AssignmentExpression') {
		let b = expression.right.start;
		while (template[b] !== '=') b -= 1;
		expression = parse_expression_at(template.slice(0, b), parser.root.comments, parser.ts, a);
	}

	// `array as item: string, index` becomes `string, index`, which is mistaken as a sequence expression - fix that
	if (expression.type === 'SequenceExpression') {
		expression = expression.expressions[0];
	}

	parser.index = /** @type {number} */ (expression.end);
	return {
		type: 'TSTypeAnnotation',
		start,
		end: parser.index,
		typeAnnotation: /** @type {any} */ (expression).typeAnnotation
	};
}

/** @import { ArrowFunctionExpression, Expression, Identifier, Pattern } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { Parser } from '../index.js' */

const regex_whitespace_with_closing_curly_brace = /^\s*}/;

const pointy_bois = { '<': '>' };

/** @param {Parser} parser */
function tag(parser) {
	const start = parser.index;
	parser.index += 1;

	parser.allow_whitespace();

	if (parser.eat('#')) return open(parser);
	if (parser.eat(':')) return next(parser);
	if (parser.eat('@')) return special(parser);
	if (parser.match('/')) {
		if (!parser.match('/*') && !parser.match('//')) {
			parser.eat('/');
			return close(parser);
		}
	}

	const expression = read_expression(parser);

	parser.allow_whitespace();
	parser.eat('}', true);

	parser.append({
		type: 'ExpressionTag',
		start,
		end: parser.index,
		expression,
		metadata: {
			expression: new ExpressionMetadata()
		}
	});
}

/** @param {Parser} parser */
function open(parser) {
	let start = parser.index - 2;
	while (parser.template[start] !== '{') start -= 1;

	if (parser.eat('if')) {
		parser.require_whitespace();

		/** @type {AST.IfBlock} */
		const block = parser.append({
			type: 'IfBlock',
			elseif: false,
			start,
			end: -1,
			test: read_expression(parser),
			consequent: create_fragment(),
			alternate: null,
			metadata: {
				expression: new ExpressionMetadata()
			}
		});

		parser.allow_whitespace();
		parser.eat('}', true);

		parser.stack.push(block);
		parser.fragments.push(block.consequent);

		return;
	}

	if (parser.eat('each')) {
		parser.require_whitespace();

		const template = parser.template;
		let end = parser.template.length;

		/** @type {Expression | undefined} */
		let expression;

		// we have to do this loop because `{#each x as { y = z }}` fails to parse —
		// the `as { y = z }` is treated as an Expression but it's actually a Pattern.
		// the 'fix' is to backtrack and hide everything from the `as` onwards, until
		// we get a valid expression
		while (!expression) {
			try {
				expression = read_expression(parser, undefined, true);
			} catch (err) {
				end = /** @type {any} */ (err).position[0] - 2;

				while (end > start && parser.template.slice(end, end + 2) !== 'as') {
					end -= 1;
				}

				if (end <= start) {
					if (parser.loose) {
						expression = get_loose_identifier(parser);
						if (expression) {
							break;
						}
					}
					throw err;
				}

				// @ts-expect-error parser.template is meant to be readonly, this is a special case
				parser.template = template.slice(0, end);
			}
		}

		// @ts-expect-error
		parser.template = template;

		parser.allow_whitespace();

		// {#each} blocks must declare a context – {#each list as item}
		if (!parser.match('as')) {
			// this could be a TypeScript assertion that was erroneously eaten.

			if (expression.type === 'SequenceExpression') {
				expression = expression.expressions[0];
			}

			let assertion = null;
			let end = expression.end;

			expression = walk$1(expression, null, {
				// @ts-expect-error
				TSAsExpression(node, context) {
					if (node.end === /** @type {Expression} */ (expression).end) {
						assertion = node;
						end = node.expression.end;
						return node.expression;
					}

					context.next();
				}
			});

			expression.end = end;

			if (assertion) {
				// we can't reset `parser.index` to `expression.expression.end` because
				// it will ignore any parentheses — we need to jump through this hoop
				let end = /** @type {any} */ (/** @type {any} */ (assertion).typeAnnotation).start - 2;
				while (parser.template.slice(end, end + 2) !== 'as') end -= 1;

				parser.index = end;
			}
		}

		/** @type {Pattern | null} */
		let context = null;
		let index;
		let key;

		if (parser.eat('as')) {
			parser.require_whitespace();

			context = read_pattern(parser);
		} else {
			// {#each Array.from({ length: 10 }), i} is read as a sequence expression,
			// which is set back above - we now gotta reset the index as a consequence
			// to properly read the , i part
			parser.index = /** @type {number} */ (expression.end);
		}

		parser.allow_whitespace();

		if (parser.eat(',')) {
			parser.allow_whitespace();
			index = parser.read_identifier().name;
			if (!index) {
				expected_identifier(parser.index);
			}

			parser.allow_whitespace();
		}

		if (parser.eat('(')) {
			parser.allow_whitespace();

			key = read_expression(parser, '(');
			parser.allow_whitespace();
			parser.eat(')', true);
			parser.allow_whitespace();
		}

		const matches = parser.eat('}', true, false);

		if (!matches) {
			// Parser may have read the `as` as part of the expression (e.g. in `{#each foo. as x}`)
			if (parser.template.slice(parser.index - 4, parser.index) === ' as ') {
				const prev_index = parser.index;
				context = read_pattern(parser);
				parser.eat('}', true);
				expression = {
					type: 'Identifier',
					name: '',
					start: expression.start,
					end: prev_index - 4
				};
			} else {
				parser.eat('}', true); // rerun to produce the parser error
			}
		}

		/** @type {AST.EachBlock} */
		const block = parser.append({
			type: 'EachBlock',
			start,
			end: -1,
			expression,
			body: create_fragment(),
			context,
			index,
			key,
			metadata: /** @type {any} */ (null) // filled in later
		});

		parser.stack.push(block);
		parser.fragments.push(block.body);

		return;
	}

	if (parser.eat('await')) {
		parser.require_whitespace();
		const expression = read_expression(parser);
		parser.allow_whitespace();

		/** @type {AST.AwaitBlock} */
		const block = parser.append({
			type: 'AwaitBlock',
			start,
			end: -1,
			expression,
			value: null,
			error: null,
			pending: null,
			then: null,
			catch: null,
			metadata: {
				expression: new ExpressionMetadata()
			}
		});

		if (parser.eat('then')) {
			if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
				parser.allow_whitespace();
			} else {
				parser.require_whitespace();
				block.value = read_pattern(parser);
				parser.allow_whitespace();
			}

			block.then = create_fragment();
			parser.fragments.push(block.then);
		} else if (parser.eat('catch')) {
			if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
				parser.allow_whitespace();
			} else {
				parser.require_whitespace();
				block.error = read_pattern(parser);
				parser.allow_whitespace();
			}

			block.catch = create_fragment();
			parser.fragments.push(block.catch);
		} else {
			block.pending = create_fragment();
			parser.fragments.push(block.pending);
		}

		const matches = parser.eat('}', true, false);

		// Parser may have read the `then/catch` as part of the expression (e.g. in `{#await foo. then x}`)
		if (!matches) {
			if (parser.template.slice(parser.index - 6, parser.index) === ' then ') {
				const prev_index = parser.index;
				block.value = read_pattern(parser);
				parser.eat('}', true);
				block.expression = {
					type: 'Identifier',
					name: '',
					start: expression.start,
					end: prev_index - 6
				};
				block.then = block.pending;
				block.pending = null;
			} else if (parser.template.slice(parser.index - 7, parser.index) === ' catch ') {
				const prev_index = parser.index;
				block.error = read_pattern(parser);
				parser.eat('}', true);
				block.expression = {
					type: 'Identifier',
					name: '',
					start: expression.start,
					end: prev_index - 7
				};
				block.catch = block.pending;
				block.pending = null;
			} else {
				parser.eat('}', true); // rerun to produce the parser error
			}
		}

		parser.stack.push(block);

		return;
	}

	if (parser.eat('key')) {
		parser.require_whitespace();

		const expression = read_expression(parser);
		parser.allow_whitespace();

		parser.eat('}', true);

		/** @type {AST.KeyBlock} */
		const block = parser.append({
			type: 'KeyBlock',
			start,
			end: -1,
			expression,
			fragment: create_fragment(),
			metadata: {
				expression: new ExpressionMetadata()
			}
		});

		parser.stack.push(block);
		parser.fragments.push(block.fragment);

		return;
	}

	if (parser.eat('snippet')) {
		parser.require_whitespace();

		const id = parser.read_identifier();

		if (id.name === '' && !parser.loose) {
			expected_identifier(parser.index);
		}

		parser.allow_whitespace();

		const params_start = parser.index;

		// snippets could have a generic signature, e.g. `#snippet foo<T>(...)`
		/** @type {string | undefined} */
		let type_params;

		// if we match a generic opening
		if (parser.ts && parser.match('<')) {
			const start = parser.index;
			const end = match_bracket(parser, start, pointy_bois);

			type_params = parser.template.slice(start + 1, end - 1);

			parser.index = end;
		}

		parser.allow_whitespace();

		const matched = parser.eat('(', true, false);

		if (matched) {
			let parentheses = 1;

			while (parser.index < parser.template.length && (!parser.match(')') || parentheses !== 1)) {
				if (parser.match('(')) parentheses++;
				if (parser.match(')')) parentheses--;
				parser.index += 1;
			}

			parser.eat(')', true);
		}

		const prelude = parser.template.slice(0, params_start).replace(/\S/g, ' ');
		const params = parser.template.slice(params_start, parser.index);

		let function_expression = matched
			? /** @type {ArrowFunctionExpression} */ (
					parse_expression_at(
						prelude + `${params} => {}`,
						parser.root.comments,
						parser.ts,
						params_start
					)
				)
			: { params: [] };

		parser.allow_whitespace();
		parser.eat('}', true);

		/** @type {AST.SnippetBlock} */
		const block = parser.append({
			type: 'SnippetBlock',
			start,
			end: -1,
			expression: id,
			typeParams: type_params,
			parameters: function_expression.params,
			body: create_fragment(),
			metadata: {
				can_hoist: false,
				sites: new Set()
			}
		});
		parser.stack.push(block);
		parser.fragments.push(block.body);

		return;
	}

	expected_block_type(parser.index);
}

/** @param {Parser} parser */
function next(parser) {
	const start = parser.index - 1;

	const block = parser.current(); // TODO type should not be TemplateNode, that's much too broad

	if (block.type === 'IfBlock') {
		if (!parser.eat('else')) expected_token(start, '{:else} or {:else if}');
		if (parser.eat('if')) block_invalid_elseif(start);

		parser.allow_whitespace();

		parser.fragments.pop();

		block.alternate = create_fragment();
		parser.fragments.push(block.alternate);

		// :else if
		if (parser.eat('if')) {
			parser.require_whitespace();

			const expression = read_expression(parser);

			parser.allow_whitespace();
			parser.eat('}', true);

			let elseif_start = start - 1;
			while (parser.template[elseif_start] !== '{') elseif_start -= 1;

			/** @type {AST.IfBlock} */
			const child = parser.append({
				start: elseif_start,
				end: -1,
				type: 'IfBlock',
				elseif: true,
				test: expression,
				consequent: create_fragment(),
				alternate: null,
				metadata: {
					expression: new ExpressionMetadata()
				}
			});

			parser.stack.push(child);
			parser.fragments.pop();
			parser.fragments.push(child.consequent);
		} else {
			// :else
			parser.allow_whitespace();
			parser.eat('}', true);
		}

		return;
	}

	if (block.type === 'EachBlock') {
		if (!parser.eat('else')) expected_token(start, '{:else}');

		parser.allow_whitespace();
		parser.eat('}', true);

		block.fallback = create_fragment();

		parser.fragments.pop();
		parser.fragments.push(block.fallback);

		return;
	}

	if (block.type === 'AwaitBlock') {
		if (parser.eat('then')) {
			if (block.then) {
				block_duplicate_clause(start, '{:then}');
			}

			if (!parser.eat('}')) {
				parser.require_whitespace();
				block.value = read_pattern(parser);
				parser.allow_whitespace();
				parser.eat('}', true);
			}

			block.then = create_fragment();
			parser.fragments.pop();
			parser.fragments.push(block.then);

			return;
		}

		if (parser.eat('catch')) {
			if (block.catch) {
				block_duplicate_clause(start, '{:catch}');
			}

			if (!parser.eat('}')) {
				parser.require_whitespace();
				block.error = read_pattern(parser);
				parser.allow_whitespace();
				parser.eat('}', true);
			}

			block.catch = create_fragment();
			parser.fragments.pop();
			parser.fragments.push(block.catch);

			return;
		}

		expected_token(start, '{:then ...} or {:catch ...}');
	}

	block_invalid_continuation_placement(start);
}

/** @param {Parser} parser */
function close(parser) {
	const start = parser.index - 1;

	let block = parser.current();
	/** Only relevant/reached for loose parsing mode */
	let matched;

	switch (block.type) {
		case 'IfBlock':
			matched = parser.eat('if', true, false);

			if (!matched) {
				block.end = start - 1;
				parser.pop();
				close(parser);
				return;
			}

			parser.allow_whitespace();
			parser.eat('}', true);

			while (block.elseif) {
				block.end = parser.index;
				parser.stack.pop();
				block = /** @type {AST.IfBlock} */ (parser.current());
			}

			block.end = parser.index;
			parser.pop();
			return;

		case 'EachBlock':
			matched = parser.eat('each', true, false);
			break;
		case 'KeyBlock':
			matched = parser.eat('key', true, false);
			break;
		case 'AwaitBlock':
			matched = parser.eat('await', true, false);
			break;
		case 'SnippetBlock':
			matched = parser.eat('snippet', true, false);
			break;

		case 'RegularElement':
			if (parser.loose) {
				matched = false;
			} else {
				// TODO handle implicitly closed elements
				block_unexpected_close(start);
			}
			break;

		default:
			block_unexpected_close(start);
	}

	if (!matched) {
		block.end = start - 1;
		parser.pop();
		close(parser);
		return;
	}

	parser.allow_whitespace();
	parser.eat('}', true);
	block.end = parser.index;
	parser.pop();
}

/** @param {Parser} parser */
function special(parser) {
	let start = parser.index;
	while (parser.template[start] !== '{') start -= 1;

	if (parser.eat('html')) {
		// {@html content} tag
		parser.require_whitespace();

		const expression = read_expression(parser);

		parser.allow_whitespace();
		parser.eat('}', true);

		parser.append({
			type: 'HtmlTag',
			start,
			end: parser.index,
			expression,
			metadata: {
				expression: new ExpressionMetadata()
			}
		});

		return;
	}

	if (parser.eat('debug')) {
		/** @type {Identifier[]} */
		let identifiers;

		// Implies {@debug} which indicates "debug all"
		if (parser.read(regex_whitespace_with_closing_curly_brace)) {
			identifiers = [];
		} else {
			const expression = read_expression(parser);

			identifiers =
				expression.type === 'SequenceExpression'
					? /** @type {Identifier[]} */ (expression.expressions)
					: [/** @type {Identifier} */ (expression)];

			identifiers.forEach(
				/** @param {any} node */ (node) => {
					if (node.type !== 'Identifier') {
						debug_tag_invalid_arguments(/** @type {number} */ (node.start));
					}
				}
			);

			parser.allow_whitespace();
			parser.eat('}', true);
		}

		parser.append({
			type: 'DebugTag',
			start,
			end: parser.index,
			identifiers
		});

		return;
	}

	if (parser.eat('const')) {
		parser.require_whitespace();

		const id = read_pattern(parser);
		parser.allow_whitespace();

		parser.eat('=', true);
		parser.allow_whitespace();

		const expression_start = parser.index;
		const init = read_expression(parser);
		if (
			init.type === 'SequenceExpression' &&
			!parser.template.substring(expression_start, init.start).includes('(')
		) {
			// const a = (b, c) is allowed but a = b, c = d is not;
			const_tag_invalid_expression(init);
		}
		parser.allow_whitespace();

		parser.eat('}', true);

		parser.append({
			type: 'ConstTag',
			start,
			end: parser.index,
			declaration: {
				type: 'VariableDeclaration',
				kind: 'const',
				declarations: [{ type: 'VariableDeclarator', id, init, start: id.start, end: init.end }],
				start: start + 2, // start at const, not at @const
				end: parser.index - 1
			},
			metadata: {
				expression: new ExpressionMetadata()
			}
		});
		return;
	}

	if (parser.eat('render')) {
		// {@render foo(...)}
		parser.require_whitespace();

		const expression = read_expression(parser);

		if (
			expression.type !== 'CallExpression' &&
			(expression.type !== 'ChainExpression' || expression.expression.type !== 'CallExpression')
		) {
			render_tag_invalid_expression(expression);
		}

		parser.allow_whitespace();
		parser.eat('}', true);

		parser.append({
			type: 'RenderTag',
			start,
			end: parser.index,
			expression: /** @type {AST.RenderTag['expression']} */ (expression),
			metadata: {
				expression: new ExpressionMetadata(),
				dynamic: false,
				arguments: [],
				path: [],
				snippets: new Set()
			}
		});
		return;
	}
	expected_tag(parser.index);
}

/** @import { AST } from '#compiler' */
/** @import { Parser } from '../index.js' */

/** @param {Parser} parser */
function text(parser) {
	const start = parser.index;

	let data = '';

	while (parser.index < parser.template.length && !parser.match('<') && !parser.match('{')) {
		data += parser.template[parser.index++];
	}

	/** @type {AST.Text} */
	parser.append({
		type: 'Text',
		start,
		end: parser.index,
		raw: data,
		data: decode_character_references(data, false)
	});
}

/** @import { Parser } from '../index.js' */

/** @param {Parser} parser */
function fragment(parser) {
	if (parser.match('<')) {
		return element;
	}

	if (parser.match('{')) {
		return tag;
	}

	return text;
}

/** @import { ObjectExpression } from 'estree' */
/** @import { AST } from '#compiler' */

/**
 * @param {AST.SvelteOptionsRaw} node
 * @returns {AST.Root['options']}
 */
function read_options(node) {
	/** @type {AST.SvelteOptions} */
	const component_options = {
		start: node.start,
		end: node.end,
		// @ts-ignore
		attributes: node.attributes
	};

	if (!node) {
		return component_options;
	}

	for (const attribute of node.attributes) {
		if (attribute.type !== 'Attribute') {
			svelte_options_invalid_attribute(attribute);
		}

		const { name } = attribute;

		switch (name) {
			case 'runes': {
				component_options.runes = get_boolean_value(attribute);
				break;
			}
			case 'tag': {
				svelte_options_deprecated_tag(attribute);
				break; // eslint doesn't know this is unnecessary
			}
			case 'customElement': {
				/** @type {AST.SvelteOptions['customElement']} */
				const ce = {};
				const { value: v } = attribute;
				const value = v === true || Array.isArray(v) ? v : [v];

				if (value === true) {
					svelte_options_invalid_customelement(attribute);
				} else if (value[0].type === 'Text') {
					const tag = get_static_value$1(attribute);
					validate_tag(attribute, tag);
					ce.tag = tag;
					component_options.customElement = ce;
					break;
				} else if (value[0].expression.type !== 'ObjectExpression') {
					// Before Svelte 4 it was necessary to explicitly set customElement to null or else you'd get a warning.
					// This is no longer necessary, but for backwards compat just skip in this case now.
					if (value[0].expression.type === 'Literal' && value[0].expression.value === null) {
						break;
					}
					svelte_options_invalid_customelement(attribute);
				}

				/** @type {Array<[string, any]>} */
				const properties = [];
				for (const property of value[0].expression.properties) {
					if (
						property.type !== 'Property' ||
						property.computed ||
						property.key.type !== 'Identifier'
					) {
						svelte_options_invalid_customelement(attribute);
					}
					properties.push([property.key.name, property.value]);
				}

				const tag = properties.find(([name]) => name === 'tag');
				if (tag) {
					const tag_value = tag[1]?.value;
					validate_tag(tag, tag_value);
					ce.tag = tag_value;
				}

				const props = properties.find(([name]) => name === 'props')?.[1];
				if (props) {
					if (props.type !== 'ObjectExpression') {
						svelte_options_invalid_customelement_props(attribute);
					}
					ce.props = {};
					for (const property of /** @type {ObjectExpression} */ (props).properties) {
						if (
							property.type !== 'Property' ||
							property.computed ||
							property.key.type !== 'Identifier' ||
							property.value.type !== 'ObjectExpression'
						) {
							svelte_options_invalid_customelement_props(attribute);
						}
						ce.props[property.key.name] = {};
						for (const prop of property.value.properties) {
							if (
								prop.type !== 'Property' ||
								prop.computed ||
								prop.key.type !== 'Identifier' ||
								prop.value.type !== 'Literal'
							) {
								svelte_options_invalid_customelement_props(attribute);
							}

							if (prop.key.name === 'type') {
								if (
									['String', 'Number', 'Boolean', 'Array', 'Object'].indexOf(
										/** @type {string} */ (prop.value.value)
									) === -1
								) {
									svelte_options_invalid_customelement_props(attribute);
								}
								ce.props[property.key.name].type = /** @type {any} */ (prop.value.value);
							} else if (prop.key.name === 'reflect') {
								if (typeof prop.value.value !== 'boolean') {
									svelte_options_invalid_customelement_props(attribute);
								}
								ce.props[property.key.name].reflect = prop.value.value;
							} else if (prop.key.name === 'attribute') {
								if (typeof prop.value.value !== 'string') {
									svelte_options_invalid_customelement_props(attribute);
								}
								ce.props[property.key.name].attribute = prop.value.value;
							} else {
								svelte_options_invalid_customelement_props(attribute);
							}
						}
					}
				}

				const shadow = properties.find(([name]) => name === 'shadow')?.[1];
				if (shadow) {
					const shadowdom = shadow?.value;
					if (shadowdom !== 'open' && shadowdom !== 'none') {
						svelte_options_invalid_customelement_shadow(shadow);
					}
					ce.shadow = shadowdom;
				}

				const extend = properties.find(([name]) => name === 'extend')?.[1];
				if (extend) {
					ce.extend = extend;
				}

				component_options.customElement = ce;
				break;
			}
			case 'namespace': {
				const value = get_static_value$1(attribute);

				if (value === NAMESPACE_SVG) {
					component_options.namespace = 'svg';
				} else if (value === NAMESPACE_MATHML) {
					component_options.namespace = 'mathml';
				} else if (value === 'html' || value === 'mathml' || value === 'svg') {
					component_options.namespace = value;
				} else {
					svelte_options_invalid_attribute_value(attribute, `"html", "mathml" or "svg"`);
				}

				break;
			}
			case 'css': {
				const value = get_static_value$1(attribute);

				if (value === 'injected') {
					component_options.css = value;
				} else {
					svelte_options_invalid_attribute_value(attribute, `"injected"`);
				}

				break;
			}
			case 'immutable': {
				component_options.immutable = get_boolean_value(attribute);
				break;
			}
			case 'preserveWhitespace': {
				component_options.preserveWhitespace = get_boolean_value(attribute);
				break;
			}
			case 'accessors': {
				component_options.accessors = get_boolean_value(attribute);
				break;
			}
			default:
				svelte_options_unknown_attribute(attribute, name);
		}
	}

	return component_options;
}

/**
 * @param {any} attribute
 */
function get_static_value$1(attribute) {
	const { value } = attribute;

	if (value === true) return true;

	const chunk = Array.isArray(value) ? value[0] : value;

	if (!chunk) return true;
	if (value.length > 1) {
		return null;
	}
	if (chunk.type === 'Text') return chunk.data;
	if (chunk.expression.type !== 'Literal') {
		return null;
	}

	return chunk.expression.value;
}

/**
 * @param {any} attribute
 */
function get_boolean_value(attribute) {
	const value = get_static_value$1(attribute);
	if (typeof value !== 'boolean') {
		svelte_options_invalid_attribute_value(attribute, 'true or false');
	}
	return value;
}

// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
const tag_name_char =
	'[a-z0-9_.\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}-]';
const regex_valid_tag_name = new RegExp(`^[a-z]${tag_name_char}*-${tag_name_char}*$`, 'u');
const reserved_tag_names = [
	'annotation-xml',
	'color-profile',
	'font-face',
	'font-face-src',
	'font-face-uri',
	'font-face-format',
	'font-face-name',
	'missing-glyph'
];

/**
 * @param {any} attribute
 * @param {string | null} tag
 * @returns {asserts tag is string}
 */
function validate_tag(attribute, tag) {
	if (typeof tag !== 'string') {
		svelte_options_invalid_tagname(attribute);
	}
	if (tag) {
		if (!regex_valid_tag_name.test(tag)) {
			svelte_options_invalid_tagname(attribute);
		} else if (reserved_tag_names.includes(tag)) {
			svelte_options_reserved_tagname(attribute);
		}
	}
}

/** @import { AST } from '#compiler' */

/**
 * @param {AST.SvelteBody | AST.SvelteDocument | AST.SvelteOptionsRaw | AST.SvelteWindow} node
 */
function disallow_children(node) {
	const { nodes } = node.fragment;

	if (nodes.length > 0) {
		const first = nodes[0];
		const last = nodes[nodes.length - 1];

		svelte_meta_invalid_content({ start: first.start, end: last.end }, node.name);
	}
}

/** @import { AST } from '#compiler' */
/** @import { Location } from 'locate-character' */
/** @import * as ESTree from 'estree' */
// @ts-expect-error acorn type definitions are borked in the release we use

const regex_position_indicator = / \(\d+:\d+\)$/;

const regex_lang_attribute =
	/<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;

class Parser {
	/**
	 * @readonly
	 * @type {string}
	 */
	template;

	/**
	 * Whether or not we're in loose parsing mode, in which
	 * case we try to continue parsing as much as possible
	 * @type {boolean}
	 */
	loose;

	/** */
	index = 0;

	/** Whether we're parsing in TypeScript mode */
	ts = false;

	/** @type {AST.TemplateNode[]} */
	stack = [];

	/** @type {AST.Fragment[]} */
	fragments = [];

	/** @type {AST.Root} */
	root;

	/** @type {Record<string, boolean>} */
	meta_tags = {};

	/** @type {LastAutoClosedTag | undefined} */
	last_auto_closed_tag;

	/**
	 * @param {string} template
	 * @param {boolean} loose
	 */
	constructor(template, loose) {
		if (typeof template !== 'string') {
			throw new TypeError('Template must be a string');
		}

		this.loose = loose;
		this.template = template.trimEnd();

		let match_lang;

		do match_lang = regex_lang_attribute.exec(template);
		while (match_lang && match_lang[0][1] !== 's'); // ensure it starts with '<s' to match script tags

		regex_lang_attribute.lastIndex = 0; // reset matched index to pass tests - otherwise declare the regex inside the constructor

		this.ts = match_lang?.[2] === 'ts';

		this.root = {
			css: null,
			js: [],
			// @ts-ignore
			start: null,
			// @ts-ignore
			end: null,
			type: 'Root',
			fragment: create_fragment(),
			options: null,
			comments: [],
			metadata: {
				ts: this.ts
			}
		};

		this.stack.push(this.root);
		this.fragments.push(this.root.fragment);

		/** @type {ParserState} */
		let state = fragment;

		while (this.index < this.template.length) {
			state = state(this) || fragment;
		}

		if (this.stack.length > 1) {
			const current = this.current();

			if (this.loose) {
				current.end = this.template.length;
			} else if (current.type === 'RegularElement') {
				current.end = current.start + 1;
				element_unclosed(current, current.name);
			} else {
				current.end = current.start + 1;
				block_unclosed(current);
			}
		}

		if (state !== fragment) {
			unexpected_eof(this.index);
		}

		this.root.start = 0;
		this.root.end = template.length;

		const options_index = this.root.fragment.nodes.findIndex(
			/** @param {any} thing */
			(thing) => thing.type === 'SvelteOptions'
		);
		if (options_index !== -1) {
			const options = /** @type {AST.SvelteOptionsRaw} */ (this.root.fragment.nodes[options_index]);
			this.root.fragment.nodes.splice(options_index, 1);
			this.root.options = read_options(options);

			disallow_children(options);

			// We need this for the old AST format
			Object.defineProperty(this.root.options, '__raw__', {
				value: options,
				enumerable: false
			});
		}
	}

	current() {
		return this.stack[this.stack.length - 1];
	}

	/**
	 * @param {any} err
	 * @returns {never}
	 */
	acorn_error(err) {
		js_parse_error(err.pos, err.message.replace(regex_position_indicator, ''));
	}

	/**
	 * @param {string} str
	 * @param {boolean} required
	 * @param {boolean} required_in_loose
	 */
	eat(str, required = false, required_in_loose = true) {
		if (this.match(str)) {
			this.index += str.length;
			return true;
		}

		if (required && (!this.loose || required_in_loose)) {
			expected_token(this.index, str);
		}

		return false;
	}

	/** @param {string} str */
	match(str) {
		const length = str.length;
		if (length === 1) {
			// more performant than slicing
			return this.template[this.index] === str;
		}

		return this.template.slice(this.index, this.index + length) === str;
	}

	/**
	 * Match a regex at the current index
	 * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
	 */
	match_regex(pattern) {
		const match = pattern.exec(this.template.slice(this.index));
		if (!match || match.index !== 0) return null;

		return match[0];
	}

	allow_whitespace() {
		while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
			this.index++;
		}
	}

	/**
	 * Search for a regex starting at the current index and return the result if it matches
	 * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
	 */
	read(pattern) {
		const result = this.match_regex(pattern);
		if (result) this.index += result.length;
		return result;
	}

	/**
	 * @returns {ESTree.Identifier & { start: number, end: number, loc: { start: Location, end: Location } }}
	 */
	read_identifier() {
		const start = this.index;
		let end = start;
		let name = '';

		const code = /** @type {number} */ (this.template.codePointAt(this.index));

		if (isIdentifierStart(code, true)) {
			this.index;
			end += code <= 0xffff ? 1 : 2;

			while (end < this.template.length) {
				const code = /** @type {number} */ (this.template.codePointAt(end));

				if (!isIdentifierChar(code, true)) break;
				end += code <= 0xffff ? 1 : 2;
			}

			name = this.template.slice(start, end);
			this.index = end;

			if (is_reserved(name)) {
				unexpected_reserved_word(start, name);
			}
		}

		return {
			type: 'Identifier',
			name,
			start,
			end,
			loc: {
				start: locator(start),
				end: locator(end)
			}
		};
	}

	/** @param {RegExp} pattern */
	read_until(pattern) {
		if (this.index >= this.template.length) {
			if (this.loose) return '';
			unexpected_eof(this.template.length);
		}

		const start = this.index;
		const match = pattern.exec(this.template.slice(start));

		if (match) {
			this.index = start + match.index;
			return this.template.slice(start, this.index);
		}

		this.index = this.template.length;
		return this.template.slice(start);
	}

	require_whitespace() {
		if (!regex_whitespace.test(this.template[this.index])) {
			expected_whitespace(this.index);
		}

		this.allow_whitespace();
	}

	pop() {
		this.fragments.pop();
		return this.stack.pop();
	}

	/**
	 * @template {AST.Fragment['nodes'][number]} T
	 * @param {T} node
	 * @returns {T}
	 */
	append(node) {
		this.fragments.at(-1)?.nodes.push(node);
		return node;
	}
}

/**
 * @param {string} template
 * @param {boolean} [loose]
 * @returns {AST.Root}
 */
function parse$3(template, loose = false) {
	set_source(template);

	const parser = new Parser(template, loose);
	return parser.root;
}

/** @typedef {(parser: Parser) => ParserState | void} ParserState */

/** @typedef {Object} LastAutoClosedTag
 * @property {string} tag
 * @property {string} reason
 * @property {number} depth
 */

/** @import { Context, Visitors } from 'zimmerframe' */
/** @import { FunctionExpression, FunctionDeclaration } from 'estree' */

/**
 * @param {FunctionExpression | FunctionDeclaration} node
 * @param {Context<any, any>} context
 */
function remove_this_param(node, context) {
	if (node.params[0]?.type === 'Identifier' && node.params[0].name === 'this') {
		node.params.shift();
	}
	return context.next();
}

/** @type {Visitors<any, null>} */
const visitors$4 = {
	_(node, context) {
		const n = context.next() ?? node;

		// TODO there may come a time when we decide to preserve type annotations.
		// until that day comes, we just delete them so they don't confuse esrap
		delete n.typeAnnotation;
		delete n.typeParameters;
		delete n.typeArguments;
		delete n.returnType;
		delete n.accessibility;
		delete n.readonly;
		delete n.definite;
		delete n.override;
	},
	Decorator(node) {
		typescript_invalid_feature(node, 'decorators (related TSC proposal is not stage 4 yet)');
	},
	ImportDeclaration(node) {
		if (node.importKind === 'type') return empty;

		if (node.specifiers?.length > 0) {
			const specifiers = node.specifiers.filter((/** @type {any} */ s) => s.importKind !== 'type');
			if (specifiers.length === 0) return empty;

			return { ...node, specifiers };
		}

		return node;
	},
	ExportNamedDeclaration(node, context) {
		if (node.exportKind === 'type') return empty;

		if (node.declaration) {
			const result = context.next();
			if (result?.declaration?.type === 'EmptyStatement') {
				return empty;
			}
			return result;
		}

		if (node.specifiers) {
			const specifiers = node.specifiers.filter((/** @type {any} */ s) => s.exportKind !== 'type');
			if (specifiers.length === 0) return empty;

			return { ...node, specifiers };
		}

		return node;
	},
	ExportDefaultDeclaration(node) {
		if (node.exportKind === 'type') return empty;
		return node;
	},
	ExportAllDeclaration(node) {
		if (node.exportKind === 'type') return empty;
		return node;
	},
	PropertyDefinition(node, { next }) {
		if (node.accessor) {
			typescript_invalid_feature(
				node,
				'accessor fields (related TSC proposal is not stage 4 yet)'
			);
		}
		return next();
	},
	TSAsExpression(node, context) {
		return context.visit(node.expression);
	},
	TSSatisfiesExpression(node, context) {
		return context.visit(node.expression);
	},
	TSNonNullExpression(node, context) {
		return context.visit(node.expression);
	},
	TSInterfaceDeclaration() {
		return empty;
	},
	TSTypeAliasDeclaration() {
		return empty;
	},
	TSTypeAssertion(node, context) {
		return context.visit(node.expression);
	},
	TSEnumDeclaration(node) {
		typescript_invalid_feature(node, 'enums');
	},
	TSParameterProperty(node, context) {
		if ((node.readonly || node.accessibility) && context.path.at(-2)?.kind === 'constructor') {
			typescript_invalid_feature(node, 'accessibility modifiers on constructor parameters');
		}
		return context.visit(node.parameter);
	},
	TSInstantiationExpression(node, context) {
		return context.visit(node.expression);
	},
	FunctionExpression: remove_this_param,
	FunctionDeclaration: remove_this_param,
	TSDeclareFunction() {
		return empty;
	},
	ClassBody(node, context) {
		const body = [];
		for (const _child of node.body) {
			const child = context.visit(_child);
			if (child.type !== 'PropertyDefinition' || !child.declare) {
				body.push(child);
			}
		}
		return {
			...node,
			body
		};
	},
	ClassDeclaration(node, context) {
		if (node.declare) {
			return empty;
		}
		delete node.abstract;
		delete node.implements;
		delete node.superTypeArguments;
		return context.next();
	},
	ClassExpression(node, context) {
		delete node.implements;
		delete node.superTypeArguments;
		return context.next();
	},
	MethodDefinition(node, context) {
		if (node.abstract) {
			return empty;
		}
		return context.next();
	},
	VariableDeclaration(node, context) {
		if (node.declare) {
			return empty;
		}
		return context.next();
	},
	TSModuleDeclaration(node, context) {
		if (!node.body) return empty;

		// namespaces can contain non-type nodes
		const cleaned = /** @type {any[]} */ (node.body.body).map((entry) => context.visit(entry));
		if (cleaned.some((entry) => entry !== empty)) {
			typescript_invalid_feature(node, 'namespaces with non-type nodes');
		}

		return empty;
	}
};

/**
 * @template T
 * @param {T} ast
 * @returns {T}
 */
function remove_typescript_nodes(ast) {
	return walk$1(ast, null, visitors$4);
}

/** @import { Node } from 'estree' */

/**
 * @param {Node} node
 * @param {Node} parent
 * @returns {boolean}
 */
function is_reference(node, parent) {
	if (node.type === 'MemberExpression') {
		return !node.computed && is_reference(node.object, node);
	}

	if (node.type !== 'Identifier') return false;

	switch (parent?.type) {
		// disregard `bar` in `foo.bar`
		case 'MemberExpression':
			return parent.computed || node === parent.object;

		// disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
		case 'MethodDefinition':
			return parent.computed;

		// disregard the `meta` in `import.meta`
		case 'MetaProperty':
			return parent.meta === node;

		// disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`
		case 'PropertyDefinition':
			return parent.computed || node === parent.value;

		// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
		case 'Property':
			return parent.computed || node === parent.value;

		// disregard the `bar` in `export { foo as bar }` or
		// the foo in `import { foo as bar }`
		case 'ExportSpecifier':
		case 'ImportSpecifier':
			return node === parent.local;

		// disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
		case 'LabeledStatement':
		case 'BreakStatement':
		case 'ContinueStatement':
			return false;

		default:
			return true;
	}
}

/** @import { AST } from '#compiler' */

/**
 * @param {AST.SvelteNode} node
 */
function determine_slot(node) {
	if (!is_element_node(node)) return null;

	for (const attribute of node.attributes) {
		if (attribute.type !== 'Attribute') continue;
		if (attribute.name !== 'slot') continue;
		if (!is_text_attribute(attribute)) continue;

		return /** @type {string} */ (attribute.value[0].data);
	}

	return null;
}

/** @import { AssignmentExpression, Expression, Literal, Node, Pattern, Super, UpdateExpression, VariableDeclarator } from 'estree' */
/** @import { AST, Binding } from '#compiler' */
/** @import { AnalysisState, Context } from '../../types' */
/** @import { Scope } from '../../../scope' */
/** @import { NodeLike } from '../../../../errors.js' */

/**
 * @param {AssignmentExpression | UpdateExpression | AST.BindDirective} node
 * @param {Pattern | Expression} argument
 * @param {Context} context
 */
function validate_assignment(node, argument, context) {
	validate_no_const_assignment(node, argument, context.state.scope, node.type === 'BindDirective');

	if (argument.type === 'Identifier') {
		const binding = context.state.scope.get(argument.name);

		if (context.state.analysis.runes) {
			if (
				context.state.analysis.props_id != null &&
				binding?.node === context.state.analysis.props_id
			) {
				constant_assignment(node, '$props.id()');
			}

			if (binding?.kind === 'each') {
				each_item_invalid_assignment(node);
			}
		}

		if (binding?.kind === 'snippet') {
			snippet_parameter_assignment(node);
		}
	}

	if (argument.type === 'MemberExpression' && argument.object.type === 'ThisExpression') {
		const name =
			argument.computed && argument.property.type !== 'Literal'
				? null
				: get_name(argument.property);

		const field = name !== null && context.state.state_fields?.get(name);

		// check we're not assigning to a state field before its declaration in the constructor
		if (field && field.node.type === 'AssignmentExpression' && node !== field.node) {
			let i = context.path.length;
			while (i--) {
				const parent = context.path[i];

				if (
					parent.type === 'FunctionDeclaration' ||
					parent.type === 'FunctionExpression' ||
					parent.type === 'ArrowFunctionExpression'
				) {
					const grandparent = get_parent(context.path, i - 1);

					if (
						grandparent.type === 'MethodDefinition' &&
						grandparent.kind === 'constructor' &&
						/** @type {number} */ (node.start) < /** @type {number} */ (field.node.start)
					) {
						state_field_invalid_assignment(node);
					}

					break;
				}
			}
		}
	}
}

/**
 * @param {NodeLike} node
 * @param {Pattern | Expression} argument
 * @param {Scope} scope
 * @param {boolean} is_binding
 */
function validate_no_const_assignment(node, argument, scope, is_binding) {
	if (argument.type === 'ArrayPattern') {
		for (const element of argument.elements) {
			if (element) {
				validate_no_const_assignment(node, element, scope, is_binding);
			}
		}
	} else if (argument.type === 'ObjectPattern') {
		for (const element of argument.properties) {
			if (element.type === 'Property') {
				validate_no_const_assignment(node, element.value, scope, is_binding);
			}
		}
	} else if (argument.type === 'Identifier') {
		const binding = scope.get(argument.name);
		if (
			binding?.declaration_kind === 'import' ||
			(binding?.declaration_kind === 'const' && binding.kind !== 'each')
		) {
			// e.invalid_const_assignment(
			// 	node,
			// 	is_binding,
			// 	// This takes advantage of the fact that we don't assign initial for let directives and then/catch variables.
			// 	// If we start doing that, we need another property on the binding to differentiate, or give up on the more precise error message.
			// 	binding.kind !== 'state' &&
			// 		binding.kind !== 'raw_state' &&
			// 		(binding.kind !== 'normal' || !binding.initial)
			// );

			// TODO have a more specific error message for assignments to things like `{:then foo}`
			const thing = binding.declaration_kind === 'import' ? 'import' : 'constant';

			if (is_binding) {
				constant_binding(node, thing);
			} else {
				constant_assignment(node, thing);
			}
		}
	}
}

/**
 * Validates that the opening of a control flow block is `{` immediately followed by the expected character.
 * In legacy mode whitespace is allowed inbetween. TODO remove once legacy mode is gone and move this into parser instead.
 * @param {{start: number; end: number}} node
 * @param {AnalysisState} state
 * @param {string} expected
 */
function validate_opening_tag(node, state, expected) {
	if (state.analysis.source[node.start + 1] !== expected) {
		// avoid a sea of red and only mark the first few characters
		block_unexpected_character({ start: node.start, end: node.start + 5 }, expected);
	}
}

/**
 * @param {AST.Fragment | null | undefined} node
 * @param {Context} context
 */
function validate_block_not_empty(node, context) {
	if (!node) return;
	// Assumption: If the block has zero elements, someone's in the middle of typing it out,
	// so don't warn in that case because it would be distracting.
	if (node.nodes.length === 1 && node.nodes[0].type === 'Text' && !node.nodes[0].raw.trim()) {
		block_empty(node.nodes[0]);
	}
}

/**
 * @param {VariableDeclarator} node
 * @param {AnalysisState} state
 */
function ensure_no_module_import_conflict(node, state) {
	const ids = extract_identifiers(node.id);
	for (const id of ids) {
		if (
			state.ast_type === 'instance' &&
			state.scope === state.analysis.instance.scope &&
			state.analysis.module.scope.get(id.name)?.declaration_kind === 'import'
		) {
			// TODO fix the message here
			declaration_duplicate_module_import(node.id);
		}
	}
}

/**
 * A 'safe' identifier means that the `foo` in `foo.bar` or `foo()` will not
 * call functions that require component context to exist
 * @param {Expression | Super} expression
 * @param {Scope} scope
 */
function is_safe_identifier(expression, scope) {
	let node = expression;
	while (node.type === 'MemberExpression') node = node.object;

	if (node.type !== 'Identifier') return false;

	const binding = scope.get(node.name);
	if (!binding) return true;

	if (binding.kind === 'store_sub') {
		return is_safe_identifier({ name: node.name.slice(1), type: 'Identifier' }, scope);
	}

	return (
		binding.declaration_kind !== 'import' &&
		binding.kind !== 'prop' &&
		binding.kind !== 'bindable_prop' &&
		binding.kind !== 'rest_prop'
	);
}

/**
 * @param {Expression | Literal | Super} node
 * @param {Context} context
 * @returns {boolean}
 */
function is_pure(node, context) {
	if (node.type === 'Literal') {
		return true;
	}

	if (node.type === 'CallExpression') {
		if (!is_pure(node.callee, context)) {
			return false;
		}
		for (let arg of node.arguments) {
			if (!is_pure(arg.type === 'SpreadElement' ? arg.argument : arg, context)) {
				return false;
			}
		}
		return true;
	}

	if (node.type !== 'Identifier' && node.type !== 'MemberExpression') {
		return false;
	}

	if (get_rune(call(node), context.state.scope) === '$effect.tracking') {
		return false;
	}

	/** @type {Expression | Super | null} */
	let left = node;
	while (left.type === 'MemberExpression') {
		left = left.object;
	}

	if (!left) return false;

	if (left.type === 'Identifier') {
		const binding = context.state.scope.get(left.name);
		if (binding === null) return true; // globals are assumed to be safe
	} else if (is_pure(left, context)) {
		return true;
	}

	// TODO add more cases (safe Svelte imports, etc)
	return false;
}

/**
 * Checks if the name is valid, which it is when it's not starting with (or is) a dollar sign or if it's a function parameter.
 * The second argument is the depth of the scope, which is there for backwards compatibility reasons: In Svelte 4, you
 * were allowed to define `$`-prefixed variables anywhere below the top level of components. Once legacy mode is gone, this
 * argument can be removed / the call sites adjusted accordingly.
 * @param {Binding | null} binding
 * @param {number | undefined} [function_depth]
 */
function validate_identifier_name(binding, function_depth) {
	if (!binding) return;

	const declaration_kind = binding.declaration_kind;

	if (
		declaration_kind !== 'synthetic' &&
		declaration_kind !== 'param' &&
		declaration_kind !== 'rest_param' &&
		(!function_depth || function_depth <= 1)
	) {
		const node = binding.node;

		if (node.name === '$') {
			dollar_binding_invalid(node);
		} else if (
			node.name.startsWith('$') &&
			// import type { $Type } from "" - these are normally already filtered out,
			// but for the migration they aren't, and throwing here is preventing the migration to complete
			// TODO -> once migration script is gone we can remove this check
			!(
				binding.initial?.type === 'ImportDeclaration' &&
				/** @type {any} */ (binding.initial).importKind === 'type'
			)
		) {
			dollar_prefix_invalid(node);
		}
	}
}

/**
 * Checks that the exported name is not a derived or reassigned state variable.
 * @param {Node} node
 * @param {Scope} scope
 * @param {string} name
 */
function validate_export(node, scope, name) {
	const binding = scope.get(name);
	if (!binding) return;

	if (binding.kind === 'derived') {
		derived_invalid_export(node);
	}

	if ((binding.kind === 'state' || binding.kind === 'raw_state') && binding.reassigned) {
		state_invalid_export(node);
	}
}

/** @import { BinaryOperator, ClassDeclaration, Expression, FunctionDeclaration, Identifier, ImportDeclaration, MemberExpression, LogicalOperator, Node, Pattern, UnaryOperator, VariableDeclarator, Super, SimpleLiteral, FunctionExpression, ArrowFunctionExpression } from 'estree' */
/** @import { Context, Visitor } from 'zimmerframe' */
/** @import { AST, BindingKind, DeclarationKind } from '#compiler' */

const UNKNOWN$1 = Symbol('unknown');
/** Includes `BigInt` */
const NUMBER = Symbol('number');
const STRING = Symbol('string');
const FUNCTION = Symbol('string');

/** @type {Record<string, [type: typeof NUMBER | typeof  STRING | typeof  UNKNOWN, fn?: Function]>} */
const globals = {
	BigInt: [NUMBER],
	'Math.min': [NUMBER, Math.min],
	'Math.max': [NUMBER, Math.max],
	'Math.random': [NUMBER],
	'Math.floor': [NUMBER, Math.floor],
	// @ts-ignore
	'Math.f16round': [NUMBER, Math.f16round],
	'Math.round': [NUMBER, Math.round],
	'Math.abs': [NUMBER, Math.abs],
	'Math.acos': [NUMBER, Math.acos],
	'Math.asin': [NUMBER, Math.asin],
	'Math.atan': [NUMBER, Math.atan],
	'Math.atan2': [NUMBER, Math.atan2],
	'Math.ceil': [NUMBER, Math.ceil],
	'Math.cos': [NUMBER, Math.cos],
	'Math.sin': [NUMBER, Math.sin],
	'Math.tan': [NUMBER, Math.tan],
	'Math.exp': [NUMBER, Math.exp],
	'Math.log': [NUMBER, Math.log],
	'Math.pow': [NUMBER, Math.pow],
	'Math.sqrt': [NUMBER, Math.sqrt],
	'Math.clz32': [NUMBER, Math.clz32],
	'Math.imul': [NUMBER, Math.imul],
	'Math.sign': [NUMBER, Math.sign],
	'Math.log10': [NUMBER, Math.log10],
	'Math.log2': [NUMBER, Math.log2],
	'Math.log1p': [NUMBER, Math.log1p],
	'Math.expm1': [NUMBER, Math.expm1],
	'Math.cosh': [NUMBER, Math.cosh],
	'Math.sinh': [NUMBER, Math.sinh],
	'Math.tanh': [NUMBER, Math.tanh],
	'Math.acosh': [NUMBER, Math.acosh],
	'Math.asinh': [NUMBER, Math.asinh],
	'Math.atanh': [NUMBER, Math.atanh],
	'Math.trunc': [NUMBER, Math.trunc],
	'Math.fround': [NUMBER, Math.fround],
	'Math.cbrt': [NUMBER, Math.cbrt],
	Number: [NUMBER, Number],
	'Number.isInteger': [NUMBER, Number.isInteger],
	'Number.isFinite': [NUMBER, Number.isFinite],
	'Number.isNaN': [NUMBER, Number.isNaN],
	'Number.isSafeInteger': [NUMBER, Number.isSafeInteger],
	'Number.parseFloat': [NUMBER, Number.parseFloat],
	'Number.parseInt': [NUMBER, Number.parseInt],
	String: [STRING, String],
	'String.fromCharCode': [STRING, String.fromCharCode],
	'String.fromCodePoint': [STRING, String.fromCodePoint]
};

/** @type {Record<string, any>} */
const global_constants = {
	'Math.PI': Math.PI,
	'Math.E': Math.E,
	'Math.LN10': Math.LN10,
	'Math.LN2': Math.LN2,
	'Math.LOG10E': Math.LOG10E,
	'Math.LOG2E': Math.LOG2E,
	'Math.SQRT2': Math.SQRT2,
	'Math.SQRT1_2': Math.SQRT1_2
};

class Binding {
	/** @type {Scope} */
	scope;

	/** @type {Identifier} */
	node;

	/** @type {BindingKind} */
	kind;

	/** @type {DeclarationKind} */
	declaration_kind;

	/**
	 * What the value was initialized with.
	 * For destructured props such as `let { foo = 'bar' } = $props()` this is `'bar'` and not `$props()`
	 * @type {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock}
	 */
	initial = null;

	/** @type {Array<{ node: Identifier; path: AST.SvelteNode[] }>} */
	references = [];

	/**
	 * (Re)assignments of this binding. Includes declarations such as `function x() {}`.
	 * @type {Array<{ value: Expression; scope: Scope }>}
	 */
	assignments = [];

	/**
	 * For `legacy_reactive`: its reactive dependencies
	 * @type {Binding[]}
	 */
	legacy_dependencies = [];

	/**
	 * Legacy props: the `class` in `{ export klass as class}`. $props(): The `class` in { class: klass } = $props()
	 * @type {string | null}
	 */
	prop_alias = null;

	/**
	 * Additional metadata, varies per binding type
	 * @type {null | { inside_rest?: boolean; is_template_declaration?: boolean; exclude_props?: string[] }}
	 */
	metadata = null;

	mutated = false;
	reassigned = false;

	/**
	 * Instance-level declarations may follow (or contain) a top-level `await`. In these cases,
	 * any reads that occur in the template must wait for the corresponding promise to resolve
	 * otherwise the initial value will not have been assigned.
	 * It is a member expression of the form `$$blockers[n]`.
	 * TODO the blocker is set during transform which feels a bit grubby
	 * @type {MemberExpression | null}
	 */
	blocker = null;

	/**
	 *
	 * @param {Scope} scope
	 * @param {Identifier} node
	 * @param {BindingKind} kind
	 * @param {DeclarationKind} declaration_kind
	 * @param {Binding['initial']} initial
	 */
	constructor(scope, node, kind, declaration_kind, initial) {
		this.scope = scope;
		this.node = node;
		this.initial = initial;
		this.kind = kind;
		this.declaration_kind = declaration_kind;

		if (initial) {
			this.assignments.push({ value: /** @type {Expression} */ (initial), scope });
		}
	}

	get updated() {
		return this.mutated || this.reassigned;
	}

	/**
	 * @returns {this is Binding & { initial: ArrowFunctionExpression | FunctionDeclaration | FunctionExpression }}
	 */
	is_function() {
		if (this.updated) {
			// even if it's reassigned to another function,
			// we can't use it directly as e.g. an event handler
			return false;
		}

		const type = this.initial?.type;

		return (
			type === 'ArrowFunctionExpression' ||
			type === 'FunctionExpression' ||
			type === 'FunctionDeclaration'
		);
	}
}

class Evaluation {
	/** @type {Set<any>} */
	values;

	/**
	 * True if there is exactly one possible value
	 * @readonly
	 * @type {boolean}
	 */
	is_known = true;

	/**
	 * True if the possible values contains `UNKNOWN`
	 * @readonly
	 * @type {boolean}
	 */
	has_unknown = false;

	/**
	 * True if the value is known to not be null/undefined
	 * @readonly
	 * @type {boolean}
	 */
	is_defined = true;

	/**
	 * True if the value is known to be a string
	 * @readonly
	 * @type {boolean}
	 */
	is_string = true;

	/**
	 * True if the value is known to be a number
	 * @readonly
	 * @type {boolean}
	 */
	is_number = true;

	/**
	 * True if the value is known to be a function
	 * @readonly
	 * @type {boolean}
	 */
	is_function = true;

	/**
	 * @readonly
	 * @type {any}
	 */
	value = undefined;

	/**
	 *
	 * @param {Scope} scope
	 * @param {Expression | FunctionDeclaration} expression
	 * @param {Set<any>} values
	 */
	constructor(scope, expression, values) {
		current_evaluations.set(expression, this);

		this.values = values;

		switch (expression.type) {
			case 'Literal': {
				this.values.add(expression.value);
				break;
			}

			case 'Identifier': {
				const binding = scope.get(expression.name);

				if (binding) {
					if (
						binding.initial?.type === 'CallExpression' &&
						get_rune(binding.initial, scope) === '$props.id'
					) {
						this.values.add(STRING);
						break;
					}

					const is_prop =
						binding.kind === 'prop' ||
						binding.kind === 'rest_prop' ||
						binding.kind === 'bindable_prop';

					if (binding.initial?.type === 'EachBlock' && binding.initial.index === expression.name) {
						this.values.add(NUMBER);
						break;
					}

					if (binding.initial?.type === 'SnippetBlock') {
						this.is_defined = true;
						this.is_known = false;
						this.values.add(UNKNOWN$1);
						break;
					}

					if (!binding.updated && binding.initial !== null && !is_prop) {
						binding.scope.evaluate(/** @type {Expression} */ (binding.initial), this.values);
						break;
					}
				} else if (expression.name === 'undefined') {
					this.values.add(undefined);
					break;
				}

				// TODO glean what we can from reassignments
				// TODO one day, expose props and imports somehow

				this.values.add(UNKNOWN$1);
				break;
			}

			case 'BinaryExpression': {
				const a = scope.evaluate(/** @type {Expression} */ (expression.left)); // `left` cannot be `PrivateIdentifier` unless operator is `in`
				const b = scope.evaluate(expression.right);

				if (a.is_known && b.is_known) {
					this.values.add(binary[expression.operator](a.value, b.value));
					break;
				}

				switch (expression.operator) {
					case '!=':
					case '!==':
					case '<':
					case '<=':
					case '>':
					case '>=':
					case '==':
					case '===':
					case 'in':
					case 'instanceof':
						this.values.add(true);
						this.values.add(false);
						break;

					case '%':
					case '&':
					case '*':
					case '**':
					case '-':
					case '/':
					case '<<':
					case '>>':
					case '>>>':
					case '^':
					case '|':
						this.values.add(NUMBER);
						break;

					case '+':
						if (a.is_string || b.is_string) {
							this.values.add(STRING);
						} else if (a.is_number && b.is_number) {
							this.values.add(NUMBER);
						} else {
							this.values.add(STRING);
							this.values.add(NUMBER);
						}
						break;

					default:
						this.values.add(UNKNOWN$1);
				}
				break;
			}

			case 'ConditionalExpression': {
				const test = scope.evaluate(expression.test);
				const consequent = scope.evaluate(expression.consequent);
				const alternate = scope.evaluate(expression.alternate);

				if (test.is_known) {
					for (const value of (test.value ? consequent : alternate).values) {
						this.values.add(value);
					}
				} else {
					for (const value of consequent.values) {
						this.values.add(value);
					}

					for (const value of alternate.values) {
						this.values.add(value);
					}
				}
				break;
			}

			case 'LogicalExpression': {
				const a = scope.evaluate(expression.left);
				const b = scope.evaluate(expression.right);

				if (a.is_known) {
					if (b.is_known) {
						this.values.add(logical[expression.operator](a.value, b.value));
						break;
					}

					if (
						(expression.operator === '&&' && !a.value) ||
						(expression.operator === '||' && a.value) ||
						(expression.operator === '??' && a.value != null)
					) {
						this.values.add(a.value);
					} else {
						for (const value of b.values) {
							this.values.add(value);
						}
					}

					break;
				}

				for (const value of a.values) {
					this.values.add(value);
				}

				for (const value of b.values) {
					this.values.add(value);
				}
				break;
			}

			case 'UnaryExpression': {
				const argument = scope.evaluate(expression.argument);

				if (argument.is_known) {
					this.values.add(unary[expression.operator](argument.value));
					break;
				}

				switch (expression.operator) {
					case '!':
					case 'delete':
						this.values.add(false);
						this.values.add(true);
						break;

					case '+':
					case '-':
					case '~':
						this.values.add(NUMBER);
						break;

					case 'typeof':
						this.values.add(STRING);
						break;

					case 'void':
						this.values.add(undefined);
						break;

					default:
						this.values.add(UNKNOWN$1);
				}
				break;
			}

			case 'CallExpression': {
				const keypath = get_global_keypath(expression.callee, scope);

				if (keypath) {
					if (is_rune(keypath)) {
						const arg = /** @type {Expression | undefined} */ (expression.arguments[0]);

						switch (keypath) {
							case '$state':
							case '$state.raw':
							case '$derived':
								if (arg) {
									scope.evaluate(arg, this.values);
								} else {
									this.values.add(undefined);
								}
								break;

							case '$props.id':
								this.values.add(STRING);
								break;

							case '$effect.tracking':
								this.values.add(false);
								this.values.add(true);
								break;

							case '$derived.by':
								if (arg?.type === 'ArrowFunctionExpression' && arg.body.type !== 'BlockStatement') {
									scope.evaluate(arg.body, this.values);
									break;
								}

								this.values.add(UNKNOWN$1);
								break;

							default: {
								this.values.add(UNKNOWN$1);
							}
						}

						break;
					}

					if (
						Object.hasOwn(globals, keypath) &&
						expression.arguments.every((arg) => arg.type !== 'SpreadElement')
					) {
						const [type, fn] = globals[keypath];
						const values = expression.arguments.map((arg) => scope.evaluate(arg));

						if (fn && values.every((e) => e.is_known)) {
							this.values.add(fn(...values.map((e) => e.value)));
						} else {
							this.values.add(type);
						}

						break;
					}
				}

				this.values.add(UNKNOWN$1);
				break;
			}

			case 'TemplateLiteral': {
				let result = expression.quasis[0].value.cooked;

				for (let i = 0; i < expression.expressions.length; i += 1) {
					const e = scope.evaluate(expression.expressions[i]);

					if (e.is_known) {
						result += e.value + expression.quasis[i + 1].value.cooked;
					} else {
						this.values.add(STRING);
						break;
					}
				}

				this.values.add(result);
				break;
			}

			case 'MemberExpression': {
				const keypath = get_global_keypath(expression, scope);

				if (keypath && Object.hasOwn(global_constants, keypath)) {
					this.values.add(global_constants[keypath]);
					break;
				}

				this.values.add(UNKNOWN$1);
				break;
			}

			case 'ArrowFunctionExpression':
			case 'FunctionExpression':
			case 'FunctionDeclaration': {
				this.values.add(FUNCTION);
				break;
			}

			default: {
				this.values.add(UNKNOWN$1);
			}
		}

		for (const value of this.values) {
			this.value = value; // saves having special logic for `size === 1`

			if (value !== STRING && typeof value !== 'string') {
				this.is_string = false;
			}

			if (value !== NUMBER && typeof value !== 'number') {
				this.is_number = false;
			}

			if (value !== FUNCTION) {
				this.is_function = false;
			}

			if (value == null || value === UNKNOWN$1) {
				this.is_defined = false;
			}

			if (value === UNKNOWN$1) {
				this.has_unknown = true;
			}
		}

		if (this.values.size > 1 || typeof this.value === 'symbol') {
			this.is_known = false;
		}

		current_evaluations.delete(expression);
	}
}

class Scope {
	/** @type {ScopeRoot} */
	root;

	/**
	 * The immediate parent scope
	 * @type {Scope | null}
	 */
	parent;

	/**
	 * Whether or not `var` declarations are contained by this scope
	 * @type {boolean}
	 */
	#porous;

	/**
	 * A map of every identifier declared by this scope, and all the
	 * identifiers that reference it
	 * @type {Map<string, Binding>}
	 */
	declarations = new Map();

	/**
	 * A map of declarators to the bindings they declare
	 * @type {Map<VariableDeclarator | AST.LetDirective, Binding[]>}
	 */
	declarators = new Map();

	/**
	 * A set of all the names referenced with this scope
	 * — useful for generating unique names
	 * @type {Map<string, { node: Identifier; path: AST.SvelteNode[] }[]>}
	 */
	references = new Map();

	/**
	 * The scope depth allows us to determine if a state variable is referenced in its own scope,
	 * which is usually an error. Block statements do not increase this value
	 */
	function_depth = 0;

	/**
	 * If tracing of reactive dependencies is enabled for this scope
	 * @type {null | Expression}
	 */
	tracing = null;

	/**
	 *
	 * @param {ScopeRoot} root
	 * @param {Scope | null} parent
	 * @param {boolean} porous
	 */
	constructor(root, parent, porous) {
		this.root = root;
		this.parent = parent;
		this.#porous = porous;
		this.function_depth = parent ? parent.function_depth + (porous ? 0 : 1) : 0;
	}

	/**
	 * @param {Identifier} node
	 * @param {Binding['kind']} kind
	 * @param {DeclarationKind} declaration_kind
	 * @param {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock} initial
	 * @returns {Binding}
	 */
	declare(node, kind, declaration_kind, initial = null) {
		if (this.parent) {
			if (declaration_kind === 'var' && this.#porous) {
				return this.parent.declare(node, kind, declaration_kind);
			}

			if (declaration_kind === 'import') {
				return this.parent.declare(node, kind, declaration_kind, initial);
			}
		}

		if (this.declarations.has(node.name)) {
			const binding = this.declarations.get(node.name);
			if (binding && binding.declaration_kind !== 'var' && declaration_kind !== 'var') {
				// This also errors on function types, but that's arguably a good thing
				// declaring function twice is also caught by acorn in the parse phase
				declaration_duplicate(node, node.name);
			}
		}

		const binding = new Binding(this, node, kind, declaration_kind, initial);

		validate_identifier_name(binding, this.function_depth);

		this.declarations.set(node.name, binding);
		this.root.conflicts.add(node.name);
		return binding;
	}

	child(porous = false) {
		return new Scope(this.root, this, porous);
	}

	/**
	 * @param {string} preferred_name
	 * @returns {string}
	 */
	generate(preferred_name) {
		if (this.#porous) {
			return /** @type {Scope} */ (this.parent).generate(preferred_name);
		}

		preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, '_').replace(/^[0-9]/, '_');
		let name = preferred_name;
		let n = 1;

		while (
			this.references.has(name) ||
			this.declarations.has(name) ||
			this.root.conflicts.has(name) ||
			is_reserved(name)
		) {
			name = `${preferred_name}_${n++}`;
		}

		this.references.set(name, []);
		this.root.conflicts.add(name);
		return name;
	}

	/**
	 * @param {string} name
	 * @returns {Binding | null}
	 */
	get(name) {
		return this.declarations.get(name) ?? this.parent?.get(name) ?? null;
	}

	/**
	 * @param {VariableDeclarator | AST.LetDirective} node
	 * @returns {Binding[]}
	 */
	get_bindings(node) {
		const bindings = this.declarators.get(node);
		if (!bindings) {
			throw new Error('No binding found for declarator');
		}
		return bindings;
	}

	/**
	 * @param {string} name
	 * @returns {Scope | null}
	 */
	owner(name) {
		return this.declarations.has(name) ? this : this.parent && this.parent.owner(name);
	}

	/**
	 * @param {Identifier} node
	 * @param {AST.SvelteNode[]} path
	 */
	reference(node, path) {
		path = [...path]; // ensure that mutations to path afterwards don't affect this reference
		let references = this.references.get(node.name);

		if (!references) this.references.set(node.name, (references = []));

		references.push({ node, path });

		const binding = this.declarations.get(node.name);
		if (binding) {
			binding.references.push({ node, path });
		} else if (this.parent) {
			this.parent.reference(node, path);
		} else {
			// no binding was found, and this is the top level scope,
			// which means this is a global
			this.root.conflicts.add(node.name);
		}
	}

	/**
	 * Does partial evaluation to find an exact value or at least the rough type of the expression.
	 * Only call this once scope has been fully generated in a first pass,
	 * else this evaluates on incomplete data and may yield wrong results.
	 * @param {Expression} expression
	 * @param {Set<any>} [values]
	 */
	evaluate(expression, values = new Set()) {
		const current = current_evaluations.get(expression);
		if (current) return current;

		return new Evaluation(this, expression, values);
	}
}

/**
 * Track which expressions are currently being evaluated — this allows
 * us to prevent cyclical evaluations without passing the map around
 * @type {Map<Expression | FunctionDeclaration, Evaluation>}
 */
const current_evaluations = new Map();

/** @type {Record<BinaryOperator, (left: any, right: any) => any>} */
const binary = {
	'!=': (left, right) => left != right,
	'!==': (left, right) => left !== right,
	'<': (left, right) => left < right,
	'<=': (left, right) => left <= right,
	'>': (left, right) => left > right,
	'>=': (left, right) => left >= right,
	'==': (left, right) => left == right,
	'===': (left, right) => left === right,
	in: (left, right) => left in right,
	instanceof: (left, right) => left instanceof right,
	'%': (left, right) => left % right,
	'&': (left, right) => left & right,
	'*': (left, right) => left * right,
	'**': (left, right) => left ** right,
	'+': (left, right) => left + right,
	'-': (left, right) => left - right,
	'/': (left, right) => left / right,
	'<<': (left, right) => left << right,
	'>>': (left, right) => left >> right,
	'>>>': (left, right) => left >>> right,
	'^': (left, right) => left ^ right,
	'|': (left, right) => left | right
};

/** @type {Record<UnaryOperator, (argument: any) => any>} */
const unary = {
	'-': (argument) => -argument,
	'+': (argument) => +argument,
	'!': (argument) => !argument,
	'~': (argument) => ~argument,
	typeof: (argument) => typeof argument,
	void: () => undefined,
	delete: () => true
};

/** @type {Record<LogicalOperator, (left: any, right: any) => any>} */
const logical = {
	'||': (left, right) => left || right,
	'&&': (left, right) => left && right,
	'??': (left, right) => left ?? right
};

class ScopeRoot {
	/** @type {Set<string>} */
	conflicts = new Set();

	/**
	 * @param {string} preferred_name
	 */
	unique(preferred_name) {
		preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, '_');
		let final_name = preferred_name;
		let n = 1;

		while (this.conflicts.has(final_name)) {
			final_name = `${preferred_name}_${n++}`;
		}

		this.conflicts.add(final_name);
		const id = id$2(final_name);
		return id;
	}
}

/**
 * @param {AST.SvelteNode} ast
 * @param {ScopeRoot} root
 * @param {boolean} allow_reactive_declarations
 * @param {Scope | null} parent
 */
function create_scopes(ast, root, allow_reactive_declarations, parent) {
	/** @typedef {{ scope: Scope }} State */

	/**
	 * A map of node->associated scope. A node appearing in this map does not necessarily mean that it created a scope
	 * @type {Map<AST.SvelteNode, Scope>}
	 */
	const scopes = new Map();
	const scope = new Scope(root, parent, false);
	scopes.set(ast, scope);

	/** @type {State} */
	const state = { scope };

	/** @type {[Scope, { node: Identifier; path: AST.SvelteNode[] }][]} */
	const references = [];

	/** @type {[Scope, Pattern | MemberExpression, Expression][]} */
	const updates = [];

	/**
	 * An array of reactive declarations, i.e. the `a` in `$: a = b * 2`
	 * @type {Identifier[]}
	 */
	const possible_implicit_declarations = [];

	/**
	 * @param {Scope} scope
	 * @param {Pattern[]} params
	 */
	function add_params(scope, params) {
		for (const param of params) {
			for (const node of extract_identifiers(param)) {
				scope.declare(node, 'normal', param.type === 'RestElement' ? 'rest_param' : 'param');
			}
		}
	}

	/**
	 * @type {Visitor<Node, State, AST.SvelteNode>}
	 */
	const create_block_scope = (node, { state, next }) => {
		const scope = state.scope.child(true);
		scopes.set(node, scope);

		next({ scope });
	};

	/**
	 * @type {Visitor<AST.ElementLike, State, AST.SvelteNode>}
	 */
	const SvelteFragment = (node, { state, next }) => {
		const scope = state.scope.child();
		scopes.set(node, scope);
		next({ scope });
	};

	/**
	 * @type {Visitor<AST.Component | AST.SvelteComponent | AST.SvelteSelf, State, AST.SvelteNode>}
	 */
	const Component = (node, context) => {
		node.metadata.scopes = {
			default: context.state.scope.child()
		};

		if (node.type === 'SvelteComponent') {
			context.visit(node.expression);
		}

		const default_state = determine_slot(node)
			? context.state
			: { scope: node.metadata.scopes.default };

		for (const attribute of node.attributes) {
			if (attribute.type === 'LetDirective') {
				context.visit(attribute, default_state);
			} else {
				context.visit(attribute);
			}
		}

		for (const child of node.fragment.nodes) {
			let state = default_state;

			const slot_name = determine_slot(child);

			if (slot_name !== null) {
				node.metadata.scopes[slot_name] = context.state.scope.child();

				state = {
					scope: node.metadata.scopes[slot_name]
				};
			}

			context.visit(child, state);
		}
	};

	/**
	 * @type {Visitor<AST.AnimateDirective | AST.TransitionDirective | AST.UseDirective, State, AST.SvelteNode>}
	 */
	const SvelteDirective = (node, { state, path, visit }) => {
		state.scope.reference(id$2(node.name.split('.')[0]), path);

		if (node.expression) {
			visit(node.expression);
		}
	};

	let has_await = false;

	walk$1(ast, state, {
		AwaitExpression(node, context) {
			// this doesn't _really_ belong here, but it allows us to
			// automatically opt into runes mode on encountering
			// blocking awaits, without doing an additional walk
			// before the analysis occurs
			// TODO remove this in Svelte 7.0 or whenever we get rid of legacy support
			has_await ||= context.path.every(
				({ type }) =>
					type !== 'ArrowFunctionExpression' &&
					type !== 'FunctionExpression' &&
					type !== 'FunctionDeclaration'
			);

			context.next();
		},

		// references
		Identifier(node, { path, state }) {
			const parent = path.at(-1);
			if (
				parent &&
				is_reference(node, /** @type {Node} */ (parent)) &&
				// TSTypeAnnotation, TSInterfaceDeclaration etc - these are normally already filtered out,
				// but for the migration they aren't, so we need to filter them out here
				// TODO -> once migration script is gone we can remove this check
				!parent.type.startsWith('TS')
			) {
				references.push([state.scope, { node, path: path.slice() }]);
			}
		},
		LabeledStatement(node, { path, next }) {
			if (path.length > 1 || !allow_reactive_declarations) return next();
			if (node.label.name !== '$') return next();

			// create a scope for the $: block
			const scope = state.scope.child();
			scopes.set(node, scope);

			if (
				node.body.type === 'ExpressionStatement' &&
				node.body.expression.type === 'AssignmentExpression'
			) {
				for (const id of extract_identifiers(node.body.expression.left)) {
					if (!id.name.startsWith('$')) {
						possible_implicit_declarations.push(id);
					}
				}
			}

			next({ scope });
		},

		SvelteFragment,
		SlotElement: SvelteFragment,
		SvelteElement: SvelteFragment,
		RegularElement: SvelteFragment,

		LetDirective(node, context) {
			const scope = context.state.scope;

			/** @type {Binding[]} */
			const bindings = [];
			scope.declarators.set(node, bindings);

			if (node.expression) {
				for (const id of extract_identifiers_from_destructuring(node.expression)) {
					const binding = scope.declare(id, 'template', 'const');
					scope.reference(id, [context.path[context.path.length - 1], node]);
					bindings.push(binding);
				}
			} else {
				/** @type {Identifier} */
				const id = {
					name: node.name,
					type: 'Identifier',
					start: node.start,
					end: node.end
				};
				const binding = scope.declare(id, 'template', 'const');
				scope.reference(id, [context.path[context.path.length - 1], node]);
				bindings.push(binding);
			}
		},

		Component: (node, context) => {
			context.state.scope.reference(id$2(node.name.split('.')[0]), context.path);
			Component(node, context);
		},
		SvelteSelf: Component,
		SvelteComponent: Component,

		// updates
		AssignmentExpression(node, { state, next }) {
			updates.push([state.scope, node.left, node.right]);
			next();
		},

		UpdateExpression(node, { state, next }) {
			const expression = /** @type {Identifier | MemberExpression} */ (node.argument);
			updates.push([state.scope, expression, expression]);
			next();
		},

		ImportDeclaration(node, { state }) {
			for (const specifier of node.specifiers) {
				state.scope.declare(specifier.local, 'normal', 'import', node);
			}
		},

		FunctionExpression(node, { state, next }) {
			const scope = state.scope.child();
			scopes.set(node, scope);

			if (node.id) scope.declare(node.id, 'normal', 'function');

			add_params(scope, node.params);
			next({ scope });
		},

		FunctionDeclaration(node, { state, next }) {
			if (node.id) state.scope.declare(node.id, 'normal', 'function', node);

			const scope = state.scope.child();
			scopes.set(node, scope);

			add_params(scope, node.params);
			next({ scope });
		},

		ArrowFunctionExpression(node, { state, next }) {
			const scope = state.scope.child();
			scopes.set(node, scope);

			add_params(scope, node.params);
			next({ scope });
		},

		ForStatement: create_block_scope,
		ForInStatement: create_block_scope,
		ForOfStatement: create_block_scope,
		SwitchStatement: create_block_scope,
		BlockStatement(node, context) {
			const parent = context.path.at(-1);
			if (
				parent?.type === 'FunctionDeclaration' ||
				parent?.type === 'FunctionExpression' ||
				parent?.type === 'ArrowFunctionExpression'
			) {
				// We already created a new scope for the function
				context.next();
			} else {
				create_block_scope(node, context);
			}
		},

		ClassDeclaration(node, { state, next }) {
			if (node.id) state.scope.declare(node.id, 'normal', 'let', node);
			next();
		},

		VariableDeclaration(node, { state, path, next }) {
			const is_parent_const_tag = path.at(-1)?.type === 'ConstTag';
			for (const declarator of node.declarations) {
				/** @type {Binding[]} */
				const bindings = [];

				state.scope.declarators.set(declarator, bindings);

				for (const id of extract_identifiers(declarator.id)) {
					const binding = state.scope.declare(
						id,
						is_parent_const_tag ? 'template' : 'normal',
						node.kind,
						declarator.init
					);
					binding.metadata = { is_template_declaration: true };
					bindings.push(binding);
				}
			}

			next();
		},

		CatchClause(node, { state, next }) {
			if (node.param) {
				const scope = state.scope.child(true);
				scopes.set(node, scope);

				for (const id of extract_identifiers(node.param)) {
					scope.declare(id, 'normal', 'let');
				}

				next({ scope });
			} else {
				next();
			}
		},

		EachBlock(node, { state, visit }) {
			visit(node.expression);

			// context and children are a new scope
			const scope = state.scope.child();
			scopes.set(node, scope);

			if (node.context) {
				// declarations
				for (const id of extract_identifiers(node.context)) {
					const binding = scope.declare(id, 'each', 'const');

					let inside_rest = false;
					let is_rest_id = false;
					walk$1(node.context, null, {
						Identifier(node) {
							if (inside_rest && node === id) {
								is_rest_id = true;
							}
						},
						RestElement(_, { next }) {
							const prev = inside_rest;
							inside_rest = true;
							next();
							inside_rest = prev;
						}
					});

					binding.metadata = { inside_rest: is_rest_id };
				}

				// Visit to pick up references from default initializers
				visit(node.context, { scope });
			}

			if (node.index) {
				const is_keyed =
					node.key &&
					(node.key.type !== 'Identifier' || !node.index || node.key.name !== node.index);
				scope.declare(id$2(node.index), is_keyed ? 'template' : 'static', 'const', node);
			}
			if (node.key) visit(node.key, { scope });

			// children
			for (const child of node.body.nodes) {
				visit(child, { scope });
			}
			if (node.fallback) visit(node.fallback, { scope });

			node.metadata = {
				expression: new ExpressionMetadata(),
				keyed: false,
				contains_group_binding: false,
				index: scope.root.unique('$$index'),
				declarations: scope.declarations,
				is_controlled: false,
				// filled in during analysis
				transitive_deps: new Set()
			};
		},

		AwaitBlock(node, context) {
			context.visit(node.expression);

			if (node.pending) {
				context.visit(node.pending);
			}

			if (node.then) {
				context.visit(node.then);
				if (node.value) {
					const then_scope = /** @type {Scope} */ (scopes.get(node.then));
					const value_scope = context.state.scope.child();
					scopes.set(node.value, value_scope);
					context.visit(node.value, { scope: value_scope });
					for (const id of extract_identifiers(node.value)) {
						then_scope.declare(id, 'template', 'const');
						value_scope.declare(id, 'normal', 'const');
					}
				}
			}

			if (node.catch) {
				context.visit(node.catch);
				if (node.error) {
					const catch_scope = /** @type {Scope} */ (scopes.get(node.catch));
					const error_scope = context.state.scope.child();
					scopes.set(node.error, error_scope);
					context.visit(node.error, { scope: error_scope });
					for (const id of extract_identifiers(node.error)) {
						catch_scope.declare(id, 'template', 'const');
						error_scope.declare(id, 'normal', 'const');
					}
				}
			}
		},

		SnippetBlock(node, context) {
			const state = context.state;
			let scope = state.scope;

			scope.declare(node.expression, 'normal', 'function', node);

			const child_scope = state.scope.child();
			scopes.set(node, child_scope);

			for (const param of node.parameters) {
				for (const id of extract_identifiers(param)) {
					child_scope.declare(id, 'snippet', 'let');
				}
			}

			context.next({ scope: child_scope });
		},

		Fragment: (node, context) => {
			const scope = context.state.scope.child(node.metadata.transparent);
			scopes.set(node, scope);
			context.next({ scope });
		},

		BindDirective(node, context) {
			if (node.expression.type !== 'SequenceExpression') {
				const expression = /** @type {Identifier | MemberExpression} */ (node.expression);
				updates.push([context.state.scope, expression, expression]);
			}

			context.next();
		},

		TransitionDirective: SvelteDirective,
		AnimateDirective: SvelteDirective,
		UseDirective: SvelteDirective,
		// using it's own function instead of `SvelteDirective` because
		// StyleDirective doesn't have expressions and are generally already
		// handled by `Identifier`. This is the special case for the shorthand
		// eg <button style:height /> where the variable has the same name of
		// the css property
		StyleDirective(node, { path, state, next }) {
			if (node.value === true) {
				state.scope.reference(id$2(node.name), path.concat(node));
			}
			next();
		}

		// TODO others
	});

	for (const id of possible_implicit_declarations) {
		const binding = scope.get(id.name);
		if (binding) continue; // TODO can also be legacy_reactive if declared outside of reactive statement

		scope.declare(id, 'legacy_reactive', 'let');
	}

	// we do this after the fact, so that we don't need to worry
	// about encountering references before their declarations
	for (const [scope, { node, path }] of references) {
		scope.reference(node, path);
	}

	for (const [scope, node, value] of updates) {
		for (const expression of unwrap_pattern(node)) {
			const left = object$1(expression);
			const binding = left && scope.get(left.name);

			if (binding !== null && left !== binding.node) {
				if (left === expression) {
					binding.reassigned = true;
					binding.assignments.push({ value, scope });
				} else {
					binding.mutated = true;
				}
			}
		}
	}

	return {
		has_await,
		scope,
		scopes
	};
}

/**
 * @template {{ scope: Scope, scopes: Map<AST.SvelteNode, Scope> }} State
 * @param {AST.SvelteNode} node
 * @param {Context<AST.SvelteNode, State>} context
 */
function set_scope(node, { next, state }) {
	const scope = state.scopes.get(node);
	next(scope !== undefined && scope !== state.scope ? { ...state, scope } : state);
}

/**
 * Returns the name of the rune if the given expression is a `CallExpression` using a rune.
 * @param {Node | null | undefined} node
 * @param {Scope} scope
 */
function get_rune(node, scope) {
	if (!node) return null;
	if (node.type !== 'CallExpression') return null;

	const keypath = get_global_keypath(node.callee, scope);

	if (!keypath || !is_rune(keypath)) return null;
	return keypath;
}

/**
 * Returns the name of the rune if the given expression is a `CallExpression` using a rune.
 * @param {Expression | Super} node
 * @param {Scope} scope
 */
function get_global_keypath(node, scope) {
	let n = node;

	let joined = '';

	while (n.type === 'MemberExpression') {
		if (n.computed) return null;
		if (n.property.type !== 'Identifier') return null;
		joined = '.' + n.property.name + joined;
		n = n.object;
	}

	if (n.type === 'CallExpression' && n.callee.type === 'Identifier') {
		joined = '()' + joined;
		n = n.callee;
	}

	if (n.type !== 'Identifier') return null;

	const binding = scope.get(n.name);
	if (binding !== null) return null; // rune name, but references a variable or store

	return n.name + joined;
}

/**
 * @template T
 * @param {Array<[T, T]>} edges
 * @returns {Array<T>|undefined}
 */
function check_graph_for_cycles(edges) {
	/** @type {Map<T, T[]>} */
	const graph = edges.reduce((g, edge) => {
		const [u, v] = edge;
		if (!g.has(u)) g.set(u, []);
		if (!g.has(v)) g.set(v, []);
		g.get(u).push(v);
		return g;
	}, new Map());

	const visited = new Set();
	/** @type {Set<T>} */
	const on_stack = new Set();
	/** @type {Array<Array<T>>} */
	const cycles = [];

	/**
	 * @param {T} v
	 */
	function visit(v) {
		visited.add(v);
		on_stack.add(v);

		graph.get(v)?.forEach((w) => {
			if (!visited.has(w)) {
				visit(w);
			} else if (on_stack.has(w)) {
				cycles.push([...on_stack, w]);
			}
		});

		on_stack.delete(v);
	}

	graph.forEach((_, v) => {
		if (!visited.has(v)) {
			visit(v);
		}
	});

	return cycles[0];
}

/** @import { AST } from '#compiler' */
const regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
const regex_css_name_boundary = /^[\s,;}]$/;

/**
 * @param {string} name
 * @returns {string}
 */
function remove_css_prefix(name) {
	return name.replace(regex_css_browser_prefix, '');
}

/** @param {AST.CSS.Atrule} node */
const is_keyframes_node = (node) => remove_css_prefix(node.name) === 'keyframes';

/** @import { AST } from '#compiler' */
/** @import { Node } from 'estree' */
const UNKNOWN = {};

/**
 * @param {Node} node
 * @param {boolean} is_class
 * @param {Set<any>} set
 * @param {boolean} is_nested
 */
function gather_possible_values(node, is_class, set, is_nested = false) {
	if (set.has(UNKNOWN)) {
		// no point traversing any further
		return;
	}

	if (node.type === 'Literal') {
		set.add(String(node.value));
	} else if (node.type === 'ConditionalExpression') {
		gather_possible_values(node.consequent, is_class, set, is_nested);
		gather_possible_values(node.alternate, is_class, set, is_nested);
	} else if (node.type === 'LogicalExpression') {
		if (node.operator === '&&') {
			// && is a special case, because the only way the left
			// hand value can be included is if it's falsy. this is
			// a bit of extra work but it's worth it because
			// `class={[condition && 'blah']}` is common,
			// and we don't want to deopt on `condition`
			const left = new Set();
			gather_possible_values(node.left, is_class, left, is_nested);

			if (left.has(UNKNOWN)) {
				// add all non-nullish falsy values, unless this is a `class` attribute that
				// will be processed by cslx, in which case falsy values are removed, unless
				// they're not inside an array/object (TODO 6.0 remove that last part)
				if (!is_class || !is_nested) {
					set.add('');
					set.add(false);
					set.add(NaN);
					set.add(0); // -0 and 0n are also falsy, but stringify to '0'
				}
			} else {
				for (const value of left) {
					if (!value && value != undefined && (!is_class || !is_nested)) {
						set.add(value);
					}
				}
			}

			gather_possible_values(node.right, is_class, set, is_nested);
		} else {
			gather_possible_values(node.left, is_class, set, is_nested);
			gather_possible_values(node.right, is_class, set, is_nested);
		}
	} else if (is_class && node.type === 'ArrayExpression') {
		for (const entry of node.elements) {
			if (entry) {
				gather_possible_values(entry, is_class, set, true);
			}
		}
	} else if (is_class && node.type === 'ObjectExpression') {
		for (const property of node.properties) {
			if (
				property.type === 'Property' &&
				!property.computed &&
				(property.key.type === 'Identifier' || property.key.type === 'Literal')
			) {
				set.add(
					property.key.type === 'Identifier' ? property.key.name : String(property.key.value)
				);
			} else {
				set.add(UNKNOWN);
			}
		}
	} else {
		set.add(UNKNOWN);
	}
}

/**
 * @param {AST.Text | AST.ExpressionTag} chunk
 * @param {boolean} is_class
 * @returns {string[] | null}
 */
function get_possible_values(chunk, is_class) {
	const values = new Set();

	if (chunk.type === 'Text') {
		values.add(chunk.data);
	} else {
		gather_possible_values(chunk.expression, is_class, values);
	}

	if (values.has(UNKNOWN)) return null;
	return [...values].map((value) => String(value));
}

/**
 * Returns all parent rules; root is last
 * @param {AST.CSS.Rule | null} rule
 */
function get_parent_rules(rule) {
	const rules = [];

	while (rule) {
		rules.push(rule);
		rule = rule.metadata.parent_rule;
	}

	return rules;
}

/**
 * True if is `:global(...)` or `:global` and no pseudo class that is scoped.
 * @param {AST.CSS.RelativeSelector} relative_selector
 * @returns {relative_selector is AST.CSS.RelativeSelector & { selectors: [AST.CSS.PseudoClassSelector, ...Array<AST.CSS.PseudoClassSelector | AST.CSS.PseudoElementSelector>] }}
 */
function is_global$1(relative_selector) {
	const first = relative_selector.selectors[0];

	return (
		first.type === 'PseudoClassSelector' &&
		first.name === 'global' &&
		(first.args === null ||
			// Only these two selector types keep the whole selector global, because e.g.
			// :global(button).x means that the selector is still scoped because of the .x
			relative_selector.selectors.every(
				(selector) =>
					is_unscoped_pseudo_class(selector) || selector.type === 'PseudoElementSelector'
			))
	);
}

/**
 * `true` if is a pseudo class that cannot be or is not scoped
 * @param {AST.CSS.SimpleSelector} selector
 */
function is_unscoped_pseudo_class(selector) {
	return (
		selector.type === 'PseudoClassSelector' &&
		// These make the selector scoped
		((selector.name !== 'has' &&
			selector.name !== 'is' &&
			selector.name !== 'where' &&
			// Not is special because we want to scope as specific as possible, but because :not
			// inverses the result, we want to leave the unscoped, too. The exception is more than
			// one selector in the :not (.e.g :not(.x .y)), then .x and .y should be scoped
			(selector.name !== 'not' ||
				selector.args === null ||
				selector.args.children.every((c) => c.children.length === 1))) ||
			// selectors with has/is/where/not can also be global if all their children are global
			selector.args === null ||
			selector.args.children.every((c) => c.children.every((r) => is_global$1(r))))
	);
}

/**
 * True if is `:global(...)` or `:global`, irrespective of whether or not there are any pseudo classes that are scoped.
 * Difference to `is_global`: `:global(x):has(y)` is `true` for `is_outer_global` but `false` for `is_global`.
 * @param {AST.CSS.RelativeSelector} relative_selector
 * @returns {relative_selector is AST.CSS.RelativeSelector & { selectors: [AST.CSS.PseudoClassSelector, ...Array<AST.CSS.PseudoClassSelector | AST.CSS.PseudoElementSelector>] }}
 */
function is_outer_global(relative_selector) {
	const first = relative_selector.selectors[0];

	return (
		first.type === 'PseudoClassSelector' &&
		first.name === 'global' &&
		(first.args === null ||
			// Only these two selector types can keep the whole selector global, because e.g.
			// :global(button).x means that the selector is still scoped because of the .x
			relative_selector.selectors.every(
				(selector) =>
					selector.type === 'PseudoClassSelector' || selector.type === 'PseudoElementSelector'
			))
	);
}

/** @import { ComponentAnalysis } from '../../types.js' */
/** @import { AST } from '#compiler' */
/** @import { Visitors } from 'zimmerframe' */

/**
 * @typedef {{
 *   keyframes: string[];
 *   rule: AST.CSS.Rule | null;
 *   analysis: ComponentAnalysis;
 * }} CssState
 */

/**
 * @typedef {Visitors<AST.CSS.Node, CssState>} CssVisitors
 */

/**
 * True if is `:global`
 * @param {AST.CSS.SimpleSelector} simple_selector
 */
function is_global_block_selector(simple_selector) {
	return (
		simple_selector.type === 'PseudoClassSelector' &&
		simple_selector.name === 'global' &&
		simple_selector.args === null
	);
}

/**
 * @param {AST.SvelteNode[]} path
 */
function is_unscoped(path) {
	return path
		.filter((node) => node.type === 'Rule')
		.every((node) => node.metadata.has_global_selectors);
}

/**
 *
 * @param {Array<AST.CSS.Node>} path
 */
function is_in_global_block$1(path) {
	return path.some((node) => node.type === 'Rule' && node.metadata.is_global_block);
}

/** @type {CssVisitors} */
const css_visitors = {
	Atrule(node, context) {
		if (is_keyframes_node(node)) {
			if (!node.prelude.startsWith('-global-') && !is_in_global_block$1(context.path)) {
				context.state.keyframes.push(node.prelude);
			} else if (node.prelude.startsWith('-global-')) {
				// we don't check if the block.children.length because the keyframe is still added even if empty
				context.state.analysis.css.has_global ||= is_unscoped(context.path);
			}
		}

		context.next();
	},
	ComplexSelector(node, context) {
		context.next(); // analyse relevant selectors first

		{
			const global = node.children.find(is_global$1);

			if (global) {
				const is_nested = context.path.at(-2)?.type === 'PseudoClassSelector';
				if (is_nested && !global.selectors[0].args) {
					css_global_block_invalid_placement(global.selectors[0]);
				}

				const idx = node.children.indexOf(global);
				if (global.selectors[0].args !== null && idx !== 0 && idx !== node.children.length - 1) {
					// ensure `:global(...)` is not used in the middle of a selector (but multiple `global(...)` in sequence are ok)
					for (let i = idx + 1; i < node.children.length; i++) {
						if (!is_global$1(node.children[i])) {
							css_global_invalid_placement(global.selectors[0]);
						}
					}
				}
			}
		}

		// ensure `:global(...)` do not lead to invalid css after `:global()` is removed
		for (const relative_selector of node.children) {
			for (let i = 0; i < relative_selector.selectors.length; i++) {
				const selector = relative_selector.selectors[i];

				if (selector.type === 'PseudoClassSelector' && selector.name === 'global') {
					const child = selector.args?.children[0].children[0];
					// ensure `:global(element)` to be at the first position in a compound selector
					if (child?.selectors[0].type === 'TypeSelector' && i !== 0) {
						css_global_invalid_selector_list(selector);
					}

					// ensure `:global(.class)` is not followed by a type selector, eg: `:global(.class)element`
					if (relative_selector.selectors[i + 1]?.type === 'TypeSelector') {
						css_type_selector_invalid_placement(relative_selector.selectors[i + 1]);
					}

					// ensure `:global(...)`contains a single selector
					// (standalone :global() with multiple selectors is OK)
					if (
						selector.args !== null &&
						selector.args.children.length > 1 &&
						(node.children.length > 1 || relative_selector.selectors.length > 1)
					) {
						css_global_invalid_selector(selector);
					}
				}
			}
		}

		node.metadata.rule = context.state.rule;

		node.metadata.is_global = node.children.every(
			({ metadata }) => metadata.is_global || metadata.is_global_like
		);

		node.metadata.used ||= node.metadata.is_global;

		if (
			node.metadata.rule?.metadata.parent_rule &&
			node.children[0]?.selectors[0]?.type === 'NestingSelector'
		) {
			const first = node.children[0]?.selectors[1];
			const no_nesting_scope =
				first?.type !== 'PseudoClassSelector' || is_unscoped_pseudo_class(first);
			const parent_is_global = node.metadata.rule.metadata.parent_rule.prelude.children.some(
				(child) => child.children.length === 1 && child.children[0].metadata.is_global
			);
			// mark `&:hover` in `:global(.foo) { &:hover { color: green }}` as used
			if (no_nesting_scope && parent_is_global) {
				node.metadata.used = true;
			}
		}
	},
	RelativeSelector(node, context) {
		const parent = /** @type {AST.CSS.ComplexSelector} */ (context.path.at(-1));

		if (
			node.combinator != null &&
			!context.state.rule?.metadata.parent_rule &&
			parent.children[0] === node &&
			context.path.at(-3)?.type !== 'PseudoClassSelector'
		) {
			css_selector_invalid(node.combinator);
		}

		node.metadata.is_global = node.selectors.length >= 1 && is_global$1(node);

		if (
			node.selectors.length >= 1 &&
			node.selectors.every(
				(selector) =>
					selector.type === 'PseudoClassSelector' || selector.type === 'PseudoElementSelector'
			)
		) {
			const first = node.selectors[0];
			node.metadata.is_global_like ||=
				(first.type === 'PseudoClassSelector' && first.name === 'host') ||
				(first.type === 'PseudoElementSelector' &&
					[
						'view-transition',
						'view-transition-group',
						'view-transition-old',
						'view-transition-new',
						'view-transition-image-pair'
					].includes(first.name));
		}

		node.metadata.is_global_like ||=
			node.selectors.some(
				(child) => child.type === 'PseudoClassSelector' && child.name === 'root'
			) &&
			// :root.y:has(.x) is not a global selector because while .y is unscoped, .x inside `:has(...)` should be scoped
			!node.selectors.some((child) => child.type === 'PseudoClassSelector' && child.name === 'has');

		if (node.metadata.is_global_like || node.metadata.is_global) {
			// So that nested selectors like `:root:not(.x)` are not marked as unused
			for (const child of node.selectors) {
				walk$1(/** @type {AST.CSS.Node} */ (child), null, {
					ComplexSelector(node, context) {
						node.metadata.used = true;
						context.next();
					}
				});
			}
		}

		context.next();
	},
	Rule(node, context) {
		node.metadata.parent_rule = context.state.rule;

		// We gotta allow :global x, :global y because CSS preprocessors might generate that from :global { x, y {...} }
		for (const complex_selector of node.prelude.children) {
			let is_global_block = false;

			for (let selector_idx = 0; selector_idx < complex_selector.children.length; selector_idx++) {
				const child = complex_selector.children[selector_idx];
				const idx = child.selectors.findIndex(is_global_block_selector);

				if (is_global_block) {
					// All selectors after :global are unscoped
					child.metadata.is_global_like = true;
				}

				if (idx === 0) {
					if (
						child.selectors.length > 1 &&
						selector_idx === 0 &&
						node.metadata.parent_rule === null
					) {
						css_global_block_invalid_modifier_start(child.selectors[1]);
					} else {
						// `child` starts with `:global`
						node.metadata.is_global_block = is_global_block = true;

						for (let i = 1; i < child.selectors.length; i++) {
							walk$1(/** @type {AST.CSS.Node} */ (child.selectors[i]), null, {
								ComplexSelector(node) {
									node.metadata.used = true;
								}
							});
						}

						if (child.combinator && child.combinator.name !== ' ') {
							css_global_block_invalid_combinator(child, child.combinator.name);
						}

						const declaration = node.block.children.find((child) => child.type === 'Declaration');
						const is_lone_global =
							complex_selector.children.length === 1 &&
							complex_selector.children[0].selectors.length === 1; // just `:global`, not e.g. `:global x`

						if (is_lone_global && node.prelude.children.length > 1) {
							// `:global, :global x { z { ... } }` would become `x { z { ... } }` which means `z` is always
							// constrained by `x`, which is not what the user intended
							css_global_block_invalid_list(node.prelude);
						}

						if (
							declaration &&
							// :global { color: red; } is invalid, but foo :global { color: red; } is valid
							node.prelude.children.length === 1 &&
							is_lone_global
						) {
							css_global_block_invalid_declaration(declaration);
						}
					}
				} else if (idx !== -1) {
					css_global_block_invalid_modifier(child.selectors[idx]);
				}
			}

			if (node.metadata.is_global_block && !is_global_block) {
				css_global_block_invalid_list(node.prelude);
			}
		}

		const state = { ...context.state, rule: node };

		// visit selector list first, to populate child selector metadata
		context.visit(node.prelude, state);

		for (const selector of node.prelude.children) {
			node.metadata.has_global_selectors ||= selector.metadata.is_global;
			node.metadata.has_local_selectors ||= !selector.metadata.is_global;
		}

		// if this rule has a ComplexSelector whose RelativeSelector children are all
		// `:global(...)`, and the rule contains declarations (rather than just
		// nested rules) then the component as a whole includes global CSS
		context.state.analysis.css.has_global ||=
			node.metadata.has_global_selectors &&
			node.block.children.filter((child) => child.type === 'Declaration').length > 0 &&
			is_unscoped(context.path);

		// visit block list, so parent rule metadata is populated
		context.visit(node.block, state);
	},
	NestingSelector(node, context) {
		const rule = /** @type {AST.CSS.Rule} */ (context.state.rule);
		const parent_rule = rule.metadata.parent_rule;

		if (!parent_rule) {
			// https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector#using_outside_nested_rule
			const children = rule.prelude.children;
			const selectors = children[0].children[0].selectors;
			if (
				children.length > 1 ||
				selectors.length > 1 ||
				selectors[0].type !== 'PseudoClassSelector' ||
				selectors[0].name !== 'global' ||
				selectors[0].args?.children[0]?.children[0].selectors[0] !== node
			) {
				css_nesting_selector_invalid_placement(node);
			}
		} else if (
			// :global { &.foo { ... } } is invalid
			parent_rule.metadata.is_global_block &&
			!parent_rule.metadata.parent_rule &&
			parent_rule.prelude.children[0].children.length === 1 &&
			parent_rule.prelude.children[0].children[0].selectors.length === 1
		) {
			css_global_block_invalid_modifier_start(node);
		}

		context.next();
	}
};

/**
 * @param {AST.CSS.StyleSheet} stylesheet
 * @param {ComponentAnalysis} analysis
 */
function analyze_css(stylesheet, analysis) {
	/** @type {CssState} */
	const css_state = {
		keyframes: analysis.css.keyframes,
		rule: null,
		analysis
	};

	walk$1(stylesheet, css_state, css_visitors);
}

/** @import * as Compiler from '#compiler' */

/** @typedef {typeof NODE_PROBABLY_EXISTS | typeof NODE_DEFINITELY_EXISTS} NodeExistsValue */
/** @typedef {typeof FORWARD | typeof BACKWARD} Direction */

const NODE_PROBABLY_EXISTS = 0;
const NODE_DEFINITELY_EXISTS = 1;
const FORWARD = 0;
const BACKWARD = 1;

const whitelist_attribute_selector = new Map([
	['details', ['open']],
	['dialog', ['open']]
]);

/** @type {Compiler.AST.CSS.Combinator} */
const descendant_combinator = {
	type: 'Combinator',
	name: ' ',
	start: -1,
	end: -1
};

/** @type {Compiler.AST.CSS.RelativeSelector} */
const nesting_selector = {
	type: 'RelativeSelector',
	start: -1,
	end: -1,
	combinator: null,
	selectors: [
		{
			type: 'NestingSelector',
			name: '&',
			start: -1,
			end: -1
		}
	],
	metadata: {
		is_global: false,
		is_global_like: false,
		scoped: false
	}
};

/** @type {Compiler.AST.CSS.RelativeSelector} */
const any_selector = {
	type: 'RelativeSelector',
	start: -1,
	end: -1,
	combinator: null,
	selectors: [
		{
			type: 'TypeSelector',
			name: '*',
			start: -1,
			end: -1
		}
	],
	metadata: {
		is_global: false,
		is_global_like: false,
		scoped: false
	}
};

/**
 * Snippets encountered already (avoids infinite loops)
 * @type {Set<Compiler.AST.SnippetBlock>}
 */
const seen = new Set();

/**
 *
 * @param {Compiler.AST.CSS.StyleSheet} stylesheet
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} element
 */
function prune(stylesheet, element) {
	walk$1(/** @type {Compiler.AST.CSS.Node} */ (stylesheet), null, {
		Rule(node, context) {
			if (node.metadata.is_global_block) {
				context.visit(node.prelude);
			} else {
				context.next();
			}
		},
		ComplexSelector(node) {
			const selectors = get_relative_selectors(node);

			seen.clear();

			if (
				apply_selector(
					selectors,
					/** @type {Compiler.AST.CSS.Rule} */ (node.metadata.rule),
					element,
					BACKWARD
				)
			) {
				node.metadata.used = true;
			}

			// note: we don't call context.next() here, we only recurse into
			// selectors that don't belong to rules (i.e. inside `:is(...)` etc)
			// when we encounter them below
		}
	});
}

/**
 * Retrieves the relative selectors (minus the trailing globals) from a complex selector.
 * Also searches them for any existing `&` selectors and adds one if none are found.
 * This ensures we traverse up to the parent rule when the inner selectors match and we're
 * trying to see if the parent rule also matches.
 * @param {Compiler.AST.CSS.ComplexSelector} node
 */
function get_relative_selectors(node) {
	const selectors = truncate(node);

	if (node.metadata.rule?.metadata.parent_rule && selectors.length > 0) {
		let has_explicit_nesting_selector = false;

		// nesting could be inside pseudo classes like :is, :has or :where
		for (let selector of selectors) {
			walk$1(selector, null, {
				// @ts-ignore
				NestingSelector() {
					has_explicit_nesting_selector = true;
				}
			});

			// if we found one we can break from the others
			if (has_explicit_nesting_selector) break;
		}

		if (!has_explicit_nesting_selector) {
			if (selectors[0].combinator === null) {
				selectors[0] = {
					...selectors[0],
					combinator: descendant_combinator
				};
			}

			selectors.unshift(nesting_selector);
		}
	}

	return selectors;
}

/**
 * Discard trailing `:global(...)` selectors, these are unused for scoping purposes
 * @param {Compiler.AST.CSS.ComplexSelector} node
 */
function truncate(node) {
	const i = node.children.findLastIndex(({ metadata, selectors }) => {
		const first = selectors[0];
		return (
			// not after a :global selector
			!metadata.is_global_like &&
			!(first.type === 'PseudoClassSelector' && first.name === 'global' && first.args === null) &&
			// not a :global(...) without a :has/is/where(...) modifier that is scoped
			!metadata.is_global
		);
	});

	return node.children.slice(0, i + 1).map((child) => {
		// In case of `:root.y:has(...)`, `y` is unscoped, but everything in `:has(...)` should be scoped (if not global).
		// To properly accomplish that, we gotta filter out all selector types except `:has`.
		const root = child.selectors.find((s) => s.type === 'PseudoClassSelector' && s.name === 'root');
		if (!root || child.metadata.is_global_like) return child;

		return {
			...child,
			selectors: child.selectors.filter((s) => s.type === 'PseudoClassSelector' && s.name === 'has')
		};
	});
}

/**
 * @param {Compiler.AST.CSS.RelativeSelector[]} relative_selectors
 * @param {Compiler.AST.CSS.Rule} rule
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} element
 * @param {Direction} direction
 * @returns {boolean}
 */
function apply_selector(relative_selectors, rule, element, direction) {
	const rest_selectors = relative_selectors.slice();
	const relative_selector = direction === FORWARD ? rest_selectors.shift() : rest_selectors.pop();

	const matched =
		!!relative_selector &&
		relative_selector_might_apply_to_node(relative_selector, rule, element, direction) &&
		apply_combinator(relative_selector, rest_selectors, rule, element, direction);

	if (matched) {
		if (!is_outer_global(relative_selector)) {
			relative_selector.metadata.scoped = true;
		}

		element.metadata.scoped = true;
	}

	return matched;
}

/**
 * @param {Compiler.AST.CSS.RelativeSelector} relative_selector
 * @param {Compiler.AST.CSS.RelativeSelector[]} rest_selectors
 * @param {Compiler.AST.CSS.Rule} rule
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node
 * @param {Direction} direction
 * @returns {boolean}
 */
function apply_combinator(relative_selector, rest_selectors, rule, node, direction) {
	const combinator =
		direction == FORWARD ? rest_selectors[0]?.combinator : relative_selector.combinator;
	if (!combinator) return true;

	switch (combinator.name) {
		case ' ':
		case '>': {
			const is_adjacent = combinator.name === '>';
			const parents =
				direction === FORWARD
					? get_descendant_elements(node, is_adjacent)
					: get_ancestor_elements(node, is_adjacent);
			let parent_matched = false;

			for (const parent of parents) {
				if (apply_selector(rest_selectors, rule, parent, direction)) {
					parent_matched = true;
				}
			}

			return (
				parent_matched ||
				(direction === BACKWARD &&
					(!is_adjacent || parents.length === 0) &&
					rest_selectors.every((selector) => is_global(selector, rule)))
			);
		}

		case '+':
		case '~': {
			const siblings = get_possible_element_siblings(node, direction, combinator.name === '+');

			let sibling_matched = false;

			for (const possible_sibling of siblings.keys()) {
				if (
					possible_sibling.type === 'RenderTag' ||
					possible_sibling.type === 'SlotElement' ||
					possible_sibling.type === 'Component'
				) {
					// `{@render foo()}<p>foo</p>` with `:global(.x) + p` is a match
					if (rest_selectors.length === 1 && rest_selectors[0].metadata.is_global) {
						sibling_matched = true;
					}
				} else if (apply_selector(rest_selectors, rule, possible_sibling, direction)) {
					sibling_matched = true;
				}
			}

			return (
				sibling_matched ||
				(direction === BACKWARD &&
					get_element_parent(node) === null &&
					rest_selectors.every((selector) => is_global(selector, rule)))
			);
		}

		default:
			// TODO other combinators
			return true;
	}
}

/**
 * Returns `true` if the relative selector is global, meaning
 * it's a `:global(...)` or unscopeable selector, or
 * is an `:is(...)` or `:where(...)` selector that contains
 * a global selector
 * @param {Compiler.AST.CSS.RelativeSelector} selector
 * @param {Compiler.AST.CSS.Rule} rule
 * @returns {boolean}
 */
function is_global(selector, rule) {
	if (selector.metadata.is_global || selector.metadata.is_global_like) {
		return true;
	}

	let explicitly_global = false;

	for (const s of selector.selectors) {
		/** @type {Compiler.AST.CSS.SelectorList | null} */
		let selector_list = null;
		let can_be_global = false;
		let owner = rule;

		if (s.type === 'PseudoClassSelector') {
			if ((s.name === 'is' || s.name === 'where') && s.args) {
				selector_list = s.args;
			} else {
				can_be_global = is_unscoped_pseudo_class(s);
			}
		}

		if (s.type === 'NestingSelector') {
			owner = /** @type {Compiler.AST.CSS.Rule} */ (rule.metadata.parent_rule);
			selector_list = owner.prelude;
		}

		const has_global_selectors = !!selector_list?.children.some((complex_selector) => {
			return complex_selector.children.every((relative_selector) =>
				is_global(relative_selector, owner)
			);
		});
		explicitly_global ||= has_global_selectors;

		if (!has_global_selectors && !can_be_global) {
			return false;
		}
	}

	return explicitly_global || selector.selectors.length === 0;
}

const regex_backslash_and_following_character = /\\(.)/g;

/**
 * Ensure that `element` satisfies each simple selector in `relative_selector`
 *
 * @param {Compiler.AST.CSS.RelativeSelector} relative_selector
 * @param {Compiler.AST.CSS.Rule} rule
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} element
 * @param {Direction} direction
 * @returns {boolean}
 */
function relative_selector_might_apply_to_node(relative_selector, rule, element, direction) {
	// Sort :has(...) selectors in one bucket and everything else into another
	const has_selectors = [];
	const other_selectors = [];

	for (const selector of relative_selector.selectors) {
		if (selector.type === 'PseudoClassSelector' && selector.name === 'has' && selector.args) {
			has_selectors.push(selector);
		} else {
			other_selectors.push(selector);
		}
	}

	// If we're called recursively from a :has(...) selector, we're on the way of checking if the other selectors match.
	// In that case ignore this check (because we just came from this) to avoid an infinite loop.
	if (has_selectors.length > 0) {
		// If this is a :has inside a global selector, we gotta include the element itself, too,
		// because the global selector might be for an element that's outside the component,
		// e.g. :root:has(.scoped), :global(.foo):has(.scoped), or :root { &:has(.scoped) {} }
		const rules = get_parent_rules(rule);
		const include_self =
			rules.some((r) => r.prelude.children.some((c) => c.children.some((s) => is_global(s, r)))) ||
			rules[rules.length - 1].prelude.children.some((c) =>
				c.children.some((r) =>
					r.selectors.some(
						(s) =>
							s.type === 'PseudoClassSelector' &&
							(s.name === 'root' || (s.name === 'global' && s.args))
					)
				)
			);

		// :has(...) is special in that it means "look downwards in the CSS tree". Since our matching algorithm goes
		// upwards and back-to-front, we need to first check the selectors inside :has(...), then check the rest of the
		// selector in a way that is similar to ancestor matching. In a sense, we're treating `.x:has(.y)` as `.x .y`.
		for (const has_selector of has_selectors) {
			const complex_selectors = /** @type {Compiler.AST.CSS.SelectorList} */ (has_selector.args)
				.children;
			let matched = false;

			for (const complex_selector of complex_selectors) {
				const [first, ...rest] = truncate(complex_selector);
				// if it was just a :global(...)
				if (!first) {
					complex_selector.metadata.used = true;
					matched = true;
					continue;
				}

				if (include_self) {
					const selector_including_self = [
						first.combinator ? { ...first, combinator: null } : first,
						...rest
					];
					if (apply_selector(selector_including_self, rule, element, FORWARD)) {
						complex_selector.metadata.used = true;
						matched = true;
					}
				}

				const selector_excluding_self = [
					any_selector,
					first.combinator ? first : { ...first, combinator: descendant_combinator },
					...rest
				];
				if (apply_selector(selector_excluding_self, rule, element, FORWARD)) {
					complex_selector.metadata.used = true;
					matched = true;
				}
			}

			if (!matched) {
				return false;
			}
		}
	}

	for (const selector of other_selectors) {
		if (selector.type === 'Percentage' || selector.type === 'Nth') continue;

		const name = selector.name.replace(regex_backslash_and_following_character, '$1');

		switch (selector.type) {
			case 'PseudoClassSelector': {
				if (name === 'host' || name === 'root') return false;

				if (
					name === 'global' &&
					selector.args !== null &&
					relative_selector.selectors.length === 1
				) {
					const args = selector.args;
					const complex_selector = args.children[0];
					return apply_selector(complex_selector.children, rule, element, BACKWARD);
				}

				// We came across a :global, everything beyond it is global and therefore a potential match
				if (name === 'global' && selector.args === null) return true;

				// :not(...) contents should stay unscoped. Scoping them would achieve the opposite of what we want,
				// because they are then _more_ likely to bleed out of the component. The exception is complex selectors
				// with descendants, in which case we scope them all.
				if (name === 'not' && selector.args) {
					for (const complex_selector of selector.args.children) {
						walk$1(complex_selector, null, {
							ComplexSelector(node, context) {
								node.metadata.used = true;
								context.next();
							}
						});
						const relative = truncate(complex_selector);

						if (complex_selector.children.length > 1) {
							// foo:not(bar foo) means that bar is an ancestor of foo (side note: ending with foo is the only way the selector make sense).
							// We can't fully check if that actually matches with our current algorithm, so we just assume it does.
							// The result may not match a real element, so the only drawback is the missing prune.
							for (const selector of relative) {
								selector.metadata.scoped = true;
							}

							/** @type {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | null} */
							let el = element;
							while (el) {
								el.metadata.scoped = true;
								el = get_element_parent(el);
							}
						}
					}

					break;
				}

				if ((name === 'is' || name === 'where') && selector.args) {
					let matched = false;

					for (const complex_selector of selector.args.children) {
						const relative = truncate(complex_selector);
						const is_global = relative.length === 0;

						if (is_global) {
							complex_selector.metadata.used = true;
							matched = true;
						} else if (apply_selector(relative, rule, element, BACKWARD)) {
							complex_selector.metadata.used = true;
							matched = true;
						} else if (complex_selector.children.length > 1 && (name == 'is' || name == 'where')) {
							// foo :is(bar baz) can also mean that bar is an ancestor of foo, and baz a descendant.
							// We can't fully check if that actually matches with our current algorithm, so we just assume it does.
							// The result may not match a real element, so the only drawback is the missing prune.
							complex_selector.metadata.used = true;
							matched = true;
							for (const selector of relative) {
								selector.metadata.scoped = true;
							}
						}
					}

					if (!matched) {
						return false;
					}
				}

				break;
			}

			case 'PseudoElementSelector': {
				break;
			}

			case 'AttributeSelector': {
				const whitelisted = whitelist_attribute_selector.get(element.name.toLowerCase());
				if (
					!whitelisted?.includes(selector.name.toLowerCase()) &&
					!attribute_matches(
						element,
						selector.name,
						selector.value && unquote(selector.value),
						selector.matcher,
						selector.flags?.includes('i') ?? false
					)
				) {
					return false;
				}
				break;
			}

			case 'ClassSelector': {
				if (!attribute_matches(element, 'class', name, '~=', false)) {
					return false;
				}

				break;
			}

			case 'IdSelector': {
				if (!attribute_matches(element, 'id', name, '=', false)) {
					return false;
				}

				break;
			}

			case 'TypeSelector': {
				if (
					element.name.toLowerCase() !== name.toLowerCase() &&
					name !== '*' &&
					element.type !== 'SvelteElement'
				) {
					return false;
				}

				break;
			}

			case 'NestingSelector': {
				let matched = false;

				const parent = /** @type {Compiler.AST.CSS.Rule} */ (rule.metadata.parent_rule);

				for (const complex_selector of parent.prelude.children) {
					if (
						apply_selector(get_relative_selectors(complex_selector), parent, element, direction) ||
						complex_selector.children.every((s) => is_global(s, parent))
					) {
						complex_selector.metadata.used = true;
						matched = true;
					}
				}

				if (!matched) {
					return false;
				}

				break;
			}
		}
	}

	// possible match
	return true;
}

/**
 * @param {any} operator
 * @param {any} expected_value
 * @param {any} case_insensitive
 * @param {any} value
 */
function test_attribute(operator, expected_value, case_insensitive, value) {
	if (case_insensitive) {
		expected_value = expected_value.toLowerCase();
		value = value.toLowerCase();
	}
	switch (operator) {
		case '=':
			return value === expected_value;
		case '~=':
			return value.split(/\s/).includes(expected_value);
		case '|=':
			return `${value}-`.startsWith(`${expected_value}-`);
		case '^=':
			return value.startsWith(expected_value);
		case '$=':
			return value.endsWith(expected_value);
		case '*=':
			return value.includes(expected_value);
		default:
			throw new Error("this shouldn't happen");
	}
}

/**
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} node
 * @param {string} name
 * @param {string | null} expected_value
 * @param {string | null} operator
 * @param {boolean} case_insensitive
 */
function attribute_matches(node, name, expected_value, operator, case_insensitive) {
	for (const attribute of node.attributes) {
		if (attribute.type === 'SpreadAttribute') return true;
		if (attribute.type === 'BindDirective' && attribute.name === name) return true;

		const name_lower = name.toLowerCase();
		// match attributes against the corresponding directive but bail out on exact matching
		if (attribute.type === 'StyleDirective' && name_lower === 'style') return true;
		if (attribute.type === 'ClassDirective' && name_lower === 'class') {
			if (operator === '~=') {
				if (attribute.name === expected_value) return true;
			} else {
				return true;
			}
		}

		if (attribute.type !== 'Attribute') continue;
		if (attribute.name.toLowerCase() !== name_lower) continue;

		if (attribute.value === true) return operator === null;
		if (expected_value === null) return true;

		if (is_text_attribute(attribute)) {
			const matches = test_attribute(
				operator,
				expected_value,
				case_insensitive,
				attribute.value[0].data
			);
			// continue if we still may match against a class/style directive
			if (!matches && (name_lower === 'class' || name_lower === 'style')) continue;
			return matches;
		}

		const chunks = get_attribute_chunks(attribute.value);
		const possible_values = new Set();

		/** @type {string[]} */
		let prev_values = [];
		for (const chunk of chunks) {
			const current_possible_values = get_possible_values(chunk, name_lower === 'class');

			// impossible to find out all combinations
			if (!current_possible_values) return true;

			if (prev_values.length > 0) {
				/** @type {string[]} */
				const start_with_space = [];

				/** @type {string[]} */
				const remaining = [];

				current_possible_values.forEach((current_possible_value) => {
					if (regex_starts_with_whitespace.test(current_possible_value)) {
						start_with_space.push(current_possible_value);
					} else {
						remaining.push(current_possible_value);
					}
				});
				if (remaining.length > 0) {
					if (start_with_space.length > 0) {
						prev_values.forEach((prev_value) => possible_values.add(prev_value));
					}

					/** @type {string[]} */
					const combined = [];

					prev_values.forEach((prev_value) => {
						remaining.forEach((value) => {
							combined.push(prev_value + value);
						});
					});
					prev_values = combined;
					start_with_space.forEach((value) => {
						if (regex_ends_with_whitespace.test(value)) {
							possible_values.add(value);
						} else {
							prev_values.push(value);
						}
					});
					continue;
				} else {
					prev_values.forEach((prev_value) => possible_values.add(prev_value));
					prev_values = [];
				}
			}
			current_possible_values.forEach((current_possible_value) => {
				if (regex_ends_with_whitespace.test(current_possible_value)) {
					possible_values.add(current_possible_value);
				} else {
					prev_values.push(current_possible_value);
				}
			});
			if (prev_values.length < current_possible_values.length) {
				prev_values.push(' ');
			}
			if (prev_values.length > 20) {
				// might grow exponentially, bail out
				return true;
			}
		}
		prev_values.forEach((prev_value) => possible_values.add(prev_value));

		for (const value of possible_values) {
			if (test_attribute(operator, expected_value, case_insensitive, value)) return true;
		}
	}

	return false;
}

/** @param {string} str */
function unquote(str) {
	if ((str[0] === str[str.length - 1] && str[0] === "'") || str[0] === '"') {
		return str.slice(1, str.length - 1);
	}
	return str;
}

/**
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node
 * @param {boolean} adjacent_only
 * @param {Set<Compiler.AST.SnippetBlock>} seen
 */
function get_ancestor_elements(node, adjacent_only, seen = new Set()) {
	/** @type {Array<Compiler.AST.RegularElement | Compiler.AST.SvelteElement>} */
	const ancestors = [];

	const path = node.metadata.path;
	let i = path.length;

	while (i--) {
		const parent = path[i];

		if (parent.type === 'SnippetBlock') {
			if (!seen.has(parent)) {
				seen.add(parent);

				for (const site of parent.metadata.sites) {
					ancestors.push(...get_ancestor_elements(site, adjacent_only, seen));
				}
			}

			break;
		}

		if (parent.type === 'RegularElement' || parent.type === 'SvelteElement') {
			ancestors.push(parent);
			if (adjacent_only) {
				break;
			}
		}
	}

	return ancestors;
}

/**
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node
 * @param {boolean} adjacent_only
 * @param {Set<Compiler.AST.SnippetBlock>} seen
 */
function get_descendant_elements(node, adjacent_only, seen = new Set()) {
	/** @type {Array<Compiler.AST.RegularElement | Compiler.AST.SvelteElement>} */
	const descendants = [];

	/**
	 * @param {Compiler.AST.SvelteNode} node
	 */
	function walk_children(node) {
		walk$1(node, null, {
			_(node, context) {
				if (node.type === 'RegularElement' || node.type === 'SvelteElement') {
					descendants.push(node);

					if (!adjacent_only) {
						context.next();
					}
				} else if (node.type === 'RenderTag') {
					for (const snippet of node.metadata.snippets) {
						if (seen.has(snippet)) continue;

						seen.add(snippet);
						walk_children(snippet.body);
					}
				} else {
					context.next();
				}
			}
		});
	}

	walk_children(node.type === 'RenderTag' ? node : node.fragment);

	return descendants;
}

/**
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node
 * @returns {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | null}
 */
function get_element_parent(node) {
	let path = node.metadata.path;
	let i = path.length;

	while (i--) {
		const parent = path[i];

		if (parent.type === 'RegularElement' || parent.type === 'SvelteElement') {
			return parent;
		}
	}

	return null;
}

/**
 * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node
 * @param {Direction} direction
 * @param {boolean} adjacent_only
 * @param {Set<Compiler.AST.SnippetBlock>} seen
 * @returns {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.SlotElement | Compiler.AST.RenderTag | Compiler.AST.Component, NodeExistsValue>}
 */
function get_possible_element_siblings(node, direction, adjacent_only, seen = new Set()) {
	/** @type {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.SlotElement | Compiler.AST.RenderTag | Compiler.AST.Component, NodeExistsValue>} */
	const result = new Map();
	const path = node.metadata.path;

	/** @type {Compiler.AST.SvelteNode} */
	let current = node;

	let i = path.length;

	while (i--) {
		const fragment = /** @type {Compiler.AST.Fragment} */ (path[i--]);
		let j = fragment.nodes.indexOf(current) + (direction === FORWARD ? 1 : -1);

		while (j >= 0 && j < fragment.nodes.length) {
			const node = fragment.nodes[j];

			if (node.type === 'RegularElement') {
				const has_slot_attribute = node.attributes.some(
					(attr) => attr.type === 'Attribute' && attr.name.toLowerCase() === 'slot'
				);

				if (!has_slot_attribute) {
					result.set(node, NODE_DEFINITELY_EXISTS);

					if (adjacent_only) {
						return result;
					}
				}
				// Special case: slots, render tags and svelte:element tags could resolve to no siblings,
				// so we want to continue until we find a definite sibling even with the adjacent-only combinator
			} else if (is_block(node) || node.type === 'Component') {
				if (node.type === 'SlotElement' || node.type === 'Component') {
					result.set(node, NODE_PROBABLY_EXISTS);
				}

				const possible_last_child = get_possible_nested_siblings(node, direction, adjacent_only);
				add_to_map(possible_last_child, result);
				if (
					adjacent_only &&
					node.type !== 'Component' &&
					has_definite_elements(possible_last_child)
				) {
					return result;
				}
			} else if (node.type === 'SvelteElement') {
				result.set(node, NODE_PROBABLY_EXISTS);
			} else if (node.type === 'RenderTag') {
				result.set(node, NODE_PROBABLY_EXISTS);
				for (const snippet of node.metadata.snippets) {
					add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only), result);
				}
			}

			j = direction === FORWARD ? j + 1 : j - 1;
		}

		current = path[i];

		if (!current) break;

		if (
			current.type === 'Component' ||
			current.type === 'SvelteComponent' ||
			current.type === 'SvelteSelf'
		) {
			continue;
		}

		if (current.type === 'SnippetBlock') {
			if (seen.has(current)) break;
			seen.add(current);

			for (const site of current.metadata.sites) {
				const siblings = get_possible_element_siblings(site, direction, adjacent_only, seen);
				add_to_map(siblings, result);

				if (adjacent_only && current.metadata.sites.size === 1 && has_definite_elements(siblings)) {
					return result;
				}
			}
		}

		if (!is_block(current)) break;

		if (current.type === 'EachBlock' && fragment === current.body) {
			// `{#each ...}<a /><b />{/each}` — `<b>` can be previous sibling of `<a />`
			add_to_map(get_possible_nested_siblings(current, direction, adjacent_only), result);
		}
	}

	return result;
}

/**
 * @param {Compiler.AST.EachBlock | Compiler.AST.IfBlock | Compiler.AST.AwaitBlock | Compiler.AST.KeyBlock | Compiler.AST.SlotElement | Compiler.AST.SnippetBlock | Compiler.AST.Component} node
 * @param {Direction} direction
 * @param {boolean} adjacent_only
 * @param {Set<Compiler.AST.SnippetBlock>} seen
 * @returns {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement, NodeExistsValue>}
 */
function get_possible_nested_siblings(node, direction, adjacent_only, seen = new Set()) {
	/** @type {Array<Compiler.AST.Fragment | undefined | null>} */
	let fragments = [];

	switch (node.type) {
		case 'EachBlock':
			fragments.push(node.body, node.fallback);
			break;

		case 'IfBlock':
			fragments.push(node.consequent, node.alternate);
			break;

		case 'AwaitBlock':
			fragments.push(node.pending, node.then, node.catch);
			break;

		case 'KeyBlock':
		case 'SlotElement':
			fragments.push(node.fragment);
			break;

		case 'SnippetBlock':
			if (seen.has(node)) {
				return new Map();
			}
			seen.add(node);
			fragments.push(node.body);
			break;

		case 'Component':
			fragments.push(node.fragment, ...[...node.metadata.snippets].map((s) => s.body));
			break;
	}

	/** @type {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement, NodeExistsValue>} NodeMap */
	const result = new Map();

	let exhaustive = node.type !== 'SlotElement' && node.type !== 'SnippetBlock';

	for (const fragment of fragments) {
		if (fragment == null) {
			exhaustive = false;
			continue;
		}

		const map = loop_child(fragment.nodes, direction, adjacent_only, seen);
		exhaustive &&= has_definite_elements(map);

		add_to_map(map, result);
	}

	if (!exhaustive) {
		for (const key of result.keys()) {
			result.set(key, NODE_PROBABLY_EXISTS);
		}
	}

	return result;
}

/**
 * @param {Map<unknown, NodeExistsValue>} result
 * @returns {boolean}
 */
function has_definite_elements(result) {
	if (result.size === 0) return false;
	for (const exist of result.values()) {
		if (exist === NODE_DEFINITELY_EXISTS) {
			return true;
		}
	}
	return false;
}

/**
 * @template T2
 * @template {T2} T1
 * @param {Map<T1, NodeExistsValue>} from
 * @param {Map<T2, NodeExistsValue>} to
 * @returns {void}
 */
function add_to_map(from, to) {
	from.forEach((exist, element) => {
		to.set(element, higher_existence(exist, to.get(element)));
	});
}

/**
 * @param {NodeExistsValue} exist1
 * @param {NodeExistsValue | undefined} exist2
 * @returns {NodeExistsValue}
 */
function higher_existence(exist1, exist2) {
	if (exist2 === undefined) return exist1;
	return exist1 > exist2 ? exist1 : exist2;
}

/**
 * @param {Compiler.AST.SvelteNode[]} children
 * @param {Direction} direction
 * @param {boolean} adjacent_only
 * @param {Set<Compiler.AST.SnippetBlock>} seen
 */
function loop_child(children, direction, adjacent_only, seen) {
	/** @type {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement, NodeExistsValue>} */
	const result = new Map();

	let i = direction === FORWARD ? 0 : children.length - 1;

	while (i >= 0 && i < children.length) {
		const child = children[i];

		if (child.type === 'RegularElement') {
			result.set(child, NODE_DEFINITELY_EXISTS);
			if (adjacent_only) {
				break;
			}
		} else if (child.type === 'SvelteElement') {
			result.set(child, NODE_PROBABLY_EXISTS);
		} else if (child.type === 'RenderTag') {
			for (const snippet of child.metadata.snippets) {
				add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only, seen), result);
			}
		} else if (is_block(child)) {
			const child_result = get_possible_nested_siblings(child, direction, adjacent_only, seen);
			add_to_map(child_result, result);
			if (adjacent_only && has_definite_elements(child_result)) {
				break;
			}
		}

		i = direction === FORWARD ? i + 1 : i - 1;
	}

	return result;
}

/**
 * @param {Compiler.AST.SvelteNode} node
 * @returns {node is Compiler.AST.IfBlock | Compiler.AST.EachBlock | Compiler.AST.AwaitBlock | Compiler.AST.KeyBlock | Compiler.AST.SlotElement}
 */
function is_block(node) {
	return (
		node.type === 'IfBlock' ||
		node.type === 'EachBlock' ||
		node.type === 'AwaitBlock' ||
		node.type === 'KeyBlock' ||
		node.type === 'SlotElement'
	);
}

/** @import { Visitors } from 'zimmerframe' */
/** @import { AST } from '#compiler' */

/**
 * @param {AST.CSS.StyleSheet} stylesheet
 */
function warn_unused(stylesheet) {
	walk$1(stylesheet, { stylesheet }, visitors$3);
}

/** @type {Visitors<AST.CSS.Node, { stylesheet: AST.CSS.StyleSheet }>} */
const visitors$3 = {
	Atrule(node, context) {
		if (!is_keyframes_node(node)) {
			context.next();
		}
	},
	PseudoClassSelector(node, context) {
		if (node.name === 'is' || node.name === 'where') {
			context.next();
		}
	},
	ComplexSelector(node, context) {
		if (
			!node.metadata.used &&
			// prevent double-marking of `.unused:is(.unused)`
			(context.path.at(-2)?.type !== 'PseudoClassSelector' ||
				/** @type {AST.CSS.ComplexSelector} */ (context.path.at(-4))?.metadata.used)
		) {
			const content = context.state.stylesheet.content;
			const text = content.styles.substring(node.start - content.start, node.end - content.start);
			css_unused_selector(node, text);
		}

		context.next();
	},
	Rule(node, context) {
		if (node.metadata.is_global_block) {
			context.visit(node.prelude);
		} else {
			context.next();
		}
	}
};

/** @import { ArrowFunctionExpression, FunctionDeclaration, FunctionExpression } from 'estree' */
/** @import { Context } from '../../types' */

/**
 * @param {ArrowFunctionExpression | FunctionExpression | FunctionDeclaration} node
 * @param {Context} context
 */
function visit_function$1(node, context) {
	if (context.state.expression) {
		for (const [name] of context.state.scope.references) {
			const binding = context.state.scope.get(name);

			if (binding && binding.scope.function_depth < context.state.scope.function_depth) {
				context.state.expression.references.add(binding);
			}
		}
	}

	context.next({
		...context.state,
		function_depth: context.state.function_depth + 1,
		expression: null
	});
}

/** @import { ArrowFunctionExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {ArrowFunctionExpression} node
 * @param {Context} context
 */
function ArrowFunctionExpression$1(node, context) {
	visit_function$1(node, context);
}

/** @import { AssignmentExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {AssignmentExpression} node
 * @param {Context} context
 */
function AssignmentExpression$2(node, context) {
	validate_assignment(node, node.left, context);

	if (context.state.reactive_statement) {
		const id = node.left.type === 'MemberExpression' ? object$1(node.left) : node.left;
		if (id !== null) {
			for (const id of extract_identifiers(node.left)) {
				const binding = context.state.scope.get(id.name);

				if (binding) {
					context.state.reactive_statement.assignments.add(binding);
				}
			}
		}
	}

	if (context.state.expression) {
		context.state.expression.has_assignment = true;
	}

	context.next();
}

/** @import { Context } from '../types' */
/** @import { AST } from '#compiler'; */

/**
 * @param {AST.AnimateDirective} node
 * @param {Context} context
 */
function AnimateDirective$1(node, context) {
	context.next({ ...context.state, expression: node.metadata.expression });

	if (node.metadata.expression.has_await) {
		illegal_await_expression(node);
	}
}

/** @import { AST } from '#compiler' */

/**
 * @param {AST.SvelteNode[]} path
 */
function mark_subtree_dynamic(path) {
	let i = path.length;
	while (i--) {
		const node = path[i];
		if (node.type === 'Fragment') {
			if (node.metadata.dynamic) return;
			node.metadata.dynamic = true;
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.AttachTag} node
 * @param {Context} context
 */
function AttachTag$1(node, context) {
	mark_subtree_dynamic(context.path);
	context.next({ ...context.state, expression: node.metadata.expression });

	if (node.metadata.expression.has_await) {
		illegal_await_expression(node);
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.Attribute} node
 * @param {Context} context
 */
function Attribute$1(node, context) {
	context.next();

	const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1));

	if (parent.type === 'RegularElement') {
		// special case <option value="" />
		if (node.name === 'value' && parent.name === 'option') {
			mark_subtree_dynamic(context.path);
		}
	}

	if (is_event_attribute(node)) {
		mark_subtree_dynamic(context.path);
	}

	if (cannot_be_set_statically(node.name)) {
		mark_subtree_dynamic(context.path);
	}

	// class={[...]} or class={{...}} or `class={x}` need clsx to resolve the classes
	if (
		node.name === 'class' &&
		!Array.isArray(node.value) &&
		node.value !== true &&
		node.value.expression.type !== 'Literal' &&
		node.value.expression.type !== 'TemplateLiteral' &&
		node.value.expression.type !== 'BinaryExpression'
	) {
		mark_subtree_dynamic(context.path);
		node.metadata.needs_clsx = true;
	}

	if (node.value !== true) {
		for (const chunk of get_attribute_chunks(node.value)) {
			if (chunk.type !== 'ExpressionTag') continue;

			if (
				chunk.expression.type === 'FunctionExpression' ||
				chunk.expression.type === 'ArrowFunctionExpression'
			) {
				continue;
			}
		}

		if (is_event_attribute(node)) {
			const parent = context.path.at(-1);
			if (parent?.type === 'RegularElement' || parent?.type === 'SvelteElement') {
				context.state.analysis.uses_event_attributes = true;
			}

			node.metadata.delegated =
				parent?.type === 'RegularElement' && can_delegate_event(node.name.slice(2));
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.AwaitBlock} node
 * @param {Context} context
 */
function AwaitBlock$2(node, context) {
	validate_block_not_empty(node.pending);
	validate_block_not_empty(node.then);
	validate_block_not_empty(node.catch);

	if (context.state.analysis.runes) {
		validate_opening_tag(node, context.state, '#');

		if (node.value) {
			const start = /** @type {number} */ (node.value.start);
			const match = context.state.analysis.source
				.substring(start - 10, start)
				.match(/{(\s*):then\s+$/);

			if (match && match[1] !== '') {
				block_unexpected_character({ start: start - 10, end: start }, ':');
			}
		}

		if (node.error) {
			const start = /** @type {number} */ (node.error.start);
			const match = context.state.analysis.source
				.substring(start - 10, start)
				.match(/{(\s*):catch\s+$/);

			if (match && match[1] !== '') {
				block_unexpected_character({ start: start - 10, end: start }, ':');
			}
		}
	}

	mark_subtree_dynamic(context.path);

	context.visit(node.expression, { ...context.state, expression: node.metadata.expression });
	if (node.pending) context.visit(node.pending);
	if (node.then) context.visit(node.then);
	if (node.catch) context.visit(node.catch);
}

/** @import { AwaitExpression, Expression, SpreadElement, Property } from 'estree' */
/** @import { Context } from '../types' */
/** @import { AST } from '#compiler' */

/**
 * @param {AwaitExpression} node
 * @param {Context} context
 */
function AwaitExpression$2(node, context) {
	const tla = context.state.ast_type === 'instance' && context.state.function_depth === 1;

	// preserve context for awaits that precede other expressions in template or `$derived(...)`
	if (
		is_reactive_expression(
			context.path,
			context.state.derived_function_depth === context.state.function_depth
		) &&
		!is_last_evaluated_expression(context.path, node)
	) {
		context.state.analysis.pickled_awaits.add(node);
	}

	let suspend = tla;

	if (context.state.expression) {
		context.state.expression.has_await = true;

		suspend = true;
	}

	// disallow top-level `await` or `await` in template expressions
	// unless a) in runes mode and b) opted into `experimental.async`
	if (suspend) {
		if (!context.state.options.experimental.async) {
			experimental_async(node);
		}

		if (!context.state.analysis.runes) {
			legacy_await_invalid(node);
		}
	}

	context.next();
}

/**
 * @param {AST.SvelteNode[]} path
 * @param {boolean} in_derived
 */
function is_reactive_expression(path, in_derived) {
	if (in_derived) return true;

	let i = path.length;

	while (i--) {
		const parent = path[i];

		if (
			parent.type === 'ArrowFunctionExpression' ||
			parent.type === 'FunctionExpression' ||
			parent.type === 'FunctionDeclaration'
		) {
			// No reactive expression found between function and await
			return false;
		}

		// @ts-expect-error we could probably use a neater/more robust mechanism
		if (parent.metadata) {
			return true;
		}
	}

	return false;
}

/**
 * @param {AST.SvelteNode[]} path
 * @param {Expression | SpreadElement | Property} node
 */
function is_last_evaluated_expression(path, node) {
	let i = path.length;

	while (i--) {
		const parent = path[i];

		if (parent.type === 'ConstTag') {
			// {@const ...} tags are treated as deriveds and its contents should all get the preserve-reactivity treatment
			return false;
		}

		// @ts-expect-error we could probably use a neater/more robust mechanism
		if (parent.metadata) {
			return true;
		}

		switch (parent.type) {
			case 'ArrayExpression':
				if (node !== parent.elements.at(-1)) return false;
				break;

			case 'AssignmentExpression':
			case 'BinaryExpression':
			case 'LogicalExpression':
				if (node === parent.left) return false;
				break;

			case 'CallExpression':
			case 'NewExpression':
				if (node !== parent.arguments.at(-1)) return false;
				break;

			case 'ConditionalExpression':
				if (node === parent.test) return false;
				break;

			case 'MemberExpression':
				if (parent.computed && node === parent.object) return false;
				break;

			case 'ObjectExpression':
				if (node !== parent.properties.at(-1)) return false;
				break;

			case 'Property':
				if (node === parent.key) return false;
				break;

			case 'SequenceExpression':
				if (node !== parent.expressions.at(-1)) return false;
				break;

			case 'TaggedTemplateExpression':
				if (node !== parent.quasi.expressions.at(-1)) return false;
				break;

			case 'TemplateLiteral':
				if (node !== parent.expressions.at(-1)) return false;
				break;

			case 'VariableDeclarator':
				return true;

			default:
				return false;
		}

		node = parent;
	}
}

/**
 * @typedef BindingProperty
 * @property {string} [event] This is set if the binding corresponds to the property name on the dom element it's bound to
 * 							  and there's an event that notifies of a change to that property
 * @property {boolean} [bidirectional] Set this to `true` if updates are written to the dom property
 * @property {boolean} [omit_in_ssr] Set this to true if the binding should not be included in SSR
 * @property {string[]} [valid_elements] If this is set, the binding is only valid on the given elements
 * @property {string[]} [invalid_elements] If this is set, the binding is invalid on the given elements
 */

/**
 * @type {Record<string, BindingProperty>}
 */
const binding_properties = {
	// media
	currentTime: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true,
		bidirectional: true
	},
	duration: {
		valid_elements: ['audio', 'video'],
		event: 'durationchange',
		omit_in_ssr: true
	},
	focused: {},
	paused: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true,
		bidirectional: true
	},
	buffered: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true
	},
	seekable: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true
	},
	played: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true
	},
	volume: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true,
		bidirectional: true
	},
	muted: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true,
		bidirectional: true
	},
	playbackRate: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true,
		bidirectional: true
	},
	seeking: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true
	},
	ended: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true
	},
	readyState: {
		valid_elements: ['audio', 'video'],
		omit_in_ssr: true
	},
	// video
	videoHeight: {
		valid_elements: ['video'],
		event: 'resize',
		omit_in_ssr: true
	},
	videoWidth: {
		valid_elements: ['video'],
		event: 'resize',
		omit_in_ssr: true
	},
	// img
	naturalWidth: {
		valid_elements: ['img'],
		event: 'load',
		omit_in_ssr: true
	},
	naturalHeight: {
		valid_elements: ['img'],
		event: 'load',
		omit_in_ssr: true
	},
	// document
	activeElement: {
		valid_elements: ['svelte:document'],
		omit_in_ssr: true
	},
	fullscreenElement: {
		valid_elements: ['svelte:document'],
		event: 'fullscreenchange',
		omit_in_ssr: true
	},
	pointerLockElement: {
		valid_elements: ['svelte:document'],
		event: 'pointerlockchange',
		omit_in_ssr: true
	},
	visibilityState: {
		valid_elements: ['svelte:document'],
		event: 'visibilitychange',
		omit_in_ssr: true
	},
	// window
	innerWidth: {
		valid_elements: ['svelte:window'],
		omit_in_ssr: true
	},
	innerHeight: {
		valid_elements: ['svelte:window'],
		omit_in_ssr: true
	},
	outerWidth: {
		valid_elements: ['svelte:window'],
		omit_in_ssr: true
	},
	outerHeight: {
		valid_elements: ['svelte:window'],
		omit_in_ssr: true
	},
	scrollX: {
		valid_elements: ['svelte:window'],
		omit_in_ssr: true,
		bidirectional: true
	},
	scrollY: {
		valid_elements: ['svelte:window'],
		omit_in_ssr: true,
		bidirectional: true
	},
	online: {
		valid_elements: ['svelte:window'],
		omit_in_ssr: true
	},
	devicePixelRatio: {
		valid_elements: ['svelte:window'],
		event: 'resize',
		omit_in_ssr: true
	},
	// dimensions
	clientWidth: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	clientHeight: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	offsetWidth: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	offsetHeight: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	contentRect: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	contentBoxSize: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	borderBoxSize: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	devicePixelContentBoxSize: {
		omit_in_ssr: true,
		invalid_elements: ['svelte:window', 'svelte:document']
	},
	// checkbox/radio
	indeterminate: {
		event: 'change',
		bidirectional: true,
		valid_elements: ['input'],
		omit_in_ssr: true // no corresponding attribute
	},
	checked: {
		valid_elements: ['input'],
		bidirectional: true
	},
	group: {
		valid_elements: ['input'],
		bidirectional: true
	},
	// various
	this: {
		omit_in_ssr: true
	},
	innerText: {
		invalid_elements: ['svelte:window', 'svelte:document'],
		bidirectional: true
	},
	innerHTML: {
		invalid_elements: ['svelte:window', 'svelte:document'],
		bidirectional: true
	},
	textContent: {
		invalid_elements: ['svelte:window', 'svelte:document'],
		bidirectional: true
	},
	open: {
		event: 'toggle',
		bidirectional: true,
		valid_elements: ['details']
	},
	value: {
		valid_elements: ['input', 'textarea', 'select'],
		bidirectional: true
	},
	files: {
		valid_elements: ['input'],
		omit_in_ssr: true,
		bidirectional: true
	}
};

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.BindDirective} node
 * @param {Context} context
 */
function BindDirective$1(node, context) {
	const parent = context.path.at(-1);

	if (
		parent?.type === 'RegularElement' ||
		parent?.type === 'SvelteElement' ||
		parent?.type === 'SvelteWindow' ||
		parent?.type === 'SvelteDocument' ||
		parent?.type === 'SvelteBody'
	) {
		if (node.name in binding_properties) {
			const property = binding_properties[node.name];
			if (property.valid_elements && !property.valid_elements.includes(parent.name)) {
				bind_invalid_target(
					node,
					node.name,
					property.valid_elements.map((valid_element) => `\`<${valid_element}>\``).join(', ')
				);
			}

			if (property.invalid_elements && property.invalid_elements.includes(parent.name)) {
				const valid_bindings = Object.entries(binding_properties)
					.filter(([_, binding_property]) => {
						return (
							binding_property.valid_elements?.includes(parent.name) ||
							(!binding_property.valid_elements &&
								!binding_property.invalid_elements?.includes(parent.name))
						);
					})
					.map(([property_name]) => property_name)
					.sort();

				bind_invalid_name(
					node,
					node.name,
					`Possible bindings for <${parent.name}> are ${valid_bindings.join(', ')}`
				);
			}

			if (parent.name === 'input' && node.name !== 'this') {
				const type = /** @type {AST.Attribute | undefined} */ (
					parent.attributes.find((a) => a.type === 'Attribute' && a.name === 'type')
				);

				if (type && !is_text_attribute(type)) {
					if (node.name !== 'value' || type.value === true) {
						attribute_invalid_type(type);
					}
				} else {
					if (node.name === 'checked' && type?.value[0].data !== 'checkbox') {
						bind_invalid_target(
							node,
							node.name,
							`\`<input type="checkbox">\`${type?.value[0].data === 'radio' ? ` — for \`<input type="radio">\`, use \`bind:group\`` : ''}`
						);
					}

					if (node.name === 'files' && type?.value[0].data !== 'file') {
						bind_invalid_target(node, node.name, '`<input type="file">`');
					}
				}
			}

			if (parent.name === 'select' && node.name !== 'this') {
				const multiple = parent.attributes.find(
					(a) =>
						a.type === 'Attribute' &&
						a.name === 'multiple' &&
						!is_text_attribute(a) &&
						a.value !== true
				);

				if (multiple) {
					attribute_invalid_multiple(multiple);
				}
			}

			if (node.name === 'offsetWidth' && is_svg(parent.name)) {
				bind_invalid_target(
					node,
					node.name,
					`non-\`<svg>\` elements. Use \`bind:clientWidth\` for \`<svg>\` instead`
				);
			}

			if (is_content_editable_binding(node.name)) {
				const contenteditable = /** @type {AST.Attribute} */ (
					parent.attributes.find((a) => a.type === 'Attribute' && a.name === 'contenteditable')
				);

				if (!contenteditable) {
					attribute_contenteditable_missing(node);
				} else if (!is_text_attribute(contenteditable) && contenteditable.value !== true) {
					attribute_contenteditable_dynamic(contenteditable);
				}
			}
		} else {
			const match = fuzzymatch(node.name, Object.keys(binding_properties));

			if (match) {
				const property = binding_properties[match];
				if (!property.valid_elements || property.valid_elements.includes(parent.name)) {
					bind_invalid_name(node, node.name, `Did you mean '${match}'?`);
				}
			}

			bind_invalid_name(node, node.name);
		}
	}

	// When dealing with bind getters/setters skip the specific binding validation
	// Group bindings aren't supported for getter/setters so we don't need to handle
	// the metadata
	if (node.expression.type === 'SequenceExpression') {
		if (node.name === 'group') {
			bind_group_invalid_expression(node);
		}

		let i = /** @type {number} */ (node.expression.start);
		let leading_comments_start = /**@type {any}*/ (node.expression.leadingComments?.at(0))?.start;
		let leading_comments_end = /**@type {any}*/ (node.expression.leadingComments?.at(-1))?.end;
		while (context.state.analysis.source[--i] !== '{') {
			if (
				context.state.analysis.source[i] === '(' &&
				// if the parenthesis is in a leading comment we don't need to throw the error
				!(
					leading_comments_start &&
					leading_comments_end &&
					i <= leading_comments_end &&
					i >= leading_comments_start
				)
			) {
				bind_invalid_parens(node, node.name);
			}
		}

		if (node.expression.expressions.length !== 2) {
			bind_invalid_expression(node);
		}

		mark_subtree_dynamic(context.path);

		const [get, set] = node.expression.expressions;
		// We gotta jump across the getter/setter functions to avoid the expression metadata field being reset to null
		// as we want to collect the functions' blocker/async info
		context.visit(get.type === 'ArrowFunctionExpression' ? get.body : get, {
			...context.state,
			expression: node.metadata.expression
		});
		context.visit(set.type === 'ArrowFunctionExpression' ? set.body : set, {
			...context.state,
			expression: node.metadata.expression
		});

		if (node.metadata.expression.has_await) {
			illegal_await_expression(node);
		}

		return;
	}

	validate_assignment(node, node.expression, context);

	const assignee = node.expression;
	const left = object$1(assignee);

	if (left === null) {
		bind_invalid_expression(node);
	}

	const binding = context.state.scope.get(left.name);
	node.metadata.binding = binding;

	if (assignee.type === 'Identifier') {
		// reassignment
		if (
			node.name !== 'this' && // bind:this also works for regular variables
			(!binding ||
				(binding.kind !== 'state' &&
					binding.kind !== 'raw_state' &&
					binding.kind !== 'prop' &&
					binding.kind !== 'bindable_prop' &&
					binding.kind !== 'each' &&
					binding.kind !== 'store_sub' &&
					!binding.updated)) // TODO wut?
		) {
			bind_invalid_value(node.expression);
		}
	}

	if (node.name === 'group') {
		if (!binding) {
			throw new Error('Cannot find declaration for bind:group');
		}

		if (binding.kind === 'snippet') {
			bind_group_invalid_snippet_parameter(node);
		}

		// Traverse the path upwards and find all EachBlocks who are (indirectly) contributing to bind:group,
		// i.e. one of their declarations is referenced in the binding. This allows group bindings to work
		// correctly when referencing a variable declared in an EachBlock by using the index of the each block
		// entries as keys.
		const each_blocks = [];
		const [keypath, expression_ids] = extract_all_identifiers_from_expression(node.expression);
		let ids = expression_ids;

		let i = context.path.length;
		while (i--) {
			const parent = context.path[i];

			if (parent.type === 'EachBlock') {
				const references = ids.filter((id) => parent.metadata.declarations.has(id.name));

				if (references.length > 0) {
					parent.metadata.contains_group_binding = true;

					each_blocks.push(parent);
					ids = ids.filter((id) => !references.includes(id));
					ids.push(...extract_all_identifiers_from_expression(parent.expression)[1]);
				}
			}
		}

		// The identifiers that make up the binding expression form they key for the binding group.
		// If the same identifiers in the same order are used in another bind:group, they will be in the same group.
		// (there's an edge case where `bind:group={a[i]}` will be in a different group than `bind:group={a[j]}` even when i == j,
		//  but this is a limitation of the current static analysis we do; it also never worked in Svelte 4)
		const bindings = expression_ids.map((id) => context.state.scope.get(id.name));
		let group_name;

		outer: for (const [[key, b], group] of context.state.analysis.binding_groups) {
			if (b.length !== bindings.length || key !== keypath) continue;
			for (let i = 0; i < bindings.length; i++) {
				if (bindings[i] !== b[i]) continue outer;
			}
			group_name = group;
		}

		if (!group_name) {
			group_name = context.state.scope.root.unique('binding_group');
			context.state.analysis.binding_groups.set([keypath, bindings], group_name);
		}

		node.metadata = {
			binding_group_name: group_name,
			parent_each_blocks: each_blocks,
			expression: node.metadata.expression
		};
	}

	if (binding?.kind === 'each' && binding.metadata?.inside_rest) {
		bind_invalid_each_rest(binding.node, binding.node.name);
	}

	context.next({ ...context.state, expression: node.metadata.expression });

	if (node.metadata.expression.has_await) {
		illegal_await_expression(node);
	}
}

/** @import { ArrowFunctionExpression, CallExpression, Expression, FunctionDeclaration, FunctionExpression, Identifier, VariableDeclarator } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {CallExpression} node
 * @param {Context} context
 */
function CallExpression$2(node, context) {
	const parent = /** @type {AST.SvelteNode} */ (get_parent(context.path, -1));

	const rune = get_rune(node, context.state.scope);

	if (rune && rune !== '$inspect') {
		for (const arg of node.arguments) {
			if (arg.type === 'SpreadElement') {
				rune_invalid_spread(node, rune);
			}
		}
	}

	switch (rune) {
		case null:
			if (!is_safe_identifier(node.callee, context.state.scope)) {
				context.state.analysis.needs_context = true;
			}

			break;

		case '$bindable':
			if (node.arguments.length > 1) {
				rune_invalid_arguments_length(node, '$bindable', 'zero or one arguments');
			}

			if (
				parent.type !== 'AssignmentPattern' ||
				context.path.at(-3)?.type !== 'ObjectPattern' ||
				context.path.at(-4)?.type !== 'VariableDeclarator' ||
				get_rune(
					/** @type {VariableDeclarator} */ (context.path.at(-4)).init,
					context.state.scope
				) !== '$props'
			) {
				bindable_invalid_location(node);
			}

			// We need context in case the bound prop is stale
			context.state.analysis.needs_context = true;

			break;

		case '$host':
			if (node.arguments.length > 0) {
				rune_invalid_arguments(node, '$host');
			} else if (context.state.ast_type === 'module' || !context.state.analysis.custom_element) {
				host_invalid_placement(node);
			}

			break;

		case '$props':
			if (context.state.has_props_rune) {
				props_duplicate(node, rune);
			}

			context.state.has_props_rune = true;

			if (
				parent.type !== 'VariableDeclarator' ||
				context.state.ast_type !== 'instance' ||
				context.state.scope !== context.state.analysis.instance.scope
			) {
				props_invalid_placement(node);
			}

			if (node.arguments.length > 0) {
				rune_invalid_arguments(node, rune);
			}

			break;

		case '$props.id': {
			const grand_parent = get_parent(context.path, -2);

			if (context.state.analysis.props_id) {
				props_duplicate(node, rune);
			}

			if (
				parent.type !== 'VariableDeclarator' ||
				parent.id.type !== 'Identifier' ||
				context.state.ast_type !== 'instance' ||
				context.state.scope !== context.state.analysis.instance.scope ||
				grand_parent.type !== 'VariableDeclaration'
			) {
				props_id_invalid_placement(node);
			}

			if (node.arguments.length > 0) {
				rune_invalid_arguments(node, rune);
			}

			context.state.analysis.props_id = parent.id;

			break;
		}

		case '$state':
		case '$state.raw':
		case '$derived':
		case '$derived.by': {
			const valid =
				is_variable_declaration(parent, context) ||
				is_class_property_definition(parent) ||
				is_class_property_assignment_at_constructor_root(parent, context);

			if (!valid) {
				state_invalid_placement(node, rune);
			}

			if ((rune === '$derived' || rune === '$derived.by') && node.arguments.length !== 1) {
				rune_invalid_arguments_length(node, rune, 'exactly one argument');
			} else if (node.arguments.length > 1) {
				rune_invalid_arguments_length(node, rune, 'zero or one arguments');
			}

			break;
		}

		case '$effect':
		case '$effect.pre':
			if (parent.type !== 'ExpressionStatement') {
				effect_invalid_placement(node);
			}

			if (node.arguments.length !== 1) {
				rune_invalid_arguments_length(node, rune, 'exactly one argument');
			}

			// `$effect` needs context because Svelte needs to know whether it should re-run
			// effects that invalidate themselves, and that's determined by whether we're in runes mode
			context.state.analysis.needs_context = true;

			break;

		case '$effect.tracking':
			if (node.arguments.length !== 0) {
				rune_invalid_arguments(node, rune);
			}

			break;

		case '$effect.root':
			if (node.arguments.length !== 1) {
				rune_invalid_arguments_length(node, rune, 'exactly one argument');
			}

			break;

		case '$effect.pending':
			if (context.state.expression) {
				context.state.expression.has_state = true;
			}

			break;

		case '$inspect':
			if (node.arguments.length < 1) {
				rune_invalid_arguments_length(node, rune, 'one or more arguments');
			}

			break;

		case '$inspect().with':
			if (node.arguments.length !== 1) {
				rune_invalid_arguments_length(node, rune, 'exactly one argument');
			}

			break;

		case '$inspect.trace': {
			if (node.arguments.length > 1) {
				rune_invalid_arguments_length(node, rune, 'zero or one arguments');
			}

			const grand_parent = context.path.at(-2);
			const fn = context.path.at(-3);

			if (
				parent.type !== 'ExpressionStatement' ||
				grand_parent?.type !== 'BlockStatement' ||
				!(
					fn?.type === 'FunctionDeclaration' ||
					fn?.type === 'FunctionExpression' ||
					fn?.type === 'ArrowFunctionExpression'
				) ||
				grand_parent.body[0] !== parent
			) {
				inspect_trace_invalid_placement(node);
			}

			if (fn.generator) {
				inspect_trace_generator(node);
			}

			if (dev) {
				if (node.arguments[0]) {
					context.state.scope.tracing = thunk(/** @type {Expression} */ (node.arguments[0]));
				} else {
					const label = get_function_label(context.path.slice(0, -2)) ?? 'trace';
					const loc = `(${locate_node(fn)})`;

					context.state.scope.tracing = thunk(literal(label + ' ' + loc));
				}

				context.state.analysis.tracing = true;
			}

			break;
		}

		case '$state.eager':
			if (node.arguments.length !== 1) {
				rune_invalid_arguments_length(node, rune, 'exactly one argument');
			}

			break;

		case '$state.snapshot':
			if (node.arguments.length !== 1) {
				rune_invalid_arguments_length(node, rune, 'exactly one argument');
			}

			break;
	}

	// `$inspect(foo)` or `$derived(foo) should not trigger the `static-state-reference` warning
	if (rune === '$derived') {
		const expression = new ExpressionMetadata();

		context.next({
			...context.state,
			function_depth: context.state.function_depth + 1,
			derived_function_depth: context.state.function_depth + 1,
			expression
		});

		if (expression.has_await) {
			context.state.analysis.async_deriveds.add(node);
		}
	} else if (rune === '$inspect') {
		context.next({ ...context.state, function_depth: context.state.function_depth + 1 });
	} else {
		context.next();
	}

	if (context.state.expression) {
		// TODO We assume that any dependencies are stateful, which isn't necessarily the case — see
		// https://github.com/sveltejs/svelte/issues/13266. This check also includes dependencies
		// outside the call expression itself (e.g. `{blah && pure()}`) resulting in additional
		// false positives, but for now we accept that trade-off
		if (!is_pure(node.callee, context) || context.state.expression.dependencies.size > 0) {
			context.state.expression.has_call = true;
			context.state.expression.has_state = true;
		}
	}
}

/**
 * @param {AST.SvelteNode[]} nodes
 */
function get_function_label(nodes) {
	const fn = /** @type {FunctionExpression | FunctionDeclaration | ArrowFunctionExpression} */ (
		nodes.at(-1)
	);

	if ((fn.type === 'FunctionDeclaration' || fn.type === 'FunctionExpression') && fn.id != null) {
		return fn.id.name;
	}

	const parent = nodes.at(-2);
	if (!parent) return;

	if (parent.type === 'CallExpression') {
		return source.slice(parent.callee.start, parent.callee.end) + '(...)';
	}

	if (parent.type === 'Property' && !parent.computed) {
		return /** @type {Identifier} */ (parent.key).name;
	}

	if (parent.type === 'VariableDeclarator' && parent.id.type === 'Identifier') {
		return parent.id.name;
	}
}

/**
 * @param {AST.SvelteNode} parent
 * @param {Context} context
 */
function is_variable_declaration(parent, context) {
	return parent.type === 'VariableDeclarator' && get_parent(context.path, -3).type !== 'ConstTag';
}

/**
 * @param {AST.SvelteNode} parent
 */
function is_class_property_definition(parent) {
	return parent.type === 'PropertyDefinition' && !parent.static && !parent.computed;
}

/**
 * @param {AST.SvelteNode} node
 * @param {Context} context
 */
function is_class_property_assignment_at_constructor_root(node, context) {
	if (
		node.type === 'AssignmentExpression' &&
		node.operator === '=' &&
		node.left.type === 'MemberExpression' &&
		node.left.object.type === 'ThisExpression' &&
		((node.left.property.type === 'Identifier' && !node.left.computed) ||
			node.left.property.type === 'PrivateIdentifier' ||
			node.left.property.type === 'Literal')
	) {
		// MethodDefinition (-5) -> FunctionExpression (-4) -> BlockStatement (-3) -> ExpressionStatement (-2) -> AssignmentExpression (-1)
		const parent = get_parent(context.path, -5);
		return parent?.type === 'MethodDefinition' && parent.kind === 'constructor';
	}

	return false;
}

/** @import { AssignmentExpression, CallExpression, ClassBody, PropertyDefinition, Expression, PrivateIdentifier, MethodDefinition } from 'estree' */
/** @import { StateField } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {ClassBody} node
 * @param {Context} context
 */
function ClassBody$2(node, context) {
	if (!context.state.analysis.runes) {
		context.next();
		return;
	}

	/** @type {string[]} */
	const private_ids = [];

	for (const prop of node.body) {
		if (
			(prop.type === 'MethodDefinition' || prop.type === 'PropertyDefinition') &&
			prop.key.type === 'PrivateIdentifier'
		) {
			private_ids.push(prop.key.name);
		}
	}

	/** @type {Map<string, StateField>} */
	const state_fields = new Map();

	/** @type {Map<string, Array<MethodDefinition['kind'] | 'prop' | 'assigned_prop'>>} */
	const fields = new Map();

	context.state.analysis.classes.set(node, state_fields);

	/** @type {MethodDefinition | null} */
	let constructor = null;

	/**
	 * @param {PropertyDefinition | AssignmentExpression} node
	 * @param {Expression | PrivateIdentifier} key
	 * @param {Expression | null | undefined} value
	 */
	function handle(node, key, value) {
		const name = get_name(key);
		if (name === null) return;

		const rune = get_rune(value, context.state.scope);

		if (rune && is_state_creation_rune(rune)) {
			if (state_fields.has(name)) {
				state_field_duplicate(node, name);
			}

			const _key = (node.type === 'AssignmentExpression' || !node.static ? '' : '@') + name;
			const field = fields.get(_key);

			// if there's already a method or assigned field, error
			if (field && !(field.length === 1 && field[0] === 'prop')) {
				duplicate_class_field(node, _key);
			}

			state_fields.set(name, {
				node,
				type: rune,
				// @ts-expect-error for public state this is filled out in a moment
				key: key.type === 'PrivateIdentifier' ? key : null,
				value: /** @type {CallExpression} */ (value)
			});
		}
	}

	for (const child of node.body) {
		if (child.type === 'PropertyDefinition' && !child.computed && !child.static) {
			handle(child, child.key, child.value);
			const key = /** @type {string} */ (get_name(child.key));
			const field = fields.get(key);
			if (!field) {
				fields.set(key, [child.value ? 'assigned_prop' : 'prop']);
				continue;
			}
			duplicate_class_field(child, key);
		}

		if (child.type === 'MethodDefinition') {
			if (child.kind === 'constructor') {
				constructor = child;
			} else if (!child.computed) {
				const key = (child.static ? '@' : '') + get_name(child.key);
				const field = fields.get(key);
				if (!field) {
					fields.set(key, [child.kind]);
					continue;
				}
				if (
					field.includes(child.kind) ||
					field.includes('prop') ||
					field.includes('assigned_prop')
				) {
					duplicate_class_field(child, key);
				}
				if (child.kind === 'get') {
					if (field.length === 1 && field[0] === 'set') {
						field.push('get');
						continue;
					}
				} else if (child.kind === 'set') {
					if (field.length === 1 && field[0] === 'get') {
						field.push('set');
						continue;
					}
				} else {
					field.push(child.kind);
					continue;
				}
				duplicate_class_field(child, key);
			}
		}
	}

	if (constructor) {
		for (const statement of constructor.value.body.body) {
			if (statement.type !== 'ExpressionStatement') continue;
			if (statement.expression.type !== 'AssignmentExpression') continue;

			const { left, right } = statement.expression;

			if (left.type !== 'MemberExpression') continue;
			if (left.object.type !== 'ThisExpression') continue;
			if (left.computed && left.property.type !== 'Literal') continue;

			handle(statement.expression, left.property, right);
		}
	}

	for (const [name, field] of state_fields) {
		if (name[0] === '#') {
			continue;
		}

		let deconflicted = name.replace(regex_invalid_identifier_chars, '_');
		while (private_ids.includes(deconflicted)) {
			deconflicted = '_' + deconflicted;
		}

		private_ids.push(deconflicted);
		field.key = private_id(deconflicted);
	}

	context.next({ ...context.state, state_fields });
}

/** @import { ClassDeclaration } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {ClassDeclaration} node
 * @param {Context} context
 */
function ClassDeclaration(node, context) {
	if (context.state.analysis.runes && node.id !== null) {
		validate_identifier_name(context.state.scope.get(node.id.name));
	}

	// In modules, we allow top-level module scope only, in components, we allow the component scope,
	// which is function_depth of 1. With the exception of `new class` which is also not allowed at
	// component scope level either.
	const allowed_depth = context.state.ast_type === 'module' ? 0 : 1;

	if (context.state.scope.function_depth > allowed_depth) {
		perf_avoid_nested_class(node);
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */


/**
 * @param {AST.ClassDirective} node
 * @param {Context} context
 */
function ClassDirective(node, context) {
	mark_subtree_dynamic(context.path);
	context.next({ ...context.state, expression: node.metadata.expression });
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../../types' */

/**
 * @param {AST.Attribute} attribute
 */
function validate_attribute_name(attribute) {
	if (
		attribute.name.includes(':') &&
		!attribute.name.startsWith('xmlns:') &&
		!attribute.name.startsWith('xlink:') &&
		!attribute.name.startsWith('xml:')
	) {
		attribute_illegal_colon(attribute);
	}
}

/**
 * @param {AST.Attribute} attribute
 * @param {AST.ElementLike} parent
 */
function validate_attribute(attribute, parent) {
	if (
		Array.isArray(attribute.value) &&
		attribute.value.length === 1 &&
		attribute.value[0].type === 'ExpressionTag' &&
		(parent.type === 'Component' ||
			parent.type === 'SvelteComponent' ||
			parent.type === 'SvelteSelf' ||
			(parent.type === 'RegularElement' && is_custom_element_node(parent)))
	) {
		attribute_quoted(attribute);
	}

	if (attribute.value === true || !Array.isArray(attribute.value) || attribute.value.length === 1) {
		return;
	}

	const is_quoted = attribute.value.at(-1)?.end !== attribute.end;

	if (!is_quoted) {
		attribute_unquoted_sequence(attribute);
	}
}

/**
 * @param {Context} context
 * @param {AST.Attribute} attribute
 * @param {boolean} is_component
 */
function validate_slot_attribute(context, attribute, is_component = false) {
	const parent = context.path.at(-2);
	let owner = undefined;

	if (parent?.type === 'SnippetBlock') {
		if (!is_text_attribute(attribute)) {
			slot_attribute_invalid(attribute);
		}
		return;
	}

	let i = context.path.length;
	while (i--) {
		const ancestor = context.path[i];
		if (
			!owner &&
			(ancestor.type === 'Component' ||
				ancestor.type === 'SvelteComponent' ||
				ancestor.type === 'SvelteSelf' ||
				ancestor.type === 'SvelteElement' ||
				(ancestor.type === 'RegularElement' && is_custom_element_node(ancestor)))
		) {
			owner = ancestor;
		}
	}

	if (owner) {
		if (
			owner.type === 'Component' ||
			owner.type === 'SvelteComponent' ||
			owner.type === 'SvelteSelf'
		) {
			if (owner !== parent) {
				if (!is_component) {
					slot_attribute_invalid_placement(attribute);
				}
			} else {
				if (!is_text_attribute(attribute)) {
					slot_attribute_invalid(attribute);
				}

				const name = attribute.value[0].data;

				if (context.state.component_slots.has(name)) {
					slot_attribute_duplicate(attribute, name, owner.name);
				}

				context.state.component_slots.add(name);

				if (name === 'default') {
					for (const node of owner.fragment.nodes) {
						if (node.type === 'Text' && regex_only_whitespaces.test(node.data)) {
							continue;
						}

						if (node.type === 'RegularElement' || node.type === 'SvelteFragment') {
							if (node.attributes.some((a) => a.type === 'Attribute' && a.name === 'slot')) {
								continue;
							}
						}

						slot_default_duplicate(node);
					}
				}
			}
		}
	} else if (!is_component) {
		slot_attribute_invalid_placement(attribute);
	}
}

/** @import { Binding } from '#compiler' */

/**
 * Returns `true` if a binding unambiguously resolves to a specific
 * snippet declaration, or is external to the current component
 * @param {Binding | null} binding
 */
function is_resolved_snippet(binding) {
	return (
		!binding ||
		binding.declaration_kind === 'import' ||
		binding.kind === 'prop' ||
		binding.kind === 'rest_prop' ||
		binding.kind === 'bindable_prop' ||
		binding?.initial?.type === 'SnippetBlock'
	);
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { AnalysisState, Context } from '../../types' */

/**
 * @param {AST.Component | AST.SvelteComponent | AST.SvelteSelf} node
 * @param {Context} context
 */
function visit_component(node, context) {
	node.metadata.path = [...context.path];

	// link this node to all the snippets that it could render, so that we can prune CSS correctly
	node.metadata.snippets = new Set();

	// 'resolved' means we know which snippets this component might render. if it is `false`,
	// then `node.metadata.snippets` is populated with every locally defined snippet
	// once analysis is complete
	let resolved = true;

	for (const attribute of node.attributes) {
		if (attribute.type === 'SpreadAttribute' || attribute.type === 'BindDirective') {
			resolved = false;
			continue;
		}

		if (attribute.type !== 'Attribute' || !is_expression_attribute(attribute)) {
			continue;
		}

		const expression = get_attribute_expression(attribute);

		// given an attribute like `foo={bar}`, if `bar` resolves to an import or a prop
		// then we know it doesn't reference a locally defined snippet. if it resolves
		// to a `{#snippet bar()}` then we know _which_ snippet it resolves to. in all
		// other cases, we can't know (without much more complex static analysis) which
		// snippets the component might render, so we treat the component as unresolved
		if (expression.type === 'Identifier') {
			const binding = context.state.scope.get(expression.name);

			resolved &&= is_resolved_snippet(binding);

			if (binding?.initial?.type === 'SnippetBlock') {
				node.metadata.snippets.add(binding.initial);
			}
		} else if (expression.type !== 'Literal') {
			resolved = false;
		}
	}

	if (resolved) {
		for (const child of node.fragment.nodes) {
			if (child.type === 'SnippetBlock') {
				node.metadata.snippets.add(child);
			}
		}
	}

	context.state.analysis.snippet_renderers.set(node, resolved);

	mark_subtree_dynamic(context.path);

	for (const attribute of node.attributes) {
		if (
			attribute.type !== 'Attribute' &&
			attribute.type !== 'SpreadAttribute' &&
			attribute.type !== 'LetDirective' &&
			attribute.type !== 'OnDirective' &&
			attribute.type !== 'BindDirective' &&
			attribute.type !== 'AttachTag'
		) {
			component_invalid_directive(attribute);
		}

		if (
			attribute.type === 'OnDirective' &&
			(attribute.modifiers.length > 1 || attribute.modifiers.some((m) => m !== 'once'))
		) {
			event_handler_invalid_component_modifier(attribute);
		}

		if (attribute.type === 'Attribute') {
			if (context.state.analysis.runes) {
				validate_attribute(attribute, node);

				if (is_expression_attribute(attribute)) {
					disallow_unparenthesized_sequences(
						get_attribute_expression(attribute),
						context.state.analysis.source
					);
				}
			}

			validate_attribute_name(attribute);

			if (attribute.name === 'slot') {
				validate_slot_attribute(context, attribute, true);
			}
		}

		if (attribute.type === 'BindDirective' && attribute.name !== 'this') {
			context.state.analysis.uses_component_bindings = true;
		}

		if (attribute.type === 'AttachTag') {
			disallow_unparenthesized_sequences(attribute.expression, context.state.analysis.source);
		}
	}

	// If the component has a slot attribute — `<Foo slot="whatever" .../>` —
	// then `let:` directives apply to other attributes, instead of just the
	// top-level contents of the component. Yes, this is very weird.
	const default_state = determine_slot(node)
		? context.state
		: { ...context.state, scope: node.metadata.scopes.default };

	for (const attribute of node.attributes) {
		context.visit(attribute, attribute.type === 'LetDirective' ? default_state : context.state);
	}

	/** @type {AST.Comment[]} */
	let comments = [];

	/** @type {Record<string, AST.Fragment['nodes']>} */
	const nodes = { default: [] };

	for (const child of node.fragment.nodes) {
		if (child.type === 'Comment') {
			comments.push(child);
			continue;
		}

		const slot_name = determine_slot(child) ?? 'default';
		(nodes[slot_name] ??= []).push(...comments, child);

		if (slot_name !== 'default') comments = [];
	}

	/** @type {Set<string>} */
	const component_slots = new Set();

	for (const slot_name in nodes) {
		/** @type {AnalysisState} */
		const state = {
			...context.state,
			scope: node.metadata.scopes[slot_name],
			parent_element: null,
			component_slots
		};

		context.visit({ ...node.fragment, nodes: nodes[slot_name] }, state);
	}
}

/**
 * @param {Expression} expression
 * @param {string} source
 */
function disallow_unparenthesized_sequences(expression, source) {
	if (expression.type === 'SequenceExpression') {
		let i = /** @type {number} */ (expression.start);
		while (--i > 0) {
			const char = source[i];
			if (char === '(') break; // parenthesized sequence expressions are ok
			if (char === '{') attribute_invalid_sequence_expression(expression);
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.Component} node
 * @param {Context} context
 */
function Component$2(node, context) {
	const binding = context.state.scope.get(
		node.name.includes('.') ? node.name.slice(0, node.name.indexOf('.')) : node.name
	);

	node.metadata.dynamic =
		context.state.analysis.runes && // Svelte 4 required you to use svelte:component to switch components
		binding !== null &&
		(binding.kind !== 'normal' || node.name.includes('.'));

	if (binding) {
		node.metadata.expression.has_state = node.metadata.dynamic;
		node.metadata.expression.dependencies.add(binding);
		node.metadata.expression.references.add(binding);
	}

	visit_component(node, context);
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.ConstTag} node
 * @param {Context} context
 */
function ConstTag$2(node, context) {
	if (context.state.analysis.runes) {
		validate_opening_tag(node, context.state, '@');
	}

	const parent = context.path.at(-1);
	const grand_parent = context.path.at(-2);

	if (
		parent?.type !== 'Fragment' ||
		(grand_parent?.type !== 'IfBlock' &&
			grand_parent?.type !== 'SvelteFragment' &&
			grand_parent?.type !== 'Component' &&
			grand_parent?.type !== 'SvelteComponent' &&
			grand_parent?.type !== 'EachBlock' &&
			grand_parent?.type !== 'AwaitBlock' &&
			grand_parent?.type !== 'SnippetBlock' &&
			grand_parent?.type !== 'SvelteBoundary' &&
			grand_parent?.type !== 'KeyBlock' &&
			((grand_parent?.type !== 'RegularElement' && grand_parent?.type !== 'SvelteElement') ||
				!grand_parent.attributes.some((a) => a.type === 'Attribute' && a.name === 'slot')))
	) {
		const_tag_invalid_placement(node);
	}

	const declaration = node.declaration.declarations[0];

	context.visit(declaration.id);
	context.visit(declaration.init, {
		...context.state,
		expression: node.metadata.expression,
		// We're treating this like a $derived under the hood
		function_depth: context.state.function_depth + 1,
		derived_function_depth: context.state.function_depth + 1
	});
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.DebugTag} node
 * @param {Context} context
 */
function DebugTag$2(node, context) {
	if (context.state.analysis.runes) {
		validate_opening_tag(node, context.state, '@');
	}

	context.next();
}

/** @import { Expression } from 'estree' */
/** @import { AST, Binding } from '#compiler' */
/** @import { Context } from '../types' */
/** @import { Scope } from '../../scope' */

/**
 * @param {AST.EachBlock} node
 * @param {Context} context
 */
function EachBlock$2(node, context) {
	validate_opening_tag(node, context.state, '#');

	validate_block_not_empty(node.body);
	validate_block_not_empty(node.fallback);

	const id = node.context;
	if (id?.type === 'Identifier' && (id.name === '$state' || id.name === '$derived')) {
		// TODO weird that this is necessary
		state_invalid_placement(node, id.name);
	}

	if (node.key) {
		// treat `{#each items as item, i (i)}` as a normal indexed block, everything else as keyed
		node.metadata.keyed =
			node.key.type !== 'Identifier' || !node.index || node.key.name !== node.index;
	}

	if (node.metadata.keyed && !node.context) {
		each_key_without_as(/** @type {Expression} */ (node.key));
	}

	// evaluate expression in parent scope
	context.visit(node.expression, {
		...context.state,
		expression: node.metadata.expression,
		scope: /** @type {Scope} */ (context.state.scope.parent)
	});

	context.visit(node.body);
	if (node.key) context.visit(node.key);
	if (node.fallback) context.visit(node.fallback);

	if (!context.state.analysis.runes) {
		let mutated =
			!!node.context &&
			extract_identifiers(node.context).some((id) => {
				const binding = context.state.scope.get(id.name);
				return !!binding?.mutated;
			});

		// collect transitive dependencies...
		for (const binding of node.metadata.expression.dependencies) {
			collect_transitive_dependencies(binding, node.metadata.transitive_deps);
		}

		// ...and ensure they are marked as state, so they can be turned
		// into mutable sources and invalidated
		if (mutated) {
			for (const binding of node.metadata.transitive_deps) {
				if (
					binding.kind === 'normal' &&
					(binding.declaration_kind === 'const' ||
						binding.declaration_kind === 'let' ||
						binding.declaration_kind === 'var')
				) {
					binding.kind = 'state';
				}
			}
		}
	}

	mark_subtree_dynamic(context.path);
}

/**
 * @param {Binding} binding
 * @param {Set<Binding>} bindings
 * @returns {void}
 */
function collect_transitive_dependencies(binding, bindings) {
	if (bindings.has(binding)) {
		return;
	}
	bindings.add(binding);

	if (binding.kind === 'legacy_reactive') {
		for (const dep of binding.legacy_dependencies) {
			collect_transitive_dependencies(dep, bindings);
		}
	}
}

/** @import { ExportDefaultDeclaration } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {ExportDefaultDeclaration} node
 * @param {Context} context
 */
function ExportDefaultDeclaration(node, context) {
	if (!context.state.ast_type /* .svelte.js module */) {
		if (node.declaration.type === 'Identifier') {
			validate_export(node, context.state.scope, node.declaration.name);
		}
	} else {
		module_illegal_default_export(node);
	}

	context.next();
}

/** @import { ExportNamedDeclaration, Identifier } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {ExportNamedDeclaration} node
 * @param {Context} context
 */
function ExportNamedDeclaration$1(node, context) {
	// visit children, so bindings are correctly initialised
	context.next();

	if (
		context.state.ast_type &&
		node.specifiers.some((specifier) =>
			specifier.exported.type === 'Identifier'
				? specifier.exported.name === 'default'
				: specifier.exported.value === 'default'
		)
	) {
		module_illegal_default_export(node);
	}

	if (node.declaration?.type === 'VariableDeclaration') {
		// in runes mode, forbid `export let`
		if (
			context.state.analysis.runes &&
			context.state.ast_type === 'instance' &&
			node.declaration.kind === 'let'
		) {
			legacy_export_invalid(node);
		}

		for (const declarator of node.declaration.declarations) {
			for (const id of extract_identifiers(declarator.id)) {
				const binding = context.state.scope.get(id.name);
				if (!binding) continue;

				if (binding.kind === 'derived') {
					derived_invalid_export(node);
				}

				if ((binding.kind === 'state' || binding.kind === 'raw_state') && binding.reassigned) {
					state_invalid_export(node);
				}
			}
		}
	}

	if (context.state.analysis.runes) {
		if (node.declaration && context.state.ast_type === 'instance') {
			if (
				node.declaration.type === 'FunctionDeclaration' ||
				node.declaration.type === 'ClassDeclaration'
			) {
				context.state.analysis.exports.push({
					name: /** @type {Identifier} */ (node.declaration.id).name,
					alias: null
				});
			} else if (node.declaration.kind === 'const') {
				for (const declarator of node.declaration.declarations) {
					for (const node of extract_identifiers(declarator.id)) {
						context.state.analysis.exports.push({ name: node.name, alias: null });
					}
				}
			}
		}
	}
}

/** @import { ExportSpecifier } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {ExportSpecifier} node
 * @param {Context} context
 */
function ExportSpecifier(node, context) {
	const local_name =
		node.local.type === 'Identifier' ? node.local.name : /** @type {string} */ (node.local.value);
	const exported_name =
		node.exported.type === 'Identifier'
			? node.exported.name
			: /** @type {string} */ (node.exported.value);

	if (context.state.ast_type === 'instance') {
		if (context.state.analysis.runes) {
			context.state.analysis.exports.push({
				name: local_name,
				alias: exported_name
			});

			const binding = context.state.scope.get(local_name);
			if (binding) binding.reassigned = true;
		}
	} else {
		validate_export(node, context.state.scope, local_name);
	}
}

/** @import { ExpressionStatement, ImportDeclaration } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {ExpressionStatement} node
 * @param {Context} context
 */
function ExpressionStatement$2(node, context) {
	// warn on `new Component({ target: ... })` if imported from a `.svelte` file
	if (
		node.expression.type === 'NewExpression' &&
		node.expression.callee.type === 'Identifier' &&
		node.expression.arguments.length === 1 &&
		node.expression.arguments[0].type === 'ObjectExpression' &&
		node.expression.arguments[0].properties.some(
			(p) => p.type === 'Property' && p.key.type === 'Identifier' && p.key.name === 'target'
		)
	) {
		const binding = context.state.scope.get(node.expression.callee.name);

		if (binding?.kind === 'normal' && binding.declaration_kind === 'import') {
			const declaration = /** @type {ImportDeclaration} */ (binding.initial);

			// Theoretically someone could import a class from a `.svelte.js` module, but that's too rare to worry about
			if (
				/** @type {string} */ (declaration.source.value).endsWith('.svelte') &&
				declaration.specifiers.find(
					(s) => s.local.name === binding.node.name && s.type === 'ImportDefaultSpecifier'
				)
			) {
				legacy_component_creation(node.expression);
			}
		}
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.ExpressionTag} node
 * @param {Context} context
 */
function ExpressionTag(node, context) {
	const in_template = context.path.at(-1)?.type === 'Fragment';

	if (in_template && context.state.parent_element) {
		const message = is_tag_valid_with_parent('#text', context.state.parent_element);
		if (message) {
			node_invalid_placement(node, message);
		}
	}

	// TODO ideally we wouldn't do this here, we'd just do it on encountering
	// an `Identifier` within the tag. But we currently need to handle `{42}` etc
	mark_subtree_dynamic(context.path);

	context.next({ ...context.state, expression: node.metadata.expression });
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types.js' */

/**
 * @param {AST.Fragment} node
 * @param {Context} context
 */
function Fragment$2(node, context) {
	context.next({ ...context.state, fragment: node });
}

/** @import { FunctionDeclaration } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {FunctionDeclaration} node
 * @param {Context} context
 */
function FunctionDeclaration$1(node, context) {
	if (context.state.analysis.runes && node.id !== null) {
		validate_identifier_name(context.state.scope.get(node.id.name));
	}

	visit_function$1(node, context);
}

/** @import { FunctionExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {FunctionExpression} node
 * @param {Context} context
 */
function FunctionExpression$1(node, context) {
	visit_function$1(node, context);
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.HtmlTag} node
 * @param {Context} context
 */
function HtmlTag$2(node, context) {
	if (context.state.analysis.runes) {
		validate_opening_tag(node, context.state, '@');
	}

	// unfortunately this is necessary in order to fix invalid HTML
	mark_subtree_dynamic(context.path);

	context.next({ ...context.state, expression: node.metadata.expression });
}

/** @import { BlockStatement, Expression, Identifier } from 'estree' */
/** @import { Binding } from '#compiler' */
/** @import { ClientTransformState, ComponentClientTransformState } from './types.js' */
/** @import { Analysis } from '../../types.js' */
/** @import { Scope } from '../../scope.js' */

/**
 * @param {Binding} binding
 * @param {Analysis} analysis
 * @returns {boolean}
 */
function is_state_source(binding, analysis) {
	return (
		(binding.kind === 'state' || binding.kind === 'raw_state') &&
		(!analysis.immutable || binding.reassigned || analysis.accessors)
	);
}

/**
 * @param {Identifier} node
 * @param {ClientTransformState} state
 * @returns {Expression}
 */
function build_getter$1(node, state) {
	if (Object.hasOwn(state.transform, node.name)) {
		const binding = state.scope.get(node.name);

		// don't transform the declaration itself
		if (node !== binding?.node) {
			return state.transform[node.name].read(node);
		}
	}

	return node;
}

/**
 * @param {Binding} binding
 * @param {ComponentClientTransformState} state
 * @param {string} name
 * @param {Expression | null} [initial]
 * @returns
 */
function get_prop_source(binding, state, name, initial) {
	/** @type {Expression[]} */
	const args = [id$2('$$props'), literal(name)];

	let flags = 0;

	if (binding.kind === 'bindable_prop') {
		flags |= PROPS_IS_BINDABLE;
	}

	if (state.analysis.immutable) {
		flags |= PROPS_IS_IMMUTABLE;
	}

	if (state.analysis.runes) {
		flags |= PROPS_IS_RUNES;
	}

	if (
		state.analysis.accessors ||
		(state.analysis.immutable
			? binding.reassigned || (state.analysis.runes && binding.mutated)
			: binding.updated)
	) {
		flags |= PROPS_IS_UPDATED;
	}

	/** @type {Expression | undefined} */
	let arg;

	if (initial) {
		// To avoid eagerly evaluating the right-hand-side, we wrap it in a thunk if necessary
		if (is_simple_expression(initial)) {
			arg = initial;
		} else {
			if (
				initial.type === 'CallExpression' &&
				initial.callee.type === 'Identifier' &&
				initial.arguments.length === 0
			) {
				arg = initial.callee;
			} else {
				arg = thunk(initial);
			}

			flags |= PROPS_IS_LAZY_INITIAL;
		}
	}

	if (flags || arg) {
		args.push(literal(flags));
		if (arg) args.push(arg);
	}

	return call('$.prop', ...args);
}

/**
 *
 * @param {Binding} binding
 * @param {ClientTransformState} state
 * @returns
 */
function is_prop_source(binding, state) {
	return (
		(binding.kind === 'prop' || binding.kind === 'bindable_prop') &&
		(!state.analysis.runes ||
			state.analysis.accessors ||
			binding.reassigned ||
			binding.initial ||
			// Until legacy mode is gone, we also need to use the prop source when only mutated is true,
			// because the parent could be a legacy component which needs coarse-grained reactivity
			binding.updated)
	);
}

/**
 * @param {Expression} node
 * @param {Scope | null} scope
 */
function should_proxy(node, scope) {
	if (
		!node ||
		node.type === 'Literal' ||
		node.type === 'TemplateLiteral' ||
		node.type === 'ArrowFunctionExpression' ||
		node.type === 'FunctionExpression' ||
		node.type === 'UnaryExpression' ||
		node.type === 'BinaryExpression' ||
		(node.type === 'Identifier' && node.name === 'undefined')
	) {
		return false;
	}

	if (node.type === 'Identifier' && scope !== null) {
		const binding = scope.get(node.name);
		// Let's see if the reference is something that can be proxied
		if (
			binding !== null &&
			!binding.reassigned &&
			binding.initial !== null &&
			binding.initial.type !== 'FunctionDeclaration' &&
			binding.initial.type !== 'ClassDeclaration' &&
			binding.initial.type !== 'ImportDeclaration' &&
			binding.initial.type !== 'EachBlock' &&
			binding.initial.type !== 'SnippetBlock'
		) {
			return should_proxy(binding.initial, null);
		}
	}

	return true;
}

/**
 * Svelte legacy mode should use safe equals in most places, runes mode shouldn't
 * @param {ComponentClientTransformState} state
 * @param {Expression | BlockStatement} expression
 * @param {boolean} [async]
 */
function create_derived(state, expression, async = false) {
	const thunk$1 = thunk(expression, async);

	if (async) {
		return save(call('$.async_derived', thunk$1));
	} else {
		return call(state.analysis.runes ? '$.derived' : '$.derived_safe_equal', thunk$1);
	}
}

/** @import { Expression, Identifier } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {Identifier} node
 * @param {Context} context
 */
function Identifier$2(node, context) {
	let i = context.path.length;
	let parent = /** @type {Expression} */ (context.path[--i]);

	if (!is_reference(node, parent)) {
		return;
	}

	mark_subtree_dynamic(context.path);

	// If we are using arguments outside of a function, then throw an error
	if (
		node.name === 'arguments' &&
		!context.path.some((n) => n.type === 'FunctionDeclaration' || n.type === 'FunctionExpression')
	) {
		invalid_arguments_usage(node);
	}

	// `$$slots` exists even in runes mode
	if (node.name === '$$slots') {
		context.state.analysis.uses_slots = true;
	}

	if (context.state.analysis.runes) {
		if (
			is_rune(node.name) &&
			context.state.scope.get(node.name) === null &&
			context.state.scope.get(node.name.slice(1))?.kind !== 'store_sub'
		) {
			/** @type {Expression} */
			let current = node;
			let name = node.name;

			while (parent.type === 'MemberExpression') {
				if (parent.computed) rune_invalid_computed_property(parent);
				name += `.${/** @type {Identifier} */ (parent.property).name}`;

				current = parent;
				parent = /** @type {Expression} */ (context.path[--i]);

				if (!is_rune(name)) {
					if (name === '$effect.active') {
						rune_renamed(parent, '$effect.active', '$effect.tracking');
					}

					if (name === '$state.frozen') {
						rune_renamed(parent, '$state.frozen', '$state.raw');
					}

					if (name === '$state.is') {
						rune_removed(parent, '$state.is');
					}

					rune_invalid_name(parent, name);
				}
			}

			if (parent.type !== 'CallExpression') {
				rune_missing_parentheses(current);
			}
		}
	}

	let binding = context.state.scope.get(node.name);

	if (!context.state.analysis.runes) {
		if (node.name === '$$props') {
			context.state.analysis.uses_props = true;
		}

		if (node.name === '$$restProps') {
			context.state.analysis.uses_rest_props = true;
		}
	}

	if (binding) {
		if (context.state.expression) {
			context.state.expression.dependencies.add(binding);
			context.state.expression.references.add(binding);
			context.state.expression.has_state ||=
				binding.kind !== 'static' &&
				(binding.kind === 'prop' ||
					binding.kind === 'bindable_prop' ||
					binding.kind === 'rest_prop' ||
					!binding.is_function()) &&
				!context.state.scope.evaluate(node).is_known;
		}

		if (
			context.state.analysis.runes &&
			node !== binding.node &&
			context.state.function_depth === binding.scope.function_depth &&
			// If we have $state that can be proxied or frozen and isn't re-assigned, then that means
			// it's likely not using a primitive value and thus this warning isn't that helpful.
			((binding.kind === 'state' &&
				(binding.reassigned ||
					(binding.initial?.type === 'CallExpression' &&
						binding.initial.arguments.length === 1 &&
						binding.initial.arguments[0].type !== 'SpreadElement' &&
						!should_proxy(binding.initial.arguments[0], context.state.scope)))) ||
				binding.kind === 'raw_state' ||
				binding.kind === 'derived' ||
				binding.kind === 'prop') &&
			// We're only concerned with reads here
			(parent.type !== 'AssignmentExpression' || parent.left !== node) &&
			parent.type !== 'UpdateExpression'
		) {
			let type = 'closure';

			let i = context.path.length;
			while (i--) {
				const parent = context.path[i];

				if (
					parent.type === 'ArrowFunctionExpression' ||
					parent.type === 'FunctionDeclaration' ||
					parent.type === 'FunctionExpression'
				) {
					break;
				}

				if (
					parent.type === 'CallExpression' &&
					parent.arguments.includes(/** @type {any} */ (context.path[i + 1]))
				) {
					const rune = get_rune(parent, context.state.scope);

					if (rune === '$state' || rune === '$state.raw') {
						type = 'derived';
						break;
					}
				}
			}

			state_referenced_locally(node, node.name, type);
		}

		if (
			context.state.reactive_statement &&
			binding.scope === context.state.analysis.module.scope &&
			binding.reassigned
		) {
			reactive_declaration_module_script_dependency(node);
		}

		if (binding.metadata?.is_template_declaration && context.state.options.experimental.async) {
			let snippet_name;

			// Find out if this references a {@const ...} declaration of an implicit children snippet
			// when it is itself inside a snippet block at the same level. If so, error.
			for (let i = context.path.length - 1; i >= 0; i--) {
				const parent = context.path[i];
				const grand_parent = context.path[i - 1];

				if (parent.type === 'SnippetBlock') {
					snippet_name = parent.expression.name;
				} else if (
					snippet_name &&
					grand_parent &&
					parent.type === 'Fragment' &&
					(is_component_node(grand_parent) ||
						(grand_parent.type === 'SvelteBoundary' &&
							(snippet_name === 'failed' || snippet_name === 'pending')))
				) {
					if (
						is_component_node(grand_parent)
							? grand_parent.metadata.scopes.default === binding.scope
							: context.state.scopes.get(parent) === binding.scope
					) {
						const_tag_invalid_reference(node, node.name);
					} else {
						break;
					}
				}
			}
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.IfBlock} node
 * @param {Context} context
 */
function IfBlock$2(node, context) {
	validate_block_not_empty(node.consequent);
	validate_block_not_empty(node.alternate);

	if (context.state.analysis.runes) {
		validate_opening_tag(node, context.state, node.elseif ? ':' : '#');
	}

	mark_subtree_dynamic(context.path);

	context.visit(node.test, {
		...context.state,
		expression: node.metadata.expression
	});

	context.visit(node.consequent);
	if (node.alternate) context.visit(node.alternate);
}

/** @import { ImportDeclaration } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {ImportDeclaration} node
 * @param {Context} context
 */
function ImportDeclaration(node, context) {
	if (context.state.analysis.runes) {
		const source = /** @type {string} */ (node.source.value);

		if (source.startsWith('svelte/internal')) {
			import_svelte_internal_forbidden(node);
		}

		if (source === 'svelte') {
			for (const specifier of node.specifiers) {
				if (specifier.type === 'ImportSpecifier') {
					if (
						specifier.imported.type === 'Identifier' &&
						(specifier.imported.name === 'beforeUpdate' ||
							specifier.imported.name === 'afterUpdate')
					) {
						runes_mode_invalid_import(specifier, specifier.imported.name);
					}
				}
			}
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.KeyBlock} node
 * @param {Context} context
 */
function KeyBlock$2(node, context) {
	validate_block_not_empty(node.fragment);

	if (context.state.analysis.runes) {
		validate_opening_tag(node, context.state, '#');
	}

	mark_subtree_dynamic(context.path);

	context.visit(node.expression, { ...context.state, expression: node.metadata.expression });
	context.visit(node.fragment);
}

/** @import { Expression, LabeledStatement } from 'estree' */
/** @import { AST, ReactiveStatement } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {LabeledStatement} node
 * @param {Context} context
 */
function LabeledStatement$2(node, context) {
	if (node.label.name === '$') {
		const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1));

		const is_reactive_statement =
			context.state.ast_type === 'instance' && parent.type === 'Program';

		if (is_reactive_statement) {
			if (context.state.analysis.runes) {
				legacy_reactive_statement_invalid(node);
			}

			// Find all dependencies of this `$: {...}` statement
			/** @type {ReactiveStatement} */
			const reactive_statement = {
				assignments: new Set(),
				dependencies: []
			};

			context.next({
				...context.state,
				reactive_statement,
				function_depth: context.state.scope.function_depth + 1
			});

			// Every referenced binding becomes a dependency, unless it's on
			// the left-hand side of an `=` assignment
			for (const [name, nodes] of context.state.scope.references) {
				const binding = context.state.scope.get(name);
				if (binding === null) continue;

				for (const { node, path } of nodes) {
					/** @type {Expression} */
					let left = node;

					let i = path.length - 1;
					let parent = /** @type {Expression} */ (path.at(i));
					while (parent.type === 'MemberExpression') {
						left = parent;
						parent = /** @type {Expression} */ (path.at(--i));
					}

					if (
						parent.type === 'AssignmentExpression' &&
						parent.operator === '=' &&
						parent.left === left
					) {
						continue;
					}

					reactive_statement.dependencies.push(binding);
					break;
				}
			}

			context.state.analysis.reactive_statements.set(node, reactive_statement);

			if (
				node.body.type === 'ExpressionStatement' &&
				node.body.expression.type === 'AssignmentExpression'
			) {
				let ids = extract_identifiers(node.body.expression.left);
				if (node.body.expression.left.type === 'MemberExpression') {
					const id = object$1(node.body.expression.left);
					if (id !== null) {
						ids = [id];
					}
				}

				for (const id of ids) {
					const binding = context.state.scope.get(id.name);
					if (binding?.kind === 'legacy_reactive') {
						// TODO does this include `let double; $: double = x * 2`?
						binding.legacy_dependencies = Array.from(reactive_statement.dependencies);
					}
				}
			}
		} else if (!context.state.analysis.runes) {
			reactive_declaration_invalid_placement(node);
		}
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.LetDirective} node
 * @param {Context} context
 */
function LetDirective$1(node, context) {
	const parent = context.path.at(-1);

	if (
		parent === undefined ||
		(parent.type !== 'Component' &&
			parent.type !== 'RegularElement' &&
			parent.type !== 'SlotElement' &&
			parent.type !== 'SvelteElement' &&
			parent.type !== 'SvelteComponent' &&
			parent.type !== 'SvelteSelf' &&
			parent.type !== 'SvelteFragment')
	) {
		let_directive_invalid_placement(node);
	}
}

/** @import { Literal } from 'estree' */

/**
 * @param {Literal} node
 */
function Literal(node) {
	if (typeof node.value === 'string') {
		if (regex_bidirectional_control_characters.test(node.value)) {
			bidirectional_control_characters(node);
		}
	}
}

/** @import { MemberExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {MemberExpression} node
 * @param {Context} context
 */
function MemberExpression$2(node, context) {
	if (node.object.type === 'Identifier' && node.property.type === 'Identifier') {
		const binding = context.state.scope.get(node.object.name);
		if (binding?.kind === 'rest_prop' && node.property.name.startsWith('$$')) {
			props_illegal_name(node.property);
		}
	}

	if (context.state.expression) {
		context.state.expression.has_member_expression = true;
		context.state.expression.has_state ||= !is_pure(node, context);
	}

	if (!is_safe_identifier(node, context.state.scope)) {
		context.state.analysis.needs_context = true;
	}

	context.next();
}

/** @import { NewExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {NewExpression} node
 * @param {Context} context
 */
function NewExpression(node, context) {
	if (node.callee.type === 'ClassExpression' && context.state.scope.function_depth > 0) {
		perf_avoid_inline_class(node);
	}

	context.state.analysis.needs_context = true;

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.OnDirective} node
 * @param {Context} context
 */
function OnDirective$1(node, context) {
	if (context.state.analysis.runes) {
		const parent_type = context.path.at(-1)?.type;

		// Don't warn on component events; these might not be under the author's control so the warning would be unactionable
		if (parent_type === 'RegularElement' || parent_type === 'SvelteElement') {
			event_directive_deprecated(node, node.name);
		}
	}

	const parent = context.path.at(-1);
	if (parent?.type === 'SvelteElement' || parent?.type === 'RegularElement') {
		context.state.analysis.event_directive_node ??= node;
	}

	mark_subtree_dynamic(context.path);

	context.next({ ...context.state, expression: node.metadata.expression });
}

/** @import { PropertyDefinition } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {PropertyDefinition} node
 * @param {Context} context
 */
function PropertyDefinition$1(node, context) {
	const name = get_name(node.key);
	const field = name && context.state.state_fields.get(name);

	if (field && node !== field.node && node.value) {
		if (/** @type {number} */ (node.start) < /** @type {number} */ (field.node.start)) {
			state_field_invalid_assignment(node);
		}
	}

	context.next();
}

var lib$2 = {};

var ariaPropsMap = {};

var iterationDecorator$1 = {};

var iteratorProxy$1 = {};

var hasRequiredIteratorProxy$1;

function requireIteratorProxy$1 () {
	if (hasRequiredIteratorProxy$1) return iteratorProxy$1;
	hasRequiredIteratorProxy$1 = 1;

	Object.defineProperty(iteratorProxy$1, "__esModule", {
	  value: true
	});
	iteratorProxy$1.default = void 0;
	// eslint-disable-next-line no-unused-vars
	function iteratorProxy() {
	  var values = this;
	  var index = 0;
	  var iter = {
	    '@@iterator': function iterator() {
	      return iter;
	    },
	    next: function next() {
	      if (index < values.length) {
	        var value = values[index];
	        index = index + 1;
	        return {
	          done: false,
	          value: value
	        };
	      } else {
	        return {
	          done: true
	        };
	      }
	    }
	  };
	  return iter;
	}
	iteratorProxy$1.default = iteratorProxy;
	return iteratorProxy$1;
}

var hasRequiredIterationDecorator$1;

function requireIterationDecorator$1 () {
	if (hasRequiredIterationDecorator$1) return iterationDecorator$1;
	hasRequiredIterationDecorator$1 = 1;

	Object.defineProperty(iterationDecorator$1, "__esModule", {
	  value: true
	});
	iterationDecorator$1.default = iterationDecorator;
	var _iteratorProxy = _interopRequireDefault(requireIteratorProxy$1());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function iterationDecorator(collection, entries) {
	  if (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol') {
	    Object.defineProperty(collection, Symbol.iterator, {
	      value: _iteratorProxy.default.bind(entries)
	    });
	  }
	  return collection;
	}
	return iterationDecorator$1;
}

var hasRequiredAriaPropsMap;

function requireAriaPropsMap () {
	if (hasRequiredAriaPropsMap) return ariaPropsMap;
	hasRequiredAriaPropsMap = 1;

	Object.defineProperty(ariaPropsMap, "__esModule", {
	  value: true
	});
	ariaPropsMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
	function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
	var properties = [['aria-activedescendant', {
	  'type': 'id'
	}], ['aria-atomic', {
	  'type': 'boolean'
	}], ['aria-autocomplete', {
	  'type': 'token',
	  'values': ['inline', 'list', 'both', 'none']
	}], ['aria-braillelabel', {
	  'type': 'string'
	}], ['aria-brailleroledescription', {
	  'type': 'string'
	}], ['aria-busy', {
	  'type': 'boolean'
	}], ['aria-checked', {
	  'type': 'tristate'
	}], ['aria-colcount', {
	  type: 'integer'
	}], ['aria-colindex', {
	  type: 'integer'
	}], ['aria-colspan', {
	  type: 'integer'
	}], ['aria-controls', {
	  'type': 'idlist'
	}], ['aria-current', {
	  type: 'token',
	  values: ['page', 'step', 'location', 'date', 'time', true, false]
	}], ['aria-describedby', {
	  'type': 'idlist'
	}], ['aria-description', {
	  'type': 'string'
	}], ['aria-details', {
	  'type': 'id'
	}], ['aria-disabled', {
	  'type': 'boolean'
	}], ['aria-dropeffect', {
	  'type': 'tokenlist',
	  'values': ['copy', 'execute', 'link', 'move', 'none', 'popup']
	}], ['aria-errormessage', {
	  'type': 'id'
	}], ['aria-expanded', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-flowto', {
	  'type': 'idlist'
	}], ['aria-grabbed', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-haspopup', {
	  'type': 'token',
	  'values': [false, true, 'menu', 'listbox', 'tree', 'grid', 'dialog']
	}], ['aria-hidden', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-invalid', {
	  'type': 'token',
	  'values': ['grammar', false, 'spelling', true]
	}], ['aria-keyshortcuts', {
	  type: 'string'
	}], ['aria-label', {
	  'type': 'string'
	}], ['aria-labelledby', {
	  'type': 'idlist'
	}], ['aria-level', {
	  'type': 'integer'
	}], ['aria-live', {
	  'type': 'token',
	  'values': ['assertive', 'off', 'polite']
	}], ['aria-modal', {
	  type: 'boolean'
	}], ['aria-multiline', {
	  'type': 'boolean'
	}], ['aria-multiselectable', {
	  'type': 'boolean'
	}], ['aria-orientation', {
	  'type': 'token',
	  'values': ['vertical', 'undefined', 'horizontal']
	}], ['aria-owns', {
	  'type': 'idlist'
	}], ['aria-placeholder', {
	  type: 'string'
	}], ['aria-posinset', {
	  'type': 'integer'
	}], ['aria-pressed', {
	  'type': 'tristate'
	}], ['aria-readonly', {
	  'type': 'boolean'
	}], ['aria-relevant', {
	  'type': 'tokenlist',
	  'values': ['additions', 'all', 'removals', 'text']
	}], ['aria-required', {
	  'type': 'boolean'
	}], ['aria-roledescription', {
	  type: 'string'
	}], ['aria-rowcount', {
	  type: 'integer'
	}], ['aria-rowindex', {
	  type: 'integer'
	}], ['aria-rowspan', {
	  type: 'integer'
	}], ['aria-selected', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-setsize', {
	  'type': 'integer'
	}], ['aria-sort', {
	  'type': 'token',
	  'values': ['ascending', 'descending', 'none', 'other']
	}], ['aria-valuemax', {
	  'type': 'number'
	}], ['aria-valuemin', {
	  'type': 'number'
	}], ['aria-valuenow', {
	  'type': 'number'
	}], ['aria-valuetext', {
	  'type': 'string'
	}]];
	var ariaPropsMap$1 = {
	  entries: function entries() {
	    return properties;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i = 0, _properties = properties; _i < _properties.length; _i++) {
	      var _properties$_i = _slicedToArray(_properties[_i], 2),
	        key = _properties$_i[0],
	        values = _properties$_i[1];
	      fn.call(thisArg, values, key, properties);
	    }
	  },
	  get: function get(key) {
	    var item = properties.filter(function (tuple) {
	      return tuple[0] === key ? true : false;
	    })[0];
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!ariaPropsMap$1.get(key);
	  },
	  keys: function keys() {
	    return properties.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return properties.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	ariaPropsMap.default = (0, _iterationDecorator.default)(ariaPropsMap$1, ariaPropsMap$1.entries());
	return ariaPropsMap;
}

var domMap = {};

var hasRequiredDomMap;

function requireDomMap () {
	if (hasRequiredDomMap) return domMap;
	hasRequiredDomMap = 1;

	Object.defineProperty(domMap, "__esModule", {
	  value: true
	});
	domMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
	function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
	var dom = [['a', {
	  reserved: false
	}], ['abbr', {
	  reserved: false
	}], ['acronym', {
	  reserved: false
	}], ['address', {
	  reserved: false
	}], ['applet', {
	  reserved: false
	}], ['area', {
	  reserved: false
	}], ['article', {
	  reserved: false
	}], ['aside', {
	  reserved: false
	}], ['audio', {
	  reserved: false
	}], ['b', {
	  reserved: false
	}], ['base', {
	  reserved: true
	}], ['bdi', {
	  reserved: false
	}], ['bdo', {
	  reserved: false
	}], ['big', {
	  reserved: false
	}], ['blink', {
	  reserved: false
	}], ['blockquote', {
	  reserved: false
	}], ['body', {
	  reserved: false
	}], ['br', {
	  reserved: false
	}], ['button', {
	  reserved: false
	}], ['canvas', {
	  reserved: false
	}], ['caption', {
	  reserved: false
	}], ['center', {
	  reserved: false
	}], ['cite', {
	  reserved: false
	}], ['code', {
	  reserved: false
	}], ['col', {
	  reserved: true
	}], ['colgroup', {
	  reserved: true
	}], ['content', {
	  reserved: false
	}], ['data', {
	  reserved: false
	}], ['datalist', {
	  reserved: false
	}], ['dd', {
	  reserved: false
	}], ['del', {
	  reserved: false
	}], ['details', {
	  reserved: false
	}], ['dfn', {
	  reserved: false
	}], ['dialog', {
	  reserved: false
	}], ['dir', {
	  reserved: false
	}], ['div', {
	  reserved: false
	}], ['dl', {
	  reserved: false
	}], ['dt', {
	  reserved: false
	}], ['em', {
	  reserved: false
	}], ['embed', {
	  reserved: false
	}], ['fieldset', {
	  reserved: false
	}], ['figcaption', {
	  reserved: false
	}], ['figure', {
	  reserved: false
	}], ['font', {
	  reserved: false
	}], ['footer', {
	  reserved: false
	}], ['form', {
	  reserved: false
	}], ['frame', {
	  reserved: false
	}], ['frameset', {
	  reserved: false
	}], ['h1', {
	  reserved: false
	}], ['h2', {
	  reserved: false
	}], ['h3', {
	  reserved: false
	}], ['h4', {
	  reserved: false
	}], ['h5', {
	  reserved: false
	}], ['h6', {
	  reserved: false
	}], ['head', {
	  reserved: true
	}], ['header', {
	  reserved: false
	}], ['hgroup', {
	  reserved: false
	}], ['hr', {
	  reserved: false
	}], ['html', {
	  reserved: true
	}], ['i', {
	  reserved: false
	}], ['iframe', {
	  reserved: false
	}], ['img', {
	  reserved: false
	}], ['input', {
	  reserved: false
	}], ['ins', {
	  reserved: false
	}], ['kbd', {
	  reserved: false
	}], ['keygen', {
	  reserved: false
	}], ['label', {
	  reserved: false
	}], ['legend', {
	  reserved: false
	}], ['li', {
	  reserved: false
	}], ['link', {
	  reserved: true
	}], ['main', {
	  reserved: false
	}], ['map', {
	  reserved: false
	}], ['mark', {
	  reserved: false
	}], ['marquee', {
	  reserved: false
	}], ['menu', {
	  reserved: false
	}], ['menuitem', {
	  reserved: false
	}], ['meta', {
	  reserved: true
	}], ['meter', {
	  reserved: false
	}], ['nav', {
	  reserved: false
	}], ['noembed', {
	  reserved: true
	}], ['noscript', {
	  reserved: true
	}], ['object', {
	  reserved: false
	}], ['ol', {
	  reserved: false
	}], ['optgroup', {
	  reserved: false
	}], ['option', {
	  reserved: false
	}], ['output', {
	  reserved: false
	}], ['p', {
	  reserved: false
	}], ['param', {
	  reserved: true
	}], ['picture', {
	  reserved: true
	}], ['pre', {
	  reserved: false
	}], ['progress', {
	  reserved: false
	}], ['q', {
	  reserved: false
	}], ['rp', {
	  reserved: false
	}], ['rt', {
	  reserved: false
	}], ['rtc', {
	  reserved: false
	}], ['ruby', {
	  reserved: false
	}], ['s', {
	  reserved: false
	}], ['samp', {
	  reserved: false
	}], ['script', {
	  reserved: true
	}], ['section', {
	  reserved: false
	}], ['select', {
	  reserved: false
	}], ['small', {
	  reserved: false
	}], ['source', {
	  reserved: true
	}], ['spacer', {
	  reserved: false
	}], ['span', {
	  reserved: false
	}], ['strike', {
	  reserved: false
	}], ['strong', {
	  reserved: false
	}], ['style', {
	  reserved: true
	}], ['sub', {
	  reserved: false
	}], ['summary', {
	  reserved: false
	}], ['sup', {
	  reserved: false
	}], ['table', {
	  reserved: false
	}], ['tbody', {
	  reserved: false
	}], ['td', {
	  reserved: false
	}], ['textarea', {
	  reserved: false
	}], ['tfoot', {
	  reserved: false
	}], ['th', {
	  reserved: false
	}], ['thead', {
	  reserved: false
	}], ['time', {
	  reserved: false
	}], ['title', {
	  reserved: true
	}], ['tr', {
	  reserved: false
	}], ['track', {
	  reserved: true
	}], ['tt', {
	  reserved: false
	}], ['u', {
	  reserved: false
	}], ['ul', {
	  reserved: false
	}], ['var', {
	  reserved: false
	}], ['video', {
	  reserved: false
	}], ['wbr', {
	  reserved: false
	}], ['xmp', {
	  reserved: false
	}]];
	var domMap$1 = {
	  entries: function entries() {
	    return dom;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i = 0, _dom = dom; _i < _dom.length; _i++) {
	      var _dom$_i = _slicedToArray(_dom[_i], 2),
	        key = _dom$_i[0],
	        values = _dom$_i[1];
	      fn.call(thisArg, values, key, dom);
	    }
	  },
	  get: function get(key) {
	    var item = dom.filter(function (tuple) {
	      return tuple[0] === key ? true : false;
	    })[0];
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!domMap$1.get(key);
	  },
	  keys: function keys() {
	    return dom.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return dom.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	domMap.default = (0, _iterationDecorator.default)(domMap$1, domMap$1.entries());
	return domMap;
}

var rolesMap = {};

var ariaAbstractRoles = {};

var commandRole = {};

var hasRequiredCommandRole;

function requireCommandRole () {
	if (hasRequiredCommandRole) return commandRole;
	hasRequiredCommandRole = 1;

	Object.defineProperty(commandRole, "__esModule", {
	  value: true
	});
	commandRole.default = void 0;
	var commandRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget']]
	};
	commandRole.default = commandRole$1;
	return commandRole;
}

var compositeRole = {};

var hasRequiredCompositeRole;

function requireCompositeRole () {
	if (hasRequiredCompositeRole) return compositeRole;
	hasRequiredCompositeRole = 1;

	Object.defineProperty(compositeRole, "__esModule", {
	  value: true
	});
	compositeRole.default = void 0;
	var compositeRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-disabled': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget']]
	};
	compositeRole.default = compositeRole$1;
	return compositeRole;
}

var inputRole = {};

var hasRequiredInputRole;

function requireInputRole () {
	if (hasRequiredInputRole) return inputRole;
	hasRequiredInputRole = 1;

	Object.defineProperty(inputRole, "__esModule", {
	  value: true
	});
	inputRole.default = void 0;
	var inputRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'input'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget']]
	};
	inputRole.default = inputRole$1;
	return inputRole;
}

var landmarkRole = {};

var hasRequiredLandmarkRole;

function requireLandmarkRole () {
	if (hasRequiredLandmarkRole) return landmarkRole;
	hasRequiredLandmarkRole = 1;

	Object.defineProperty(landmarkRole, "__esModule", {
	  value: true
	});
	landmarkRole.default = void 0;
	var landmarkRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	landmarkRole.default = landmarkRole$1;
	return landmarkRole;
}

var rangeRole = {};

var hasRequiredRangeRole;

function requireRangeRole () {
	if (hasRequiredRangeRole) return rangeRole;
	hasRequiredRangeRole = 1;

	Object.defineProperty(rangeRole, "__esModule", {
	  value: true
	});
	rangeRole.default = void 0;
	var rangeRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-valuemax': null,
	    'aria-valuemin': null,
	    'aria-valuenow': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	rangeRole.default = rangeRole$1;
	return rangeRole;
}

var roletypeRole = {};

var hasRequiredRoletypeRole;

function requireRoletypeRole () {
	if (hasRequiredRoletypeRole) return roletypeRole;
	hasRequiredRoletypeRole = 1;

	Object.defineProperty(roletypeRole, "__esModule", {
	  value: true
	});
	roletypeRole.default = void 0;
	var roletypeRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {
	    'aria-atomic': null,
	    'aria-busy': null,
	    'aria-controls': null,
	    'aria-current': null,
	    'aria-describedby': null,
	    'aria-details': null,
	    'aria-dropeffect': null,
	    'aria-flowto': null,
	    'aria-grabbed': null,
	    'aria-hidden': null,
	    'aria-keyshortcuts': null,
	    'aria-label': null,
	    'aria-labelledby': null,
	    'aria-live': null,
	    'aria-owns': null,
	    'aria-relevant': null,
	    'aria-roledescription': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'role'
	    },
	    module: 'XHTML'
	  }, {
	    concept: {
	      name: 'type'
	    },
	    module: 'Dublin Core'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: []
	};
	roletypeRole.default = roletypeRole$1;
	return roletypeRole;
}

var sectionRole = {};

var hasRequiredSectionRole;

function requireSectionRole () {
	if (hasRequiredSectionRole) return sectionRole;
	hasRequiredSectionRole = 1;

	Object.defineProperty(sectionRole, "__esModule", {
	  value: true
	});
	sectionRole.default = void 0;
	var sectionRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'frontmatter'
	    },
	    module: 'DTB'
	  }, {
	    concept: {
	      name: 'level'
	    },
	    module: 'DTB'
	  }, {
	    concept: {
	      name: 'level'
	    },
	    module: 'SMIL'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	sectionRole.default = sectionRole$1;
	return sectionRole;
}

var sectionheadRole = {};

var hasRequiredSectionheadRole;

function requireSectionheadRole () {
	if (hasRequiredSectionheadRole) return sectionheadRole;
	hasRequiredSectionheadRole = 1;

	Object.defineProperty(sectionheadRole, "__esModule", {
	  value: true
	});
	sectionheadRole.default = void 0;
	var sectionheadRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	sectionheadRole.default = sectionheadRole$1;
	return sectionheadRole;
}

var selectRole = {};

var hasRequiredSelectRole;

function requireSelectRole () {
	if (hasRequiredSelectRole) return selectRole;
	hasRequiredSelectRole = 1;

	Object.defineProperty(selectRole, "__esModule", {
	  value: true
	});
	selectRole.default = void 0;
	var selectRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite'], ['roletype', 'structure', 'section', 'group']]
	};
	selectRole.default = selectRole$1;
	return selectRole;
}

var structureRole = {};

var hasRequiredStructureRole;

function requireStructureRole () {
	if (hasRequiredStructureRole) return structureRole;
	hasRequiredStructureRole = 1;

	Object.defineProperty(structureRole, "__esModule", {
	  value: true
	});
	structureRole.default = void 0;
	var structureRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype']]
	};
	structureRole.default = structureRole$1;
	return structureRole;
}

var widgetRole = {};

var hasRequiredWidgetRole;

function requireWidgetRole () {
	if (hasRequiredWidgetRole) return widgetRole;
	hasRequiredWidgetRole = 1;

	Object.defineProperty(widgetRole, "__esModule", {
	  value: true
	});
	widgetRole.default = void 0;
	var widgetRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype']]
	};
	widgetRole.default = widgetRole$1;
	return widgetRole;
}

var windowRole = {};

var hasRequiredWindowRole$1;

function requireWindowRole$1 () {
	if (hasRequiredWindowRole$1) return windowRole;
	hasRequiredWindowRole$1 = 1;

	Object.defineProperty(windowRole, "__esModule", {
	  value: true
	});
	windowRole.default = void 0;
	var windowRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-modal': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype']]
	};
	windowRole.default = windowRole$1;
	return windowRole;
}

var hasRequiredAriaAbstractRoles;

function requireAriaAbstractRoles () {
	if (hasRequiredAriaAbstractRoles) return ariaAbstractRoles;
	hasRequiredAriaAbstractRoles = 1;

	Object.defineProperty(ariaAbstractRoles, "__esModule", {
	  value: true
	});
	ariaAbstractRoles.default = void 0;
	var _commandRole = _interopRequireDefault(requireCommandRole());
	var _compositeRole = _interopRequireDefault(requireCompositeRole());
	var _inputRole = _interopRequireDefault(requireInputRole());
	var _landmarkRole = _interopRequireDefault(requireLandmarkRole());
	var _rangeRole = _interopRequireDefault(requireRangeRole());
	var _roletypeRole = _interopRequireDefault(requireRoletypeRole());
	var _sectionRole = _interopRequireDefault(requireSectionRole());
	var _sectionheadRole = _interopRequireDefault(requireSectionheadRole());
	var _selectRole = _interopRequireDefault(requireSelectRole());
	var _structureRole = _interopRequireDefault(requireStructureRole());
	var _widgetRole = _interopRequireDefault(requireWidgetRole());
	var _windowRole = _interopRequireDefault(requireWindowRole$1());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	var ariaAbstractRoles$1 = [['command', _commandRole.default], ['composite', _compositeRole.default], ['input', _inputRole.default], ['landmark', _landmarkRole.default], ['range', _rangeRole.default], ['roletype', _roletypeRole.default], ['section', _sectionRole.default], ['sectionhead', _sectionheadRole.default], ['select', _selectRole.default], ['structure', _structureRole.default], ['widget', _widgetRole.default], ['window', _windowRole.default]];
	ariaAbstractRoles.default = ariaAbstractRoles$1;
	return ariaAbstractRoles;
}

var ariaLiteralRoles = {};

var alertRole = {};

var hasRequiredAlertRole$1;

function requireAlertRole$1 () {
	if (hasRequiredAlertRole$1) return alertRole;
	hasRequiredAlertRole$1 = 1;

	Object.defineProperty(alertRole, "__esModule", {
	  value: true
	});
	alertRole.default = void 0;
	var alertRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-atomic': 'true',
	    'aria-live': 'assertive'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'alert'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	alertRole.default = alertRole$1;
	return alertRole;
}

var alertdialogRole = {};

var hasRequiredAlertdialogRole;

function requireAlertdialogRole () {
	if (hasRequiredAlertdialogRole) return alertdialogRole;
	hasRequiredAlertdialogRole = 1;

	Object.defineProperty(alertdialogRole, "__esModule", {
	  value: true
	});
	alertdialogRole.default = void 0;
	var alertdialogRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'alert'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'alert'], ['roletype', 'window', 'dialog']]
	};
	alertdialogRole.default = alertdialogRole$1;
	return alertdialogRole;
}

var applicationRole = {};

var hasRequiredApplicationRole$1;

function requireApplicationRole$1 () {
	if (hasRequiredApplicationRole$1) return applicationRole;
	hasRequiredApplicationRole$1 = 1;

	Object.defineProperty(applicationRole, "__esModule", {
	  value: true
	});
	applicationRole.default = void 0;
	var applicationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'Device Independence Delivery Unit'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	applicationRole.default = applicationRole$1;
	return applicationRole;
}

var articleRole = {};

var hasRequiredArticleRole$1;

function requireArticleRole$1 () {
	if (hasRequiredArticleRole$1) return articleRole;
	hasRequiredArticleRole$1 = 1;

	Object.defineProperty(articleRole, "__esModule", {
	  value: true
	});
	articleRole.default = void 0;
	var articleRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'article'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'document']]
	};
	articleRole.default = articleRole$1;
	return articleRole;
}

var bannerRole = {};

var hasRequiredBannerRole$1;

function requireBannerRole$1 () {
	if (hasRequiredBannerRole$1) return bannerRole;
	hasRequiredBannerRole$1 = 1;

	Object.defineProperty(bannerRole, "__esModule", {
	  value: true
	});
	bannerRole.default = void 0;
	var bannerRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      constraints: ['scoped to the body element'],
	      name: 'header'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	bannerRole.default = bannerRole$1;
	return bannerRole;
}

var blockquoteRole = {};

var hasRequiredBlockquoteRole$1;

function requireBlockquoteRole$1 () {
	if (hasRequiredBlockquoteRole$1) return blockquoteRole;
	hasRequiredBlockquoteRole$1 = 1;

	Object.defineProperty(blockquoteRole, "__esModule", {
	  value: true
	});
	blockquoteRole.default = void 0;
	var blockquoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'blockquote'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	blockquoteRole.default = blockquoteRole$1;
	return blockquoteRole;
}

var buttonRole = {};

var hasRequiredButtonRole$1;

function requireButtonRole$1 () {
	if (hasRequiredButtonRole$1) return buttonRole;
	hasRequiredButtonRole$1 = 1;

	Object.defineProperty(buttonRole, "__esModule", {
	  value: true
	});
	buttonRole.default = void 0;
	var buttonRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-pressed': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'button'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'image'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'reset'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'submit'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'button'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'trigger'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command']]
	};
	buttonRole.default = buttonRole$1;
	return buttonRole;
}

var captionRole = {};

var hasRequiredCaptionRole$1;

function requireCaptionRole$1 () {
	if (hasRequiredCaptionRole$1) return captionRole;
	hasRequiredCaptionRole$1 = 1;

	Object.defineProperty(captionRole, "__esModule", {
	  value: true
	});
	captionRole.default = void 0;
	var captionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'caption'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['figure', 'grid', 'table'],
	  requiredContextRole: ['figure', 'grid', 'table'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	captionRole.default = captionRole$1;
	return captionRole;
}

var cellRole = {};

var hasRequiredCellRole$1;

function requireCellRole$1 () {
	if (hasRequiredCellRole$1) return cellRole;
	hasRequiredCellRole$1 = 1;

	Object.defineProperty(cellRole, "__esModule", {
	  value: true
	});
	cellRole.default = void 0;
	var cellRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-colindex': null,
	    'aria-colspan': null,
	    'aria-rowindex': null,
	    'aria-rowspan': null
	  },
	  relatedConcepts: [{
	    concept: {
	      constraints: ['ancestor table element has table role'],
	      name: 'td'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row'],
	  requiredContextRole: ['row'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	cellRole.default = cellRole$1;
	return cellRole;
}

var checkboxRole = {};

var hasRequiredCheckboxRole;

function requireCheckboxRole () {
	if (hasRequiredCheckboxRole) return checkboxRole;
	hasRequiredCheckboxRole = 1;

	Object.defineProperty(checkboxRole, "__esModule", {
	  value: true
	});
	checkboxRole.default = void 0;
	var checkboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-checked': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'checkbox'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'option'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	checkboxRole.default = checkboxRole$1;
	return checkboxRole;
}

var codeRole = {};

var hasRequiredCodeRole;

function requireCodeRole () {
	if (hasRequiredCodeRole) return codeRole;
	hasRequiredCodeRole = 1;

	Object.defineProperty(codeRole, "__esModule", {
	  value: true
	});
	codeRole.default = void 0;
	var codeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'code'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	codeRole.default = codeRole$1;
	return codeRole;
}

var columnheaderRole = {};

var hasRequiredColumnheaderRole;

function requireColumnheaderRole () {
	if (hasRequiredColumnheaderRole) return columnheaderRole;
	hasRequiredColumnheaderRole = 1;

	Object.defineProperty(columnheaderRole, "__esModule", {
	  value: true
	});
	columnheaderRole.default = void 0;
	var columnheaderRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-sort': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'th'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'col'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'colgroup'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row'],
	  requiredContextRole: ['row'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'structure', 'section', 'cell', 'gridcell'], ['roletype', 'widget', 'gridcell'], ['roletype', 'structure', 'sectionhead']]
	};
	columnheaderRole.default = columnheaderRole$1;
	return columnheaderRole;
}

var comboboxRole = {};

var hasRequiredComboboxRole;

function requireComboboxRole () {
	if (hasRequiredComboboxRole) return comboboxRole;
	hasRequiredComboboxRole = 1;

	Object.defineProperty(comboboxRole, "__esModule", {
	  value: true
	});
	comboboxRole.default = void 0;
	var comboboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-autocomplete': null,
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-expanded': 'false',
	    'aria-haspopup': 'listbox'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'email'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'search'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'tel'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'text'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'url'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'url'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'multiple'
	      }, {
	        constraints: ['undefined'],
	        name: 'size'
	      }],
	      constraints: ['the multiple attribute is not set and the size attribute does not have a value greater than 1'],
	      name: 'select'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'select'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-controls': null,
	    'aria-expanded': 'false'
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	comboboxRole.default = comboboxRole$1;
	return comboboxRole;
}

var complementaryRole = {};

var hasRequiredComplementaryRole$1;

function requireComplementaryRole$1 () {
	if (hasRequiredComplementaryRole$1) return complementaryRole;
	hasRequiredComplementaryRole$1 = 1;

	Object.defineProperty(complementaryRole, "__esModule", {
	  value: true
	});
	complementaryRole.default = void 0;
	var complementaryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      constraints: ['scoped to the body element', 'scoped to the main element'],
	      name: 'aside'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-label'
	      }],
	      constraints: ['scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'aside'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-labelledby'
	      }],
	      constraints: ['scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'aside'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	complementaryRole.default = complementaryRole$1;
	return complementaryRole;
}

var contentinfoRole = {};

var hasRequiredContentinfoRole;

function requireContentinfoRole () {
	if (hasRequiredContentinfoRole) return contentinfoRole;
	hasRequiredContentinfoRole = 1;

	Object.defineProperty(contentinfoRole, "__esModule", {
	  value: true
	});
	contentinfoRole.default = void 0;
	var contentinfoRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      constraints: ['scoped to the body element'],
	      name: 'footer'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	contentinfoRole.default = contentinfoRole$1;
	return contentinfoRole;
}

var definitionRole = {};

var hasRequiredDefinitionRole$1;

function requireDefinitionRole$1 () {
	if (hasRequiredDefinitionRole$1) return definitionRole;
	hasRequiredDefinitionRole$1 = 1;

	Object.defineProperty(definitionRole, "__esModule", {
	  value: true
	});
	definitionRole.default = void 0;
	var definitionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'dd'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	definitionRole.default = definitionRole$1;
	return definitionRole;
}

var deletionRole = {};

var hasRequiredDeletionRole;

function requireDeletionRole () {
	if (hasRequiredDeletionRole) return deletionRole;
	hasRequiredDeletionRole = 1;

	Object.defineProperty(deletionRole, "__esModule", {
	  value: true
	});
	deletionRole.default = void 0;
	var deletionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'del'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	deletionRole.default = deletionRole$1;
	return deletionRole;
}

var dialogRole = {};

var hasRequiredDialogRole$1;

function requireDialogRole$1 () {
	if (hasRequiredDialogRole$1) return dialogRole;
	hasRequiredDialogRole$1 = 1;

	Object.defineProperty(dialogRole, "__esModule", {
	  value: true
	});
	dialogRole.default = void 0;
	var dialogRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'dialog'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'window']]
	};
	dialogRole.default = dialogRole$1;
	return dialogRole;
}

var directoryRole = {};

var hasRequiredDirectoryRole$1;

function requireDirectoryRole$1 () {
	if (hasRequiredDirectoryRole$1) return directoryRole;
	hasRequiredDirectoryRole$1 = 1;

	Object.defineProperty(directoryRole, "__esModule", {
	  value: true
	});
	directoryRole.default = void 0;
	var directoryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    module: 'DAISY Guide'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'list']]
	};
	directoryRole.default = directoryRole$1;
	return directoryRole;
}

var documentRole = {};

var hasRequiredDocumentRole$1;

function requireDocumentRole$1 () {
	if (hasRequiredDocumentRole$1) return documentRole;
	hasRequiredDocumentRole$1 = 1;

	Object.defineProperty(documentRole, "__esModule", {
	  value: true
	});
	documentRole.default = void 0;
	var documentRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'Device Independence Delivery Unit'
	    }
	  }, {
	    concept: {
	      name: 'html'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	documentRole.default = documentRole$1;
	return documentRole;
}

var emphasisRole = {};

var hasRequiredEmphasisRole;

function requireEmphasisRole () {
	if (hasRequiredEmphasisRole) return emphasisRole;
	hasRequiredEmphasisRole = 1;

	Object.defineProperty(emphasisRole, "__esModule", {
	  value: true
	});
	emphasisRole.default = void 0;
	var emphasisRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'em'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	emphasisRole.default = emphasisRole$1;
	return emphasisRole;
}

var feedRole = {};

var hasRequiredFeedRole$1;

function requireFeedRole$1 () {
	if (hasRequiredFeedRole$1) return feedRole;
	hasRequiredFeedRole$1 = 1;

	Object.defineProperty(feedRole, "__esModule", {
	  value: true
	});
	feedRole.default = void 0;
	var feedRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['article']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'list']]
	};
	feedRole.default = feedRole$1;
	return feedRole;
}

var figureRole = {};

var hasRequiredFigureRole$1;

function requireFigureRole$1 () {
	if (hasRequiredFigureRole$1) return figureRole;
	hasRequiredFigureRole$1 = 1;

	Object.defineProperty(figureRole, "__esModule", {
	  value: true
	});
	figureRole.default = void 0;
	var figureRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'figure'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	figureRole.default = figureRole$1;
	return figureRole;
}

var formRole = {};

var hasRequiredFormRole$1;

function requireFormRole$1 () {
	if (hasRequiredFormRole$1) return formRole;
	hasRequiredFormRole$1 = 1;

	Object.defineProperty(formRole, "__esModule", {
	  value: true
	});
	formRole.default = void 0;
	var formRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-label'
	      }],
	      name: 'form'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-labelledby'
	      }],
	      name: 'form'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'name'
	      }],
	      name: 'form'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	formRole.default = formRole$1;
	return formRole;
}

var genericRole = {};

var hasRequiredGenericRole;

function requireGenericRole () {
	if (hasRequiredGenericRole) return genericRole;
	hasRequiredGenericRole = 1;

	Object.defineProperty(genericRole, "__esModule", {
	  value: true
	});
	genericRole.default = void 0;
	var genericRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'a'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'area'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'aside'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'b'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'bdo'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'body'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'data'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'div'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      constraints: ['scoped to the main element', 'scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'footer'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      constraints: ['scoped to the main element', 'scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'header'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'hgroup'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'i'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'pre'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'q'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'samp'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'section'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'small'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'span'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'u'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	genericRole.default = genericRole$1;
	return genericRole;
}

var gridRole = {};

var hasRequiredGridRole$1;

function requireGridRole$1 () {
	if (hasRequiredGridRole$1) return gridRole;
	hasRequiredGridRole$1 = 1;

	Object.defineProperty(gridRole, "__esModule", {
	  value: true
	});
	gridRole.default = void 0;
	var gridRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-multiselectable': null,
	    'aria-readonly': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['row'], ['row', 'rowgroup']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite'], ['roletype', 'structure', 'section', 'table']]
	};
	gridRole.default = gridRole$1;
	return gridRole;
}

var gridcellRole = {};

var hasRequiredGridcellRole;

function requireGridcellRole () {
	if (hasRequiredGridcellRole) return gridcellRole;
	hasRequiredGridcellRole = 1;

	Object.defineProperty(gridcellRole, "__esModule", {
	  value: true
	});
	gridcellRole.default = void 0;
	var gridcellRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-selected': null
	  },
	  relatedConcepts: [{
	    concept: {
	      constraints: ['ancestor table element has grid role', 'ancestor table element has treegrid role'],
	      name: 'td'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row'],
	  requiredContextRole: ['row'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'widget']]
	};
	gridcellRole.default = gridcellRole$1;
	return gridcellRole;
}

var groupRole = {};

var hasRequiredGroupRole$1;

function requireGroupRole$1 () {
	if (hasRequiredGroupRole$1) return groupRole;
	hasRequiredGroupRole$1 = 1;

	Object.defineProperty(groupRole, "__esModule", {
	  value: true
	});
	groupRole.default = void 0;
	var groupRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-disabled': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'details'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'fieldset'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'optgroup'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'address'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	groupRole.default = groupRole$1;
	return groupRole;
}

var headingRole = {};

var hasRequiredHeadingRole$1;

function requireHeadingRole$1 () {
	if (hasRequiredHeadingRole$1) return headingRole;
	hasRequiredHeadingRole$1 = 1;

	Object.defineProperty(headingRole, "__esModule", {
	  value: true
	});
	headingRole.default = void 0;
	var headingRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-level': '2'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'h1'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h2'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h3'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h4'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h5'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h6'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-level': '2'
	  },
	  superClass: [['roletype', 'structure', 'sectionhead']]
	};
	headingRole.default = headingRole$1;
	return headingRole;
}

var imgRole = {};

var hasRequiredImgRole;

function requireImgRole () {
	if (hasRequiredImgRole) return imgRole;
	hasRequiredImgRole = 1;

	Object.defineProperty(imgRole, "__esModule", {
	  value: true
	});
	imgRole.default = void 0;
	var imgRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'alt'
	      }],
	      name: 'img'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'alt'
	      }],
	      name: 'img'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'imggroup'
	    },
	    module: 'DTB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	imgRole.default = imgRole$1;
	return imgRole;
}

var insertionRole = {};

var hasRequiredInsertionRole;

function requireInsertionRole () {
	if (hasRequiredInsertionRole) return insertionRole;
	hasRequiredInsertionRole = 1;

	Object.defineProperty(insertionRole, "__esModule", {
	  value: true
	});
	insertionRole.default = void 0;
	var insertionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'ins'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	insertionRole.default = insertionRole$1;
	return insertionRole;
}

var linkRole = {};

var hasRequiredLinkRole$1;

function requireLinkRole$1 () {
	if (hasRequiredLinkRole$1) return linkRole;
	hasRequiredLinkRole$1 = 1;

	Object.defineProperty(linkRole, "__esModule", {
	  value: true
	});
	linkRole.default = void 0;
	var linkRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'href'
	      }],
	      name: 'a'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'href'
	      }],
	      name: 'area'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command']]
	};
	linkRole.default = linkRole$1;
	return linkRole;
}

var listRole = {};

var hasRequiredListRole$1;

function requireListRole$1 () {
	if (hasRequiredListRole$1) return listRole;
	hasRequiredListRole$1 = 1;

	Object.defineProperty(listRole, "__esModule", {
	  value: true
	});
	listRole.default = void 0;
	var listRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'menu'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'ol'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'ul'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['listitem']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	listRole.default = listRole$1;
	return listRole;
}

var listboxRole = {};

var hasRequiredListboxRole;

function requireListboxRole () {
	if (hasRequiredListboxRole) return listboxRole;
	hasRequiredListboxRole = 1;

	Object.defineProperty(listboxRole, "__esModule", {
	  value: true
	});
	listboxRole.default = void 0;
	var listboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-invalid': null,
	    'aria-multiselectable': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-orientation': 'vertical'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['>1'],
	        name: 'size'
	      }],
	      constraints: ['the size attribute value is greater than 1'],
	      name: 'select'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'multiple'
	      }],
	      name: 'select'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'datalist'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'list'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'select'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['option', 'group'], ['option']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	listboxRole.default = listboxRole$1;
	return listboxRole;
}

var listitemRole = {};

var hasRequiredListitemRole;

function requireListitemRole () {
	if (hasRequiredListitemRole) return listitemRole;
	hasRequiredListitemRole = 1;

	Object.defineProperty(listitemRole, "__esModule", {
	  value: true
	});
	listitemRole.default = void 0;
	var listitemRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-level': null,
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      constraints: ['direct descendant of ol', 'direct descendant of ul', 'direct descendant of menu'],
	      name: 'li'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'item'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: ['directory', 'list'],
	  requiredContextRole: ['directory', 'list'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	listitemRole.default = listitemRole$1;
	return listitemRole;
}

var logRole = {};

var hasRequiredLogRole$1;

function requireLogRole$1 () {
	if (hasRequiredLogRole$1) return logRole;
	hasRequiredLogRole$1 = 1;

	Object.defineProperty(logRole, "__esModule", {
	  value: true
	});
	logRole.default = void 0;
	var logRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-live': 'polite'
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	logRole.default = logRole$1;
	return logRole;
}

var mainRole = {};

var hasRequiredMainRole$1;

function requireMainRole$1 () {
	if (hasRequiredMainRole$1) return mainRole;
	hasRequiredMainRole$1 = 1;

	Object.defineProperty(mainRole, "__esModule", {
	  value: true
	});
	mainRole.default = void 0;
	var mainRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'main'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	mainRole.default = mainRole$1;
	return mainRole;
}

var markRole = {};

var hasRequiredMarkRole$1;

function requireMarkRole$1 () {
	if (hasRequiredMarkRole$1) return markRole;
	hasRequiredMarkRole$1 = 1;

	Object.defineProperty(markRole, "__esModule", {
	  value: true
	});
	markRole.default = void 0;
	var markRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: [],
	  props: {
	    'aria-braillelabel': null,
	    'aria-brailleroledescription': null,
	    'aria-description': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'mark'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	markRole.default = markRole$1;
	return markRole;
}

var marqueeRole = {};

var hasRequiredMarqueeRole$1;

function requireMarqueeRole$1 () {
	if (hasRequiredMarqueeRole$1) return marqueeRole;
	hasRequiredMarqueeRole$1 = 1;

	Object.defineProperty(marqueeRole, "__esModule", {
	  value: true
	});
	marqueeRole.default = void 0;
	var marqueeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	marqueeRole.default = marqueeRole$1;
	return marqueeRole;
}

var mathRole = {};

var hasRequiredMathRole$1;

function requireMathRole$1 () {
	if (hasRequiredMathRole$1) return mathRole;
	hasRequiredMathRole$1 = 1;

	Object.defineProperty(mathRole, "__esModule", {
	  value: true
	});
	mathRole.default = void 0;
	var mathRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'math'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	mathRole.default = mathRole$1;
	return mathRole;
}

var menuRole = {};

var hasRequiredMenuRole$1;

function requireMenuRole$1 () {
	if (hasRequiredMenuRole$1) return menuRole;
	hasRequiredMenuRole$1 = 1;

	Object.defineProperty(menuRole, "__esModule", {
	  value: true
	});
	menuRole.default = void 0;
	var menuRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': 'vertical'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'MENU'
	    },
	    module: 'JAPI'
	  }, {
	    concept: {
	      name: 'list'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'select'
	    },
	    module: 'XForms'
	  }, {
	    concept: {
	      name: 'sidebar'
	    },
	    module: 'DTB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['menuitem', 'group'], ['menuitemradio', 'group'], ['menuitemcheckbox', 'group'], ['menuitem'], ['menuitemcheckbox'], ['menuitemradio']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	menuRole.default = menuRole$1;
	return menuRole;
}

var menubarRole = {};

var hasRequiredMenubarRole;

function requireMenubarRole () {
	if (hasRequiredMenubarRole) return menubarRole;
	hasRequiredMenubarRole = 1;

	Object.defineProperty(menubarRole, "__esModule", {
	  value: true
	});
	menubarRole.default = void 0;
	var menubarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': 'horizontal'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'toolbar'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['menuitem', 'group'], ['menuitemradio', 'group'], ['menuitemcheckbox', 'group'], ['menuitem'], ['menuitemcheckbox'], ['menuitemradio']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select', 'menu'], ['roletype', 'structure', 'section', 'group', 'select', 'menu']]
	};
	menubarRole.default = menubarRole$1;
	return menubarRole;
}

var menuitemRole = {};

var hasRequiredMenuitemRole;

function requireMenuitemRole () {
	if (hasRequiredMenuitemRole) return menuitemRole;
	hasRequiredMenuitemRole = 1;

	Object.defineProperty(menuitemRole, "__esModule", {
	  value: true
	});
	menuitemRole.default = void 0;
	var menuitemRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'MENU_ITEM'
	    },
	    module: 'JAPI'
	  }, {
	    concept: {
	      name: 'listitem'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'option'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: ['group', 'menu', 'menubar'],
	  requiredContextRole: ['group', 'menu', 'menubar'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command']]
	};
	menuitemRole.default = menuitemRole$1;
	return menuitemRole;
}

var menuitemcheckboxRole = {};

var hasRequiredMenuitemcheckboxRole;

function requireMenuitemcheckboxRole () {
	if (hasRequiredMenuitemcheckboxRole) return menuitemcheckboxRole;
	hasRequiredMenuitemcheckboxRole = 1;

	Object.defineProperty(menuitemcheckboxRole, "__esModule", {
	  value: true
	});
	menuitemcheckboxRole.default = void 0;
	var menuitemcheckboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'menuitem'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: ['group', 'menu', 'menubar'],
	  requiredContextRole: ['group', 'menu', 'menubar'],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input', 'checkbox'], ['roletype', 'widget', 'command', 'menuitem']]
	};
	menuitemcheckboxRole.default = menuitemcheckboxRole$1;
	return menuitemcheckboxRole;
}

var menuitemradioRole = {};

var hasRequiredMenuitemradioRole;

function requireMenuitemradioRole () {
	if (hasRequiredMenuitemradioRole) return menuitemradioRole;
	hasRequiredMenuitemradioRole = 1;

	Object.defineProperty(menuitemradioRole, "__esModule", {
	  value: true
	});
	menuitemradioRole.default = void 0;
	var menuitemradioRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'menuitem'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: ['group', 'menu', 'menubar'],
	  requiredContextRole: ['group', 'menu', 'menubar'],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input', 'checkbox', 'menuitemcheckbox'], ['roletype', 'widget', 'command', 'menuitem', 'menuitemcheckbox'], ['roletype', 'widget', 'input', 'radio']]
	};
	menuitemradioRole.default = menuitemradioRole$1;
	return menuitemradioRole;
}

var meterRole = {};

var hasRequiredMeterRole$1;

function requireMeterRole$1 () {
	if (hasRequiredMeterRole$1) return meterRole;
	hasRequiredMeterRole$1 = 1;

	Object.defineProperty(meterRole, "__esModule", {
	  value: true
	});
	meterRole.default = void 0;
	var meterRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-valuetext': null,
	    'aria-valuemax': '100',
	    'aria-valuemin': '0'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'meter'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-valuenow': null
	  },
	  superClass: [['roletype', 'structure', 'range']]
	};
	meterRole.default = meterRole$1;
	return meterRole;
}

var navigationRole = {};

var hasRequiredNavigationRole$1;

function requireNavigationRole$1 () {
	if (hasRequiredNavigationRole$1) return navigationRole;
	hasRequiredNavigationRole$1 = 1;

	Object.defineProperty(navigationRole, "__esModule", {
	  value: true
	});
	navigationRole.default = void 0;
	var navigationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'nav'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	navigationRole.default = navigationRole$1;
	return navigationRole;
}

var noneRole = {};

var hasRequiredNoneRole$1;

function requireNoneRole$1 () {
	if (hasRequiredNoneRole$1) return noneRole;
	hasRequiredNoneRole$1 = 1;

	Object.defineProperty(noneRole, "__esModule", {
	  value: true
	});
	noneRole.default = void 0;
	var noneRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: []
	};
	noneRole.default = noneRole$1;
	return noneRole;
}

var noteRole = {};

var hasRequiredNoteRole$1;

function requireNoteRole$1 () {
	if (hasRequiredNoteRole$1) return noteRole;
	hasRequiredNoteRole$1 = 1;

	Object.defineProperty(noteRole, "__esModule", {
	  value: true
	});
	noteRole.default = void 0;
	var noteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	noteRole.default = noteRole$1;
	return noteRole;
}

var optionRole = {};

var hasRequiredOptionRole;

function requireOptionRole () {
	if (hasRequiredOptionRole) return optionRole;
	hasRequiredOptionRole = 1;

	Object.defineProperty(optionRole, "__esModule", {
	  value: true
	});
	optionRole.default = void 0;
	var optionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-checked': null,
	    'aria-posinset': null,
	    'aria-setsize': null,
	    'aria-selected': 'false'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'item'
	    },
	    module: 'XForms'
	  }, {
	    concept: {
	      name: 'listitem'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'option'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-selected': 'false'
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	optionRole.default = optionRole$1;
	return optionRole;
}

var paragraphRole = {};

var hasRequiredParagraphRole$1;

function requireParagraphRole$1 () {
	if (hasRequiredParagraphRole$1) return paragraphRole;
	hasRequiredParagraphRole$1 = 1;

	Object.defineProperty(paragraphRole, "__esModule", {
	  value: true
	});
	paragraphRole.default = void 0;
	var paragraphRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'p'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	paragraphRole.default = paragraphRole$1;
	return paragraphRole;
}

var presentationRole = {};

var hasRequiredPresentationRole;

function requirePresentationRole () {
	if (hasRequiredPresentationRole) return presentationRole;
	hasRequiredPresentationRole = 1;

	Object.defineProperty(presentationRole, "__esModule", {
	  value: true
	});
	presentationRole.default = void 0;
	var presentationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'alt',
	        value: ''
	      }],
	      name: 'img'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	presentationRole.default = presentationRole$1;
	return presentationRole;
}

var progressbarRole = {};

var hasRequiredProgressbarRole;

function requireProgressbarRole () {
	if (hasRequiredProgressbarRole) return progressbarRole;
	hasRequiredProgressbarRole = 1;

	Object.defineProperty(progressbarRole, "__esModule", {
	  value: true
	});
	progressbarRole.default = void 0;
	var progressbarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-valuetext': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'progress'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'status'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'range'], ['roletype', 'widget']]
	};
	progressbarRole.default = progressbarRole$1;
	return progressbarRole;
}

var radioRole = {};

var hasRequiredRadioRole;

function requireRadioRole () {
	if (hasRequiredRadioRole) return radioRole;
	hasRequiredRadioRole = 1;

	Object.defineProperty(radioRole, "__esModule", {
	  value: true
	});
	radioRole.default = void 0;
	var radioRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-checked': null,
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'radio'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	radioRole.default = radioRole$1;
	return radioRole;
}

var radiogroupRole = {};

var hasRequiredRadiogroupRole;

function requireRadiogroupRole () {
	if (hasRequiredRadiogroupRole) return radiogroupRole;
	hasRequiredRadiogroupRole = 1;

	Object.defineProperty(radiogroupRole, "__esModule", {
	  value: true
	});
	radiogroupRole.default = void 0;
	var radiogroupRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'list'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['radio']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	radiogroupRole.default = radiogroupRole$1;
	return radiogroupRole;
}

var regionRole = {};

var hasRequiredRegionRole$1;

function requireRegionRole$1 () {
	if (hasRequiredRegionRole$1) return regionRole;
	hasRequiredRegionRole$1 = 1;

	Object.defineProperty(regionRole, "__esModule", {
	  value: true
	});
	regionRole.default = void 0;
	var regionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-label'
	      }],
	      name: 'section'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-labelledby'
	      }],
	      name: 'section'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'Device Independence Glossart perceivable unit'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	regionRole.default = regionRole$1;
	return regionRole;
}

var rowRole = {};

var hasRequiredRowRole$1;

function requireRowRole$1 () {
	if (hasRequiredRowRole$1) return rowRole;
	hasRequiredRowRole$1 = 1;

	Object.defineProperty(rowRole, "__esModule", {
	  value: true
	});
	rowRole.default = void 0;
	var rowRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-colindex': null,
	    'aria-expanded': null,
	    'aria-level': null,
	    'aria-posinset': null,
	    'aria-rowindex': null,
	    'aria-selected': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'tr'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
	  requiredContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
	  requiredOwnedElements: [['cell'], ['columnheader'], ['gridcell'], ['rowheader']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'group'], ['roletype', 'widget']]
	};
	rowRole.default = rowRole$1;
	return rowRole;
}

var rowgroupRole = {};

var hasRequiredRowgroupRole;

function requireRowgroupRole () {
	if (hasRequiredRowgroupRole) return rowgroupRole;
	hasRequiredRowgroupRole = 1;

	Object.defineProperty(rowgroupRole, "__esModule", {
	  value: true
	});
	rowgroupRole.default = void 0;
	var rowgroupRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'tbody'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'tfoot'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'thead'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['grid', 'table', 'treegrid'],
	  requiredContextRole: ['grid', 'table', 'treegrid'],
	  requiredOwnedElements: [['row']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	rowgroupRole.default = rowgroupRole$1;
	return rowgroupRole;
}

var rowheaderRole = {};

var hasRequiredRowheaderRole;

function requireRowheaderRole () {
	if (hasRequiredRowheaderRole) return rowheaderRole;
	hasRequiredRowheaderRole = 1;

	Object.defineProperty(rowheaderRole, "__esModule", {
	  value: true
	});
	rowheaderRole.default = void 0;
	var rowheaderRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-sort': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'row'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'rowgroup'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row', 'rowgroup'],
	  requiredContextRole: ['row', 'rowgroup'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'structure', 'section', 'cell', 'gridcell'], ['roletype', 'widget', 'gridcell'], ['roletype', 'structure', 'sectionhead']]
	};
	rowheaderRole.default = rowheaderRole$1;
	return rowheaderRole;
}

var scrollbarRole = {};

var hasRequiredScrollbarRole;

function requireScrollbarRole () {
	if (hasRequiredScrollbarRole) return scrollbarRole;
	hasRequiredScrollbarRole = 1;

	Object.defineProperty(scrollbarRole, "__esModule", {
	  value: true
	});
	scrollbarRole.default = void 0;
	var scrollbarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-valuetext': null,
	    'aria-orientation': 'vertical',
	    'aria-valuemax': '100',
	    'aria-valuemin': '0'
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-controls': null,
	    'aria-valuenow': null
	  },
	  superClass: [['roletype', 'structure', 'range'], ['roletype', 'widget']]
	};
	scrollbarRole.default = scrollbarRole$1;
	return scrollbarRole;
}

var searchRole = {};

var hasRequiredSearchRole$1;

function requireSearchRole$1 () {
	if (hasRequiredSearchRole$1) return searchRole;
	hasRequiredSearchRole$1 = 1;

	Object.defineProperty(searchRole, "__esModule", {
	  value: true
	});
	searchRole.default = void 0;
	var searchRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	searchRole.default = searchRole$1;
	return searchRole;
}

var searchboxRole = {};

var hasRequiredSearchboxRole;

function requireSearchboxRole () {
	if (hasRequiredSearchboxRole) return searchboxRole;
	hasRequiredSearchboxRole = 1;

	Object.defineProperty(searchboxRole, "__esModule", {
	  value: true
	});
	searchboxRole.default = void 0;
	var searchboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'search'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'input', 'textbox']]
	};
	searchboxRole.default = searchboxRole$1;
	return searchboxRole;
}

var separatorRole = {};

var hasRequiredSeparatorRole;

function requireSeparatorRole () {
	if (hasRequiredSeparatorRole) return separatorRole;
	hasRequiredSeparatorRole = 1;

	Object.defineProperty(separatorRole, "__esModule", {
	  value: true
	});
	separatorRole.default = void 0;
	var separatorRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-orientation': 'horizontal',
	    'aria-valuemax': '100',
	    'aria-valuemin': '0',
	    'aria-valuenow': null,
	    'aria-valuetext': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'hr'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	separatorRole.default = separatorRole$1;
	return separatorRole;
}

var sliderRole = {};

var hasRequiredSliderRole$1;

function requireSliderRole$1 () {
	if (hasRequiredSliderRole$1) return sliderRole;
	hasRequiredSliderRole$1 = 1;

	Object.defineProperty(sliderRole, "__esModule", {
	  value: true
	});
	sliderRole.default = void 0;
	var sliderRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-haspopup': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-valuetext': null,
	    'aria-orientation': 'horizontal',
	    'aria-valuemax': '100',
	    'aria-valuemin': '0'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'range'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-valuenow': null
	  },
	  superClass: [['roletype', 'widget', 'input'], ['roletype', 'structure', 'range']]
	};
	sliderRole.default = sliderRole$1;
	return sliderRole;
}

var spinbuttonRole = {};

var hasRequiredSpinbuttonRole;

function requireSpinbuttonRole () {
	if (hasRequiredSpinbuttonRole) return spinbuttonRole;
	hasRequiredSpinbuttonRole = 1;

	Object.defineProperty(spinbuttonRole, "__esModule", {
	  value: true
	});
	spinbuttonRole.default = void 0;
	var spinbuttonRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-valuetext': null,
	    'aria-valuenow': '0'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'number'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite'], ['roletype', 'widget', 'input'], ['roletype', 'structure', 'range']]
	};
	spinbuttonRole.default = spinbuttonRole$1;
	return spinbuttonRole;
}

var statusRole = {};

var hasRequiredStatusRole$1;

function requireStatusRole$1 () {
	if (hasRequiredStatusRole$1) return statusRole;
	hasRequiredStatusRole$1 = 1;

	Object.defineProperty(statusRole, "__esModule", {
	  value: true
	});
	statusRole.default = void 0;
	var statusRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-atomic': 'true',
	    'aria-live': 'polite'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'output'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	statusRole.default = statusRole$1;
	return statusRole;
}

var strongRole = {};

var hasRequiredStrongRole;

function requireStrongRole () {
	if (hasRequiredStrongRole) return strongRole;
	hasRequiredStrongRole = 1;

	Object.defineProperty(strongRole, "__esModule", {
	  value: true
	});
	strongRole.default = void 0;
	var strongRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'strong'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	strongRole.default = strongRole$1;
	return strongRole;
}

var subscriptRole = {};

var hasRequiredSubscriptRole;

function requireSubscriptRole () {
	if (hasRequiredSubscriptRole) return subscriptRole;
	hasRequiredSubscriptRole = 1;

	Object.defineProperty(subscriptRole, "__esModule", {
	  value: true
	});
	subscriptRole.default = void 0;
	var subscriptRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'sub'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	subscriptRole.default = subscriptRole$1;
	return subscriptRole;
}

var superscriptRole = {};

var hasRequiredSuperscriptRole;

function requireSuperscriptRole () {
	if (hasRequiredSuperscriptRole) return superscriptRole;
	hasRequiredSuperscriptRole = 1;

	Object.defineProperty(superscriptRole, "__esModule", {
	  value: true
	});
	superscriptRole.default = void 0;
	var superscriptRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'sup'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	superscriptRole.default = superscriptRole$1;
	return superscriptRole;
}

var switchRole = {};

var hasRequiredSwitchRole$1;

function requireSwitchRole$1 () {
	if (hasRequiredSwitchRole$1) return switchRole;
	hasRequiredSwitchRole$1 = 1;

	Object.defineProperty(switchRole, "__esModule", {
	  value: true
	});
	switchRole.default = void 0;
	var switchRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'button'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input', 'checkbox']]
	};
	switchRole.default = switchRole$1;
	return switchRole;
}

var tabRole = {};

var hasRequiredTabRole$1;

function requireTabRole$1 () {
	if (hasRequiredTabRole$1) return tabRole;
	hasRequiredTabRole$1 = 1;

	Object.defineProperty(tabRole, "__esModule", {
	  value: true
	});
	tabRole.default = void 0;
	var tabRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-posinset': null,
	    'aria-setsize': null,
	    'aria-selected': 'false'
	  },
	  relatedConcepts: [],
	  requireContextRole: ['tablist'],
	  requiredContextRole: ['tablist'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'sectionhead'], ['roletype', 'widget']]
	};
	tabRole.default = tabRole$1;
	return tabRole;
}

var tableRole = {};

var hasRequiredTableRole$1;

function requireTableRole$1 () {
	if (hasRequiredTableRole$1) return tableRole;
	hasRequiredTableRole$1 = 1;

	Object.defineProperty(tableRole, "__esModule", {
	  value: true
	});
	tableRole.default = void 0;
	var tableRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-colcount': null,
	    'aria-rowcount': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'table'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['row'], ['row', 'rowgroup']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	tableRole.default = tableRole$1;
	return tableRole;
}

var tablistRole = {};

var hasRequiredTablistRole;

function requireTablistRole () {
	if (hasRequiredTablistRole) return tablistRole;
	hasRequiredTablistRole = 1;

	Object.defineProperty(tablistRole, "__esModule", {
	  value: true
	});
	tablistRole.default = void 0;
	var tablistRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-level': null,
	    'aria-multiselectable': null,
	    'aria-orientation': 'horizontal'
	  },
	  relatedConcepts: [{
	    module: 'DAISY',
	    concept: {
	      name: 'guide'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['tab']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite']]
	};
	tablistRole.default = tablistRole$1;
	return tablistRole;
}

var tabpanelRole = {};

var hasRequiredTabpanelRole;

function requireTabpanelRole () {
	if (hasRequiredTabpanelRole) return tabpanelRole;
	hasRequiredTabpanelRole = 1;

	Object.defineProperty(tabpanelRole, "__esModule", {
	  value: true
	});
	tabpanelRole.default = void 0;
	var tabpanelRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	tabpanelRole.default = tabpanelRole$1;
	return tabpanelRole;
}

var termRole = {};

var hasRequiredTermRole$1;

function requireTermRole$1 () {
	if (hasRequiredTermRole$1) return termRole;
	hasRequiredTermRole$1 = 1;

	Object.defineProperty(termRole, "__esModule", {
	  value: true
	});
	termRole.default = void 0;
	var termRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'dfn'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'dt'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	termRole.default = termRole$1;
	return termRole;
}

var textboxRole = {};

var hasRequiredTextboxRole;

function requireTextboxRole () {
	if (hasRequiredTextboxRole) return textboxRole;
	hasRequiredTextboxRole = 1;

	Object.defineProperty(textboxRole, "__esModule", {
	  value: true
	});
	textboxRole.default = void 0;
	var textboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-autocomplete': null,
	    'aria-errormessage': null,
	    'aria-haspopup': null,
	    'aria-invalid': null,
	    'aria-multiline': null,
	    'aria-placeholder': null,
	    'aria-readonly': null,
	    'aria-required': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'type'
	      }, {
	        constraints: ['undefined'],
	        name: 'list'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'email'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'tel'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'text'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'url'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'input'
	    },
	    module: 'XForms'
	  }, {
	    concept: {
	      name: 'textarea'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'input']]
	};
	textboxRole.default = textboxRole$1;
	return textboxRole;
}

var timeRole = {};

var hasRequiredTimeRole$1;

function requireTimeRole$1 () {
	if (hasRequiredTimeRole$1) return timeRole;
	hasRequiredTimeRole$1 = 1;

	Object.defineProperty(timeRole, "__esModule", {
	  value: true
	});
	timeRole.default = void 0;
	var timeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'time'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	timeRole.default = timeRole$1;
	return timeRole;
}

var timerRole = {};

var hasRequiredTimerRole$1;

function requireTimerRole$1 () {
	if (hasRequiredTimerRole$1) return timerRole;
	hasRequiredTimerRole$1 = 1;

	Object.defineProperty(timerRole, "__esModule", {
	  value: true
	});
	timerRole.default = void 0;
	var timerRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'status']]
	};
	timerRole.default = timerRole$1;
	return timerRole;
}

var toolbarRole = {};

var hasRequiredToolbarRole$1;

function requireToolbarRole$1 () {
	if (hasRequiredToolbarRole$1) return toolbarRole;
	hasRequiredToolbarRole$1 = 1;

	Object.defineProperty(toolbarRole, "__esModule", {
	  value: true
	});
	toolbarRole.default = void 0;
	var toolbarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': 'horizontal'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'menubar'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'group']]
	};
	toolbarRole.default = toolbarRole$1;
	return toolbarRole;
}

var tooltipRole = {};

var hasRequiredTooltipRole;

function requireTooltipRole () {
	if (hasRequiredTooltipRole) return tooltipRole;
	hasRequiredTooltipRole = 1;

	Object.defineProperty(tooltipRole, "__esModule", {
	  value: true
	});
	tooltipRole.default = void 0;
	var tooltipRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	tooltipRole.default = tooltipRole$1;
	return tooltipRole;
}

var treeRole = {};

var hasRequiredTreeRole$1;

function requireTreeRole$1 () {
	if (hasRequiredTreeRole$1) return treeRole;
	hasRequiredTreeRole$1 = 1;

	Object.defineProperty(treeRole, "__esModule", {
	  value: true
	});
	treeRole.default = void 0;
	var treeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-multiselectable': null,
	    'aria-required': null,
	    'aria-orientation': 'vertical'
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['treeitem', 'group'], ['treeitem']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	treeRole.default = treeRole$1;
	return treeRole;
}

var treegridRole = {};

var hasRequiredTreegridRole;

function requireTreegridRole () {
	if (hasRequiredTreegridRole) return treegridRole;
	hasRequiredTreegridRole = 1;

	Object.defineProperty(treegridRole, "__esModule", {
	  value: true
	});
	treegridRole.default = void 0;
	var treegridRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['row'], ['row', 'rowgroup']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'grid'], ['roletype', 'structure', 'section', 'table', 'grid'], ['roletype', 'widget', 'composite', 'select', 'tree'], ['roletype', 'structure', 'section', 'group', 'select', 'tree']]
	};
	treegridRole.default = treegridRole$1;
	return treegridRole;
}

var treeitemRole = {};

var hasRequiredTreeitemRole;

function requireTreeitemRole () {
	if (hasRequiredTreeitemRole) return treeitemRole;
	hasRequiredTreeitemRole = 1;

	Object.defineProperty(treeitemRole, "__esModule", {
	  value: true
	});
	treeitemRole.default = void 0;
	var treeitemRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-expanded': null,
	    'aria-haspopup': null
	  },
	  relatedConcepts: [],
	  requireContextRole: ['group', 'tree'],
	  requiredContextRole: ['group', 'tree'],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-selected': null
	  },
	  superClass: [['roletype', 'structure', 'section', 'listitem'], ['roletype', 'widget', 'input', 'option']]
	};
	treeitemRole.default = treeitemRole$1;
	return treeitemRole;
}

var hasRequiredAriaLiteralRoles;

function requireAriaLiteralRoles () {
	if (hasRequiredAriaLiteralRoles) return ariaLiteralRoles;
	hasRequiredAriaLiteralRoles = 1;

	Object.defineProperty(ariaLiteralRoles, "__esModule", {
	  value: true
	});
	ariaLiteralRoles.default = void 0;
	var _alertRole = _interopRequireDefault(requireAlertRole$1());
	var _alertdialogRole = _interopRequireDefault(requireAlertdialogRole());
	var _applicationRole = _interopRequireDefault(requireApplicationRole$1());
	var _articleRole = _interopRequireDefault(requireArticleRole$1());
	var _bannerRole = _interopRequireDefault(requireBannerRole$1());
	var _blockquoteRole = _interopRequireDefault(requireBlockquoteRole$1());
	var _buttonRole = _interopRequireDefault(requireButtonRole$1());
	var _captionRole = _interopRequireDefault(requireCaptionRole$1());
	var _cellRole = _interopRequireDefault(requireCellRole$1());
	var _checkboxRole = _interopRequireDefault(requireCheckboxRole());
	var _codeRole = _interopRequireDefault(requireCodeRole());
	var _columnheaderRole = _interopRequireDefault(requireColumnheaderRole());
	var _comboboxRole = _interopRequireDefault(requireComboboxRole());
	var _complementaryRole = _interopRequireDefault(requireComplementaryRole$1());
	var _contentinfoRole = _interopRequireDefault(requireContentinfoRole());
	var _definitionRole = _interopRequireDefault(requireDefinitionRole$1());
	var _deletionRole = _interopRequireDefault(requireDeletionRole());
	var _dialogRole = _interopRequireDefault(requireDialogRole$1());
	var _directoryRole = _interopRequireDefault(requireDirectoryRole$1());
	var _documentRole = _interopRequireDefault(requireDocumentRole$1());
	var _emphasisRole = _interopRequireDefault(requireEmphasisRole());
	var _feedRole = _interopRequireDefault(requireFeedRole$1());
	var _figureRole = _interopRequireDefault(requireFigureRole$1());
	var _formRole = _interopRequireDefault(requireFormRole$1());
	var _genericRole = _interopRequireDefault(requireGenericRole());
	var _gridRole = _interopRequireDefault(requireGridRole$1());
	var _gridcellRole = _interopRequireDefault(requireGridcellRole());
	var _groupRole = _interopRequireDefault(requireGroupRole$1());
	var _headingRole = _interopRequireDefault(requireHeadingRole$1());
	var _imgRole = _interopRequireDefault(requireImgRole());
	var _insertionRole = _interopRequireDefault(requireInsertionRole());
	var _linkRole = _interopRequireDefault(requireLinkRole$1());
	var _listRole = _interopRequireDefault(requireListRole$1());
	var _listboxRole = _interopRequireDefault(requireListboxRole());
	var _listitemRole = _interopRequireDefault(requireListitemRole());
	var _logRole = _interopRequireDefault(requireLogRole$1());
	var _mainRole = _interopRequireDefault(requireMainRole$1());
	var _markRole = _interopRequireDefault(requireMarkRole$1());
	var _marqueeRole = _interopRequireDefault(requireMarqueeRole$1());
	var _mathRole = _interopRequireDefault(requireMathRole$1());
	var _menuRole = _interopRequireDefault(requireMenuRole$1());
	var _menubarRole = _interopRequireDefault(requireMenubarRole());
	var _menuitemRole = _interopRequireDefault(requireMenuitemRole());
	var _menuitemcheckboxRole = _interopRequireDefault(requireMenuitemcheckboxRole());
	var _menuitemradioRole = _interopRequireDefault(requireMenuitemradioRole());
	var _meterRole = _interopRequireDefault(requireMeterRole$1());
	var _navigationRole = _interopRequireDefault(requireNavigationRole$1());
	var _noneRole = _interopRequireDefault(requireNoneRole$1());
	var _noteRole = _interopRequireDefault(requireNoteRole$1());
	var _optionRole = _interopRequireDefault(requireOptionRole());
	var _paragraphRole = _interopRequireDefault(requireParagraphRole$1());
	var _presentationRole = _interopRequireDefault(requirePresentationRole());
	var _progressbarRole = _interopRequireDefault(requireProgressbarRole());
	var _radioRole = _interopRequireDefault(requireRadioRole());
	var _radiogroupRole = _interopRequireDefault(requireRadiogroupRole());
	var _regionRole = _interopRequireDefault(requireRegionRole$1());
	var _rowRole = _interopRequireDefault(requireRowRole$1());
	var _rowgroupRole = _interopRequireDefault(requireRowgroupRole());
	var _rowheaderRole = _interopRequireDefault(requireRowheaderRole());
	var _scrollbarRole = _interopRequireDefault(requireScrollbarRole());
	var _searchRole = _interopRequireDefault(requireSearchRole$1());
	var _searchboxRole = _interopRequireDefault(requireSearchboxRole());
	var _separatorRole = _interopRequireDefault(requireSeparatorRole());
	var _sliderRole = _interopRequireDefault(requireSliderRole$1());
	var _spinbuttonRole = _interopRequireDefault(requireSpinbuttonRole());
	var _statusRole = _interopRequireDefault(requireStatusRole$1());
	var _strongRole = _interopRequireDefault(requireStrongRole());
	var _subscriptRole = _interopRequireDefault(requireSubscriptRole());
	var _superscriptRole = _interopRequireDefault(requireSuperscriptRole());
	var _switchRole = _interopRequireDefault(requireSwitchRole$1());
	var _tabRole = _interopRequireDefault(requireTabRole$1());
	var _tableRole = _interopRequireDefault(requireTableRole$1());
	var _tablistRole = _interopRequireDefault(requireTablistRole());
	var _tabpanelRole = _interopRequireDefault(requireTabpanelRole());
	var _termRole = _interopRequireDefault(requireTermRole$1());
	var _textboxRole = _interopRequireDefault(requireTextboxRole());
	var _timeRole = _interopRequireDefault(requireTimeRole$1());
	var _timerRole = _interopRequireDefault(requireTimerRole$1());
	var _toolbarRole = _interopRequireDefault(requireToolbarRole$1());
	var _tooltipRole = _interopRequireDefault(requireTooltipRole());
	var _treeRole = _interopRequireDefault(requireTreeRole$1());
	var _treegridRole = _interopRequireDefault(requireTreegridRole());
	var _treeitemRole = _interopRequireDefault(requireTreeitemRole());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	var ariaLiteralRoles$1 = [['alert', _alertRole.default], ['alertdialog', _alertdialogRole.default], ['application', _applicationRole.default], ['article', _articleRole.default], ['banner', _bannerRole.default], ['blockquote', _blockquoteRole.default], ['button', _buttonRole.default], ['caption', _captionRole.default], ['cell', _cellRole.default], ['checkbox', _checkboxRole.default], ['code', _codeRole.default], ['columnheader', _columnheaderRole.default], ['combobox', _comboboxRole.default], ['complementary', _complementaryRole.default], ['contentinfo', _contentinfoRole.default], ['definition', _definitionRole.default], ['deletion', _deletionRole.default], ['dialog', _dialogRole.default], ['directory', _directoryRole.default], ['document', _documentRole.default], ['emphasis', _emphasisRole.default], ['feed', _feedRole.default], ['figure', _figureRole.default], ['form', _formRole.default], ['generic', _genericRole.default], ['grid', _gridRole.default], ['gridcell', _gridcellRole.default], ['group', _groupRole.default], ['heading', _headingRole.default], ['img', _imgRole.default], ['insertion', _insertionRole.default], ['link', _linkRole.default], ['list', _listRole.default], ['listbox', _listboxRole.default], ['listitem', _listitemRole.default], ['log', _logRole.default], ['main', _mainRole.default], ['mark', _markRole.default], ['marquee', _marqueeRole.default], ['math', _mathRole.default], ['menu', _menuRole.default], ['menubar', _menubarRole.default], ['menuitem', _menuitemRole.default], ['menuitemcheckbox', _menuitemcheckboxRole.default], ['menuitemradio', _menuitemradioRole.default], ['meter', _meterRole.default], ['navigation', _navigationRole.default], ['none', _noneRole.default], ['note', _noteRole.default], ['option', _optionRole.default], ['paragraph', _paragraphRole.default], ['presentation', _presentationRole.default], ['progressbar', _progressbarRole.default], ['radio', _radioRole.default], ['radiogroup', _radiogroupRole.default], ['region', _regionRole.default], ['row', _rowRole.default], ['rowgroup', _rowgroupRole.default], ['rowheader', _rowheaderRole.default], ['scrollbar', _scrollbarRole.default], ['search', _searchRole.default], ['searchbox', _searchboxRole.default], ['separator', _separatorRole.default], ['slider', _sliderRole.default], ['spinbutton', _spinbuttonRole.default], ['status', _statusRole.default], ['strong', _strongRole.default], ['subscript', _subscriptRole.default], ['superscript', _superscriptRole.default], ['switch', _switchRole.default], ['tab', _tabRole.default], ['table', _tableRole.default], ['tablist', _tablistRole.default], ['tabpanel', _tabpanelRole.default], ['term', _termRole.default], ['textbox', _textboxRole.default], ['time', _timeRole.default], ['timer', _timerRole.default], ['toolbar', _toolbarRole.default], ['tooltip', _tooltipRole.default], ['tree', _treeRole.default], ['treegrid', _treegridRole.default], ['treeitem', _treeitemRole.default]];
	ariaLiteralRoles.default = ariaLiteralRoles$1;
	return ariaLiteralRoles;
}

var ariaDpubRoles = {};

var docAbstractRole = {};

var hasRequiredDocAbstractRole;

function requireDocAbstractRole () {
	if (hasRequiredDocAbstractRole) return docAbstractRole;
	hasRequiredDocAbstractRole = 1;

	Object.defineProperty(docAbstractRole, "__esModule", {
	  value: true
	});
	docAbstractRole.default = void 0;
	var docAbstractRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'abstract [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docAbstractRole.default = docAbstractRole$1;
	return docAbstractRole;
}

var docAcknowledgmentsRole = {};

var hasRequiredDocAcknowledgmentsRole;

function requireDocAcknowledgmentsRole () {
	if (hasRequiredDocAcknowledgmentsRole) return docAcknowledgmentsRole;
	hasRequiredDocAcknowledgmentsRole = 1;

	Object.defineProperty(docAcknowledgmentsRole, "__esModule", {
	  value: true
	});
	docAcknowledgmentsRole.default = void 0;
	var docAcknowledgmentsRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'acknowledgments [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docAcknowledgmentsRole.default = docAcknowledgmentsRole$1;
	return docAcknowledgmentsRole;
}

var docAfterwordRole = {};

var hasRequiredDocAfterwordRole;

function requireDocAfterwordRole () {
	if (hasRequiredDocAfterwordRole) return docAfterwordRole;
	hasRequiredDocAfterwordRole = 1;

	Object.defineProperty(docAfterwordRole, "__esModule", {
	  value: true
	});
	docAfterwordRole.default = void 0;
	var docAfterwordRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'afterword [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docAfterwordRole.default = docAfterwordRole$1;
	return docAfterwordRole;
}

var docAppendixRole = {};

var hasRequiredDocAppendixRole;

function requireDocAppendixRole () {
	if (hasRequiredDocAppendixRole) return docAppendixRole;
	hasRequiredDocAppendixRole = 1;

	Object.defineProperty(docAppendixRole, "__esModule", {
	  value: true
	});
	docAppendixRole.default = void 0;
	var docAppendixRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'appendix [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docAppendixRole.default = docAppendixRole$1;
	return docAppendixRole;
}

var docBacklinkRole = {};

var hasRequiredDocBacklinkRole;

function requireDocBacklinkRole () {
	if (hasRequiredDocBacklinkRole) return docBacklinkRole;
	hasRequiredDocBacklinkRole = 1;

	Object.defineProperty(docBacklinkRole, "__esModule", {
	  value: true
	});
	docBacklinkRole.default = void 0;
	var docBacklinkRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'referrer [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	docBacklinkRole.default = docBacklinkRole$1;
	return docBacklinkRole;
}

var docBiblioentryRole = {};

var hasRequiredDocBiblioentryRole;

function requireDocBiblioentryRole () {
	if (hasRequiredDocBiblioentryRole) return docBiblioentryRole;
	hasRequiredDocBiblioentryRole = 1;

	Object.defineProperty(docBiblioentryRole, "__esModule", {
	  value: true
	});
	docBiblioentryRole.default = void 0;
	var docBiblioentryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'EPUB biblioentry [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: ['doc-bibliography'],
	  requiredContextRole: ['doc-bibliography'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'listitem']]
	};
	docBiblioentryRole.default = docBiblioentryRole$1;
	return docBiblioentryRole;
}

var docBibliographyRole = {};

var hasRequiredDocBibliographyRole;

function requireDocBibliographyRole () {
	if (hasRequiredDocBibliographyRole) return docBibliographyRole;
	hasRequiredDocBibliographyRole = 1;

	Object.defineProperty(docBibliographyRole, "__esModule", {
	  value: true
	});
	docBibliographyRole.default = void 0;
	var docBibliographyRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'bibliography [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['doc-biblioentry']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docBibliographyRole.default = docBibliographyRole$1;
	return docBibliographyRole;
}

var docBibliorefRole = {};

var hasRequiredDocBibliorefRole;

function requireDocBibliorefRole () {
	if (hasRequiredDocBibliorefRole) return docBibliorefRole;
	hasRequiredDocBibliorefRole = 1;

	Object.defineProperty(docBibliorefRole, "__esModule", {
	  value: true
	});
	docBibliorefRole.default = void 0;
	var docBibliorefRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'biblioref [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	docBibliorefRole.default = docBibliorefRole$1;
	return docBibliorefRole;
}

var docChapterRole = {};

var hasRequiredDocChapterRole;

function requireDocChapterRole () {
	if (hasRequiredDocChapterRole) return docChapterRole;
	hasRequiredDocChapterRole = 1;

	Object.defineProperty(docChapterRole, "__esModule", {
	  value: true
	});
	docChapterRole.default = void 0;
	var docChapterRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'chapter [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docChapterRole.default = docChapterRole$1;
	return docChapterRole;
}

var docColophonRole = {};

var hasRequiredDocColophonRole;

function requireDocColophonRole () {
	if (hasRequiredDocColophonRole) return docColophonRole;
	hasRequiredDocColophonRole = 1;

	Object.defineProperty(docColophonRole, "__esModule", {
	  value: true
	});
	docColophonRole.default = void 0;
	var docColophonRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'colophon [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docColophonRole.default = docColophonRole$1;
	return docColophonRole;
}

var docConclusionRole = {};

var hasRequiredDocConclusionRole;

function requireDocConclusionRole () {
	if (hasRequiredDocConclusionRole) return docConclusionRole;
	hasRequiredDocConclusionRole = 1;

	Object.defineProperty(docConclusionRole, "__esModule", {
	  value: true
	});
	docConclusionRole.default = void 0;
	var docConclusionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'conclusion [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docConclusionRole.default = docConclusionRole$1;
	return docConclusionRole;
}

var docCoverRole = {};

var hasRequiredDocCoverRole;

function requireDocCoverRole () {
	if (hasRequiredDocCoverRole) return docCoverRole;
	hasRequiredDocCoverRole = 1;

	Object.defineProperty(docCoverRole, "__esModule", {
	  value: true
	});
	docCoverRole.default = void 0;
	var docCoverRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'cover [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'img']]
	};
	docCoverRole.default = docCoverRole$1;
	return docCoverRole;
}

var docCreditRole = {};

var hasRequiredDocCreditRole;

function requireDocCreditRole () {
	if (hasRequiredDocCreditRole) return docCreditRole;
	hasRequiredDocCreditRole = 1;

	Object.defineProperty(docCreditRole, "__esModule", {
	  value: true
	});
	docCreditRole.default = void 0;
	var docCreditRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'credit [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docCreditRole.default = docCreditRole$1;
	return docCreditRole;
}

var docCreditsRole = {};

var hasRequiredDocCreditsRole;

function requireDocCreditsRole () {
	if (hasRequiredDocCreditsRole) return docCreditsRole;
	hasRequiredDocCreditsRole = 1;

	Object.defineProperty(docCreditsRole, "__esModule", {
	  value: true
	});
	docCreditsRole.default = void 0;
	var docCreditsRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'credits [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docCreditsRole.default = docCreditsRole$1;
	return docCreditsRole;
}

var docDedicationRole = {};

var hasRequiredDocDedicationRole;

function requireDocDedicationRole () {
	if (hasRequiredDocDedicationRole) return docDedicationRole;
	hasRequiredDocDedicationRole = 1;

	Object.defineProperty(docDedicationRole, "__esModule", {
	  value: true
	});
	docDedicationRole.default = void 0;
	var docDedicationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'dedication [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docDedicationRole.default = docDedicationRole$1;
	return docDedicationRole;
}

var docEndnoteRole = {};

var hasRequiredDocEndnoteRole;

function requireDocEndnoteRole () {
	if (hasRequiredDocEndnoteRole) return docEndnoteRole;
	hasRequiredDocEndnoteRole = 1;

	Object.defineProperty(docEndnoteRole, "__esModule", {
	  value: true
	});
	docEndnoteRole.default = void 0;
	var docEndnoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'rearnote [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: ['doc-endnotes'],
	  requiredContextRole: ['doc-endnotes'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'listitem']]
	};
	docEndnoteRole.default = docEndnoteRole$1;
	return docEndnoteRole;
}

var docEndnotesRole = {};

var hasRequiredDocEndnotesRole;

function requireDocEndnotesRole () {
	if (hasRequiredDocEndnotesRole) return docEndnotesRole;
	hasRequiredDocEndnotesRole = 1;

	Object.defineProperty(docEndnotesRole, "__esModule", {
	  value: true
	});
	docEndnotesRole.default = void 0;
	var docEndnotesRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'rearnotes [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['doc-endnote']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docEndnotesRole.default = docEndnotesRole$1;
	return docEndnotesRole;
}

var docEpigraphRole = {};

var hasRequiredDocEpigraphRole;

function requireDocEpigraphRole () {
	if (hasRequiredDocEpigraphRole) return docEpigraphRole;
	hasRequiredDocEpigraphRole = 1;

	Object.defineProperty(docEpigraphRole, "__esModule", {
	  value: true
	});
	docEpigraphRole.default = void 0;
	var docEpigraphRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'epigraph [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docEpigraphRole.default = docEpigraphRole$1;
	return docEpigraphRole;
}

var docEpilogueRole = {};

var hasRequiredDocEpilogueRole;

function requireDocEpilogueRole () {
	if (hasRequiredDocEpilogueRole) return docEpilogueRole;
	hasRequiredDocEpilogueRole = 1;

	Object.defineProperty(docEpilogueRole, "__esModule", {
	  value: true
	});
	docEpilogueRole.default = void 0;
	var docEpilogueRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'epilogue [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docEpilogueRole.default = docEpilogueRole$1;
	return docEpilogueRole;
}

var docErrataRole = {};

var hasRequiredDocErrataRole;

function requireDocErrataRole () {
	if (hasRequiredDocErrataRole) return docErrataRole;
	hasRequiredDocErrataRole = 1;

	Object.defineProperty(docErrataRole, "__esModule", {
	  value: true
	});
	docErrataRole.default = void 0;
	var docErrataRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'errata [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docErrataRole.default = docErrataRole$1;
	return docErrataRole;
}

var docExampleRole = {};

var hasRequiredDocExampleRole;

function requireDocExampleRole () {
	if (hasRequiredDocExampleRole) return docExampleRole;
	hasRequiredDocExampleRole = 1;

	Object.defineProperty(docExampleRole, "__esModule", {
	  value: true
	});
	docExampleRole.default = void 0;
	var docExampleRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docExampleRole.default = docExampleRole$1;
	return docExampleRole;
}

var docFootnoteRole = {};

var hasRequiredDocFootnoteRole;

function requireDocFootnoteRole () {
	if (hasRequiredDocFootnoteRole) return docFootnoteRole;
	hasRequiredDocFootnoteRole = 1;

	Object.defineProperty(docFootnoteRole, "__esModule", {
	  value: true
	});
	docFootnoteRole.default = void 0;
	var docFootnoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'footnote [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docFootnoteRole.default = docFootnoteRole$1;
	return docFootnoteRole;
}

var docForewordRole = {};

var hasRequiredDocForewordRole;

function requireDocForewordRole () {
	if (hasRequiredDocForewordRole) return docForewordRole;
	hasRequiredDocForewordRole = 1;

	Object.defineProperty(docForewordRole, "__esModule", {
	  value: true
	});
	docForewordRole.default = void 0;
	var docForewordRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'foreword [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docForewordRole.default = docForewordRole$1;
	return docForewordRole;
}

var docGlossaryRole = {};

var hasRequiredDocGlossaryRole;

function requireDocGlossaryRole () {
	if (hasRequiredDocGlossaryRole) return docGlossaryRole;
	hasRequiredDocGlossaryRole = 1;

	Object.defineProperty(docGlossaryRole, "__esModule", {
	  value: true
	});
	docGlossaryRole.default = void 0;
	var docGlossaryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'glossary [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['definition'], ['term']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docGlossaryRole.default = docGlossaryRole$1;
	return docGlossaryRole;
}

var docGlossrefRole = {};

var hasRequiredDocGlossrefRole;

function requireDocGlossrefRole () {
	if (hasRequiredDocGlossrefRole) return docGlossrefRole;
	hasRequiredDocGlossrefRole = 1;

	Object.defineProperty(docGlossrefRole, "__esModule", {
	  value: true
	});
	docGlossrefRole.default = void 0;
	var docGlossrefRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'glossref [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	docGlossrefRole.default = docGlossrefRole$1;
	return docGlossrefRole;
}

var docIndexRole = {};

var hasRequiredDocIndexRole;

function requireDocIndexRole () {
	if (hasRequiredDocIndexRole) return docIndexRole;
	hasRequiredDocIndexRole = 1;

	Object.defineProperty(docIndexRole, "__esModule", {
	  value: true
	});
	docIndexRole.default = void 0;
	var docIndexRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'index [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
	};
	docIndexRole.default = docIndexRole$1;
	return docIndexRole;
}

var docIntroductionRole = {};

var hasRequiredDocIntroductionRole;

function requireDocIntroductionRole () {
	if (hasRequiredDocIntroductionRole) return docIntroductionRole;
	hasRequiredDocIntroductionRole = 1;

	Object.defineProperty(docIntroductionRole, "__esModule", {
	  value: true
	});
	docIntroductionRole.default = void 0;
	var docIntroductionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'introduction [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docIntroductionRole.default = docIntroductionRole$1;
	return docIntroductionRole;
}

var docNoterefRole = {};

var hasRequiredDocNoterefRole;

function requireDocNoterefRole () {
	if (hasRequiredDocNoterefRole) return docNoterefRole;
	hasRequiredDocNoterefRole = 1;

	Object.defineProperty(docNoterefRole, "__esModule", {
	  value: true
	});
	docNoterefRole.default = void 0;
	var docNoterefRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'noteref [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	docNoterefRole.default = docNoterefRole$1;
	return docNoterefRole;
}

var docNoticeRole = {};

var hasRequiredDocNoticeRole;

function requireDocNoticeRole () {
	if (hasRequiredDocNoticeRole) return docNoticeRole;
	hasRequiredDocNoticeRole = 1;

	Object.defineProperty(docNoticeRole, "__esModule", {
	  value: true
	});
	docNoticeRole.default = void 0;
	var docNoticeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'notice [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'note']]
	};
	docNoticeRole.default = docNoticeRole$1;
	return docNoticeRole;
}

var docPagebreakRole = {};

var hasRequiredDocPagebreakRole;

function requireDocPagebreakRole () {
	if (hasRequiredDocPagebreakRole) return docPagebreakRole;
	hasRequiredDocPagebreakRole = 1;

	Object.defineProperty(docPagebreakRole, "__esModule", {
	  value: true
	});
	docPagebreakRole.default = void 0;
	var docPagebreakRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'pagebreak [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'separator']]
	};
	docPagebreakRole.default = docPagebreakRole$1;
	return docPagebreakRole;
}

var docPagefooterRole = {};

var hasRequiredDocPagefooterRole;

function requireDocPagefooterRole () {
	if (hasRequiredDocPagefooterRole) return docPagefooterRole;
	hasRequiredDocPagefooterRole = 1;

	Object.defineProperty(docPagefooterRole, "__esModule", {
	  value: true
	});
	docPagefooterRole.default = void 0;
	var docPagefooterRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: [],
	  props: {
	    'aria-braillelabel': null,
	    'aria-brailleroledescription': null,
	    'aria-description': null,
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docPagefooterRole.default = docPagefooterRole$1;
	return docPagefooterRole;
}

var docPageheaderRole = {};

var hasRequiredDocPageheaderRole;

function requireDocPageheaderRole () {
	if (hasRequiredDocPageheaderRole) return docPageheaderRole;
	hasRequiredDocPageheaderRole = 1;

	Object.defineProperty(docPageheaderRole, "__esModule", {
	  value: true
	});
	docPageheaderRole.default = void 0;
	var docPageheaderRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: [],
	  props: {
	    'aria-braillelabel': null,
	    'aria-brailleroledescription': null,
	    'aria-description': null,
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docPageheaderRole.default = docPageheaderRole$1;
	return docPageheaderRole;
}

var docPagelistRole = {};

var hasRequiredDocPagelistRole;

function requireDocPagelistRole () {
	if (hasRequiredDocPagelistRole) return docPagelistRole;
	hasRequiredDocPagelistRole = 1;

	Object.defineProperty(docPagelistRole, "__esModule", {
	  value: true
	});
	docPagelistRole.default = void 0;
	var docPagelistRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'page-list [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
	};
	docPagelistRole.default = docPagelistRole$1;
	return docPagelistRole;
}

var docPartRole = {};

var hasRequiredDocPartRole;

function requireDocPartRole () {
	if (hasRequiredDocPartRole) return docPartRole;
	hasRequiredDocPartRole = 1;

	Object.defineProperty(docPartRole, "__esModule", {
	  value: true
	});
	docPartRole.default = void 0;
	var docPartRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'part [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docPartRole.default = docPartRole$1;
	return docPartRole;
}

var docPrefaceRole = {};

var hasRequiredDocPrefaceRole;

function requireDocPrefaceRole () {
	if (hasRequiredDocPrefaceRole) return docPrefaceRole;
	hasRequiredDocPrefaceRole = 1;

	Object.defineProperty(docPrefaceRole, "__esModule", {
	  value: true
	});
	docPrefaceRole.default = void 0;
	var docPrefaceRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'preface [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docPrefaceRole.default = docPrefaceRole$1;
	return docPrefaceRole;
}

var docPrologueRole = {};

var hasRequiredDocPrologueRole;

function requireDocPrologueRole () {
	if (hasRequiredDocPrologueRole) return docPrologueRole;
	hasRequiredDocPrologueRole = 1;

	Object.defineProperty(docPrologueRole, "__esModule", {
	  value: true
	});
	docPrologueRole.default = void 0;
	var docPrologueRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'prologue [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	docPrologueRole.default = docPrologueRole$1;
	return docPrologueRole;
}

var docPullquoteRole = {};

var hasRequiredDocPullquoteRole;

function requireDocPullquoteRole () {
	if (hasRequiredDocPullquoteRole) return docPullquoteRole;
	hasRequiredDocPullquoteRole = 1;

	Object.defineProperty(docPullquoteRole, "__esModule", {
	  value: true
	});
	docPullquoteRole.default = void 0;
	var docPullquoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'pullquote [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['none']]
	};
	docPullquoteRole.default = docPullquoteRole$1;
	return docPullquoteRole;
}

var docQnaRole = {};

var hasRequiredDocQnaRole;

function requireDocQnaRole () {
	if (hasRequiredDocQnaRole) return docQnaRole;
	hasRequiredDocQnaRole = 1;

	Object.defineProperty(docQnaRole, "__esModule", {
	  value: true
	});
	docQnaRole.default = void 0;
	var docQnaRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'qna [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	docQnaRole.default = docQnaRole$1;
	return docQnaRole;
}

var docSubtitleRole = {};

var hasRequiredDocSubtitleRole;

function requireDocSubtitleRole () {
	if (hasRequiredDocSubtitleRole) return docSubtitleRole;
	hasRequiredDocSubtitleRole = 1;

	Object.defineProperty(docSubtitleRole, "__esModule", {
	  value: true
	});
	docSubtitleRole.default = void 0;
	var docSubtitleRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'subtitle [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'sectionhead']]
	};
	docSubtitleRole.default = docSubtitleRole$1;
	return docSubtitleRole;
}

var docTipRole = {};

var hasRequiredDocTipRole;

function requireDocTipRole () {
	if (hasRequiredDocTipRole) return docTipRole;
	hasRequiredDocTipRole = 1;

	Object.defineProperty(docTipRole, "__esModule", {
	  value: true
	});
	docTipRole.default = void 0;
	var docTipRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'help [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'note']]
	};
	docTipRole.default = docTipRole$1;
	return docTipRole;
}

var docTocRole = {};

var hasRequiredDocTocRole;

function requireDocTocRole () {
	if (hasRequiredDocTocRole) return docTocRole;
	hasRequiredDocTocRole = 1;

	Object.defineProperty(docTocRole, "__esModule", {
	  value: true
	});
	docTocRole.default = void 0;
	var docTocRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'toc [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
	};
	docTocRole.default = docTocRole$1;
	return docTocRole;
}

var hasRequiredAriaDpubRoles;

function requireAriaDpubRoles () {
	if (hasRequiredAriaDpubRoles) return ariaDpubRoles;
	hasRequiredAriaDpubRoles = 1;

	Object.defineProperty(ariaDpubRoles, "__esModule", {
	  value: true
	});
	ariaDpubRoles.default = void 0;
	var _docAbstractRole = _interopRequireDefault(requireDocAbstractRole());
	var _docAcknowledgmentsRole = _interopRequireDefault(requireDocAcknowledgmentsRole());
	var _docAfterwordRole = _interopRequireDefault(requireDocAfterwordRole());
	var _docAppendixRole = _interopRequireDefault(requireDocAppendixRole());
	var _docBacklinkRole = _interopRequireDefault(requireDocBacklinkRole());
	var _docBiblioentryRole = _interopRequireDefault(requireDocBiblioentryRole());
	var _docBibliographyRole = _interopRequireDefault(requireDocBibliographyRole());
	var _docBibliorefRole = _interopRequireDefault(requireDocBibliorefRole());
	var _docChapterRole = _interopRequireDefault(requireDocChapterRole());
	var _docColophonRole = _interopRequireDefault(requireDocColophonRole());
	var _docConclusionRole = _interopRequireDefault(requireDocConclusionRole());
	var _docCoverRole = _interopRequireDefault(requireDocCoverRole());
	var _docCreditRole = _interopRequireDefault(requireDocCreditRole());
	var _docCreditsRole = _interopRequireDefault(requireDocCreditsRole());
	var _docDedicationRole = _interopRequireDefault(requireDocDedicationRole());
	var _docEndnoteRole = _interopRequireDefault(requireDocEndnoteRole());
	var _docEndnotesRole = _interopRequireDefault(requireDocEndnotesRole());
	var _docEpigraphRole = _interopRequireDefault(requireDocEpigraphRole());
	var _docEpilogueRole = _interopRequireDefault(requireDocEpilogueRole());
	var _docErrataRole = _interopRequireDefault(requireDocErrataRole());
	var _docExampleRole = _interopRequireDefault(requireDocExampleRole());
	var _docFootnoteRole = _interopRequireDefault(requireDocFootnoteRole());
	var _docForewordRole = _interopRequireDefault(requireDocForewordRole());
	var _docGlossaryRole = _interopRequireDefault(requireDocGlossaryRole());
	var _docGlossrefRole = _interopRequireDefault(requireDocGlossrefRole());
	var _docIndexRole = _interopRequireDefault(requireDocIndexRole());
	var _docIntroductionRole = _interopRequireDefault(requireDocIntroductionRole());
	var _docNoterefRole = _interopRequireDefault(requireDocNoterefRole());
	var _docNoticeRole = _interopRequireDefault(requireDocNoticeRole());
	var _docPagebreakRole = _interopRequireDefault(requireDocPagebreakRole());
	var _docPagefooterRole = _interopRequireDefault(requireDocPagefooterRole());
	var _docPageheaderRole = _interopRequireDefault(requireDocPageheaderRole());
	var _docPagelistRole = _interopRequireDefault(requireDocPagelistRole());
	var _docPartRole = _interopRequireDefault(requireDocPartRole());
	var _docPrefaceRole = _interopRequireDefault(requireDocPrefaceRole());
	var _docPrologueRole = _interopRequireDefault(requireDocPrologueRole());
	var _docPullquoteRole = _interopRequireDefault(requireDocPullquoteRole());
	var _docQnaRole = _interopRequireDefault(requireDocQnaRole());
	var _docSubtitleRole = _interopRequireDefault(requireDocSubtitleRole());
	var _docTipRole = _interopRequireDefault(requireDocTipRole());
	var _docTocRole = _interopRequireDefault(requireDocTocRole());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	var ariaDpubRoles$1 = [['doc-abstract', _docAbstractRole.default], ['doc-acknowledgments', _docAcknowledgmentsRole.default], ['doc-afterword', _docAfterwordRole.default], ['doc-appendix', _docAppendixRole.default], ['doc-backlink', _docBacklinkRole.default], ['doc-biblioentry', _docBiblioentryRole.default], ['doc-bibliography', _docBibliographyRole.default], ['doc-biblioref', _docBibliorefRole.default], ['doc-chapter', _docChapterRole.default], ['doc-colophon', _docColophonRole.default], ['doc-conclusion', _docConclusionRole.default], ['doc-cover', _docCoverRole.default], ['doc-credit', _docCreditRole.default], ['doc-credits', _docCreditsRole.default], ['doc-dedication', _docDedicationRole.default], ['doc-endnote', _docEndnoteRole.default], ['doc-endnotes', _docEndnotesRole.default], ['doc-epigraph', _docEpigraphRole.default], ['doc-epilogue', _docEpilogueRole.default], ['doc-errata', _docErrataRole.default], ['doc-example', _docExampleRole.default], ['doc-footnote', _docFootnoteRole.default], ['doc-foreword', _docForewordRole.default], ['doc-glossary', _docGlossaryRole.default], ['doc-glossref', _docGlossrefRole.default], ['doc-index', _docIndexRole.default], ['doc-introduction', _docIntroductionRole.default], ['doc-noteref', _docNoterefRole.default], ['doc-notice', _docNoticeRole.default], ['doc-pagebreak', _docPagebreakRole.default], ['doc-pagefooter', _docPagefooterRole.default], ['doc-pageheader', _docPageheaderRole.default], ['doc-pagelist', _docPagelistRole.default], ['doc-part', _docPartRole.default], ['doc-preface', _docPrefaceRole.default], ['doc-prologue', _docPrologueRole.default], ['doc-pullquote', _docPullquoteRole.default], ['doc-qna', _docQnaRole.default], ['doc-subtitle', _docSubtitleRole.default], ['doc-tip', _docTipRole.default], ['doc-toc', _docTocRole.default]];
	ariaDpubRoles.default = ariaDpubRoles$1;
	return ariaDpubRoles;
}

var ariaGraphicsRoles = {};

var graphicsDocumentRole = {};

var hasRequiredGraphicsDocumentRole;

function requireGraphicsDocumentRole () {
	if (hasRequiredGraphicsDocumentRole) return graphicsDocumentRole;
	hasRequiredGraphicsDocumentRole = 1;

	Object.defineProperty(graphicsDocumentRole, "__esModule", {
	  value: true
	});
	graphicsDocumentRole.default = void 0;
	var graphicsDocumentRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    module: 'GRAPHICS',
	    concept: {
	      name: 'graphics-object'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'img'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'article'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'document']]
	};
	graphicsDocumentRole.default = graphicsDocumentRole$1;
	return graphicsDocumentRole;
}

var graphicsObjectRole = {};

var hasRequiredGraphicsObjectRole;

function requireGraphicsObjectRole () {
	if (hasRequiredGraphicsObjectRole) return graphicsObjectRole;
	hasRequiredGraphicsObjectRole = 1;

	Object.defineProperty(graphicsObjectRole, "__esModule", {
	  value: true
	});
	graphicsObjectRole.default = void 0;
	var graphicsObjectRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    module: 'GRAPHICS',
	    concept: {
	      name: 'graphics-document'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'group'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'img'
	    }
	  }, {
	    module: 'GRAPHICS',
	    concept: {
	      name: 'graphics-symbol'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'group']]
	};
	graphicsObjectRole.default = graphicsObjectRole$1;
	return graphicsObjectRole;
}

var graphicsSymbolRole = {};

var hasRequiredGraphicsSymbolRole;

function requireGraphicsSymbolRole () {
	if (hasRequiredGraphicsSymbolRole) return graphicsSymbolRole;
	hasRequiredGraphicsSymbolRole = 1;

	Object.defineProperty(graphicsSymbolRole, "__esModule", {
	  value: true
	});
	graphicsSymbolRole.default = void 0;
	var graphicsSymbolRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'img']]
	};
	graphicsSymbolRole.default = graphicsSymbolRole$1;
	return graphicsSymbolRole;
}

var hasRequiredAriaGraphicsRoles;

function requireAriaGraphicsRoles () {
	if (hasRequiredAriaGraphicsRoles) return ariaGraphicsRoles;
	hasRequiredAriaGraphicsRoles = 1;

	Object.defineProperty(ariaGraphicsRoles, "__esModule", {
	  value: true
	});
	ariaGraphicsRoles.default = void 0;
	var _graphicsDocumentRole = _interopRequireDefault(requireGraphicsDocumentRole());
	var _graphicsObjectRole = _interopRequireDefault(requireGraphicsObjectRole());
	var _graphicsSymbolRole = _interopRequireDefault(requireGraphicsSymbolRole());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	var ariaGraphicsRoles$1 = [['graphics-document', _graphicsDocumentRole.default], ['graphics-object', _graphicsObjectRole.default], ['graphics-symbol', _graphicsSymbolRole.default]];
	ariaGraphicsRoles.default = ariaGraphicsRoles$1;
	return ariaGraphicsRoles;
}

var hasRequiredRolesMap;

function requireRolesMap () {
	if (hasRequiredRolesMap) return rolesMap;
	hasRequiredRolesMap = 1;

	Object.defineProperty(rolesMap, "__esModule", {
	  value: true
	});
	rolesMap.default = void 0;
	var _ariaAbstractRoles = _interopRequireDefault(requireAriaAbstractRoles());
	var _ariaLiteralRoles = _interopRequireDefault(requireAriaLiteralRoles());
	var _ariaDpubRoles = _interopRequireDefault(requireAriaDpubRoles());
	var _ariaGraphicsRoles = _interopRequireDefault(requireAriaGraphicsRoles());
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: true } : { done: false, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = true, u = false; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = true, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
	function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
	function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
	var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
	roles.forEach(function (_ref) {
	  var _ref2 = _slicedToArray(_ref, 2),
	    roleDefinition = _ref2[1];
	  // Conglomerate the properties
	  var _iterator = _createForOfIteratorHelper(roleDefinition.superClass),
	    _step;
	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var superClassIter = _step.value;
	      var _iterator2 = _createForOfIteratorHelper(superClassIter),
	        _step2;
	      try {
	        var _loop = function _loop() {
	          var superClassName = _step2.value;
	          var superClassRoleTuple = roles.filter(function (_ref3) {
	            var _ref4 = _slicedToArray(_ref3, 1),
	              name = _ref4[0];
	            return name === superClassName;
	          })[0];
	          if (superClassRoleTuple) {
	            var superClassDefinition = superClassRoleTuple[1];
	            for (var _i = 0, _Object$keys = Object.keys(superClassDefinition.props); _i < _Object$keys.length; _i++) {
	              var prop = _Object$keys[_i];
	              if (
	              // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
	              !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)) {
	                // $FlowIgnore assigning without an index signature is fine
	                roleDefinition.props[prop] = superClassDefinition.props[prop];
	              }
	            }
	          }
	        };
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          _loop();
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }
	});
	var rolesMap$1 = {
	  entries: function entries() {
	    return roles;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator3 = _createForOfIteratorHelper(roles),
	      _step3;
	    try {
	      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	        var _step3$value = _slicedToArray(_step3.value, 2),
	          key = _step3$value[0],
	          values = _step3$value[1];
	        fn.call(thisArg, values, key, roles);
	      }
	    } catch (err) {
	      _iterator3.e(err);
	    } finally {
	      _iterator3.f();
	    }
	  },
	  get: function get(key) {
	    var item = roles.filter(function (tuple) {
	      return tuple[0] === key ? true : false;
	    })[0];
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!rolesMap$1.get(key);
	  },
	  keys: function keys() {
	    return roles.map(function (_ref5) {
	      var _ref6 = _slicedToArray(_ref5, 1),
	        key = _ref6[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return roles.map(function (_ref7) {
	      var _ref8 = _slicedToArray(_ref7, 2),
	        values = _ref8[1];
	      return values;
	    });
	  }
	};
	rolesMap.default = (0, _iterationDecorator.default)(rolesMap$1, rolesMap$1.entries());
	return rolesMap;
}

var elementRoleMap = {};

var hasRequiredElementRoleMap;

function requireElementRoleMap () {
	if (hasRequiredElementRoleMap) return elementRoleMap;
	hasRequiredElementRoleMap = 1;

	Object.defineProperty(elementRoleMap, "__esModule", {
	  value: true
	});
	elementRoleMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	var _rolesMap = _interopRequireDefault(requireRolesMap());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
	function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
	var elementRoles = [];
	var keys = _rolesMap.default.keys();
	for (var i = 0; i < keys.length; i++) {
	  var key = keys[i];
	  var role = _rolesMap.default.get(key);
	  if (role) {
	    var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
	    var _loop = function _loop() {
	      var relation = concepts[k];
	      if (relation.module === 'HTML') {
	        var concept = relation.concept;
	        if (concept) {
	          var elementRoleRelation = elementRoles.filter(function (relation) {
	            return ariaRoleRelationConceptEquals(relation[0], concept);
	          })[0];
	          var roles;
	          if (elementRoleRelation) {
	            roles = elementRoleRelation[1];
	          } else {
	            roles = [];
	          }
	          var isUnique = true;
	          for (var _i = 0; _i < roles.length; _i++) {
	            if (roles[_i] === key) {
	              isUnique = false;
	              break;
	            }
	          }
	          if (isUnique) {
	            roles.push(key);
	          }
	          if (!elementRoleRelation) {
	            elementRoles.push([concept, roles]);
	          }
	        }
	      }
	    };
	    for (var k = 0; k < concepts.length; k++) {
	      _loop();
	    }
	  }
	}
	var elementRoleMap$1 = {
	  entries: function entries() {
	    return elementRoles;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i2 = 0, _elementRoles = elementRoles; _i2 < _elementRoles.length; _i2++) {
	      var _elementRoles$_i = _slicedToArray(_elementRoles[_i2], 2),
	        _key = _elementRoles$_i[0],
	        values = _elementRoles$_i[1];
	      fn.call(thisArg, values, _key, elementRoles);
	    }
	  },
	  get: function get(key) {
	    var item = elementRoles.filter(function (tuple) {
	      return key.name === tuple[0].name && ariaRoleRelationConceptAttributeEquals(key.attributes, tuple[0].attributes);
	    })[0];
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!elementRoleMap$1.get(key);
	  },
	  keys: function keys() {
	    return elementRoles.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return elementRoles.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	function ariaRoleRelationConceptEquals(a, b) {
	  return a.name === b.name && ariaRoleRelationConstraintsEquals(a.constraints, b.constraints) && ariaRoleRelationConceptAttributeEquals(a.attributes, b.attributes);
	}
	function ariaRoleRelationConstraintsEquals(a, b) {
	  if (a === undefined && b !== undefined) {
	    return false;
	  }
	  if (a !== undefined && b === undefined) {
	    return false;
	  }
	  if (a !== undefined && b !== undefined) {
	    if (a.length !== b.length) {
	      return false;
	    }
	    for (var _i3 = 0; _i3 < a.length; _i3++) {
	      if (a[_i3] !== b[_i3]) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	function ariaRoleRelationConceptAttributeEquals(a, b) {
	  if (a === undefined && b !== undefined) {
	    return false;
	  }
	  if (a !== undefined && b === undefined) {
	    return false;
	  }
	  if (a !== undefined && b !== undefined) {
	    if (a.length !== b.length) {
	      return false;
	    }
	    for (var _i4 = 0; _i4 < a.length; _i4++) {
	      if (a[_i4].name !== b[_i4].name || a[_i4].value !== b[_i4].value) {
	        return false;
	      }
	      if (a[_i4].constraints === undefined && b[_i4].constraints !== undefined) {
	        return false;
	      }
	      if (a[_i4].constraints !== undefined && b[_i4].constraints === undefined) {
	        return false;
	      }
	      if (a[_i4].constraints !== undefined && b[_i4].constraints !== undefined) {
	        if (a[_i4].constraints.length !== b[_i4].constraints.length) {
	          return false;
	        }
	        for (var j = 0; j < a[_i4].constraints.length; j++) {
	          if (a[_i4].constraints[j] !== b[_i4].constraints[j]) {
	            return false;
	          }
	        }
	      }
	    }
	  }
	  return true;
	}
	elementRoleMap.default = (0, _iterationDecorator.default)(elementRoleMap$1, elementRoleMap$1.entries());
	return elementRoleMap;
}

var roleElementMap = {};

var hasRequiredRoleElementMap;

function requireRoleElementMap () {
	if (hasRequiredRoleElementMap) return roleElementMap;
	hasRequiredRoleElementMap = 1;

	Object.defineProperty(roleElementMap, "__esModule", {
	  value: true
	});
	roleElementMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	var _rolesMap = _interopRequireDefault(requireRolesMap());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
	function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
	var roleElement = [];
	var keys = _rolesMap.default.keys();
	for (var i = 0; i < keys.length; i++) {
	  var key = keys[i];
	  var role = _rolesMap.default.get(key);
	  var relationConcepts = [];
	  if (role) {
	    var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
	    for (var k = 0; k < concepts.length; k++) {
	      var relation = concepts[k];
	      if (relation.module === 'HTML') {
	        var concept = relation.concept;
	        if (concept != null) {
	          relationConcepts.push(concept);
	        }
	      }
	    }
	    if (relationConcepts.length > 0) {
	      roleElement.push([key, relationConcepts]);
	    }
	  }
	}
	var roleElementMap$1 = {
	  entries: function entries() {
	    return roleElement;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i = 0, _roleElement = roleElement; _i < _roleElement.length; _i++) {
	      var _roleElement$_i = _slicedToArray(_roleElement[_i], 2),
	        _key = _roleElement$_i[0],
	        values = _roleElement$_i[1];
	      fn.call(thisArg, values, _key, roleElement);
	    }
	  },
	  get: function get(key) {
	    var item = roleElement.filter(function (tuple) {
	      return tuple[0] === key ? true : false;
	    })[0];
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!roleElementMap$1.get(key);
	  },
	  keys: function keys() {
	    return roleElement.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return roleElement.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	roleElementMap.default = (0, _iterationDecorator.default)(roleElementMap$1, roleElementMap$1.entries());
	return roleElementMap;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$2;
	hasRequiredLib$2 = 1;

	Object.defineProperty(lib$2, "__esModule", {
	  value: true
	});
	lib$2.roles = lib$2.roleElements = lib$2.elementRoles = lib$2.dom = lib$2.aria = void 0;
	var _ariaPropsMap = _interopRequireDefault(requireAriaPropsMap());
	var _domMap = _interopRequireDefault(requireDomMap());
	var _rolesMap = _interopRequireDefault(requireRolesMap());
	var _elementRoleMap = _interopRequireDefault(requireElementRoleMap());
	var _roleElementMap = _interopRequireDefault(requireRoleElementMap());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	lib$2.aria = _ariaPropsMap.default;
	lib$2.dom = _domMap.default;
	lib$2.roles = _rolesMap.default;
	lib$2.elementRoles = _elementRoleMap.default;
	lib$2.roleElements = _roleElementMap.default;
	return lib$2;
}

var libExports$1 = requireLib$2();

var lib$1 = {};

var AXObjectElementMap = {};

var iterationDecorator = {};

var iteratorProxy = {};

var hasRequiredIteratorProxy;

function requireIteratorProxy () {
	if (hasRequiredIteratorProxy) return iteratorProxy;
	hasRequiredIteratorProxy = 1;

	Object.defineProperty(iteratorProxy, "__esModule", {
	  value: true
	});
	iteratorProxy.default = void 0;
	// eslint-disable-next-line no-unused-vars
	function iteratorProxy$1() {
	  var values = this;
	  var index = 0;
	  var iter = {
	    '@@iterator': function iterator() {
	      return iter;
	    },
	    next: function next() {
	      if (index < values.length) {
	        var value = values[index];
	        index = index + 1;
	        return {
	          done: false,
	          value: value
	        };
	      } else {
	        return {
	          done: true
	        };
	      }
	    }
	  };
	  return iter;
	}
	var _default = iteratorProxy$1;
	iteratorProxy.default = _default;
	return iteratorProxy;
}

var hasRequiredIterationDecorator;

function requireIterationDecorator () {
	if (hasRequiredIterationDecorator) return iterationDecorator;
	hasRequiredIterationDecorator = 1;

	Object.defineProperty(iterationDecorator, "__esModule", {
	  value: true
	});
	iterationDecorator.default = iterationDecorator$1;
	var _iteratorProxy = _interopRequireDefault(requireIteratorProxy());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
	function iterationDecorator$1(collection, entries) {
	  if (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol') {
	    Object.defineProperty(collection, Symbol.iterator, {
	      value: _iteratorProxy.default.bind(entries)
	    });
	  }
	  return collection;
	}
	return iterationDecorator;
}

var AXObjectsMap = {};

var AbbrRole = {};

var hasRequiredAbbrRole;

function requireAbbrRole () {
	if (hasRequiredAbbrRole) return AbbrRole;
	hasRequiredAbbrRole = 1;

	Object.defineProperty(AbbrRole, "__esModule", {
	  value: true
	});
	AbbrRole.default = void 0;
	var AbbrRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'abbr'
	    }
	  }],
	  type: 'structure'
	};
	var _default = AbbrRole$1;
	AbbrRole.default = _default;
	return AbbrRole;
}

var AlertDialogRole = {};

var hasRequiredAlertDialogRole;

function requireAlertDialogRole () {
	if (hasRequiredAlertDialogRole) return AlertDialogRole;
	hasRequiredAlertDialogRole = 1;

	Object.defineProperty(AlertDialogRole, "__esModule", {
	  value: true
	});
	AlertDialogRole.default = void 0;
	var AlertDialogRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'alertdialog'
	    }
	  }],
	  type: 'window'
	};
	var _default = AlertDialogRole$1;
	AlertDialogRole.default = _default;
	return AlertDialogRole;
}

var AlertRole = {};

var hasRequiredAlertRole;

function requireAlertRole () {
	if (hasRequiredAlertRole) return AlertRole;
	hasRequiredAlertRole = 1;

	Object.defineProperty(AlertRole, "__esModule", {
	  value: true
	});
	AlertRole.default = void 0;
	var AlertRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'alert'
	    }
	  }],
	  type: 'structure'
	};
	var _default = AlertRole$1;
	AlertRole.default = _default;
	return AlertRole;
}

var AnnotationRole = {};

var hasRequiredAnnotationRole;

function requireAnnotationRole () {
	if (hasRequiredAnnotationRole) return AnnotationRole;
	hasRequiredAnnotationRole = 1;

	Object.defineProperty(AnnotationRole, "__esModule", {
	  value: true
	});
	AnnotationRole.default = void 0;
	var AnnotationRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = AnnotationRole$1;
	AnnotationRole.default = _default;
	return AnnotationRole;
}

var ApplicationRole = {};

var hasRequiredApplicationRole;

function requireApplicationRole () {
	if (hasRequiredApplicationRole) return ApplicationRole;
	hasRequiredApplicationRole = 1;

	Object.defineProperty(ApplicationRole, "__esModule", {
	  value: true
	});
	ApplicationRole.default = void 0;
	var ApplicationRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'application'
	    }
	  }],
	  type: 'window'
	};
	var _default = ApplicationRole$1;
	ApplicationRole.default = _default;
	return ApplicationRole;
}

var ArticleRole = {};

var hasRequiredArticleRole;

function requireArticleRole () {
	if (hasRequiredArticleRole) return ArticleRole;
	hasRequiredArticleRole = 1;

	Object.defineProperty(ArticleRole, "__esModule", {
	  value: true
	});
	ArticleRole.default = void 0;
	var ArticleRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'article'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'article'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ArticleRole$1;
	ArticleRole.default = _default;
	return ArticleRole;
}

var AudioRole = {};

var hasRequiredAudioRole;

function requireAudioRole () {
	if (hasRequiredAudioRole) return AudioRole;
	hasRequiredAudioRole = 1;

	Object.defineProperty(AudioRole, "__esModule", {
	  value: true
	});
	AudioRole.default = void 0;
	var AudioRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'audio'
	    }
	  }],
	  type: 'widget'
	};
	var _default = AudioRole$1;
	AudioRole.default = _default;
	return AudioRole;
}

var BannerRole = {};

var hasRequiredBannerRole;

function requireBannerRole () {
	if (hasRequiredBannerRole) return BannerRole;
	hasRequiredBannerRole = 1;

	Object.defineProperty(BannerRole, "__esModule", {
	  value: true
	});
	BannerRole.default = void 0;
	var BannerRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'banner'
	    }
	  }],
	  type: 'structure'
	};
	var _default = BannerRole$1;
	BannerRole.default = _default;
	return BannerRole;
}

var BlockquoteRole = {};

var hasRequiredBlockquoteRole;

function requireBlockquoteRole () {
	if (hasRequiredBlockquoteRole) return BlockquoteRole;
	hasRequiredBlockquoteRole = 1;

	Object.defineProperty(BlockquoteRole, "__esModule", {
	  value: true
	});
	BlockquoteRole.default = void 0;
	var BlockquoteRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'blockquote'
	    }
	  }],
	  type: 'structure'
	};
	var _default = BlockquoteRole$1;
	BlockquoteRole.default = _default;
	return BlockquoteRole;
}

var BusyIndicatorRole = {};

var hasRequiredBusyIndicatorRole;

function requireBusyIndicatorRole () {
	if (hasRequiredBusyIndicatorRole) return BusyIndicatorRole;
	hasRequiredBusyIndicatorRole = 1;

	Object.defineProperty(BusyIndicatorRole, "__esModule", {
	  value: true
	});
	BusyIndicatorRole.default = void 0;
	var BusyIndicatorRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      attributes: [{
	        name: 'aria-busy',
	        value: 'true'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = BusyIndicatorRole$1;
	BusyIndicatorRole.default = _default;
	return BusyIndicatorRole;
}

var ButtonRole = {};

var hasRequiredButtonRole;

function requireButtonRole () {
	if (hasRequiredButtonRole) return ButtonRole;
	hasRequiredButtonRole = 1;

	Object.defineProperty(ButtonRole, "__esModule", {
	  value: true
	});
	ButtonRole.default = void 0;
	var ButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'button'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'button'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ButtonRole$1;
	ButtonRole.default = _default;
	return ButtonRole;
}

var CanvasRole = {};

var hasRequiredCanvasRole;

function requireCanvasRole () {
	if (hasRequiredCanvasRole) return CanvasRole;
	hasRequiredCanvasRole = 1;

	Object.defineProperty(CanvasRole, "__esModule", {
	  value: true
	});
	CanvasRole.default = void 0;
	var CanvasRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'canvas'
	    }
	  }],
	  type: 'widget'
	};
	var _default = CanvasRole$1;
	CanvasRole.default = _default;
	return CanvasRole;
}

var CaptionRole = {};

var hasRequiredCaptionRole;

function requireCaptionRole () {
	if (hasRequiredCaptionRole) return CaptionRole;
	hasRequiredCaptionRole = 1;

	Object.defineProperty(CaptionRole, "__esModule", {
	  value: true
	});
	CaptionRole.default = void 0;
	var CaptionRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'caption'
	    }
	  }],
	  type: 'structure'
	};
	var _default = CaptionRole$1;
	CaptionRole.default = _default;
	return CaptionRole;
}

var CellRole = {};

var hasRequiredCellRole;

function requireCellRole () {
	if (hasRequiredCellRole) return CellRole;
	hasRequiredCellRole = 1;

	Object.defineProperty(CellRole, "__esModule", {
	  value: true
	});
	CellRole.default = void 0;
	var CellRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'cell'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'gridcell'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'td'
	    }
	  }],
	  type: 'widget'
	};
	var _default = CellRole$1;
	CellRole.default = _default;
	return CellRole;
}

var CheckBoxRole = {};

var hasRequiredCheckBoxRole;

function requireCheckBoxRole () {
	if (hasRequiredCheckBoxRole) return CheckBoxRole;
	hasRequiredCheckBoxRole = 1;

	Object.defineProperty(CheckBoxRole, "__esModule", {
	  value: true
	});
	CheckBoxRole.default = void 0;
	var CheckBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'checkbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'checkbox'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = CheckBoxRole$1;
	CheckBoxRole.default = _default;
	return CheckBoxRole;
}

var ColorWellRole = {};

var hasRequiredColorWellRole;

function requireColorWellRole () {
	if (hasRequiredColorWellRole) return ColorWellRole;
	hasRequiredColorWellRole = 1;

	Object.defineProperty(ColorWellRole, "__esModule", {
	  value: true
	});
	ColorWellRole.default = void 0;
	var ColorWellRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'color'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = ColorWellRole$1;
	ColorWellRole.default = _default;
	return ColorWellRole;
}

var ColumnHeaderRole = {};

var hasRequiredColumnHeaderRole;

function requireColumnHeaderRole () {
	if (hasRequiredColumnHeaderRole) return ColumnHeaderRole;
	hasRequiredColumnHeaderRole = 1;

	Object.defineProperty(ColumnHeaderRole, "__esModule", {
	  value: true
	});
	ColumnHeaderRole.default = void 0;
	var ColumnHeaderRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'columnheader'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'th'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ColumnHeaderRole$1;
	ColumnHeaderRole.default = _default;
	return ColumnHeaderRole;
}

var ColumnRole = {};

var hasRequiredColumnRole;

function requireColumnRole () {
	if (hasRequiredColumnRole) return ColumnRole;
	hasRequiredColumnRole = 1;

	Object.defineProperty(ColumnRole, "__esModule", {
	  value: true
	});
	ColumnRole.default = void 0;
	var ColumnRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = ColumnRole$1;
	ColumnRole.default = _default;
	return ColumnRole;
}

var ComboBoxRole = {};

var hasRequiredComboBoxRole;

function requireComboBoxRole () {
	if (hasRequiredComboBoxRole) return ComboBoxRole;
	hasRequiredComboBoxRole = 1;

	Object.defineProperty(ComboBoxRole, "__esModule", {
	  value: true
	});
	ComboBoxRole.default = void 0;
	var ComboBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'combobox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'select'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ComboBoxRole$1;
	ComboBoxRole.default = _default;
	return ComboBoxRole;
}

var ComplementaryRole = {};

var hasRequiredComplementaryRole;

function requireComplementaryRole () {
	if (hasRequiredComplementaryRole) return ComplementaryRole;
	hasRequiredComplementaryRole = 1;

	Object.defineProperty(ComplementaryRole, "__esModule", {
	  value: true
	});
	ComplementaryRole.default = void 0;
	var ComplementaryRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'complementary'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ComplementaryRole$1;
	ComplementaryRole.default = _default;
	return ComplementaryRole;
}

var ContentInfoRole = {};

var hasRequiredContentInfoRole;

function requireContentInfoRole () {
	if (hasRequiredContentInfoRole) return ContentInfoRole;
	hasRequiredContentInfoRole = 1;

	Object.defineProperty(ContentInfoRole, "__esModule", {
	  value: true
	});
	ContentInfoRole.default = void 0;
	var ContentInfoRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'structureinfo'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ContentInfoRole$1;
	ContentInfoRole.default = _default;
	return ContentInfoRole;
}

var DateRole = {};

var hasRequiredDateRole;

function requireDateRole () {
	if (hasRequiredDateRole) return DateRole;
	hasRequiredDateRole = 1;

	Object.defineProperty(DateRole, "__esModule", {
	  value: true
	});
	DateRole.default = void 0;
	var DateRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'date'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = DateRole$1;
	DateRole.default = _default;
	return DateRole;
}

var DateTimeRole = {};

var hasRequiredDateTimeRole;

function requireDateTimeRole () {
	if (hasRequiredDateTimeRole) return DateTimeRole;
	hasRequiredDateTimeRole = 1;

	Object.defineProperty(DateTimeRole, "__esModule", {
	  value: true
	});
	DateTimeRole.default = void 0;
	var DateTimeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'datetime'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = DateTimeRole$1;
	DateTimeRole.default = _default;
	return DateTimeRole;
}

var DefinitionRole = {};

var hasRequiredDefinitionRole;

function requireDefinitionRole () {
	if (hasRequiredDefinitionRole) return DefinitionRole;
	hasRequiredDefinitionRole = 1;

	Object.defineProperty(DefinitionRole, "__esModule", {
	  value: true
	});
	DefinitionRole.default = void 0;
	var DefinitionRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dfn'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DefinitionRole$1;
	DefinitionRole.default = _default;
	return DefinitionRole;
}

var DescriptionListDetailRole = {};

var hasRequiredDescriptionListDetailRole;

function requireDescriptionListDetailRole () {
	if (hasRequiredDescriptionListDetailRole) return DescriptionListDetailRole;
	hasRequiredDescriptionListDetailRole = 1;

	Object.defineProperty(DescriptionListDetailRole, "__esModule", {
	  value: true
	});
	DescriptionListDetailRole.default = void 0;
	var DescriptionListDetailRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dd'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DescriptionListDetailRole$1;
	DescriptionListDetailRole.default = _default;
	return DescriptionListDetailRole;
}

var DescriptionListRole = {};

var hasRequiredDescriptionListRole;

function requireDescriptionListRole () {
	if (hasRequiredDescriptionListRole) return DescriptionListRole;
	hasRequiredDescriptionListRole = 1;

	Object.defineProperty(DescriptionListRole, "__esModule", {
	  value: true
	});
	DescriptionListRole.default = void 0;
	var DescriptionListRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dl'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DescriptionListRole$1;
	DescriptionListRole.default = _default;
	return DescriptionListRole;
}

var DescriptionListTermRole = {};

var hasRequiredDescriptionListTermRole;

function requireDescriptionListTermRole () {
	if (hasRequiredDescriptionListTermRole) return DescriptionListTermRole;
	hasRequiredDescriptionListTermRole = 1;

	Object.defineProperty(DescriptionListTermRole, "__esModule", {
	  value: true
	});
	DescriptionListTermRole.default = void 0;
	var DescriptionListTermRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dt'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DescriptionListTermRole$1;
	DescriptionListTermRole.default = _default;
	return DescriptionListTermRole;
}

var DetailsRole = {};

var hasRequiredDetailsRole;

function requireDetailsRole () {
	if (hasRequiredDetailsRole) return DetailsRole;
	hasRequiredDetailsRole = 1;

	Object.defineProperty(DetailsRole, "__esModule", {
	  value: true
	});
	DetailsRole.default = void 0;
	var DetailsRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'details'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DetailsRole$1;
	DetailsRole.default = _default;
	return DetailsRole;
}

var DialogRole = {};

var hasRequiredDialogRole;

function requireDialogRole () {
	if (hasRequiredDialogRole) return DialogRole;
	hasRequiredDialogRole = 1;

	Object.defineProperty(DialogRole, "__esModule", {
	  value: true
	});
	DialogRole.default = void 0;
	var DialogRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'dialog'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'dialog'
	    }
	  }],
	  type: 'window'
	};
	var _default = DialogRole$1;
	DialogRole.default = _default;
	return DialogRole;
}

var DirectoryRole = {};

var hasRequiredDirectoryRole;

function requireDirectoryRole () {
	if (hasRequiredDirectoryRole) return DirectoryRole;
	hasRequiredDirectoryRole = 1;

	Object.defineProperty(DirectoryRole, "__esModule", {
	  value: true
	});
	DirectoryRole.default = void 0;
	var DirectoryRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'directory'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'dir'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DirectoryRole$1;
	DirectoryRole.default = _default;
	return DirectoryRole;
}

var DisclosureTriangleRole = {};

var hasRequiredDisclosureTriangleRole;

function requireDisclosureTriangleRole () {
	if (hasRequiredDisclosureTriangleRole) return DisclosureTriangleRole;
	hasRequiredDisclosureTriangleRole = 1;

	Object.defineProperty(DisclosureTriangleRole, "__esModule", {
	  value: true
	});
	DisclosureTriangleRole.default = void 0;
	var DisclosureTriangleRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      constraints: ['scoped to a details element'],
	      name: 'summary'
	    }
	  }],
	  type: 'widget'
	};
	var _default = DisclosureTriangleRole$1;
	DisclosureTriangleRole.default = _default;
	return DisclosureTriangleRole;
}

var DivRole = {};

var hasRequiredDivRole;

function requireDivRole () {
	if (hasRequiredDivRole) return DivRole;
	hasRequiredDivRole = 1;

	Object.defineProperty(DivRole, "__esModule", {
	  value: true
	});
	DivRole.default = void 0;
	var DivRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'div'
	    }
	  }],
	  type: 'generic'
	};
	var _default = DivRole$1;
	DivRole.default = _default;
	return DivRole;
}

var DocumentRole = {};

var hasRequiredDocumentRole;

function requireDocumentRole () {
	if (hasRequiredDocumentRole) return DocumentRole;
	hasRequiredDocumentRole = 1;

	Object.defineProperty(DocumentRole, "__esModule", {
	  value: true
	});
	DocumentRole.default = void 0;
	var DocumentRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'document'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DocumentRole$1;
	DocumentRole.default = _default;
	return DocumentRole;
}

var EmbeddedObjectRole = {};

var hasRequiredEmbeddedObjectRole;

function requireEmbeddedObjectRole () {
	if (hasRequiredEmbeddedObjectRole) return EmbeddedObjectRole;
	hasRequiredEmbeddedObjectRole = 1;

	Object.defineProperty(EmbeddedObjectRole, "__esModule", {
	  value: true
	});
	EmbeddedObjectRole.default = void 0;
	var EmbeddedObjectRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'embed'
	    }
	  }],
	  type: 'widget'
	};
	var _default = EmbeddedObjectRole$1;
	EmbeddedObjectRole.default = _default;
	return EmbeddedObjectRole;
}

var FeedRole = {};

var hasRequiredFeedRole;

function requireFeedRole () {
	if (hasRequiredFeedRole) return FeedRole;
	hasRequiredFeedRole = 1;

	Object.defineProperty(FeedRole, "__esModule", {
	  value: true
	});
	FeedRole.default = void 0;
	var FeedRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'feed'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FeedRole$1;
	FeedRole.default = _default;
	return FeedRole;
}

var FigcaptionRole = {};

var hasRequiredFigcaptionRole;

function requireFigcaptionRole () {
	if (hasRequiredFigcaptionRole) return FigcaptionRole;
	hasRequiredFigcaptionRole = 1;

	Object.defineProperty(FigcaptionRole, "__esModule", {
	  value: true
	});
	FigcaptionRole.default = void 0;
	var FigcaptionRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'figcaption'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FigcaptionRole$1;
	FigcaptionRole.default = _default;
	return FigcaptionRole;
}

var FigureRole = {};

var hasRequiredFigureRole;

function requireFigureRole () {
	if (hasRequiredFigureRole) return FigureRole;
	hasRequiredFigureRole = 1;

	Object.defineProperty(FigureRole, "__esModule", {
	  value: true
	});
	FigureRole.default = void 0;
	var FigureRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'figure'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'figure'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FigureRole$1;
	FigureRole.default = _default;
	return FigureRole;
}

var FooterRole = {};

var hasRequiredFooterRole;

function requireFooterRole () {
	if (hasRequiredFooterRole) return FooterRole;
	hasRequiredFooterRole = 1;

	Object.defineProperty(FooterRole, "__esModule", {
	  value: true
	});
	FooterRole.default = void 0;
	var FooterRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'footer'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FooterRole$1;
	FooterRole.default = _default;
	return FooterRole;
}

var FormRole = {};

var hasRequiredFormRole;

function requireFormRole () {
	if (hasRequiredFormRole) return FormRole;
	hasRequiredFormRole = 1;

	Object.defineProperty(FormRole, "__esModule", {
	  value: true
	});
	FormRole.default = void 0;
	var FormRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'form'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'form'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FormRole$1;
	FormRole.default = _default;
	return FormRole;
}

var GridRole = {};

var hasRequiredGridRole;

function requireGridRole () {
	if (hasRequiredGridRole) return GridRole;
	hasRequiredGridRole = 1;

	Object.defineProperty(GridRole, "__esModule", {
	  value: true
	});
	GridRole.default = void 0;
	var GridRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'grid'
	    }
	  }],
	  type: 'widget'
	};
	var _default = GridRole$1;
	GridRole.default = _default;
	return GridRole;
}

var GroupRole = {};

var hasRequiredGroupRole;

function requireGroupRole () {
	if (hasRequiredGroupRole) return GroupRole;
	hasRequiredGroupRole = 1;

	Object.defineProperty(GroupRole, "__esModule", {
	  value: true
	});
	GroupRole.default = void 0;
	var GroupRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'group'
	    }
	  }],
	  type: 'structure'
	};
	var _default = GroupRole$1;
	GroupRole.default = _default;
	return GroupRole;
}

var HeadingRole = {};

var hasRequiredHeadingRole;

function requireHeadingRole () {
	if (hasRequiredHeadingRole) return HeadingRole;
	hasRequiredHeadingRole = 1;

	Object.defineProperty(HeadingRole, "__esModule", {
	  value: true
	});
	HeadingRole.default = void 0;
	var HeadingRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'heading'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h1'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h2'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h3'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h4'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h5'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h6'
	    }
	  }],
	  type: 'structure'
	};
	var _default = HeadingRole$1;
	HeadingRole.default = _default;
	return HeadingRole;
}

var IframePresentationalRole = {};

var hasRequiredIframePresentationalRole;

function requireIframePresentationalRole () {
	if (hasRequiredIframePresentationalRole) return IframePresentationalRole;
	hasRequiredIframePresentationalRole = 1;

	Object.defineProperty(IframePresentationalRole, "__esModule", {
	  value: true
	});
	IframePresentationalRole.default = void 0;
	var IframePresentationalRole$1 = {
	  relatedConcepts: [],
	  type: 'window'
	};
	var _default = IframePresentationalRole$1;
	IframePresentationalRole.default = _default;
	return IframePresentationalRole;
}

var IframeRole = {};

var hasRequiredIframeRole;

function requireIframeRole () {
	if (hasRequiredIframeRole) return IframeRole;
	hasRequiredIframeRole = 1;

	Object.defineProperty(IframeRole, "__esModule", {
	  value: true
	});
	IframeRole.default = void 0;
	var IframeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'iframe'
	    }
	  }],
	  type: 'window'
	};
	var _default = IframeRole$1;
	IframeRole.default = _default;
	return IframeRole;
}

var IgnoredRole = {};

var hasRequiredIgnoredRole;

function requireIgnoredRole () {
	if (hasRequiredIgnoredRole) return IgnoredRole;
	hasRequiredIgnoredRole = 1;

	Object.defineProperty(IgnoredRole, "__esModule", {
	  value: true
	});
	IgnoredRole.default = void 0;
	var IgnoredRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = IgnoredRole$1;
	IgnoredRole.default = _default;
	return IgnoredRole;
}

var ImageMapLinkRole = {};

var hasRequiredImageMapLinkRole;

function requireImageMapLinkRole () {
	if (hasRequiredImageMapLinkRole) return ImageMapLinkRole;
	hasRequiredImageMapLinkRole = 1;

	Object.defineProperty(ImageMapLinkRole, "__esModule", {
	  value: true
	});
	ImageMapLinkRole.default = void 0;
	var ImageMapLinkRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = ImageMapLinkRole$1;
	ImageMapLinkRole.default = _default;
	return ImageMapLinkRole;
}

var ImageMapRole = {};

var hasRequiredImageMapRole;

function requireImageMapRole () {
	if (hasRequiredImageMapRole) return ImageMapRole;
	hasRequiredImageMapRole = 1;

	Object.defineProperty(ImageMapRole, "__esModule", {
	  value: true
	});
	ImageMapRole.default = void 0;
	var ImageMapRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'img',
	      attributes: [{
	        name: 'usemap'
	      }]
	    }
	  }],
	  type: 'structure'
	};
	var _default = ImageMapRole$1;
	ImageMapRole.default = _default;
	return ImageMapRole;
}

var ImageRole = {};

var hasRequiredImageRole;

function requireImageRole () {
	if (hasRequiredImageRole) return ImageRole;
	hasRequiredImageRole = 1;

	Object.defineProperty(ImageRole, "__esModule", {
	  value: true
	});
	ImageRole.default = void 0;
	var ImageRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'img'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'img'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ImageRole$1;
	ImageRole.default = _default;
	return ImageRole;
}

var InlineTextBoxRole = {};

var hasRequiredInlineTextBoxRole;

function requireInlineTextBoxRole () {
	if (hasRequiredInlineTextBoxRole) return InlineTextBoxRole;
	hasRequiredInlineTextBoxRole = 1;

	Object.defineProperty(InlineTextBoxRole, "__esModule", {
	  value: true
	});
	InlineTextBoxRole.default = void 0;
	var InlineTextBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input'
	    }
	  }],
	  type: 'widget'
	};
	var _default = InlineTextBoxRole$1;
	InlineTextBoxRole.default = _default;
	return InlineTextBoxRole;
}

var InputTimeRole = {};

var hasRequiredInputTimeRole;

function requireInputTimeRole () {
	if (hasRequiredInputTimeRole) return InputTimeRole;
	hasRequiredInputTimeRole = 1;

	Object.defineProperty(InputTimeRole, "__esModule", {
	  value: true
	});
	InputTimeRole.default = void 0;
	var InputTimeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'time'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = InputTimeRole$1;
	InputTimeRole.default = _default;
	return InputTimeRole;
}

var LabelRole = {};

var hasRequiredLabelRole;

function requireLabelRole () {
	if (hasRequiredLabelRole) return LabelRole;
	hasRequiredLabelRole = 1;

	Object.defineProperty(LabelRole, "__esModule", {
	  value: true
	});
	LabelRole.default = void 0;
	var LabelRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'label'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LabelRole$1;
	LabelRole.default = _default;
	return LabelRole;
}

var LegendRole = {};

var hasRequiredLegendRole;

function requireLegendRole () {
	if (hasRequiredLegendRole) return LegendRole;
	hasRequiredLegendRole = 1;

	Object.defineProperty(LegendRole, "__esModule", {
	  value: true
	});
	LegendRole.default = void 0;
	var LegendRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'legend'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LegendRole$1;
	LegendRole.default = _default;
	return LegendRole;
}

var LineBreakRole = {};

var hasRequiredLineBreakRole;

function requireLineBreakRole () {
	if (hasRequiredLineBreakRole) return LineBreakRole;
	hasRequiredLineBreakRole = 1;

	Object.defineProperty(LineBreakRole, "__esModule", {
	  value: true
	});
	LineBreakRole.default = void 0;
	var LineBreakRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'br'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LineBreakRole$1;
	LineBreakRole.default = _default;
	return LineBreakRole;
}

var LinkRole = {};

var hasRequiredLinkRole;

function requireLinkRole () {
	if (hasRequiredLinkRole) return LinkRole;
	hasRequiredLinkRole = 1;

	Object.defineProperty(LinkRole, "__esModule", {
	  value: true
	});
	LinkRole.default = void 0;
	var LinkRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'link'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'a',
	      attributes: [{
	        name: 'href'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = LinkRole$1;
	LinkRole.default = _default;
	return LinkRole;
}

var ListBoxOptionRole = {};

var hasRequiredListBoxOptionRole;

function requireListBoxOptionRole () {
	if (hasRequiredListBoxOptionRole) return ListBoxOptionRole;
	hasRequiredListBoxOptionRole = 1;

	Object.defineProperty(ListBoxOptionRole, "__esModule", {
	  value: true
	});
	ListBoxOptionRole.default = void 0;
	var ListBoxOptionRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'option'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'option'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ListBoxOptionRole$1;
	ListBoxOptionRole.default = _default;
	return ListBoxOptionRole;
}

var ListBoxRole = {};

var hasRequiredListBoxRole;

function requireListBoxRole () {
	if (hasRequiredListBoxRole) return ListBoxRole;
	hasRequiredListBoxRole = 1;

	Object.defineProperty(ListBoxRole, "__esModule", {
	  value: true
	});
	ListBoxRole.default = void 0;
	var ListBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'listbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'datalist'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'select'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ListBoxRole$1;
	ListBoxRole.default = _default;
	return ListBoxRole;
}

var ListItemRole = {};

var hasRequiredListItemRole;

function requireListItemRole () {
	if (hasRequiredListItemRole) return ListItemRole;
	hasRequiredListItemRole = 1;

	Object.defineProperty(ListItemRole, "__esModule", {
	  value: true
	});
	ListItemRole.default = void 0;
	var ListItemRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'listitem'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'li'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ListItemRole$1;
	ListItemRole.default = _default;
	return ListItemRole;
}

var ListMarkerRole = {};

var hasRequiredListMarkerRole;

function requireListMarkerRole () {
	if (hasRequiredListMarkerRole) return ListMarkerRole;
	hasRequiredListMarkerRole = 1;

	Object.defineProperty(ListMarkerRole, "__esModule", {
	  value: true
	});
	ListMarkerRole.default = void 0;
	var ListMarkerRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = ListMarkerRole$1;
	ListMarkerRole.default = _default;
	return ListMarkerRole;
}

var ListRole = {};

var hasRequiredListRole;

function requireListRole () {
	if (hasRequiredListRole) return ListRole;
	hasRequiredListRole = 1;

	Object.defineProperty(ListRole, "__esModule", {
	  value: true
	});
	ListRole.default = void 0;
	var ListRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'list'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'ul'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'ol'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ListRole$1;
	ListRole.default = _default;
	return ListRole;
}

var LogRole = {};

var hasRequiredLogRole;

function requireLogRole () {
	if (hasRequiredLogRole) return LogRole;
	hasRequiredLogRole = 1;

	Object.defineProperty(LogRole, "__esModule", {
	  value: true
	});
	LogRole.default = void 0;
	var LogRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'log'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LogRole$1;
	LogRole.default = _default;
	return LogRole;
}

var MainRole = {};

var hasRequiredMainRole;

function requireMainRole () {
	if (hasRequiredMainRole) return MainRole;
	hasRequiredMainRole = 1;

	Object.defineProperty(MainRole, "__esModule", {
	  value: true
	});
	MainRole.default = void 0;
	var MainRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'main'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'main'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MainRole$1;
	MainRole.default = _default;
	return MainRole;
}

var MarkRole = {};

var hasRequiredMarkRole;

function requireMarkRole () {
	if (hasRequiredMarkRole) return MarkRole;
	hasRequiredMarkRole = 1;

	Object.defineProperty(MarkRole, "__esModule", {
	  value: true
	});
	MarkRole.default = void 0;
	var MarkRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'mark'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MarkRole$1;
	MarkRole.default = _default;
	return MarkRole;
}

var MarqueeRole = {};

var hasRequiredMarqueeRole;

function requireMarqueeRole () {
	if (hasRequiredMarqueeRole) return MarqueeRole;
	hasRequiredMarqueeRole = 1;

	Object.defineProperty(MarqueeRole, "__esModule", {
	  value: true
	});
	MarqueeRole.default = void 0;
	var MarqueeRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'marquee'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'marquee'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MarqueeRole$1;
	MarqueeRole.default = _default;
	return MarqueeRole;
}

var MathRole = {};

var hasRequiredMathRole;

function requireMathRole () {
	if (hasRequiredMathRole) return MathRole;
	hasRequiredMathRole = 1;

	Object.defineProperty(MathRole, "__esModule", {
	  value: true
	});
	MathRole.default = void 0;
	var MathRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'math'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MathRole$1;
	MathRole.default = _default;
	return MathRole;
}

var MenuBarRole = {};

var hasRequiredMenuBarRole;

function requireMenuBarRole () {
	if (hasRequiredMenuBarRole) return MenuBarRole;
	hasRequiredMenuBarRole = 1;

	Object.defineProperty(MenuBarRole, "__esModule", {
	  value: true
	});
	MenuBarRole.default = void 0;
	var MenuBarRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menubar'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MenuBarRole$1;
	MenuBarRole.default = _default;
	return MenuBarRole;
}

var MenuButtonRole = {};

var hasRequiredMenuButtonRole;

function requireMenuButtonRole () {
	if (hasRequiredMenuButtonRole) return MenuButtonRole;
	hasRequiredMenuButtonRole = 1;

	Object.defineProperty(MenuButtonRole, "__esModule", {
	  value: true
	});
	MenuButtonRole.default = void 0;
	var MenuButtonRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = MenuButtonRole$1;
	MenuButtonRole.default = _default;
	return MenuButtonRole;
}

var MenuItemRole = {};

var hasRequiredMenuItemRole;

function requireMenuItemRole () {
	if (hasRequiredMenuItemRole) return MenuItemRole;
	hasRequiredMenuItemRole = 1;

	Object.defineProperty(MenuItemRole, "__esModule", {
	  value: true
	});
	MenuItemRole.default = void 0;
	var MenuItemRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menuitem'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'menuitem'
	    }
	  }],
	  type: 'widget'
	};
	var _default = MenuItemRole$1;
	MenuItemRole.default = _default;
	return MenuItemRole;
}

var MenuItemCheckBoxRole = {};

var hasRequiredMenuItemCheckBoxRole;

function requireMenuItemCheckBoxRole () {
	if (hasRequiredMenuItemCheckBoxRole) return MenuItemCheckBoxRole;
	hasRequiredMenuItemCheckBoxRole = 1;

	Object.defineProperty(MenuItemCheckBoxRole, "__esModule", {
	  value: true
	});
	MenuItemCheckBoxRole.default = void 0;
	var MenuItemCheckBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menuitemcheckbox'
	    }
	  }],
	  type: 'widget'
	};
	var _default = MenuItemCheckBoxRole$1;
	MenuItemCheckBoxRole.default = _default;
	return MenuItemCheckBoxRole;
}

var MenuItemRadioRole = {};

var hasRequiredMenuItemRadioRole;

function requireMenuItemRadioRole () {
	if (hasRequiredMenuItemRadioRole) return MenuItemRadioRole;
	hasRequiredMenuItemRadioRole = 1;

	Object.defineProperty(MenuItemRadioRole, "__esModule", {
	  value: true
	});
	MenuItemRadioRole.default = void 0;
	var MenuItemRadioRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menuitemradio'
	    }
	  }],
	  type: 'widget'
	};
	var _default = MenuItemRadioRole$1;
	MenuItemRadioRole.default = _default;
	return MenuItemRadioRole;
}

var MenuListOptionRole = {};

var hasRequiredMenuListOptionRole;

function requireMenuListOptionRole () {
	if (hasRequiredMenuListOptionRole) return MenuListOptionRole;
	hasRequiredMenuListOptionRole = 1;

	Object.defineProperty(MenuListOptionRole, "__esModule", {
	  value: true
	});
	MenuListOptionRole.default = void 0;
	var MenuListOptionRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = MenuListOptionRole$1;
	MenuListOptionRole.default = _default;
	return MenuListOptionRole;
}

var MenuListPopupRole = {};

var hasRequiredMenuListPopupRole;

function requireMenuListPopupRole () {
	if (hasRequiredMenuListPopupRole) return MenuListPopupRole;
	hasRequiredMenuListPopupRole = 1;

	Object.defineProperty(MenuListPopupRole, "__esModule", {
	  value: true
	});
	MenuListPopupRole.default = void 0;
	var MenuListPopupRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = MenuListPopupRole$1;
	MenuListPopupRole.default = _default;
	return MenuListPopupRole;
}

var MenuRole = {};

var hasRequiredMenuRole;

function requireMenuRole () {
	if (hasRequiredMenuRole) return MenuRole;
	hasRequiredMenuRole = 1;

	Object.defineProperty(MenuRole, "__esModule", {
	  value: true
	});
	MenuRole.default = void 0;
	var MenuRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menu'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'menu'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MenuRole$1;
	MenuRole.default = _default;
	return MenuRole;
}

var MeterRole = {};

var hasRequiredMeterRole;

function requireMeterRole () {
	if (hasRequiredMeterRole) return MeterRole;
	hasRequiredMeterRole = 1;

	Object.defineProperty(MeterRole, "__esModule", {
	  value: true
	});
	MeterRole.default = void 0;
	var MeterRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'meter'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MeterRole$1;
	MeterRole.default = _default;
	return MeterRole;
}

var NavigationRole = {};

var hasRequiredNavigationRole;

function requireNavigationRole () {
	if (hasRequiredNavigationRole) return NavigationRole;
	hasRequiredNavigationRole = 1;

	Object.defineProperty(NavigationRole, "__esModule", {
	  value: true
	});
	NavigationRole.default = void 0;
	var NavigationRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'navigation'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'nav'
	    }
	  }],
	  type: 'structure'
	};
	var _default = NavigationRole$1;
	NavigationRole.default = _default;
	return NavigationRole;
}

var NoneRole = {};

var hasRequiredNoneRole;

function requireNoneRole () {
	if (hasRequiredNoneRole) return NoneRole;
	hasRequiredNoneRole = 1;

	Object.defineProperty(NoneRole, "__esModule", {
	  value: true
	});
	NoneRole.default = void 0;
	var NoneRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'none'
	    }
	  }],
	  type: 'structure'
	};
	var _default = NoneRole$1;
	NoneRole.default = _default;
	return NoneRole;
}

var NoteRole = {};

var hasRequiredNoteRole;

function requireNoteRole () {
	if (hasRequiredNoteRole) return NoteRole;
	hasRequiredNoteRole = 1;

	Object.defineProperty(NoteRole, "__esModule", {
	  value: true
	});
	NoteRole.default = void 0;
	var NoteRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'note'
	    }
	  }],
	  type: 'structure'
	};
	var _default = NoteRole$1;
	NoteRole.default = _default;
	return NoteRole;
}

var OutlineRole = {};

var hasRequiredOutlineRole;

function requireOutlineRole () {
	if (hasRequiredOutlineRole) return OutlineRole;
	hasRequiredOutlineRole = 1;

	Object.defineProperty(OutlineRole, "__esModule", {
	  value: true
	});
	OutlineRole.default = void 0;
	var OutlineRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = OutlineRole$1;
	OutlineRole.default = _default;
	return OutlineRole;
}

var ParagraphRole = {};

var hasRequiredParagraphRole;

function requireParagraphRole () {
	if (hasRequiredParagraphRole) return ParagraphRole;
	hasRequiredParagraphRole = 1;

	Object.defineProperty(ParagraphRole, "__esModule", {
	  value: true
	});
	ParagraphRole.default = void 0;
	var ParagraphRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'p'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ParagraphRole$1;
	ParagraphRole.default = _default;
	return ParagraphRole;
}

var PopUpButtonRole = {};

var hasRequiredPopUpButtonRole;

function requirePopUpButtonRole () {
	if (hasRequiredPopUpButtonRole) return PopUpButtonRole;
	hasRequiredPopUpButtonRole = 1;

	Object.defineProperty(PopUpButtonRole, "__esModule", {
	  value: true
	});
	PopUpButtonRole.default = void 0;
	var PopUpButtonRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = PopUpButtonRole$1;
	PopUpButtonRole.default = _default;
	return PopUpButtonRole;
}

var PreRole = {};

var hasRequiredPreRole;

function requirePreRole () {
	if (hasRequiredPreRole) return PreRole;
	hasRequiredPreRole = 1;

	Object.defineProperty(PreRole, "__esModule", {
	  value: true
	});
	PreRole.default = void 0;
	var PreRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'pre'
	    }
	  }],
	  type: 'structure'
	};
	var _default = PreRole$1;
	PreRole.default = _default;
	return PreRole;
}

var PresentationalRole = {};

var hasRequiredPresentationalRole;

function requirePresentationalRole () {
	if (hasRequiredPresentationalRole) return PresentationalRole;
	hasRequiredPresentationalRole = 1;

	Object.defineProperty(PresentationalRole, "__esModule", {
	  value: true
	});
	PresentationalRole.default = void 0;
	var PresentationalRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'presentation'
	    }
	  }],
	  type: 'structure'
	};
	var _default = PresentationalRole$1;
	PresentationalRole.default = _default;
	return PresentationalRole;
}

var ProgressIndicatorRole = {};

var hasRequiredProgressIndicatorRole;

function requireProgressIndicatorRole () {
	if (hasRequiredProgressIndicatorRole) return ProgressIndicatorRole;
	hasRequiredProgressIndicatorRole = 1;

	Object.defineProperty(ProgressIndicatorRole, "__esModule", {
	  value: true
	});
	ProgressIndicatorRole.default = void 0;
	var ProgressIndicatorRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'progressbar'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'progress'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ProgressIndicatorRole$1;
	ProgressIndicatorRole.default = _default;
	return ProgressIndicatorRole;
}

var RadioButtonRole = {};

var hasRequiredRadioButtonRole;

function requireRadioButtonRole () {
	if (hasRequiredRadioButtonRole) return RadioButtonRole;
	hasRequiredRadioButtonRole = 1;

	Object.defineProperty(RadioButtonRole, "__esModule", {
	  value: true
	});
	RadioButtonRole.default = void 0;
	var RadioButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'radio'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'radio'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = RadioButtonRole$1;
	RadioButtonRole.default = _default;
	return RadioButtonRole;
}

var RadioGroupRole = {};

var hasRequiredRadioGroupRole;

function requireRadioGroupRole () {
	if (hasRequiredRadioGroupRole) return RadioGroupRole;
	hasRequiredRadioGroupRole = 1;

	Object.defineProperty(RadioGroupRole, "__esModule", {
	  value: true
	});
	RadioGroupRole.default = void 0;
	var RadioGroupRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'radiogroup'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RadioGroupRole$1;
	RadioGroupRole.default = _default;
	return RadioGroupRole;
}

var RegionRole = {};

var hasRequiredRegionRole;

function requireRegionRole () {
	if (hasRequiredRegionRole) return RegionRole;
	hasRequiredRegionRole = 1;

	Object.defineProperty(RegionRole, "__esModule", {
	  value: true
	});
	RegionRole.default = void 0;
	var RegionRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'region'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RegionRole$1;
	RegionRole.default = _default;
	return RegionRole;
}

var RootWebAreaRole = {};

var hasRequiredRootWebAreaRole;

function requireRootWebAreaRole () {
	if (hasRequiredRootWebAreaRole) return RootWebAreaRole;
	hasRequiredRootWebAreaRole = 1;

	Object.defineProperty(RootWebAreaRole, "__esModule", {
	  value: true
	});
	RootWebAreaRole.default = void 0;
	var RootWebAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = RootWebAreaRole$1;
	RootWebAreaRole.default = _default;
	return RootWebAreaRole;
}

var RowHeaderRole = {};

var hasRequiredRowHeaderRole;

function requireRowHeaderRole () {
	if (hasRequiredRowHeaderRole) return RowHeaderRole;
	hasRequiredRowHeaderRole = 1;

	Object.defineProperty(RowHeaderRole, "__esModule", {
	  value: true
	});
	RowHeaderRole.default = void 0;
	var RowHeaderRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'rowheader'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'th',
	      attributes: [{
	        name: 'scope',
	        value: 'row'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = RowHeaderRole$1;
	RowHeaderRole.default = _default;
	return RowHeaderRole;
}

var RowRole = {};

var hasRequiredRowRole;

function requireRowRole () {
	if (hasRequiredRowRole) return RowRole;
	hasRequiredRowRole = 1;

	Object.defineProperty(RowRole, "__esModule", {
	  value: true
	});
	RowRole.default = void 0;
	var RowRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'row'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'tr'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RowRole$1;
	RowRole.default = _default;
	return RowRole;
}

var RubyRole = {};

var hasRequiredRubyRole;

function requireRubyRole () {
	if (hasRequiredRubyRole) return RubyRole;
	hasRequiredRubyRole = 1;

	Object.defineProperty(RubyRole, "__esModule", {
	  value: true
	});
	RubyRole.default = void 0;
	var RubyRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'ruby'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RubyRole$1;
	RubyRole.default = _default;
	return RubyRole;
}

var RulerRole = {};

var hasRequiredRulerRole;

function requireRulerRole () {
	if (hasRequiredRulerRole) return RulerRole;
	hasRequiredRulerRole = 1;

	Object.defineProperty(RulerRole, "__esModule", {
	  value: true
	});
	RulerRole.default = void 0;
	var RulerRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = RulerRole$1;
	RulerRole.default = _default;
	return RulerRole;
}

var ScrollAreaRole = {};

var hasRequiredScrollAreaRole;

function requireScrollAreaRole () {
	if (hasRequiredScrollAreaRole) return ScrollAreaRole;
	hasRequiredScrollAreaRole = 1;

	Object.defineProperty(ScrollAreaRole, "__esModule", {
	  value: true
	});
	ScrollAreaRole.default = void 0;
	var ScrollAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = ScrollAreaRole$1;
	ScrollAreaRole.default = _default;
	return ScrollAreaRole;
}

var ScrollBarRole = {};

var hasRequiredScrollBarRole;

function requireScrollBarRole () {
	if (hasRequiredScrollBarRole) return ScrollBarRole;
	hasRequiredScrollBarRole = 1;

	Object.defineProperty(ScrollBarRole, "__esModule", {
	  value: true
	});
	ScrollBarRole.default = void 0;
	var ScrollBarRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'scrollbar'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ScrollBarRole$1;
	ScrollBarRole.default = _default;
	return ScrollBarRole;
}

var SeamlessWebAreaRole = {};

var hasRequiredSeamlessWebAreaRole;

function requireSeamlessWebAreaRole () {
	if (hasRequiredSeamlessWebAreaRole) return SeamlessWebAreaRole;
	hasRequiredSeamlessWebAreaRole = 1;

	Object.defineProperty(SeamlessWebAreaRole, "__esModule", {
	  value: true
	});
	SeamlessWebAreaRole.default = void 0;
	var SeamlessWebAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SeamlessWebAreaRole$1;
	SeamlessWebAreaRole.default = _default;
	return SeamlessWebAreaRole;
}

var SearchRole = {};

var hasRequiredSearchRole;

function requireSearchRole () {
	if (hasRequiredSearchRole) return SearchRole;
	hasRequiredSearchRole = 1;

	Object.defineProperty(SearchRole, "__esModule", {
	  value: true
	});
	SearchRole.default = void 0;
	var SearchRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'search'
	    }
	  }],
	  type: 'structure'
	};
	var _default = SearchRole$1;
	SearchRole.default = _default;
	return SearchRole;
}

var SearchBoxRole = {};

var hasRequiredSearchBoxRole;

function requireSearchBoxRole () {
	if (hasRequiredSearchBoxRole) return SearchBoxRole;
	hasRequiredSearchBoxRole = 1;

	Object.defineProperty(SearchBoxRole, "__esModule", {
	  value: true
	});
	SearchBoxRole.default = void 0;
	var SearchBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'searchbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'search'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SearchBoxRole$1;
	SearchBoxRole.default = _default;
	return SearchBoxRole;
}

var SliderRole = {};

var hasRequiredSliderRole;

function requireSliderRole () {
	if (hasRequiredSliderRole) return SliderRole;
	hasRequiredSliderRole = 1;

	Object.defineProperty(SliderRole, "__esModule", {
	  value: true
	});
	SliderRole.default = void 0;
	var SliderRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'slider'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'range'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SliderRole$1;
	SliderRole.default = _default;
	return SliderRole;
}

var SliderThumbRole = {};

var hasRequiredSliderThumbRole;

function requireSliderThumbRole () {
	if (hasRequiredSliderThumbRole) return SliderThumbRole;
	hasRequiredSliderThumbRole = 1;

	Object.defineProperty(SliderThumbRole, "__esModule", {
	  value: true
	});
	SliderThumbRole.default = void 0;
	var SliderThumbRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SliderThumbRole$1;
	SliderThumbRole.default = _default;
	return SliderThumbRole;
}

var SpinButtonRole = {};

var hasRequiredSpinButtonRole;

function requireSpinButtonRole () {
	if (hasRequiredSpinButtonRole) return SpinButtonRole;
	hasRequiredSpinButtonRole = 1;

	Object.defineProperty(SpinButtonRole, "__esModule", {
	  value: true
	});
	SpinButtonRole.default = void 0;
	var SpinButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'spinbutton'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'number'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SpinButtonRole$1;
	SpinButtonRole.default = _default;
	return SpinButtonRole;
}

var SpinButtonPartRole = {};

var hasRequiredSpinButtonPartRole;

function requireSpinButtonPartRole () {
	if (hasRequiredSpinButtonPartRole) return SpinButtonPartRole;
	hasRequiredSpinButtonPartRole = 1;

	Object.defineProperty(SpinButtonPartRole, "__esModule", {
	  value: true
	});
	SpinButtonPartRole.default = void 0;
	var SpinButtonPartRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SpinButtonPartRole$1;
	SpinButtonPartRole.default = _default;
	return SpinButtonPartRole;
}

var SplitterRole = {};

var hasRequiredSplitterRole;

function requireSplitterRole () {
	if (hasRequiredSplitterRole) return SplitterRole;
	hasRequiredSplitterRole = 1;

	Object.defineProperty(SplitterRole, "__esModule", {
	  value: true
	});
	SplitterRole.default = void 0;
	var SplitterRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'separator'
	    }
	  }],
	  type: 'widget'
	};
	var _default = SplitterRole$1;
	SplitterRole.default = _default;
	return SplitterRole;
}

var StaticTextRole = {};

var hasRequiredStaticTextRole;

function requireStaticTextRole () {
	if (hasRequiredStaticTextRole) return StaticTextRole;
	hasRequiredStaticTextRole = 1;

	Object.defineProperty(StaticTextRole, "__esModule", {
	  value: true
	});
	StaticTextRole.default = void 0;
	var StaticTextRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = StaticTextRole$1;
	StaticTextRole.default = _default;
	return StaticTextRole;
}

var StatusRole = {};

var hasRequiredStatusRole;

function requireStatusRole () {
	if (hasRequiredStatusRole) return StatusRole;
	hasRequiredStatusRole = 1;

	Object.defineProperty(StatusRole, "__esModule", {
	  value: true
	});
	StatusRole.default = void 0;
	var StatusRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'status'
	    }
	  }],
	  type: 'structure'
	};
	var _default = StatusRole$1;
	StatusRole.default = _default;
	return StatusRole;
}

var SVGRootRole = {};

var hasRequiredSVGRootRole;

function requireSVGRootRole () {
	if (hasRequiredSVGRootRole) return SVGRootRole;
	hasRequiredSVGRootRole = 1;

	Object.defineProperty(SVGRootRole, "__esModule", {
	  value: true
	});
	SVGRootRole.default = void 0;
	var SVGRootRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SVGRootRole$1;
	SVGRootRole.default = _default;
	return SVGRootRole;
}

var SwitchRole = {};

var hasRequiredSwitchRole;

function requireSwitchRole () {
	if (hasRequiredSwitchRole) return SwitchRole;
	hasRequiredSwitchRole = 1;

	Object.defineProperty(SwitchRole, "__esModule", {
	  value: true
	});
	SwitchRole.default = void 0;
	var SwitchRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'switch'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'checkbox'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SwitchRole$1;
	SwitchRole.default = _default;
	return SwitchRole;
}

var TabGroupRole = {};

var hasRequiredTabGroupRole;

function requireTabGroupRole () {
	if (hasRequiredTabGroupRole) return TabGroupRole;
	hasRequiredTabGroupRole = 1;

	Object.defineProperty(TabGroupRole, "__esModule", {
	  value: true
	});
	TabGroupRole.default = void 0;
	var TabGroupRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tablist'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TabGroupRole$1;
	TabGroupRole.default = _default;
	return TabGroupRole;
}

var TabRole = {};

var hasRequiredTabRole;

function requireTabRole () {
	if (hasRequiredTabRole) return TabRole;
	hasRequiredTabRole = 1;

	Object.defineProperty(TabRole, "__esModule", {
	  value: true
	});
	TabRole.default = void 0;
	var TabRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tab'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TabRole$1;
	TabRole.default = _default;
	return TabRole;
}

var TableHeaderContainerRole = {};

var hasRequiredTableHeaderContainerRole;

function requireTableHeaderContainerRole () {
	if (hasRequiredTableHeaderContainerRole) return TableHeaderContainerRole;
	hasRequiredTableHeaderContainerRole = 1;

	Object.defineProperty(TableHeaderContainerRole, "__esModule", {
	  value: true
	});
	TableHeaderContainerRole.default = void 0;
	var TableHeaderContainerRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = TableHeaderContainerRole$1;
	TableHeaderContainerRole.default = _default;
	return TableHeaderContainerRole;
}

var TableRole = {};

var hasRequiredTableRole;

function requireTableRole () {
	if (hasRequiredTableRole) return TableRole;
	hasRequiredTableRole = 1;

	Object.defineProperty(TableRole, "__esModule", {
	  value: true
	});
	TableRole.default = void 0;
	var TableRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'table'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'table'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TableRole$1;
	TableRole.default = _default;
	return TableRole;
}

var TabListRole = {};

var hasRequiredTabListRole;

function requireTabListRole () {
	if (hasRequiredTabListRole) return TabListRole;
	hasRequiredTabListRole = 1;

	Object.defineProperty(TabListRole, "__esModule", {
	  value: true
	});
	TabListRole.default = void 0;
	var TabListRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tablist'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TabListRole$1;
	TabListRole.default = _default;
	return TabListRole;
}

var TabPanelRole = {};

var hasRequiredTabPanelRole;

function requireTabPanelRole () {
	if (hasRequiredTabPanelRole) return TabPanelRole;
	hasRequiredTabPanelRole = 1;

	Object.defineProperty(TabPanelRole, "__esModule", {
	  value: true
	});
	TabPanelRole.default = void 0;
	var TabPanelRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tabpanel'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TabPanelRole$1;
	TabPanelRole.default = _default;
	return TabPanelRole;
}

var TermRole = {};

var hasRequiredTermRole;

function requireTermRole () {
	if (hasRequiredTermRole) return TermRole;
	hasRequiredTermRole = 1;

	Object.defineProperty(TermRole, "__esModule", {
	  value: true
	});
	TermRole.default = void 0;
	var TermRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'term'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TermRole$1;
	TermRole.default = _default;
	return TermRole;
}

var TextAreaRole = {};

var hasRequiredTextAreaRole;

function requireTextAreaRole () {
	if (hasRequiredTextAreaRole) return TextAreaRole;
	hasRequiredTextAreaRole = 1;

	Object.defineProperty(TextAreaRole, "__esModule", {
	  value: true
	});
	TextAreaRole.default = void 0;
	var TextAreaRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      attributes: [{
	        name: 'aria-multiline',
	        value: 'true'
	      }],
	      name: 'textbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'textarea'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TextAreaRole$1;
	TextAreaRole.default = _default;
	return TextAreaRole;
}

var TextFieldRole = {};

var hasRequiredTextFieldRole;

function requireTextFieldRole () {
	if (hasRequiredTextFieldRole) return TextFieldRole;
	hasRequiredTextFieldRole = 1;

	Object.defineProperty(TextFieldRole, "__esModule", {
	  value: true
	});
	TextFieldRole.default = void 0;
	var TextFieldRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'textbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'text'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = TextFieldRole$1;
	TextFieldRole.default = _default;
	return TextFieldRole;
}

var TimeRole = {};

var hasRequiredTimeRole;

function requireTimeRole () {
	if (hasRequiredTimeRole) return TimeRole;
	hasRequiredTimeRole = 1;

	Object.defineProperty(TimeRole, "__esModule", {
	  value: true
	});
	TimeRole.default = void 0;
	var TimeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'time'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TimeRole$1;
	TimeRole.default = _default;
	return TimeRole;
}

var TimerRole = {};

var hasRequiredTimerRole;

function requireTimerRole () {
	if (hasRequiredTimerRole) return TimerRole;
	hasRequiredTimerRole = 1;

	Object.defineProperty(TimerRole, "__esModule", {
	  value: true
	});
	TimerRole.default = void 0;
	var TimerRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'timer'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TimerRole$1;
	TimerRole.default = _default;
	return TimerRole;
}

var ToggleButtonRole = {};

var hasRequiredToggleButtonRole;

function requireToggleButtonRole () {
	if (hasRequiredToggleButtonRole) return ToggleButtonRole;
	hasRequiredToggleButtonRole = 1;

	Object.defineProperty(ToggleButtonRole, "__esModule", {
	  value: true
	});
	ToggleButtonRole.default = void 0;
	var ToggleButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      attributes: [{
	        name: 'aria-pressed'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = ToggleButtonRole$1;
	ToggleButtonRole.default = _default;
	return ToggleButtonRole;
}

var ToolbarRole = {};

var hasRequiredToolbarRole;

function requireToolbarRole () {
	if (hasRequiredToolbarRole) return ToolbarRole;
	hasRequiredToolbarRole = 1;

	Object.defineProperty(ToolbarRole, "__esModule", {
	  value: true
	});
	ToolbarRole.default = void 0;
	var ToolbarRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'toolbar'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ToolbarRole$1;
	ToolbarRole.default = _default;
	return ToolbarRole;
}

var TreeRole = {};

var hasRequiredTreeRole;

function requireTreeRole () {
	if (hasRequiredTreeRole) return TreeRole;
	hasRequiredTreeRole = 1;

	Object.defineProperty(TreeRole, "__esModule", {
	  value: true
	});
	TreeRole.default = void 0;
	var TreeRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tree'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TreeRole$1;
	TreeRole.default = _default;
	return TreeRole;
}

var TreeGridRole = {};

var hasRequiredTreeGridRole;

function requireTreeGridRole () {
	if (hasRequiredTreeGridRole) return TreeGridRole;
	hasRequiredTreeGridRole = 1;

	Object.defineProperty(TreeGridRole, "__esModule", {
	  value: true
	});
	TreeGridRole.default = void 0;
	var TreeGridRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'treegrid'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TreeGridRole$1;
	TreeGridRole.default = _default;
	return TreeGridRole;
}

var TreeItemRole = {};

var hasRequiredTreeItemRole;

function requireTreeItemRole () {
	if (hasRequiredTreeItemRole) return TreeItemRole;
	hasRequiredTreeItemRole = 1;

	Object.defineProperty(TreeItemRole, "__esModule", {
	  value: true
	});
	TreeItemRole.default = void 0;
	var TreeItemRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'treeitem'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TreeItemRole$1;
	TreeItemRole.default = _default;
	return TreeItemRole;
}

var UserInterfaceTooltipRole = {};

var hasRequiredUserInterfaceTooltipRole;

function requireUserInterfaceTooltipRole () {
	if (hasRequiredUserInterfaceTooltipRole) return UserInterfaceTooltipRole;
	hasRequiredUserInterfaceTooltipRole = 1;

	Object.defineProperty(UserInterfaceTooltipRole, "__esModule", {
	  value: true
	});
	UserInterfaceTooltipRole.default = void 0;
	var UserInterfaceTooltipRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tooltip'
	    }
	  }],
	  type: 'structure'
	};
	var _default = UserInterfaceTooltipRole$1;
	UserInterfaceTooltipRole.default = _default;
	return UserInterfaceTooltipRole;
}

var VideoRole = {};

var hasRequiredVideoRole;

function requireVideoRole () {
	if (hasRequiredVideoRole) return VideoRole;
	hasRequiredVideoRole = 1;

	Object.defineProperty(VideoRole, "__esModule", {
	  value: true
	});
	VideoRole.default = void 0;
	var VideoRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'video'
	    }
	  }],
	  type: 'widget'
	};
	var _default = VideoRole$1;
	VideoRole.default = _default;
	return VideoRole;
}

var WebAreaRole = {};

var hasRequiredWebAreaRole;

function requireWebAreaRole () {
	if (hasRequiredWebAreaRole) return WebAreaRole;
	hasRequiredWebAreaRole = 1;

	Object.defineProperty(WebAreaRole, "__esModule", {
	  value: true
	});
	WebAreaRole.default = void 0;
	var WebAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = WebAreaRole$1;
	WebAreaRole.default = _default;
	return WebAreaRole;
}

var WindowRole = {};

var hasRequiredWindowRole;

function requireWindowRole () {
	if (hasRequiredWindowRole) return WindowRole;
	hasRequiredWindowRole = 1;

	Object.defineProperty(WindowRole, "__esModule", {
	  value: true
	});
	WindowRole.default = void 0;
	var WindowRole$1 = {
	  relatedConcepts: [],
	  type: 'window'
	};
	var _default = WindowRole$1;
	WindowRole.default = _default;
	return WindowRole;
}

var hasRequiredAXObjectsMap;

function requireAXObjectsMap () {
	if (hasRequiredAXObjectsMap) return AXObjectsMap;
	hasRequiredAXObjectsMap = 1;

	Object.defineProperty(AXObjectsMap, "__esModule", {
	  value: true
	});
	AXObjectsMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	var _AbbrRole = _interopRequireDefault(requireAbbrRole());
	var _AlertDialogRole = _interopRequireDefault(requireAlertDialogRole());
	var _AlertRole = _interopRequireDefault(requireAlertRole());
	var _AnnotationRole = _interopRequireDefault(requireAnnotationRole());
	var _ApplicationRole = _interopRequireDefault(requireApplicationRole());
	var _ArticleRole = _interopRequireDefault(requireArticleRole());
	var _AudioRole = _interopRequireDefault(requireAudioRole());
	var _BannerRole = _interopRequireDefault(requireBannerRole());
	var _BlockquoteRole = _interopRequireDefault(requireBlockquoteRole());
	var _BusyIndicatorRole = _interopRequireDefault(requireBusyIndicatorRole());
	var _ButtonRole = _interopRequireDefault(requireButtonRole());
	var _CanvasRole = _interopRequireDefault(requireCanvasRole());
	var _CaptionRole = _interopRequireDefault(requireCaptionRole());
	var _CellRole = _interopRequireDefault(requireCellRole());
	var _CheckBoxRole = _interopRequireDefault(requireCheckBoxRole());
	var _ColorWellRole = _interopRequireDefault(requireColorWellRole());
	var _ColumnHeaderRole = _interopRequireDefault(requireColumnHeaderRole());
	var _ColumnRole = _interopRequireDefault(requireColumnRole());
	var _ComboBoxRole = _interopRequireDefault(requireComboBoxRole());
	var _ComplementaryRole = _interopRequireDefault(requireComplementaryRole());
	var _ContentInfoRole = _interopRequireDefault(requireContentInfoRole());
	var _DateRole = _interopRequireDefault(requireDateRole());
	var _DateTimeRole = _interopRequireDefault(requireDateTimeRole());
	var _DefinitionRole = _interopRequireDefault(requireDefinitionRole());
	var _DescriptionListDetailRole = _interopRequireDefault(requireDescriptionListDetailRole());
	var _DescriptionListRole = _interopRequireDefault(requireDescriptionListRole());
	var _DescriptionListTermRole = _interopRequireDefault(requireDescriptionListTermRole());
	var _DetailsRole = _interopRequireDefault(requireDetailsRole());
	var _DialogRole = _interopRequireDefault(requireDialogRole());
	var _DirectoryRole = _interopRequireDefault(requireDirectoryRole());
	var _DisclosureTriangleRole = _interopRequireDefault(requireDisclosureTriangleRole());
	var _DivRole = _interopRequireDefault(requireDivRole());
	var _DocumentRole = _interopRequireDefault(requireDocumentRole());
	var _EmbeddedObjectRole = _interopRequireDefault(requireEmbeddedObjectRole());
	var _FeedRole = _interopRequireDefault(requireFeedRole());
	var _FigcaptionRole = _interopRequireDefault(requireFigcaptionRole());
	var _FigureRole = _interopRequireDefault(requireFigureRole());
	var _FooterRole = _interopRequireDefault(requireFooterRole());
	var _FormRole = _interopRequireDefault(requireFormRole());
	var _GridRole = _interopRequireDefault(requireGridRole());
	var _GroupRole = _interopRequireDefault(requireGroupRole());
	var _HeadingRole = _interopRequireDefault(requireHeadingRole());
	var _IframePresentationalRole = _interopRequireDefault(requireIframePresentationalRole());
	var _IframeRole = _interopRequireDefault(requireIframeRole());
	var _IgnoredRole = _interopRequireDefault(requireIgnoredRole());
	var _ImageMapLinkRole = _interopRequireDefault(requireImageMapLinkRole());
	var _ImageMapRole = _interopRequireDefault(requireImageMapRole());
	var _ImageRole = _interopRequireDefault(requireImageRole());
	var _InlineTextBoxRole = _interopRequireDefault(requireInlineTextBoxRole());
	var _InputTimeRole = _interopRequireDefault(requireInputTimeRole());
	var _LabelRole = _interopRequireDefault(requireLabelRole());
	var _LegendRole = _interopRequireDefault(requireLegendRole());
	var _LineBreakRole = _interopRequireDefault(requireLineBreakRole());
	var _LinkRole = _interopRequireDefault(requireLinkRole());
	var _ListBoxOptionRole = _interopRequireDefault(requireListBoxOptionRole());
	var _ListBoxRole = _interopRequireDefault(requireListBoxRole());
	var _ListItemRole = _interopRequireDefault(requireListItemRole());
	var _ListMarkerRole = _interopRequireDefault(requireListMarkerRole());
	var _ListRole = _interopRequireDefault(requireListRole());
	var _LogRole = _interopRequireDefault(requireLogRole());
	var _MainRole = _interopRequireDefault(requireMainRole());
	var _MarkRole = _interopRequireDefault(requireMarkRole());
	var _MarqueeRole = _interopRequireDefault(requireMarqueeRole());
	var _MathRole = _interopRequireDefault(requireMathRole());
	var _MenuBarRole = _interopRequireDefault(requireMenuBarRole());
	var _MenuButtonRole = _interopRequireDefault(requireMenuButtonRole());
	var _MenuItemRole = _interopRequireDefault(requireMenuItemRole());
	var _MenuItemCheckBoxRole = _interopRequireDefault(requireMenuItemCheckBoxRole());
	var _MenuItemRadioRole = _interopRequireDefault(requireMenuItemRadioRole());
	var _MenuListOptionRole = _interopRequireDefault(requireMenuListOptionRole());
	var _MenuListPopupRole = _interopRequireDefault(requireMenuListPopupRole());
	var _MenuRole = _interopRequireDefault(requireMenuRole());
	var _MeterRole = _interopRequireDefault(requireMeterRole());
	var _NavigationRole = _interopRequireDefault(requireNavigationRole());
	var _NoneRole = _interopRequireDefault(requireNoneRole());
	var _NoteRole = _interopRequireDefault(requireNoteRole());
	var _OutlineRole = _interopRequireDefault(requireOutlineRole());
	var _ParagraphRole = _interopRequireDefault(requireParagraphRole());
	var _PopUpButtonRole = _interopRequireDefault(requirePopUpButtonRole());
	var _PreRole = _interopRequireDefault(requirePreRole());
	var _PresentationalRole = _interopRequireDefault(requirePresentationalRole());
	var _ProgressIndicatorRole = _interopRequireDefault(requireProgressIndicatorRole());
	var _RadioButtonRole = _interopRequireDefault(requireRadioButtonRole());
	var _RadioGroupRole = _interopRequireDefault(requireRadioGroupRole());
	var _RegionRole = _interopRequireDefault(requireRegionRole());
	var _RootWebAreaRole = _interopRequireDefault(requireRootWebAreaRole());
	var _RowHeaderRole = _interopRequireDefault(requireRowHeaderRole());
	var _RowRole = _interopRequireDefault(requireRowRole());
	var _RubyRole = _interopRequireDefault(requireRubyRole());
	var _RulerRole = _interopRequireDefault(requireRulerRole());
	var _ScrollAreaRole = _interopRequireDefault(requireScrollAreaRole());
	var _ScrollBarRole = _interopRequireDefault(requireScrollBarRole());
	var _SeamlessWebAreaRole = _interopRequireDefault(requireSeamlessWebAreaRole());
	var _SearchRole = _interopRequireDefault(requireSearchRole());
	var _SearchBoxRole = _interopRequireDefault(requireSearchBoxRole());
	var _SliderRole = _interopRequireDefault(requireSliderRole());
	var _SliderThumbRole = _interopRequireDefault(requireSliderThumbRole());
	var _SpinButtonRole = _interopRequireDefault(requireSpinButtonRole());
	var _SpinButtonPartRole = _interopRequireDefault(requireSpinButtonPartRole());
	var _SplitterRole = _interopRequireDefault(requireSplitterRole());
	var _StaticTextRole = _interopRequireDefault(requireStaticTextRole());
	var _StatusRole = _interopRequireDefault(requireStatusRole());
	var _SVGRootRole = _interopRequireDefault(requireSVGRootRole());
	var _SwitchRole = _interopRequireDefault(requireSwitchRole());
	var _TabGroupRole = _interopRequireDefault(requireTabGroupRole());
	var _TabRole = _interopRequireDefault(requireTabRole());
	var _TableHeaderContainerRole = _interopRequireDefault(requireTableHeaderContainerRole());
	var _TableRole = _interopRequireDefault(requireTableRole());
	var _TabListRole = _interopRequireDefault(requireTabListRole());
	var _TabPanelRole = _interopRequireDefault(requireTabPanelRole());
	var _TermRole = _interopRequireDefault(requireTermRole());
	var _TextAreaRole = _interopRequireDefault(requireTextAreaRole());
	var _TextFieldRole = _interopRequireDefault(requireTextFieldRole());
	var _TimeRole = _interopRequireDefault(requireTimeRole());
	var _TimerRole = _interopRequireDefault(requireTimerRole());
	var _ToggleButtonRole = _interopRequireDefault(requireToggleButtonRole());
	var _ToolbarRole = _interopRequireDefault(requireToolbarRole());
	var _TreeRole = _interopRequireDefault(requireTreeRole());
	var _TreeGridRole = _interopRequireDefault(requireTreeGridRole());
	var _TreeItemRole = _interopRequireDefault(requireTreeItemRole());
	var _UserInterfaceTooltipRole = _interopRequireDefault(requireUserInterfaceTooltipRole());
	var _VideoRole = _interopRequireDefault(requireVideoRole());
	var _WebAreaRole = _interopRequireDefault(requireWebAreaRole());
	var _WindowRole = _interopRequireDefault(requireWindowRole());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	var AXObjects = [['AbbrRole', _AbbrRole.default], ['AlertDialogRole', _AlertDialogRole.default], ['AlertRole', _AlertRole.default], ['AnnotationRole', _AnnotationRole.default], ['ApplicationRole', _ApplicationRole.default], ['ArticleRole', _ArticleRole.default], ['AudioRole', _AudioRole.default], ['BannerRole', _BannerRole.default], ['BlockquoteRole', _BlockquoteRole.default], ['BusyIndicatorRole', _BusyIndicatorRole.default], ['ButtonRole', _ButtonRole.default], ['CanvasRole', _CanvasRole.default], ['CaptionRole', _CaptionRole.default], ['CellRole', _CellRole.default], ['CheckBoxRole', _CheckBoxRole.default], ['ColorWellRole', _ColorWellRole.default], ['ColumnHeaderRole', _ColumnHeaderRole.default], ['ColumnRole', _ColumnRole.default], ['ComboBoxRole', _ComboBoxRole.default], ['ComplementaryRole', _ComplementaryRole.default], ['ContentInfoRole', _ContentInfoRole.default], ['DateRole', _DateRole.default], ['DateTimeRole', _DateTimeRole.default], ['DefinitionRole', _DefinitionRole.default], ['DescriptionListDetailRole', _DescriptionListDetailRole.default], ['DescriptionListRole', _DescriptionListRole.default], ['DescriptionListTermRole', _DescriptionListTermRole.default], ['DetailsRole', _DetailsRole.default], ['DialogRole', _DialogRole.default], ['DirectoryRole', _DirectoryRole.default], ['DisclosureTriangleRole', _DisclosureTriangleRole.default], ['DivRole', _DivRole.default], ['DocumentRole', _DocumentRole.default], ['EmbeddedObjectRole', _EmbeddedObjectRole.default], ['FeedRole', _FeedRole.default], ['FigcaptionRole', _FigcaptionRole.default], ['FigureRole', _FigureRole.default], ['FooterRole', _FooterRole.default], ['FormRole', _FormRole.default], ['GridRole', _GridRole.default], ['GroupRole', _GroupRole.default], ['HeadingRole', _HeadingRole.default], ['IframePresentationalRole', _IframePresentationalRole.default], ['IframeRole', _IframeRole.default], ['IgnoredRole', _IgnoredRole.default], ['ImageMapLinkRole', _ImageMapLinkRole.default], ['ImageMapRole', _ImageMapRole.default], ['ImageRole', _ImageRole.default], ['InlineTextBoxRole', _InlineTextBoxRole.default], ['InputTimeRole', _InputTimeRole.default], ['LabelRole', _LabelRole.default], ['LegendRole', _LegendRole.default], ['LineBreakRole', _LineBreakRole.default], ['LinkRole', _LinkRole.default], ['ListBoxOptionRole', _ListBoxOptionRole.default], ['ListBoxRole', _ListBoxRole.default], ['ListItemRole', _ListItemRole.default], ['ListMarkerRole', _ListMarkerRole.default], ['ListRole', _ListRole.default], ['LogRole', _LogRole.default], ['MainRole', _MainRole.default], ['MarkRole', _MarkRole.default], ['MarqueeRole', _MarqueeRole.default], ['MathRole', _MathRole.default], ['MenuBarRole', _MenuBarRole.default], ['MenuButtonRole', _MenuButtonRole.default], ['MenuItemRole', _MenuItemRole.default], ['MenuItemCheckBoxRole', _MenuItemCheckBoxRole.default], ['MenuItemRadioRole', _MenuItemRadioRole.default], ['MenuListOptionRole', _MenuListOptionRole.default], ['MenuListPopupRole', _MenuListPopupRole.default], ['MenuRole', _MenuRole.default], ['MeterRole', _MeterRole.default], ['NavigationRole', _NavigationRole.default], ['NoneRole', _NoneRole.default], ['NoteRole', _NoteRole.default], ['OutlineRole', _OutlineRole.default], ['ParagraphRole', _ParagraphRole.default], ['PopUpButtonRole', _PopUpButtonRole.default], ['PreRole', _PreRole.default], ['PresentationalRole', _PresentationalRole.default], ['ProgressIndicatorRole', _ProgressIndicatorRole.default], ['RadioButtonRole', _RadioButtonRole.default], ['RadioGroupRole', _RadioGroupRole.default], ['RegionRole', _RegionRole.default], ['RootWebAreaRole', _RootWebAreaRole.default], ['RowHeaderRole', _RowHeaderRole.default], ['RowRole', _RowRole.default], ['RubyRole', _RubyRole.default], ['RulerRole', _RulerRole.default], ['ScrollAreaRole', _ScrollAreaRole.default], ['ScrollBarRole', _ScrollBarRole.default], ['SeamlessWebAreaRole', _SeamlessWebAreaRole.default], ['SearchRole', _SearchRole.default], ['SearchBoxRole', _SearchBoxRole.default], ['SliderRole', _SliderRole.default], ['SliderThumbRole', _SliderThumbRole.default], ['SpinButtonRole', _SpinButtonRole.default], ['SpinButtonPartRole', _SpinButtonPartRole.default], ['SplitterRole', _SplitterRole.default], ['StaticTextRole', _StaticTextRole.default], ['StatusRole', _StatusRole.default], ['SVGRootRole', _SVGRootRole.default], ['SwitchRole', _SwitchRole.default], ['TabGroupRole', _TabGroupRole.default], ['TabRole', _TabRole.default], ['TableHeaderContainerRole', _TableHeaderContainerRole.default], ['TableRole', _TableRole.default], ['TabListRole', _TabListRole.default], ['TabPanelRole', _TabPanelRole.default], ['TermRole', _TermRole.default], ['TextAreaRole', _TextAreaRole.default], ['TextFieldRole', _TextFieldRole.default], ['TimeRole', _TimeRole.default], ['TimerRole', _TimerRole.default], ['ToggleButtonRole', _ToggleButtonRole.default], ['ToolbarRole', _ToolbarRole.default], ['TreeRole', _TreeRole.default], ['TreeGridRole', _TreeGridRole.default], ['TreeItemRole', _TreeItemRole.default], ['UserInterfaceTooltipRole', _UserInterfaceTooltipRole.default], ['VideoRole', _VideoRole.default], ['WebAreaRole', _WebAreaRole.default], ['WindowRole', _WindowRole.default]];
	var AXObjectsMap$1 = {
	  entries: function entries() {
	    return AXObjects;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i = 0, _AXObjects = AXObjects; _i < _AXObjects.length; _i++) {
	      var _AXObjects$_i = _slicedToArray(_AXObjects[_i], 2),
	        key = _AXObjects$_i[0],
	        values = _AXObjects$_i[1];
	      fn.call(thisArg, values, key, AXObjects);
	    }
	  },
	  get: function get(key) {
	    var item = AXObjects.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!AXObjectsMap$1.get(key);
	  },
	  keys: function keys() {
	    return AXObjects.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return AXObjects.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(AXObjectsMap$1, AXObjectsMap$1.entries());
	AXObjectsMap.default = _default;
	return AXObjectsMap;
}

var hasRequiredAXObjectElementMap;

function requireAXObjectElementMap () {
	if (hasRequiredAXObjectElementMap) return AXObjectElementMap;
	hasRequiredAXObjectElementMap = 1;

	Object.defineProperty(AXObjectElementMap, "__esModule", {
	  value: true
	});
	AXObjectElementMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var AXObjectElements = [];
	var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()),
	  _step;
	try {
	  var _loop = function _loop() {
	    var _step$value = _slicedToArray(_step.value, 2),
	      name = _step$value[0],
	      def = _step$value[1];
	    var relatedConcepts = def.relatedConcepts;
	    if (Array.isArray(relatedConcepts)) {
	      relatedConcepts.forEach(function (relation) {
	        if (relation.module === 'HTML') {
	          var concept = relation.concept;
	          if (concept) {
	            var index = AXObjectElements.findIndex(function (_ref5) {
	              var _ref6 = _slicedToArray(_ref5, 1),
	                key = _ref6[0];
	              return key === name;
	            });
	            if (index === -1) {
	              AXObjectElements.push([name, []]);
	              index = AXObjectElements.length - 1;
	            }
	            AXObjectElements[index][1].push(concept);
	          }
	        }
	      });
	    }
	  };
	  for (_iterator.s(); !(_step = _iterator.n()).done;) {
	    _loop();
	  }
	} catch (err) {
	  _iterator.e(err);
	} finally {
	  _iterator.f();
	}
	var AXObjectElementMap$1 = {
	  entries: function entries() {
	    return AXObjectElements;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i = 0, _AXObjectElements = AXObjectElements; _i < _AXObjectElements.length; _i++) {
	      var _AXObjectElements$_i = _slicedToArray(_AXObjectElements[_i], 2),
	        key = _AXObjectElements$_i[0],
	        values = _AXObjectElements$_i[1];
	      fn.call(thisArg, values, key, AXObjectElements);
	    }
	  },
	  get: function get(key) {
	    var item = AXObjectElements.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!AXObjectElementMap$1.get(key);
	  },
	  keys: function keys() {
	    return AXObjectElements.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return AXObjectElements.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(AXObjectElementMap$1, AXObjectElementMap$1.entries());
	AXObjectElementMap.default = _default;
	return AXObjectElementMap;
}

var AXObjectRoleMap = {};

var hasRequiredAXObjectRoleMap;

function requireAXObjectRoleMap () {
	if (hasRequiredAXObjectRoleMap) return AXObjectRoleMap;
	hasRequiredAXObjectRoleMap = 1;

	Object.defineProperty(AXObjectRoleMap, "__esModule", {
	  value: true
	});
	AXObjectRoleMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var AXObjectRoleElements = [];
	var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()),
	  _step;
	try {
	  var _loop = function _loop() {
	    var _step$value = _slicedToArray(_step.value, 2),
	      name = _step$value[0],
	      def = _step$value[1];
	    var relatedConcepts = def.relatedConcepts;
	    if (Array.isArray(relatedConcepts)) {
	      relatedConcepts.forEach(function (relation) {
	        if (relation.module === 'ARIA') {
	          var concept = relation.concept;
	          if (concept) {
	            var index = AXObjectRoleElements.findIndex(function (_ref5) {
	              var _ref6 = _slicedToArray(_ref5, 1),
	                key = _ref6[0];
	              return key === name;
	            });
	            if (index === -1) {
	              AXObjectRoleElements.push([name, []]);
	              index = AXObjectRoleElements.length - 1;
	            }
	            AXObjectRoleElements[index][1].push(concept);
	          }
	        }
	      });
	    }
	  };
	  for (_iterator.s(); !(_step = _iterator.n()).done;) {
	    _loop();
	  }
	} catch (err) {
	  _iterator.e(err);
	} finally {
	  _iterator.f();
	}
	var AXObjectRoleMap$1 = {
	  entries: function entries() {
	    return AXObjectRoleElements;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i = 0, _AXObjectRoleElements = AXObjectRoleElements; _i < _AXObjectRoleElements.length; _i++) {
	      var _AXObjectRoleElements2 = _slicedToArray(_AXObjectRoleElements[_i], 2),
	        key = _AXObjectRoleElements2[0],
	        values = _AXObjectRoleElements2[1];
	      fn.call(thisArg, values, key, AXObjectRoleElements);
	    }
	  },
	  get: function get(key) {
	    var item = AXObjectRoleElements.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!AXObjectRoleMap$1.get(key);
	  },
	  keys: function keys() {
	    return AXObjectRoleElements.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return AXObjectRoleElements.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(AXObjectRoleMap$1, AXObjectRoleMap$1.entries());
	AXObjectRoleMap.default = _default;
	return AXObjectRoleMap;
}

var elementAXObjectMap = {};

var hasRequiredElementAXObjectMap;

function requireElementAXObjectMap () {
	if (hasRequiredElementAXObjectMap) return elementAXObjectMap;
	hasRequiredElementAXObjectMap = 1;

	Object.defineProperty(elementAXObjectMap, "__esModule", {
	  value: true
	});
	elementAXObjectMap.default = void 0;
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var elementAXObjects = [];
	var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()),
	  _step;
	try {
	  var _loop = function _loop() {
	    var _step$value = _slicedToArray(_step.value, 2),
	      name = _step$value[0],
	      def = _step$value[1];
	    var relatedConcepts = def.relatedConcepts;
	    if (Array.isArray(relatedConcepts)) {
	      relatedConcepts.forEach(function (relation) {
	        if (relation.module === 'HTML') {
	          var concept = relation.concept;
	          if (concept != null) {
	            var conceptStr = JSON.stringify(concept);
	            var axObjects;
	            var index = 0;
	            for (; index < elementAXObjects.length; index++) {
	              var key = elementAXObjects[index][0];
	              if (JSON.stringify(key) === conceptStr) {
	                axObjects = elementAXObjects[index][1];
	                break;
	              }
	            }
	            if (!Array.isArray(axObjects)) {
	              axObjects = [];
	            }
	            var loc = axObjects.findIndex(function (item) {
	              return item === name;
	            });
	            if (loc === -1) {
	              axObjects.push(name);
	            }
	            if (index < elementAXObjects.length) {
	              elementAXObjects.splice(index, 1, [concept, axObjects]);
	            } else {
	              elementAXObjects.push([concept, axObjects]);
	            }
	          }
	        }
	      });
	    }
	  };
	  for (_iterator.s(); !(_step = _iterator.n()).done;) {
	    _loop();
	  }
	} catch (err) {
	  _iterator.e(err);
	} finally {
	  _iterator.f();
	}
	function deepAxObjectModelRelationshipConceptAttributeCheck(a, b) {
	  if (a === undefined && b !== undefined) {
	    return false;
	  }
	  if (a !== undefined && b === undefined) {
	    return false;
	  }
	  if (a !== undefined && b !== undefined) {
	    if (a.length != b.length) {
	      return false;
	    }

	    // dequal checks position equality
	    // https://github.com/lukeed/dequal/blob/5ecd990c4c055c4658c64b4bdfc170f219604eea/src/index.js#L17-L22
	    for (var i = 0; i < a.length; i++) {
	      if (b[i].name !== a[i].name || b[i].value !== a[i].value) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	var elementAXObjectMap$1 = {
	  entries: function entries() {
	    return elementAXObjects;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    for (var _i = 0, _elementAXObjects = elementAXObjects; _i < _elementAXObjects.length; _i++) {
	      var _elementAXObjects$_i = _slicedToArray(_elementAXObjects[_i], 2),
	        key = _elementAXObjects$_i[0],
	        values = _elementAXObjects$_i[1];
	      fn.call(thisArg, values, key, elementAXObjects);
	    }
	  },
	  get: function get(key) {
	    var item = elementAXObjects.find(function (tuple) {
	      return key.name === tuple[0].name && deepAxObjectModelRelationshipConceptAttributeCheck(key.attributes, tuple[0].attributes);
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!elementAXObjectMap$1.get(key);
	  },
	  keys: function keys() {
	    return elementAXObjects.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return elementAXObjects.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(elementAXObjectMap$1, elementAXObjectMap$1.entries());
	elementAXObjectMap.default = _default;
	return elementAXObjectMap;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;

	Object.defineProperty(lib$1, "__esModule", {
	  value: true
	});
	lib$1.elementAXObjects = lib$1.AXObjects = lib$1.AXObjectRoles = lib$1.AXObjectElements = void 0;
	var _AXObjectElementMap = _interopRequireDefault(requireAXObjectElementMap());
	var _AXObjectRoleMap = _interopRequireDefault(requireAXObjectRoleMap());
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	var _elementAXObjectMap = _interopRequireDefault(requireElementAXObjectMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	var AXObjectElements = _AXObjectElementMap.default;
	lib$1.AXObjectElements = AXObjectElements;
	var AXObjectRoles = _AXObjectRoleMap.default;
	lib$1.AXObjectRoles = AXObjectRoles;
	var AXObjects = _AXObjectsMap.default;
	lib$1.AXObjects = AXObjects;
	var elementAXObjects = _elementAXObjectMap.default;
	lib$1.elementAXObjects = elementAXObjects;
	return lib$1;
}

var libExports = requireLib$1();

/** @import { ARIARoleRelationConcept  } from 'aria-query' */

const aria_attributes =
	'activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext'.split(
		' '
	);

/** @type {Record<string, string[]>} */
const a11y_required_attributes = {
	a: ['href'],
	area: ['alt', 'aria-label', 'aria-labelledby'],
	// html-has-lang
	html: ['lang'],
	// iframe-has-title
	iframe: ['title'],
	img: ['alt'],
	object: ['title', 'aria-label', 'aria-labelledby']
};

const a11y_distracting_elements = ['blink', 'marquee'];

// this excludes `<a>` and `<button>` because they are handled separately
const a11y_required_content = [
	// heading-has-content
	'h1',
	'h2',
	'h3',
	'h4',
	'h5',
	'h6'
];

const a11y_labelable = [
	'button',
	'input',
	'keygen',
	'meter',
	'output',
	'progress',
	'select',
	'textarea'
];

const a11y_interactive_handlers = [
	// Keyboard events
	'keypress',
	'keydown',
	'keyup',
	// Click events
	'click',
	'contextmenu',
	'dblclick',
	'drag',
	'dragend',
	'dragenter',
	'dragexit',
	'dragleave',
	'dragover',
	'dragstart',
	'drop',
	'mousedown',
	'mouseenter',
	'mouseleave',
	'mousemove',
	'mouseout',
	'mouseover',
	'mouseup'
];

const a11y_recommended_interactive_handlers = [
	'click',
	'mousedown',
	'mouseup',
	'keypress',
	'keydown',
	'keyup'
];

const a11y_nested_implicit_semantics = new Map([
	['header', 'banner'],
	['footer', 'contentinfo']
]);

const a11y_implicit_semantics = new Map([
	['a', 'link'],
	['area', 'link'],
	['article', 'article'],
	['aside', 'complementary'],
	['body', 'document'],
	['button', 'button'],
	['datalist', 'listbox'],
	['dd', 'definition'],
	['dfn', 'term'],
	['dialog', 'dialog'],
	['details', 'group'],
	['dt', 'term'],
	['fieldset', 'group'],
	['figure', 'figure'],
	['form', 'form'],
	['h1', 'heading'],
	['h2', 'heading'],
	['h3', 'heading'],
	['h4', 'heading'],
	['h5', 'heading'],
	['h6', 'heading'],
	['hr', 'separator'],
	['img', 'img'],
	['li', 'listitem'],
	['link', 'link'],
	['main', 'main'],
	['menu', 'list'],
	['meter', 'progressbar'],
	['nav', 'navigation'],
	['ol', 'list'],
	['option', 'option'],
	['optgroup', 'group'],
	['output', 'status'],
	['progress', 'progressbar'],
	['section', 'region'],
	['summary', 'button'],
	['table', 'table'],
	['tbody', 'rowgroup'],
	['textarea', 'textbox'],
	['tfoot', 'rowgroup'],
	['thead', 'rowgroup'],
	['tr', 'row'],
	['ul', 'list']
]);

const menuitem_type_to_implicit_role = new Map([
	['command', 'menuitem'],
	['checkbox', 'menuitemcheckbox'],
	['radio', 'menuitemradio']
]);

const input_type_to_implicit_role = new Map([
	['button', 'button'],
	['image', 'button'],
	['reset', 'button'],
	['submit', 'button'],
	['checkbox', 'checkbox'],
	['radio', 'radio'],
	['range', 'slider'],
	['number', 'spinbutton'],
	['email', 'textbox'],
	['search', 'searchbox'],
	['tel', 'textbox'],
	['text', 'textbox'],
	['url', 'textbox']
]);

/**
 * Exceptions to the rule which follows common A11y conventions
 * TODO make this configurable by the user
 * @type {Record<string, string[]>}
 */
const a11y_non_interactive_element_to_interactive_role_exceptions = {
	ul: ['listbox', 'menu', 'menubar', 'radiogroup', 'tablist', 'tree', 'treegrid'],
	ol: ['listbox', 'menu', 'menubar', 'radiogroup', 'tablist', 'tree', 'treegrid'],
	li: ['menuitem', 'option', 'row', 'tab', 'treeitem'],
	table: ['grid'],
	td: ['gridcell'],
	fieldset: ['radiogroup', 'presentation']
};

const combobox_if_list = ['email', 'search', 'tel', 'text', 'url'];

// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute
const address_type_tokens = ['shipping', 'billing'];

const autofill_field_name_tokens = [
	'',
	'on',
	'off',
	'name',
	'honorific-prefix',
	'given-name',
	'additional-name',
	'family-name',
	'honorific-suffix',
	'nickname',
	'username',
	'new-password',
	'current-password',
	'one-time-code',
	'organization-title',
	'organization',
	'street-address',
	'address-line1',
	'address-line2',
	'address-line3',
	'address-level4',
	'address-level3',
	'address-level2',
	'address-level1',
	'country',
	'country-name',
	'postal-code',
	'cc-name',
	'cc-given-name',
	'cc-additional-name',
	'cc-family-name',
	'cc-number',
	'cc-exp',
	'cc-exp-month',
	'cc-exp-year',
	'cc-csc',
	'cc-type',
	'transaction-currency',
	'transaction-amount',
	'language',
	'bday',
	'bday-day',
	'bday-month',
	'bday-year',
	'sex',
	'url',
	'photo'
];

const contact_type_tokens = ['home', 'work', 'mobile', 'fax', 'pager'];

const autofill_contact_field_name_tokens = [
	'tel',
	'tel-country-code',
	'tel-national',
	'tel-area-code',
	'tel-local',
	'tel-local-prefix',
	'tel-local-suffix',
	'tel-extension',
	'email',
	'impp'
];

const ElementInteractivity = /** @type {const} */ ({
	Interactive: 'interactive',
	NonInteractive: 'non-interactive',
	Static: 'static'
});

const invisible_elements = ['meta', 'html', 'script', 'style'];

const aria_roles = libExports$1.roles.keys();

const abstract_roles = aria_roles.filter((role) => libExports$1.roles.get(role)?.abstract);

const non_abstract_roles = aria_roles.filter((name) => !abstract_roles.includes(name));

const non_interactive_roles = non_abstract_roles
	.filter((name) => {
		const role = libExports$1.roles.get(name);
		return (
			// 'toolbar' does not descend from widget, but it does support
			// aria-activedescendant, thus in practice we treat it as a widget.
			// focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
			// 'generic' is meant to have no semantic meaning.
			// 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
			!['toolbar', 'tabpanel', 'generic', 'cell'].includes(name) &&
			!role?.superClass.some((classes) => classes.includes('widget') || classes.includes('window'))
		);
	})
	.concat(
		// The `progressbar` is descended from `widget`, but in practice, its
		// value is always `readonly`, so we treat it as a non-interactive role.
		'progressbar'
	);

const interactive_roles = non_abstract_roles.filter(
	(name) =>
		!non_interactive_roles.includes(name) &&
		// 'generic' is meant to have no semantic meaning.
		name !== 'generic'
);

const presentation_roles = ['presentation', 'none'];

/** @type {ARIARoleRelationConcept[]} */
const non_interactive_element_role_schemas = [];

/** @type {ARIARoleRelationConcept[]} */
const interactive_element_role_schemas = [];

for (const [schema, roles] of libExports$1.elementRoles.entries()) {
	if ([...roles].every((role) => role !== 'generic' && non_interactive_roles.includes(role))) {
		non_interactive_element_role_schemas.push(schema);
	}

	if ([...roles].every((role) => interactive_roles.includes(role))) {
		interactive_element_role_schemas.push(schema);
	}
}

const interactive_ax_objects = [...libExports.AXObjects.keys()].filter(
	(name) => libExports.AXObjects.get(name).type === 'widget'
);

/** @type {ARIARoleRelationConcept[]} */
const interactive_element_ax_object_schemas = [];

/** @type {ARIARoleRelationConcept[]} */
const non_interactive_element_ax_object_schemas = [];

const non_interactive_ax_objects = [...libExports.AXObjects.keys()].filter((name) =>
	['windows', 'structure'].includes(libExports.AXObjects.get(name).type)
);

for (const [schema, ax_object] of libExports.elementAXObjects.entries()) {
	if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) {
		interactive_element_ax_object_schemas.push(schema);
	}

	if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) {
		non_interactive_element_ax_object_schemas.push(schema);
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../../../types.js' */
/** @import { ARIARoleDefinitionKey, ARIARoleRelationConcept, ARIAProperty, ARIAPropertyDefinition, ARIARoleDefinition } from 'aria-query' */

/**
 * @param {AST.RegularElement | AST.SvelteElement} node
 * @param {Context} context
 */
function check_element(node, context) {
	/** @type {Map<string, AST.Attribute>} */
	const attribute_map = new Map();

	/** @type {Set<string>} */
	const handlers = new Set();

	/** @type {AST.Attribute[]} */
	const attributes = [];

	const is_dynamic_element = node.type === 'SvelteElement';

	let has_spread = false;
	let has_contenteditable_attr = false;
	let has_contenteditable_binding = false;

	for (const attribute of node.attributes) {
		switch (attribute.type) {
			case 'Attribute': {
				if (is_event_attribute(attribute)) {
					handlers.add(attribute.name.slice(2));
				} else {
					attributes.push(attribute);
					attribute_map.set(attribute.name, attribute);
					if (attribute.name === 'contenteditable') {
						has_contenteditable_attr = true;
					}
				}
				break;
			}
			case 'SpreadAttribute': {
				has_spread = true;
				break;
			}
			case 'BindDirective': {
				if (is_content_editable_binding(attribute.name)) {
					has_contenteditable_binding = true;
				}
				break;
			}
			case 'OnDirective': {
				handlers.add(attribute.name);
				break;
			}
		}
	}

	for (const attribute of node.attributes) {
		if (attribute.type !== 'Attribute') continue;

		const name = attribute.name.toLowerCase();
		// aria-props
		if (name.startsWith('aria-')) {
			if (invisible_elements.includes(node.name)) {
				// aria-unsupported-elements
				a11y_aria_attributes(attribute, node.name);
			}

			const type = name.slice(5);
			if (!aria_attributes.includes(type)) {
				const match = fuzzymatch(type, aria_attributes);
				a11y_unknown_aria_attribute(attribute, type, match);
			}

			if (name === 'aria-hidden' && regex_heading_tags.test(node.name)) {
				a11y_hidden(attribute, node.name);
			}

			// aria-proptypes
			let value = get_static_value(attribute);

			const schema = libExports$1.aria.get(/** @type {ARIAProperty} */ (name));
			if (schema !== undefined) {
				validate_aria_attribute_value(attribute, /** @type {ARIAProperty} */ (name), schema, value);
			}

			// aria-activedescendant-has-tabindex
			if (
				name === 'aria-activedescendant' &&
				!is_dynamic_element &&
				!is_interactive_element(node.name, attribute_map) &&
				!attribute_map.has('tabindex') &&
				!has_spread
			) {
				a11y_aria_activedescendant_has_tabindex(attribute);
			}
		}

		switch (name) {
			// aria-role
			case 'role': {
				if (invisible_elements.includes(node.name)) {
					// aria-unsupported-elements
					a11y_misplaced_role(attribute, node.name);
				}

				const value = get_static_value(attribute);
				if (typeof value !== 'string') {
					break;
				}
				for (const c_r of value.split(regex_whitespaces)) {
					const current_role = /** @type {ARIARoleDefinitionKey} current_role */ (c_r);

					if (current_role && is_abstract_role(current_role)) {
						a11y_no_abstract_role(attribute, current_role);
					} else if (current_role && !aria_roles.includes(current_role)) {
						const match = fuzzymatch(current_role, aria_roles);
						a11y_unknown_role(attribute, current_role, match);
					}

					// no-redundant-roles
					if (
						current_role === get_implicit_role(node.name, attribute_map) &&
						// <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
						!['ul', 'ol', 'li'].includes(node.name) &&
						// <a role="link" /> is ok because without href the a tag doesn't have a role of link
						!(node.name === 'a' && !attribute_map.has('href'))
					) {
						a11y_no_redundant_roles(attribute, current_role);
					}

					// Footers and headers are special cases, and should not have redundant roles unless they are the children of sections or articles.
					const is_parent_section_or_article = is_parent(context.path, ['section', 'article']);
					if (!is_parent_section_or_article) {
						const has_nested_redundant_role =
							current_role === a11y_nested_implicit_semantics.get(node.name);
						if (has_nested_redundant_role) {
							a11y_no_redundant_roles(attribute, current_role);
						}
					}

					// role-has-required-aria-props
					if (
						!is_dynamic_element &&
						!is_semantic_role_element(current_role, node.name, attribute_map)
					) {
						const role = libExports$1.roles.get(current_role);
						if (role) {
							const required_role_props = Object.keys(role.requiredProps);
							const has_missing_props =
								!has_spread &&
								required_role_props.some((prop) => !attributes.find((a) => a.name === prop));
							if (has_missing_props) {
								a11y_role_has_required_aria_props(
									attribute,
									current_role,
									list$1(
										required_role_props.map((v) => `"${v}"`),
										'and'
									)
								);
							}
						}
					}

					// interactive-supports-focus
					if (
						!has_spread &&
						!has_disabled_attribute(attribute_map) &&
						!is_hidden_from_screen_reader(node.name, attribute_map) &&
						!is_presentation_role(current_role) &&
						is_interactive_roles(current_role) &&
						is_static_element$1(node.name, attribute_map) &&
						!attribute_map.get('tabindex')
					) {
						const has_interactive_handlers = [...handlers].some((handler) =>
							a11y_interactive_handlers.includes(handler)
						);
						if (has_interactive_handlers) {
							a11y_interactive_supports_focus(node, current_role);
						}
					}

					// no-interactive-element-to-noninteractive-role
					if (
						!has_spread &&
						is_interactive_element(node.name, attribute_map) &&
						(is_non_interactive_roles(current_role) || is_presentation_role(current_role))
					) {
						a11y_no_interactive_element_to_noninteractive_role(node, node.name, current_role);
					}

					// no-noninteractive-element-to-interactive-role
					if (
						!has_spread &&
						is_non_interactive_element(node.name, attribute_map) &&
						is_interactive_roles(current_role) &&
						!a11y_non_interactive_element_to_interactive_role_exceptions[node.name]?.includes(
							current_role
						)
					) {
						a11y_no_noninteractive_element_to_interactive_role(node, node.name, current_role);
					}
				}
				break;
			}
			// no-access-key
			case 'accesskey': {
				a11y_accesskey(attribute);
				break;
			}
			// no-autofocus
			case 'autofocus': {
				if (node.name !== 'dialog' && !is_parent(context.path, ['dialog'])) {
					a11y_autofocus(attribute);
				}
				break;
			}
			// scope
			case 'scope': {
				if (!is_dynamic_element && node.name !== 'th') {
					a11y_misplaced_scope(attribute);
				}
				break;
			}
			// tabindex-no-positive
			case 'tabindex': {
				const value = get_static_value(attribute);
				// @ts-ignore todo is tabindex=true correct case?
				if (!isNaN(value) && +value > 0) {
					a11y_positive_tabindex(attribute);
				}
				break;
			}
		}
	}

	const role = attribute_map.get('role');
	const role_static_value = /** @type {ARIARoleDefinitionKey} */ (get_static_text_value(role));

	// click-events-have-key-events
	if (handlers.has('click')) {
		const is_non_presentation_role =
			role_static_value !== null && !is_presentation_role(role_static_value);
		if (
			!is_dynamic_element &&
			!is_hidden_from_screen_reader(node.name, attribute_map) &&
			(!role || is_non_presentation_role) &&
			!is_interactive_element(node.name, attribute_map) &&
			!has_spread
		) {
			const has_key_event =
				handlers.has('keydown') || handlers.has('keyup') || handlers.has('keypress');
			if (!has_key_event) {
				a11y_click_events_have_key_events(node);
			}
		}
	}

	const role_value = /** @type {ARIARoleDefinitionKey} */ (
		role ? role_static_value : get_implicit_role(node.name, attribute_map)
	);

	// no-noninteractive-tabindex
	if (
		!is_dynamic_element &&
		!is_interactive_element(node.name, attribute_map) &&
		!is_interactive_roles(role_static_value)
	) {
		const tab_index = attribute_map.get('tabindex');
		const tab_index_value = get_static_text_value(tab_index);
		if (tab_index && (tab_index_value === null || Number(tab_index_value) >= 0)) {
			a11y_no_noninteractive_tabindex(node);
		}
	}

	// role-supports-aria-props
	if (typeof role_value === 'string' && libExports$1.roles.has(role_value)) {
		const { props } = /** @type {ARIARoleDefinition} */ (libExports$1.roles.get(role_value));
		const invalid_aria_props = libExports$1.aria.keys().filter((attribute) => !(attribute in props));
		const is_implicit = role_value && role === undefined;
		for (const attr of attributes) {
			if (invalid_aria_props.includes(/** @type {ARIAProperty} */ (attr.name))) {
				if (is_implicit) {
					a11y_role_supports_aria_props_implicit(attr, attr.name, role_value, node.name);
				} else {
					a11y_role_supports_aria_props(attr, attr.name, role_value);
				}
			}
		}
	}

	// no-noninteractive-element-interactions
	if (
		!has_spread &&
		!has_contenteditable_attr &&
		!is_hidden_from_screen_reader(node.name, attribute_map) &&
		!is_presentation_role(role_static_value) &&
		((!is_interactive_element(node.name, attribute_map) &&
			is_non_interactive_roles(role_static_value)) ||
			(is_non_interactive_element(node.name, attribute_map) && !role))
	) {
		const has_interactive_handlers = [...handlers].some((handler) =>
			a11y_recommended_interactive_handlers.includes(handler)
		);
		if (has_interactive_handlers) {
			a11y_no_noninteractive_element_interactions(node, node.name);
		}
	}

	// no-static-element-interactions
	if (
		!has_spread &&
		(!role || role_static_value !== null) &&
		!is_hidden_from_screen_reader(node.name, attribute_map) &&
		!is_presentation_role(role_static_value) &&
		!is_interactive_element(node.name, attribute_map) &&
		!is_interactive_roles(role_static_value) &&
		!is_non_interactive_element(node.name, attribute_map) &&
		!is_non_interactive_roles(role_static_value) &&
		!is_abstract_role(role_static_value)
	) {
		const interactive_handlers = [...handlers].filter((handler) =>
			a11y_interactive_handlers.includes(handler)
		);
		if (interactive_handlers.length > 0) {
			a11y_no_static_element_interactions(node, node.name, list$1(interactive_handlers));
		}
	}

	if (!has_spread && handlers.has('mouseover') && !handlers.has('focus')) {
		a11y_mouse_events_have_key_events(node, 'mouseover', 'focus');
	}

	if (!has_spread && handlers.has('mouseout') && !handlers.has('blur')) {
		a11y_mouse_events_have_key_events(node, 'mouseout', 'blur');
	}

	// element-specific checks
	const is_labelled =
		attribute_map.has('aria-label') ||
		attribute_map.has('aria-labelledby') ||
		attribute_map.has('title');

	switch (node.name) {
		case 'a':
		case 'button': {
			const is_hidden =
				get_static_value(attribute_map.get('aria-hidden')) === 'true' ||
				get_static_value(attribute_map.get('inert')) !== null;

			if (!has_spread && !is_hidden && !is_labelled && !has_content$1(node)) {
				a11y_consider_explicit_label(node);
			}
			if (node.name === 'button') {
				break;
			}
			const href = attribute_map.get('href') || attribute_map.get('xlink:href');
			if (href) {
				const href_value = get_static_text_value(href);
				if (href_value !== null) {
					if (href_value === '' || href_value === '#' || regex_js_prefix.test(href_value)) {
						a11y_invalid_attribute(href, href_value, href.name);
					}
				}
			} else if (!has_spread) {
				const id_attribute = get_static_value(attribute_map.get('id'));
				const name_attribute = get_static_value(attribute_map.get('name'));
				const aria_disabled_attribute = get_static_value(attribute_map.get('aria-disabled'));
				if (!id_attribute && !name_attribute && aria_disabled_attribute !== 'true') {
					warn_missing_attribute(node, ['href']);
				}
			}
			break;
		}
		case 'input': {
			const type = attribute_map.get('type');
			const type_value = get_static_text_value(type);
			if (type_value === 'image' && !has_spread) {
				const required_attributes = ['alt', 'aria-label', 'aria-labelledby'];
				const has_attribute = required_attributes.some((name) => attribute_map.has(name));
				if (!has_attribute) {
					warn_missing_attribute(node, required_attributes, 'input type="image"');
				}
			}
			// autocomplete-valid
			const autocomplete = attribute_map.get('autocomplete');
			if (type && autocomplete) {
				const autocomplete_value = get_static_value(autocomplete);
				if (!is_valid_autocomplete(autocomplete_value)) {
					a11y_autocomplete_valid(
						autocomplete,
						/** @type {string} */ (autocomplete_value),
						type_value ?? '...'
					);
				}
			}
			break;
		}
		case 'img': {
			const alt_attribute = get_static_text_value(attribute_map.get('alt'));
			const aria_hidden = get_static_value(attribute_map.get('aria-hidden'));
			if (alt_attribute && !aria_hidden && !has_spread) {
				if (regex_redundant_img_alt.test(alt_attribute)) {
					a11y_img_redundant_alt(node);
				}
			}
			break;
		}
		case 'label': {
			/** @param {AST.TemplateNode} node */
			const has_input_child = (node) => {
				let has = false;
				walk$1(
					node,
					{},
					{
						_(node, { next }) {
							if (
								node.type === 'SvelteElement' ||
								node.type === 'SlotElement' ||
								node.type === 'Component' ||
								node.type === 'RenderTag' ||
								(node.type === 'RegularElement' &&
									(a11y_labelable.includes(node.name) || node.name === 'slot'))
							) {
								has = true;
							} else {
								next();
							}
						}
					}
				);
				return has;
			};
			if (!has_spread && !attribute_map.has('for') && !has_input_child(node)) {
				a11y_label_has_associated_control(node);
			}
			break;
		}
		case 'video': {
			const aria_hidden_attribute = attribute_map.get('aria-hidden');
			const aria_hidden_exist = aria_hidden_attribute && get_static_value(aria_hidden_attribute);

			if (attribute_map.has('muted') || aria_hidden_exist === 'true' || has_spread) {
				return;
			}

			if (!attribute_map.has('src')) {
				// don't warn about missing captions if `<video>` has no `src` —
				// could e.g. be playing a MediaStream
				return;
			}

			let has_caption = false;
			const track = /** @type {AST.RegularElement | undefined} */ (
				node.fragment.nodes.find((i) => i.type === 'RegularElement' && i.name === 'track')
			);
			if (track) {
				has_caption = track.attributes.some(
					(a) =>
						a.type === 'SpreadAttribute' ||
						(a.type === 'Attribute' && a.name === 'kind' && get_static_value(a) === 'captions')
				);
			}
			if (!has_caption) {
				a11y_media_has_caption(node);
			}
			break;
		}
		case 'figcaption': {
			if (!is_parent(context.path, ['figure'])) {
				a11y_figcaption_parent(node);
			}
			break;
		}
		case 'figure': {
			const children = node.fragment.nodes.filter((node) => {
				if (node.type === 'Comment') return false;
				if (node.type === 'Text') return regex_not_whitespace.test(node.data);
				return true;
			});
			const index = children.findIndex(
				(child) => child.type === 'RegularElement' && child.name === 'figcaption'
			);
			if (index !== -1 && index !== 0 && index !== children.length - 1) {
				a11y_figcaption_index(children[index]);
			}
			break;
		}
	}

	if (!has_spread && node.name !== 'a') {
		const required_attributes = a11y_required_attributes[node.name];
		if (required_attributes) {
			const has_attribute = required_attributes.some((name) => attribute_map.has(name));
			if (!has_attribute) {
				warn_missing_attribute(node, required_attributes);
			}
		}
	}

	if (a11y_distracting_elements.includes(node.name)) {
		// no-distracting-elements
		a11y_distracting_elements$1(node, node.name);
	}

	// Check content
	if (
		!has_spread &&
		!is_labelled &&
		!has_contenteditable_binding &&
		a11y_required_content.includes(node.name) &&
		!has_content$1(node)
	) {
		a11y_missing_content(node, node.name);
	}
}

/**
 * @param {ARIARoleDefinitionKey} role
 */
function is_presentation_role(role) {
	return presentation_roles.includes(role);
}

/**
 * @param {string} tag_name
 * @param {Map<string, AST.Attribute>} attribute_map
 */
function is_hidden_from_screen_reader(tag_name, attribute_map) {
	if (tag_name === 'input') {
		const type = get_static_value(attribute_map.get('type'));
		if (type === 'hidden') {
			return true;
		}
	}

	const aria_hidden = attribute_map.get('aria-hidden');
	if (!aria_hidden) return false;
	const aria_hidden_value = get_static_value(aria_hidden);
	if (aria_hidden_value === null) return true;
	return aria_hidden_value === true || aria_hidden_value === 'true';
}

/**
 * @param {Map<string, AST.Attribute>} attribute_map
 */
function has_disabled_attribute(attribute_map) {
	const disabled_attr_value = get_static_value(attribute_map.get('disabled'));
	if (disabled_attr_value) {
		return true;
	}

	const aria_disabled_attr = attribute_map.get('aria-disabled');
	if (aria_disabled_attr) {
		const aria_disabled_attr_value = get_static_value(aria_disabled_attr);
		if (aria_disabled_attr_value === 'true') {
			return true;
		}
	}
	return false;
}

/**
 * @param {string} tag_name
 * @param {Map<string, AST.Attribute>} attribute_map
 * @returns {typeof ElementInteractivity[keyof typeof ElementInteractivity]}
 */
function element_interactivity(tag_name, attribute_map) {
	if (
		interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))
	) {
		return ElementInteractivity.Interactive;
	}
	if (
		tag_name !== 'header' &&
		non_interactive_element_role_schemas.some((schema) =>
			match_schema(schema, tag_name, attribute_map)
		)
	) {
		return ElementInteractivity.NonInteractive;
	}
	if (
		interactive_element_ax_object_schemas.some((schema) =>
			match_schema(schema, tag_name, attribute_map)
		)
	) {
		return ElementInteractivity.Interactive;
	}
	if (
		non_interactive_element_ax_object_schemas.some((schema) =>
			match_schema(schema, tag_name, attribute_map)
		)
	) {
		return ElementInteractivity.NonInteractive;
	}
	return ElementInteractivity.Static;
}

/**
 * @param {string} tag_name
 * @param {Map<string, AST.Attribute>} attribute_map
 * @returns {boolean}
 */
function is_interactive_element(tag_name, attribute_map) {
	return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}

/**
 * @param {string} tag_name
 * @param {Map<string, AST.Attribute>} attribute_map
 * @returns {boolean}
 */
function is_non_interactive_element(tag_name, attribute_map) {
	return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}

/**
 * @param {string} tag_name
 * @param {Map<string, AST.Attribute>} attribute_map
 * @returns {boolean}
 */
function is_static_element$1(tag_name, attribute_map) {
	return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}

/**
 * @param {ARIARoleDefinitionKey} role
 * @param {string} tag_name
 * @param {Map<string, AST.Attribute>} attribute_map
 */
function is_semantic_role_element(role, tag_name, attribute_map) {
	for (const [schema, ax_object] of libExports.elementAXObjects.entries()) {
		if (
			schema.name === tag_name &&
			(!schema.attributes ||
				schema.attributes.every(
					/** @param {any} attr */
					(attr) =>
						attribute_map.has(attr.name) &&
						get_static_value(attribute_map.get(attr.name)) === attr.value
				))
		) {
			for (const name of ax_object) {
				const roles = libExports.AXObjectRoles.get(name);
				if (roles) {
					for (const { name } of roles) {
						if (name === role) {
							return true;
						}
					}
				}
			}
		}
	}
	return false;
}

/**
 * @param {null | true | string} autocomplete
 */
function is_valid_autocomplete(autocomplete) {
	if (autocomplete === true) {
		return false;
	} else if (!autocomplete) {
		return true; // dynamic value
	}
	const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
	if (typeof tokens[0] === 'string' && tokens[0].startsWith('section-')) {
		tokens.shift();
	}
	if (address_type_tokens.includes(tokens[0])) {
		tokens.shift();
	}
	if (autofill_field_name_tokens.includes(tokens[0])) {
		tokens.shift();
	} else {
		if (contact_type_tokens.includes(tokens[0])) {
			tokens.shift();
		}
		if (autofill_contact_field_name_tokens.includes(tokens[0])) {
			tokens.shift();
		} else {
			return false;
		}
	}
	if (tokens[0] === 'webauthn') {
		tokens.shift();
	}
	return tokens.length === 0;
}

/** @param {Map<string, AST.Attribute>} attribute_map */
function input_implicit_role(attribute_map) {
	const type_attribute = attribute_map.get('type');
	if (!type_attribute) return;
	const type = get_static_text_value(type_attribute);
	if (!type) return;
	const list_attribute_exists = attribute_map.has('list');
	if (list_attribute_exists && combobox_if_list.includes(type)) {
		return 'combobox';
	}
	return input_type_to_implicit_role.get(type);
}

/** @param {Map<string, AST.Attribute>} attribute_map */
function menuitem_implicit_role(attribute_map) {
	const type_attribute = attribute_map.get('type');
	if (!type_attribute) return;
	const type = get_static_text_value(type_attribute);
	if (!type) return;
	return menuitem_type_to_implicit_role.get(type);
}

/**
 * @param {string} name
 * @param {Map<string, AST.Attribute>} attribute_map
 */
function get_implicit_role(name, attribute_map) {
	if (name === 'menuitem') {
		return menuitem_implicit_role(attribute_map);
	} else if (name === 'input') {
		return input_implicit_role(attribute_map);
	} else {
		return a11y_implicit_semantics.get(name);
	}
}

/**
 * @param {ARIARoleDefinitionKey} role
 */
function is_non_interactive_roles(role) {
	return non_interactive_roles.includes(role);
}

/**
 * @param {ARIARoleDefinitionKey} role
 */
function is_interactive_roles(role) {
	return interactive_roles.includes(role);
}

/**
 * @param {ARIARoleDefinitionKey} role
 */
function is_abstract_role(role) {
	return abstract_roles.includes(role);
}

/**
 * @param {AST.Attribute | undefined} attribute
 */
function get_static_text_value(attribute) {
	const value = get_static_value(attribute);
	if (value === true) return null;
	return value;
}

/**
 * @param {AST.Attribute | undefined} attribute
 */
function get_static_value(attribute) {
	if (!attribute) return null;
	if (attribute.value === true) return true;
	if (is_text_attribute(attribute)) return attribute.value[0].data;
	return null;
}

/**
 * @param {AST.RegularElement | AST.SvelteElement} element
 */
function has_content$1(element) {
	for (const node of element.fragment.nodes) {
		if (node.type === 'Text') {
			if (node.data.trim() === '') {
				continue;
			}
		}

		if (node.type === 'RegularElement' || node.type === 'SvelteElement') {
			if (
				node.name === 'img' &&
				node.attributes.some((node) => node.type === 'Attribute' && node.name === 'alt')
			) {
				return true;
			}

			if (!has_content$1(node)) {
				continue;
			}
		}

		// assume everything else has content — this will result in false positives
		// (e.g. an empty `{#if ...}{/if}`) but that's probably fine
		return true;
	}
}

/**
 * @param {ARIARoleRelationConcept} schema
 * @param {string} tag_name
 * @param {Map<string, AST.Attribute>} attribute_map
 */
function match_schema(schema, tag_name, attribute_map) {
	if (schema.name !== tag_name) return false;
	if (!schema.attributes) return true;
	return schema.attributes.every((schema_attribute) => {
		const attribute = attribute_map.get(schema_attribute.name);
		if (!attribute) return false;
		if (schema_attribute.value && schema_attribute.value !== get_static_text_value(attribute)) {
			return false;
		}
		return true;
	});
}

/**
 * @param {AST.SvelteNode[]} path
 * @param {string[]} elements
 */
function is_parent(path, elements) {
	let i = path.length;
	while (i--) {
		const parent = path[i];
		if (parent.type === 'SvelteElement') return true; // unknown, play it safe, so we don't warn
		if (parent.type === 'RegularElement') {
			return elements.includes(parent.name);
		}
	}
	return false;
}

/**
 * @param {AST.Attribute} attribute
 * @param {ARIAProperty} name
 * @param {ARIAPropertyDefinition} schema
 * @param {string | true | null} value
 */
function validate_aria_attribute_value(attribute, name, schema, value) {
	const type = schema.type;

	if (value === null) return;
	if (value === true) value = '';

	switch (type) {
		case 'id':
		case 'string': {
			if (value === '') {
				a11y_incorrect_aria_attribute_type(attribute, name, 'non-empty string');
			}
			break;
		}
		case 'number': {
			if (value === '' || isNaN(+value)) {
				a11y_incorrect_aria_attribute_type(attribute, name, 'number');
			}
			break;
		}
		case 'boolean': {
			if (value !== 'true' && value !== 'false') {
				a11y_incorrect_aria_attribute_type_boolean(attribute, name);
			}
			break;
		}
		case 'idlist': {
			if (value === '') {
				a11y_incorrect_aria_attribute_type_idlist(attribute, name);
			}
			break;
		}
		case 'integer': {
			if (value === '' || !Number.isInteger(+value)) {
				a11y_incorrect_aria_attribute_type_integer(attribute, name);
			}
			break;
		}
		case 'token': {
			const values = (schema.values ?? []).map((value) => value.toString());
			if (!values.includes(value.toLowerCase())) {
				a11y_incorrect_aria_attribute_type_token(
					attribute,
					name,
					list$1(values.map((v) => `"${v}"`))
				);
			}
			break;
		}
		case 'tokenlist': {
			const values = (schema.values ?? []).map((value) => value.toString());
			if (
				value
					.toLowerCase()
					.split(regex_whitespaces)
					.some((value) => !values.includes(value))
			) {
				a11y_incorrect_aria_attribute_type_tokenlist(
					attribute,
					name,
					list$1(values.map((v) => `"${v}"`))
				);
			}
			break;
		}
		case 'tristate': {
			if (value !== 'true' && value !== 'false' && value !== 'mixed') {
				a11y_incorrect_aria_attribute_type_tristate(attribute, name);
			}
			break;
		}
	}
}

/**
 * @param {AST.RegularElement |AST.SvelteElement} node
 * @param {string[]} attributes
 * @param {string} name
 */
function warn_missing_attribute(node, attributes, name = node.name) {
	const article =
		regex_starts_with_vowel.test(attributes[0]) || attributes[0] === 'href' ? 'an' : 'a';
	const sequence =
		attributes.length > 1
			? attributes.slice(0, -1).join(', ') + ` or ${attributes[attributes.length - 1]}`
			: attributes[0];

	a11y_missing_attribute(node, name, article, sequence);
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../../types' */

const EVENT_MODIFIERS = [
	'preventDefault',
	'stopPropagation',
	'stopImmediatePropagation',
	'capture',
	'once',
	'passive',
	'nonpassive',
	'self',
	'trusted'
];

/**
 * @param {AST.RegularElement | AST.SvelteElement} node
 * @param {Context} context
 */
function validate_element(node, context) {
	let has_animate_directive = false;

	/** @type {AST.TransitionDirective | null} */
	let in_transition = null;

	/** @type {AST.TransitionDirective | null} */
	let out_transition = null;

	for (const attribute of node.attributes) {
		if (attribute.type === 'Attribute') {
			const is_expression = is_expression_attribute(attribute);

			if (context.state.analysis.runes) {
				validate_attribute(attribute, node);

				if (is_expression) {
					const expression = get_attribute_expression(attribute);
					if (expression.type === 'SequenceExpression') {
						let i = /** @type {number} */ (expression.start);
						while (--i > 0) {
							const char = context.state.analysis.source[i];
							if (char === '(') break; // parenthesized sequence expressions are ok
							if (char === '{') attribute_invalid_sequence_expression(expression);
						}
					}
				}
			}

			if (regex_illegal_attribute_character.test(attribute.name)) {
				attribute_invalid_name(attribute, attribute.name);
			}

			if (attribute.name.startsWith('on') && attribute.name.length > 2) {
				if (!is_expression) {
					attribute_invalid_event_handler(attribute);
				}

				const value = get_attribute_expression(attribute);
				if (
					value.type === 'Identifier' &&
					value.name === attribute.name &&
					!context.state.scope.get(value.name)
				) {
					attribute_global_event_reference(attribute, attribute.name);
				}
			}

			if (attribute.name === 'slot') {
				/** @type {AST.RegularElement | AST.SvelteElement | AST.Component | AST.SvelteComponent | AST.SvelteSelf | undefined} */
				validate_slot_attribute(context, attribute);
			}

			if (attribute.name === 'is') {
				attribute_avoid_is(attribute);
			}

			const correct_name = react_attributes.get(attribute.name);
			if (correct_name) {
				attribute_invalid_property_name(attribute, attribute.name, correct_name);
			}

			validate_attribute_name(attribute);
		} else if (attribute.type === 'AnimateDirective') {
			const parent = context.path.at(-2);
			if (parent?.type !== 'EachBlock') {
				animation_invalid_placement(attribute);
			} else if (!parent.key) {
				animation_missing_key(attribute);
			} else if (
				parent.body.nodes.filter(
					(n) =>
						n.type !== 'Comment' &&
						n.type !== 'ConstTag' &&
						(n.type !== 'Text' || n.data.trim() !== '')
				).length > 1
			) {
				animation_invalid_placement(attribute);
			}

			if (has_animate_directive) {
				animation_duplicate(attribute);
			} else {
				has_animate_directive = true;
			}
		} else if (attribute.type === 'TransitionDirective') {
			const existing = /** @type {AST.TransitionDirective | null} */ (
				(attribute.intro && in_transition) || (attribute.outro && out_transition)
			);

			if (existing) {
				const a = existing.intro ? (existing.outro ? 'transition' : 'in') : 'out';
				const b = attribute.intro ? (attribute.outro ? 'transition' : 'in') : 'out';

				if (a === b) {
					transition_duplicate(attribute, a);
				} else {
					transition_conflict(attribute, a, b);
				}
			}

			if (attribute.intro) in_transition = attribute;
			if (attribute.outro) out_transition = attribute;
		} else if (attribute.type === 'OnDirective') {
			let has_passive_modifier = false;
			let conflicting_passive_modifier = '';
			for (const modifier of attribute.modifiers) {
				if (!EVENT_MODIFIERS.includes(modifier)) {
					const list = `${EVENT_MODIFIERS.slice(0, -1).join(', ')} or ${EVENT_MODIFIERS.at(-1)}`;
					event_handler_invalid_modifier(attribute, list);
				}
				if (modifier === 'passive') {
					has_passive_modifier = true;
				} else if (modifier === 'nonpassive' || modifier === 'preventDefault') {
					conflicting_passive_modifier = modifier;
				}
				if (has_passive_modifier && conflicting_passive_modifier) {
					event_handler_invalid_modifier_combination(
						attribute,
						'passive',
						conflicting_passive_modifier
					);
				}
			}
		}
	}
}

const react_attributes = new Map([
	['className', 'class'],
	['htmlFor', 'for']
]);

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.RegularElement} node
 * @param {Context} context
 */
function RegularElement$2(node, context) {
	validate_element(node, context);
	check_element(node, context);

	node.metadata.path = [...context.path];
	context.state.analysis.elements.push(node);

	// Special case: Move the children of <textarea> into a value attribute if they are dynamic
	if (node.name === 'textarea' && node.fragment.nodes.length > 0) {
		for (const attribute of node.attributes) {
			if (attribute.type === 'Attribute' && attribute.name === 'value') {
				textarea_invalid_content(node);
			}
		}

		if (node.fragment.nodes.length > 1 || node.fragment.nodes[0].type !== 'Text') {
			const first = node.fragment.nodes[0];
			if (first.type === 'Text') {
				// The leading newline character needs to be stripped because of a qirk:
				// It is ignored by browsers if the tag and its contents are set through
				// innerHTML, but we're now setting it through the value property at which
				// point it is _not_ ignored, so we need to strip it ourselves.
				// see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
				// see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
				first.data = first.data.replace(regex_starts_with_newline, '');
				first.raw = first.raw.replace(regex_starts_with_newline, '');
			}

			node.attributes.push(
				create_attribute(
					'value',
					null,
					-1,
					-1,
					// @ts-ignore
					node.fragment.nodes
				)
			);

			node.fragment.nodes = [];
		}
	}

	// Special case: single expression tag child of option element -> add "fake" attribute
	// to ensure that value types are the same (else for example numbers would be strings)
	if (
		node.name === 'option' &&
		node.fragment.nodes?.length === 1 &&
		node.fragment.nodes[0].type === 'ExpressionTag' &&
		!node.attributes.some(
			(attribute) => attribute.type === 'Attribute' && attribute.name === 'value'
		)
	) {
		const child = node.fragment.nodes[0];
		node.metadata.synthetic_value_node = child;
	}

	const binding = context.state.scope.get(node.name);
	if (
		binding !== null &&
		binding.declaration_kind === 'import' &&
		binding.references.length === 0
	) {
		component_name_lowercase(node, node.name);
	}

	node.metadata.has_spread = node.attributes.some(
		(attribute) => attribute.type === 'SpreadAttribute'
	);

	const is_svg_element = () => {
		if (is_svg(node.name)) {
			return true;
		}

		if (node.name === 'a' || node.name === 'title') {
			let i = context.path.length;

			while (i--) {
				const ancestor = context.path[i];
				if (ancestor.type === 'RegularElement') {
					return ancestor.metadata.svg;
				}
			}
		}

		return false;
	};

	node.metadata.svg = is_svg_element();
	node.metadata.mathml = is_mathml(node.name);

	if (is_custom_element_node(node) && node.attributes.length > 0) {
		// we're setting all attributes on custom elements through properties
		mark_subtree_dynamic(context.path);
	}

	if (context.state.parent_element) {
		let past_parent = false;
		let only_warn = false;
		const ancestors = [context.state.parent_element];

		for (let i = context.path.length - 1; i >= 0; i--) {
			const ancestor = context.path[i];

			if (
				ancestor.type === 'IfBlock' ||
				ancestor.type === 'EachBlock' ||
				ancestor.type === 'AwaitBlock' ||
				ancestor.type === 'KeyBlock'
			) {
				// We're creating a separate template string inside blocks, which means client-side this would work
				only_warn = true;
			}

			if (!past_parent) {
				if (ancestor.type === 'RegularElement' && ancestor.name === context.state.parent_element) {
					const message = is_tag_valid_with_parent(node.name, context.state.parent_element);
					if (message) {
						if (only_warn) {
							node_invalid_placement_ssr(node, message);
						} else {
							node_invalid_placement(node, message);
						}
					}

					past_parent = true;
				}
			} else if (ancestor.type === 'RegularElement') {
				ancestors.push(ancestor.name);

				const message = is_tag_valid_with_ancestor(node.name, ancestors);
				if (message) {
					if (only_warn) {
						node_invalid_placement_ssr(node, message);
					} else {
						node_invalid_placement(node, message);
					}
				}
			} else if (
				ancestor.type === 'Component' ||
				ancestor.type === 'SvelteComponent' ||
				ancestor.type === 'SvelteElement' ||
				ancestor.type === 'SvelteSelf' ||
				ancestor.type === 'SnippetBlock'
			) {
				break;
			}
		}
	}

	// Strip off any namespace from the beginning of the node name.
	const node_name = node.name.replace(/[a-zA-Z-]*:/g, '');

	if (
		context.state.analysis.source[node.end - 2] === '/' &&
		!is_void(node_name) &&
		!is_svg(node_name) &&
		!is_mathml(node_name)
	) {
		element_invalid_self_closing_tag(node, node.name);
	}

	context.next({ ...context.state, parent_element: node.name });

	// Special case: <a> tags are valid in both the SVG and HTML namespace.
	// If there's no parent, look downwards to see if it's the parent of a SVG or HTML element.
	if (node.name === 'a' && !context.state.parent_element) {
		for (const child of node.fragment.nodes) {
			if (child.type === 'RegularElement') {
				if (child.metadata.svg && child.name !== 'svg') {
					node.metadata.svg = true;
					break;
				}
			}
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.RenderTag} node
 * @param {Context} context
 */
function RenderTag$2(node, context) {
	validate_opening_tag(node, context.state, '@');

	node.metadata.path = [...context.path];

	const expression = unwrap_optional(node.expression);
	const callee = expression.callee;

	const binding = callee.type === 'Identifier' ? context.state.scope.get(callee.name) : null;

	node.metadata.dynamic = binding?.kind !== 'normal';

	/**
	 * If we can't unambiguously resolve this to a declaration, we
	 * must assume the worst and link the render tag to every snippet
	 */
	let resolved = callee.type === 'Identifier' && is_resolved_snippet(binding);

	if (binding?.initial?.type === 'SnippetBlock') {
		// if this render tag unambiguously references a local snippet, our job is easy
		node.metadata.snippets.add(binding.initial);
	}

	context.state.analysis.snippet_renderers.set(node, resolved);
	context.state.analysis.uses_render_tags = true;

	const raw_args = unwrap_optional(node.expression).arguments;
	for (const arg of raw_args) {
		if (arg.type === 'SpreadElement') {
			render_tag_invalid_spread_argument(arg);
		}
	}

	if (
		callee.type === 'MemberExpression' &&
		callee.property.type === 'Identifier' &&
		['bind', 'apply', 'call'].includes(callee.property.name)
	) {
		render_tag_invalid_call_expression(node);
	}

	mark_subtree_dynamic(context.path);

	context.visit(callee, { ...context.state, expression: node.metadata.expression });

	for (const arg of expression.arguments) {
		const metadata = new ExpressionMetadata();
		node.metadata.arguments.push(metadata);

		context.visit(arg, {
			...context.state,
			expression: metadata
		});
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SlotElement} node
 * @param {Context} context
 */
function SlotElement$2(node, context) {
	if (context.state.analysis.runes && !context.state.analysis.custom_element) {
		slot_element_deprecated(node);
	}

	mark_subtree_dynamic(context.path);

	/** @type {string} */
	let name = 'default';

	for (const attribute of node.attributes) {
		if (attribute.type === 'Attribute') {
			if (attribute.name === 'name') {
				if (!is_text_attribute(attribute)) {
					slot_element_invalid_name(attribute);
				}

				name = attribute.value[0].data;
				if (name === 'default') {
					slot_element_invalid_name_default(attribute);
				}
			}
		} else if (attribute.type !== 'SpreadAttribute' && attribute.type !== 'LetDirective') {
			slot_element_invalid_attribute(attribute);
		}
	}

	context.state.analysis.slot_names.set(name, node);

	context.next();
}

/** @import { AST, Binding } from '#compiler' */
/** @import { Scope } from '../../scope' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SnippetBlock} node
 * @param {Context} context
 */
function SnippetBlock$2(node, context) {
	context.state.analysis.snippets.add(node);

	validate_block_not_empty(node.body);

	if (context.state.analysis.runes) {
		validate_opening_tag(node, context.state, '#');
	}

	for (const arg of node.parameters) {
		if (arg.type === 'RestElement') {
			snippet_invalid_rest_parameter(arg);
		}
	}

	context.next({ ...context.state, parent_element: null });

	const can_hoist =
		context.path.length === 1 &&
		context.path[0].type === 'Fragment' &&
		can_hoist_snippet(context.state.scope, context.state.scopes);

	const name = node.expression.name;

	if (can_hoist) {
		const binding = /** @type {Binding} */ (context.state.scope.get(name));
		context.state.analysis.module.scope.declarations.set(name, binding);
	}

	node.metadata.can_hoist = can_hoist;

	const { path } = context;
	const parent = path.at(-2);
	if (!parent) return;

	if (
		parent.type === 'Component' &&
		parent.attributes.some(
			(attribute) =>
				(attribute.type === 'Attribute' || attribute.type === 'BindDirective') &&
				attribute.name === node.expression.name
		)
	) {
		snippet_shadowing_prop(node, node.expression.name);
	}

	if (node.expression.name !== 'children') return;

	if (
		parent.type === 'Component' ||
		parent.type === 'SvelteComponent' ||
		parent.type === 'SvelteSelf'
	) {
		if (
			parent.fragment.nodes.some(
				(node) =>
					node.type !== 'SnippetBlock' &&
					(node.type !== 'Text' || node.data.trim()) &&
					node.type !== 'Comment'
			)
		) {
			snippet_conflict(node);
		}
	}
}

/**
 * @param {Map<AST.SvelteNode, Scope>} scopes
 * @param {Scope} scope
 */
function can_hoist_snippet(scope, scopes, visited = new Set()) {
	for (const [reference] of scope.references) {
		const binding = scope.get(reference);
		if (!binding) continue;

		if (binding.blocker) {
			return false;
		}

		if (binding.scope.function_depth === 0) {
			continue;
		}

		// ignore bindings declared inside the snippet (e.g. the snippet's own parameters)
		if (binding.scope.function_depth >= scope.function_depth) {
			continue;
		}

		if (binding.initial?.type === 'SnippetBlock') {
			if (visited.has(binding)) continue;
			visited.add(binding);
			const snippet_scope = /** @type {Scope} */ (scopes.get(binding.initial));

			if (can_hoist_snippet(snippet_scope, scopes, visited)) {
				continue;
			}
		}

		return false;
	}

	return true;
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */


/**
 * @param {AST.SpreadAttribute} node
 * @param {Context} context
 */
function SpreadAttribute$2(node, context) {
	mark_subtree_dynamic(context.path);
	context.next({ ...context.state, expression: node.metadata.expression });
}

/** @import { SpreadElement } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {SpreadElement} node
 * @param {Context} context
 */
function SpreadElement(node, context) {
	if (context.state.expression) {
		// treat e.g. `[...x]` the same as `[...x.values()]`
		context.state.expression.has_call = true;
		context.state.expression.has_state = true;
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.StyleDirective} node
 * @param {Context} context
 */
function StyleDirective(node, context) {
	if (node.modifiers.length > 1 || (node.modifiers.length && node.modifiers[0] !== 'important')) {
		style_directive_invalid_modifier(node);
	}

	mark_subtree_dynamic(context.path);

	if (node.value === true) {
		// get the binding for node.name and change the binding to state
		let binding = context.state.scope.get(node.name);

		if (binding) {
			if (binding.kind !== 'normal') {
				node.metadata.expression.has_state = true;
			}
			if (binding.blocker) {
				node.metadata.expression.dependencies.add(binding);
			}
		}
	} else {
		context.next();

		for (const chunk of get_attribute_chunks(node.value)) {
			if (chunk.type !== 'ExpressionTag') continue;

			node.metadata.expression.merge(chunk.metadata.expression);
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteBody} node
 * @param {Context} context
 */
function SvelteBody$1(node, context) {
	disallow_children(node);
	for (const attribute of node.attributes) {
		if (
			attribute.type === 'SpreadAttribute' ||
			(attribute.type === 'Attribute' && !is_event_attribute(attribute))
		) {
			svelte_body_illegal_attribute(attribute);
		}
	}
	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteComponent} node
 * @param {Context} context
 */
function SvelteComponent$2(node, context) {
	if (context.state.analysis.runes) {
		svelte_component_deprecated(node);
	}

	context.visit(node.expression, { ...context.state, expression: node.metadata.expression });

	visit_component(node, context);
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteDocument} node
 * @param {Context} context
 */
function SvelteDocument$1(node, context) {
	disallow_children(node);

	for (const attribute of node.attributes) {
		if (
			attribute.type === 'SpreadAttribute' ||
			(attribute.type === 'Attribute' && !is_event_attribute(attribute))
		) {
			illegal_element_attribute(attribute, 'svelte:document');
		}
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteElement} node
 * @param {Context} context
 */
function SvelteElement$2(node, context) {
	validate_element(node, context);
	check_element(node, context);

	node.metadata.path = [...context.path];
	context.state.analysis.elements.push(node);

	const xmlns = /** @type {AST.Attribute & { value: [AST.Text] } | undefined} */ (
		node.attributes.find(
			(a) => a.type === 'Attribute' && a.name === 'xmlns' && is_text_attribute(a)
		)
	);

	if (xmlns) {
		node.metadata.svg = xmlns.value[0].data === NAMESPACE_SVG;
		node.metadata.mathml = xmlns.value[0].data === NAMESPACE_MATHML;
	} else {
		let i = context.path.length;
		while (i--) {
			const ancestor = context.path[i];

			if (
				ancestor.type === 'Component' ||
				ancestor.type === 'SvelteComponent' ||
				ancestor.type === 'SvelteFragment' ||
				ancestor.type === 'SnippetBlock' ||
				i === 0
			) {
				// Root element, or inside a slot or a snippet -> this resets the namespace, so assume the component namespace
				node.metadata.svg = context.state.options.namespace === 'svg';
				node.metadata.mathml = context.state.options.namespace === 'mathml';
				break;
			}

			if (ancestor.type === 'SvelteElement' || ancestor.type === 'RegularElement') {
				node.metadata.svg =
					ancestor.type === 'RegularElement' && ancestor.name === 'foreignObject'
						? false
						: ancestor.metadata.svg;

				node.metadata.mathml =
					ancestor.type === 'RegularElement' && ancestor.name === 'foreignObject'
						? false
						: ancestor.metadata.mathml;

				break;
			}
		}
	}

	mark_subtree_dynamic(context.path);

	context.visit(node.tag, {
		...context.state,
		expression: node.metadata.expression
	});

	for (const attribute of node.attributes) {
		context.visit(attribute);
	}

	context.visit(node.fragment, {
		...context.state,
		parent_element: null
	});
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteFragment} node
 * @param {Context} context
 */
function SvelteFragment$2(node, context) {
	const parent = context.path.at(-2);
	if (parent?.type !== 'Component' && parent?.type !== 'SvelteComponent') {
		svelte_fragment_invalid_placement(node);
	}

	for (const attribute of node.attributes) {
		if (attribute.type === 'Attribute') {
			if (attribute.name === 'slot') {
				validate_slot_attribute(context, attribute);
			}
		} else if (attribute.type !== 'LetDirective') {
			svelte_fragment_invalid_attribute(attribute);
		}
	}

	context.next({ ...context.state, parent_element: null });
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteHead} node
 * @param {Context} context
 */
function SvelteHead$2(node, context) {
	for (const attribute of node.attributes) {
		svelte_head_illegal_attribute(attribute);
	}

	mark_subtree_dynamic(context.path);

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteSelf} node
 * @param {Context} context
 */
function SvelteSelf$2(node, context) {
	const valid = context.path.some(
		(node) =>
			node.type === 'IfBlock' ||
			node.type === 'EachBlock' ||
			node.type === 'Component' ||
			node.type === 'SnippetBlock'
	);

	if (!valid) {
		svelte_self_invalid_placement(node);
	}

	if (context.state.analysis.runes) {
		const name = filename === UNKNOWN_FILENAME ? 'Self' : context.state.analysis.name;
		const basename =
			filename === UNKNOWN_FILENAME
				? 'Self.svelte'
				: /** @type {string} */ (filename.split(/[/\\]/).pop());

		svelte_self_deprecated(node, name, basename);
	}

	visit_component(node, context);
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.SvelteWindow} node
 * @param {Context} context
 */
function SvelteWindow$1(node, context) {
	disallow_children(node);

	for (const attribute of node.attributes) {
		if (
			attribute.type === 'SpreadAttribute' ||
			(attribute.type === 'Attribute' && !is_event_attribute(attribute))
		) {
			illegal_element_attribute(attribute, 'svelte:window');
		}
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

const valid = ['onerror', 'failed', 'pending'];

/**
 * @param {AST.SvelteBoundary} node
 * @param {Context} context
 */
function SvelteBoundary$2(node, context) {
	for (const attribute of node.attributes) {
		if (attribute.type !== 'Attribute' || !valid.includes(attribute.name)) {
			svelte_boundary_invalid_attribute(attribute);
		}

		if (
			attribute.value === true ||
			(Array.isArray(attribute.value) &&
				(attribute.value.length !== 1 || attribute.value[0].type !== 'ExpressionTag'))
		) {
			svelte_boundary_invalid_attribute_value(attribute);
		}
	}

	context.next();
}

/** @import { TaggedTemplateExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {TaggedTemplateExpression} node
 * @param {Context} context
 */
function TaggedTemplateExpression(node, context) {
	if (context.state.expression && !is_pure(node.tag, context)) {
		context.state.expression.has_call = true;
		context.state.expression.has_state = true;
	}

	context.next();
}

/** @import { TemplateElement } from 'estree' */

/**
 * @param {TemplateElement} node
 */
function TemplateElement(node) {
	if (regex_bidirectional_control_characters.test(node.value.cooked ?? '')) {
		bidirectional_control_characters(node);
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.Text} node
 * @param {Context} context
 */
function Text(node, context) {
	const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1));

	if (
		parent.type === 'Fragment' &&
		context.state.parent_element &&
		regex_not_whitespace.test(node.data)
	) {
		const message = is_tag_valid_with_parent('#text', context.state.parent_element);
		if (message) {
			node_invalid_placement(node, message);
		}
	}

	regex_bidirectional_control_characters.lastIndex = 0;
	for (const match of node.data.matchAll(regex_bidirectional_control_characters)) {
		let is_ignored = false;

		// if we have a svelte-ignore comment earlier in the text, bail
		// (otherwise we can only use svelte-ignore on parent elements/blocks)
		if (parent.type === 'Fragment') {
			for (const child of parent.nodes) {
				if (child === node) break;

				if (child.type === 'Comment') {
					is_ignored ||= extract_svelte_ignore(
						child.start + 4,
						child.data,
						context.state.analysis.runes
					).includes('bidirectional_control_characters');
				}
			}
		}

		if (!is_ignored) {
			let start = match.index + node.start;
			bidirectional_control_characters({ start, end: start + match[0].length });
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.TitleElement} node
 * @param {Context} context
 */
function TitleElement$2(node, context) {
	for (const attribute of node.attributes) {
		title_illegal_attribute(attribute);
	}

	for (const child of node.fragment.nodes) {
		if (child.type !== 'Text' && child.type !== 'ExpressionTag') {
			title_invalid_content(child);
		}
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.TransitionDirective} node
 * @param {Context} context
 */
function TransitionDirective$1(node, context) {
	mark_subtree_dynamic(context.path);

	context.next({ ...context.state, expression: node.metadata.expression });

	if (node.metadata.expression.has_await) {
		illegal_await_expression(node);
	}
}

/** @import { UpdateExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {UpdateExpression} node
 * @param {Context} context
 */
function UpdateExpression$2(node, context) {
	validate_assignment(node, node.argument, context);

	if (context.state.reactive_statement) {
		const id = node.argument.type === 'MemberExpression' ? object$1(node.argument) : node.argument;
		if (id?.type === 'Identifier') {
			const binding = context.state.scope.get(id.name);

			if (binding) {
				context.state.reactive_statement.assignments.add(binding);
			}
		}
	}

	if (context.state.expression) {
		context.state.expression.has_assignment = true;
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {AST.UseDirective} node
 * @param {Context} context
 */
function UseDirective$1(node, context) {
	mark_subtree_dynamic(context.path);

	context.next({ ...context.state, expression: node.metadata.expression });

	if (node.metadata.expression.has_await) {
		illegal_await_expression(node);
	}
}

/**
 * @template T
 * @param {any} actual
 * @param {T} expected
 * @returns {asserts actual is T}
 */
function equal(actual, expected) {
	if (actual !== expected) throw new Error('Assertion failed');
}

/** @import { Expression, Identifier, Literal, VariableDeclarator } from 'estree' */
/** @import { Binding } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {VariableDeclarator} node
 * @param {Context} context
 */
function VariableDeclarator(node, context) {
	ensure_no_module_import_conflict(node, context.state);

	if (context.state.analysis.runes) {
		const init = node.init;
		const rune = get_rune(init, context.state.scope);
		const { paths } = extract_paths(node.id, id$2('dummy'));

		for (const path of paths) {
			validate_identifier_name(context.state.scope.get(/** @type {Identifier} */ (path.node).name));
		}

		// TODO feels like this should happen during scope creation?
		if (
			rune === '$state' ||
			rune === '$state.raw' ||
			rune === '$derived' ||
			rune === '$derived.by' ||
			rune === '$props'
		) {
			for (const path of paths) {
				// @ts-ignore this fails in CI for some insane reason
				const binding = /** @type {Binding} */ (context.state.scope.get(path.node.name));
				binding.kind =
					rune === '$state'
						? 'state'
						: rune === '$state.raw'
							? 'raw_state'
							: rune === '$derived' || rune === '$derived.by'
								? 'derived'
								: path.is_rest
									? 'rest_prop'
									: 'prop';
				if (rune === '$props' && binding.kind === 'rest_prop' && node.id.type === 'ObjectPattern') {
					const { properties } = node.id;
					/** @type {string[]} */
					const exclude_props = [];
					for (const property of properties) {
						if (property.type === 'RestElement') {
							continue;
						}
						const key = /** @type {Identifier | Literal & { value: string | number }} */ (
							property.key
						);
						exclude_props.push(key.type === 'Identifier' ? key.name : key.value.toString());
					}
					(binding.metadata ??= {}).exclude_props = exclude_props;
				}
			}
		}

		if (rune === '$props') {
			if (node.id.type !== 'ObjectPattern' && node.id.type !== 'Identifier') {
				props_invalid_identifier(node);
			}

			if (
				context.state.analysis.custom_element &&
				context.state.options.customElementOptions?.props == null
			) {
				let warn_on;
				if (
					node.id.type === 'Identifier' ||
					(warn_on = node.id.properties.find((p) => p.type === 'RestElement')) != null
				) {
					custom_element_props_identifier(warn_on ?? node.id);
				}
			}

			context.state.analysis.needs_props = true;

			if (node.id.type === 'Identifier') {
				const binding = /** @type {Binding} */ (context.state.scope.get(node.id.name));
				binding.initial = null; // else would be $props()
				binding.kind = 'rest_prop';
			} else {
				equal(node.id.type, 'ObjectPattern');

				for (const property of node.id.properties) {
					if (property.type !== 'Property') continue;

					if (property.computed) {
						props_invalid_pattern(property);
					}

					if (property.key.type === 'Identifier' && property.key.name.startsWith('$$')) {
						props_illegal_name(property);
					}

					const value =
						property.value.type === 'AssignmentPattern' ? property.value.left : property.value;

					if (value.type !== 'Identifier') {
						props_invalid_pattern(property);
					}

					const alias =
						property.key.type === 'Identifier'
							? property.key.name
							: String(/** @type {Literal} */ (property.key).value);

					let initial = property.value.type === 'AssignmentPattern' ? property.value.right : null;

					const binding = /** @type {Binding} */ (context.state.scope.get(value.name));
					binding.prop_alias = alias;

					// rewire initial from $props() to the actual initial value, stripping $bindable() if necessary
					if (
						initial?.type === 'CallExpression' &&
						initial.callee.type === 'Identifier' &&
						initial.callee.name === '$bindable'
					) {
						binding.initial = /** @type {Expression | null} */ (initial.arguments[0] ?? null);
						binding.kind = 'bindable_prop';
					} else {
						binding.initial = initial;
					}
				}
			}
		}
	} else {
		if (node.init?.type === 'CallExpression') {
			const callee = node.init.callee;
			if (
				callee.type === 'Identifier' &&
				(callee.name === '$state' || callee.name === '$derived' || callee.name === '$props') &&
				context.state.scope.get(callee.name)?.kind !== 'store_sub'
			) {
				rune_invalid_usage(node.init, callee.name);
			}
		}
	}

	if (node.init && get_rune(node.init, context.state.scope) === '$props') {
		// prevent erroneous `state_referenced_locally` warnings on prop fallbacks
		context.visit(node.id, {
			...context.state,
			function_depth: context.state.function_depth + 1
		});

		context.visit(node.init);
	} else {
		context.next();
	}
}

/** @import * as ESTree from 'estree' */
/** @import { Binding, AST, ValidatedCompileOptions, ValidatedModuleCompileOptions } from '#compiler' */
/** @import { AnalysisState, Visitors } from './types' */
/** @import { Analysis, ComponentAnalysis, Js, ReactiveStatement, Template } from '../types' */

/**
 * @type {Visitors}
 */
const visitors$2 = {
	_(node, { state, next, path }) {
		const parent = path.at(-1);

		/** @type {string[]} */
		const ignores = [];

		if (parent?.type === 'Fragment' && node.type !== 'Comment' && node.type !== 'Text') {
			const idx = parent.nodes.indexOf(/** @type {any} */ (node));

			for (let i = idx - 1; i >= 0; i--) {
				const prev = parent.nodes[i];

				if (prev.type === 'Comment') {
					ignores.push(
						...extract_svelte_ignore(
							prev.start + 4 /* '<!--'.length */,
							prev.data,
							state.analysis.runes
						)
					);
				} else if (prev.type !== 'Text') {
					break;
				}
			}
		} else {
			const comments = /** @type {any} */ (node).leadingComments;

			if (comments) {
				for (const comment of comments) {
					ignores.push(
						...extract_svelte_ignore(
							comment.start + 2 /* '//'.length */,
							comment.value,
							state.analysis.runes
						)
					);
				}
			}
		}

		if (ignores.length > 0) {
			push_ignore(ignores);
		}

		ignore_map.set(node, structuredClone(ignore_stack));

		const scope = state.scopes.get(node);
		next(scope !== undefined && scope !== state.scope ? { ...state, scope } : state);

		if (ignores.length > 0) {
			pop_ignore();
		}
	},
	AnimateDirective: AnimateDirective$1,
	ArrowFunctionExpression: ArrowFunctionExpression$1,
	AssignmentExpression: AssignmentExpression$2,
	AttachTag: AttachTag$1,
	Attribute: Attribute$1,
	AwaitBlock: AwaitBlock$2,
	AwaitExpression: AwaitExpression$2,
	BindDirective: BindDirective$1,
	CallExpression: CallExpression$2,
	ClassBody: ClassBody$2,
	ClassDeclaration,
	ClassDirective,
	Component: Component$2,
	ConstTag: ConstTag$2,
	DebugTag: DebugTag$2,
	EachBlock: EachBlock$2,
	ExportDefaultDeclaration,
	ExportNamedDeclaration: ExportNamedDeclaration$1,
	ExportSpecifier,
	ExpressionStatement: ExpressionStatement$2,
	ExpressionTag,
	Fragment: Fragment$2,
	FunctionDeclaration: FunctionDeclaration$1,
	FunctionExpression: FunctionExpression$1,
	HtmlTag: HtmlTag$2,
	Identifier: Identifier$2,
	IfBlock: IfBlock$2,
	ImportDeclaration,
	KeyBlock: KeyBlock$2,
	LabeledStatement: LabeledStatement$2,
	LetDirective: LetDirective$1,
	Literal,
	MemberExpression: MemberExpression$2,
	NewExpression,
	OnDirective: OnDirective$1,
	PropertyDefinition: PropertyDefinition$1,
	RegularElement: RegularElement$2,
	RenderTag: RenderTag$2,
	SlotElement: SlotElement$2,
	SnippetBlock: SnippetBlock$2,
	SpreadAttribute: SpreadAttribute$2,
	SpreadElement,
	StyleDirective,
	SvelteBody: SvelteBody$1,
	SvelteComponent: SvelteComponent$2,
	SvelteDocument: SvelteDocument$1,
	SvelteElement: SvelteElement$2,
	SvelteFragment: SvelteFragment$2,
	SvelteHead: SvelteHead$2,
	SvelteSelf: SvelteSelf$2,
	SvelteWindow: SvelteWindow$1,
	SvelteBoundary: SvelteBoundary$2,
	TaggedTemplateExpression,
	TemplateElement,
	Text,
	TransitionDirective: TransitionDirective$1,
	TitleElement: TitleElement$2,
	UpdateExpression: UpdateExpression$2,
	UseDirective: UseDirective$1,
	VariableDeclarator
};

/**
 * @param {AST.Script | null} script
 * @param {ScopeRoot} root
 * @param {boolean} allow_reactive_declarations
 * @param {Scope | null} parent
 * @returns {Js}
 */
function js(script, root, allow_reactive_declarations, parent) {
	/** @type {ESTree.Program} */
	const ast = script?.content ?? {
		type: 'Program',
		sourceType: 'module',
		start: -1,
		end: -1,
		body: []
	};

	const { scope, scopes, has_await } = create_scopes(
		ast,
		root,
		allow_reactive_declarations,
		parent
	);

	return { ast, scope, scopes, has_await };
}

/**
 * @param {string} filename
 */
function get_component_name(filename) {
	const parts = filename.split(/[/\\]/);
	const basename = /** @type {string} */ (parts.pop());
	const last_dir = /** @type {string} */ (parts.at(-1));
	let name = basename.replace('.svelte', '');
	if (name === 'index' && last_dir && last_dir !== 'src') {
		name = last_dir;
	}
	return name[0].toUpperCase() + name.slice(1);
}

const RESERVED = ['$$props', '$$restProps', '$$slots'];

/**
 * @param {string} source
 * @param {ValidatedModuleCompileOptions} options
 * @returns {Analysis}
 */
function analyze_module(source, options) {
	/** @type {AST.JSComment[]} */
	const comments = [];

	set_source(source);
	const ast = parse$4(source, comments, false, false);

	const { scope, scopes, has_await } = create_scopes(ast, new ScopeRoot(), false, null);

	for (const [name, references] of scope.references) {
		if (name[0] !== '$' || RESERVED.includes(name)) continue;
		if (name === '$' || name[1] === '$') {
			global_reference_invalid(references[0].node, name);
		}

		const binding = scope.get(name.slice(1));

		if (binding !== null && !is_rune(name)) {
			store_invalid_subscription_module(references[0].node);
		}
	}

	/** @type {Analysis} */
	const analysis = {
		module: { ast, scope, scopes, has_await },
		name: options.filename,
		accessors: false,
		runes: true,
		immutable: true,
		tracing: false,
		async_deriveds: new Set(),
		comments,
		classes: new Map(),
		pickled_awaits: new Set()
	};

	adjust({
		dev: options.dev,
		rootDir: options.rootDir,
		runes: true
	});

	walk$1(
		/** @type {ESTree.Node} */ (ast),
		{
			scope,
			scopes,
			analysis: /** @type {ComponentAnalysis} */ (analysis),
			state_fields: new Map(),
			// TODO the following are not needed for modules, but we have to pass them in order to avoid type error,
			// and reducing the type would result in a lot of tedious type casts elsewhere - find a good solution one day
			ast_type: /** @type {any} */ (null),
			component_slots: /** @type {Set<string>} */ (new Set()),
			expression: null,
			function_depth: 0,
			has_props_rune: false,
			options: /** @type {ValidatedCompileOptions} */ (options),
			fragment: null,
			parent_element: null,
			reactive_statement: null,
			derived_function_depth: -1
		},
		visitors$2
	);

	return analysis;
}

/**
 * @param {AST.Root} root
 * @param {string} source
 * @param {ValidatedCompileOptions} options
 * @returns {ComponentAnalysis}
 */
function analyze_component(root, source, options) {
	const scope_root = new ScopeRoot();

	const module = js(root.module, scope_root, false, null);
	const instance = js(root.instance, scope_root, true, module.scope);

	const { scope, scopes, has_await } = create_scopes(
		root.fragment,
		scope_root,
		false,
		instance.scope
	);

	/** @type {Template} */
	const template = { ast: root.fragment, scope, scopes };

	let synthetic_stores_legacy_check = [];

	// create synthetic bindings for store subscriptions
	for (const [name, references] of module.scope.references) {
		if (name[0] !== '$' || RESERVED.includes(name)) continue;
		if (name === '$' || name[1] === '$') {
			global_reference_invalid(references[0].node, name);
		}

		const store_name = name.slice(1);
		const declaration = instance.scope.get(store_name);
		const init = /** @type {ESTree.Node | undefined} */ (declaration?.initial);

		// If we're not in legacy mode through the compiler option, assume the user
		// is referencing a rune and not a global store.
		if (
			options.runes === false ||
			!is_rune(name) ||
			(declaration !== null &&
				// const state = $state(0) is valid
				(get_rune(init, instance.scope) === null ||
					// rune-line names received as props are valid too (but we have to protect against $props as store)
					(store_name !== 'props' && get_rune(init, instance.scope) === '$props')) &&
				// allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other
				!(
					name === '$derived' &&
					declaration.initial?.type === 'ImportDeclaration' &&
					declaration.initial.source.value === 'svelte/store'
				))
		) {
			let is_nested_store_subscription_node = undefined;
			search: for (const reference of references) {
				for (let i = reference.path.length - 1; i >= 0; i--) {
					const scope =
						scopes.get(reference.path[i]) ||
						module.scopes.get(reference.path[i]) ||
						instance.scopes.get(reference.path[i]);
					if (scope) {
						const owner = scope?.owner(store_name);
						if (!!owner && owner !== module.scope && owner !== instance.scope) {
							is_nested_store_subscription_node = reference.node;
							break search;
						}
						break;
					}
				}
			}

			if (is_nested_store_subscription_node) {
				store_invalid_scoped_subscription(is_nested_store_subscription_node);
			}

			if (options.runes !== false) {
				if (declaration === null && /[a-z]/.test(store_name[0])) {
					global_reference_invalid(references[0].node, name);
				} else if (declaration !== null && is_rune(name)) {
					for (const { node, path } of references) {
						if (path.at(-1)?.type === 'CallExpression') {
							store_rune_conflict(node, store_name);
						}
					}
				}
			}

			if (module.ast) {
				for (const { node, path } of references) {
					// if the reference is inside module, error. this is a bit hacky but it works
					if (
						/** @type {number} */ (node.start) > /** @type {number} */ (module.ast.start) &&
						/** @type {number} */ (node.end) < /** @type {number} */ (module.ast.end) &&
						// const state = $state(0) is valid
						get_rune(/** @type {ESTree.Node} */ (path.at(-1)), module.scope) === null
					) {
						store_invalid_subscription(node);
					}
				}
			}

			// we push to the array because at this moment in time we can't be sure if we are in legacy
			// mode yet because we are still changing the module scope
			synthetic_stores_legacy_check.push(() => {
				// if we are creating a synthetic binding for a let declaration we should also declare
				// the declaration as state in case it's reassigned and we are not in runes mode (the function will
				// not be called if we are not in runes mode, that's why there's no !runes check here)
				if (
					declaration !== null &&
					declaration.kind === 'normal' &&
					declaration.declaration_kind === 'let' &&
					declaration.reassigned
				) {
					declaration.kind = 'state';
				}
			});

			const binding = instance.scope.declare(id$2(name), 'store_sub', 'synthetic');
			binding.references = references;
			instance.scope.references.set(name, references);
			module.scope.references.delete(name);
		}
	}

	const component_name = get_component_name(options.filename);

	const runes =
		options.runes ??
		(has_await || instance.has_await || Array.from(module.scope.references.keys()).some(is_rune));

	if (!runes) {
		for (let check of synthetic_stores_legacy_check) {
			check();
		}
	}

	if (runes && root.module) {
		const context = root.module.attributes.find((attribute) => attribute.name === 'context');
		if (context) {
			script_context_deprecated(context);
		}
	}

	const is_custom_element = !!options.customElementOptions || options.customElement;

	const name = module.scope.generate(options.name ?? component_name);

	adjust({
		component_name: name,
		dev: options.dev,
		rootDir: options.rootDir,
		runes
	});

	// TODO remove all the ?? stuff, we don't need it now that we're validating the config
	/** @type {ComponentAnalysis} */
	const analysis = {
		name,
		root: scope_root,
		module,
		instance,
		template,
		comments: root.comments,
		elements: [],
		runes,
		// if we are not in runes mode but we have no reserved references ($$props, $$restProps)
		// and no `export let` we might be in a wannabe runes component that is using runes in an external
		// module...we need to fallback to the runic behavior
		maybe_runes:
			!runes &&
			// if they explicitly disabled runes, use the legacy behavior
			options.runes !== false &&
			![...module.scope.references.keys()].some((name) =>
				['$$props', '$$restProps'].includes(name)
			) &&
			!instance.ast.body.some(
				(node) =>
					node.type === 'LabeledStatement' ||
					(node.type === 'ExportNamedDeclaration' &&
						((node.declaration &&
							node.declaration.type === 'VariableDeclaration' &&
							node.declaration.kind === 'let') ||
							node.specifiers.some(
								(specifier) =>
									specifier.local.type === 'Identifier' &&
									instance.scope.get(specifier.local.name)?.declaration_kind === 'let'
							)))
			),
		tracing: false,
		classes: new Map(),
		immutable: runes || options.immutable,
		exports: [],
		uses_props: false,
		props_id: null,
		uses_rest_props: false,
		uses_slots: false,
		uses_component_bindings: false,
		uses_render_tags: false,
		needs_context: false,
		needs_mutation_validation: false,
		needs_props: false,
		event_directive_node: null,
		uses_event_attributes: false,
		custom_element: is_custom_element,
		inject_styles: options.css === 'injected' || is_custom_element,
		accessors:
			is_custom_element ||
			(runes ? false : !!options.accessors) ||
			// because $set method needs accessors
			options.compatibility?.componentApi === 4,
		reactive_statements: new Map(),
		binding_groups: new Map(),
		slot_names: new Map(),
		css: {
			ast: root.css,
			hash: root.css
				? options.cssHash({
						css: root.css.content.styles,
						filename: filename,
						name: component_name,
						hash
					})
				: '',
			keyframes: [],
			has_global: false
		},
		source,
		snippet_renderers: new Map(),
		snippets: new Set(),
		async_deriveds: new Set(),
		pickled_awaits: new Set(),
		instance_body: {
			sync: [],
			async: [],
			declarations: [],
			hoisted: []
		}
	};

	if (!runes) {
		// every exported `let` or `var` declaration becomes a prop, everything else becomes an export
		for (const node of instance.ast.body) {
			if (node.type !== 'ExportNamedDeclaration') continue;

			analysis.needs_props = true;

			if (node.declaration) {
				if (
					node.declaration.type === 'FunctionDeclaration' ||
					node.declaration.type === 'ClassDeclaration'
				) {
					analysis.exports.push({
						name: /** @type {import('estree').Identifier} */ (node.declaration.id).name,
						alias: null
					});
				} else if (node.declaration.type === 'VariableDeclaration') {
					if (node.declaration.kind === 'const') {
						for (const declarator of node.declaration.declarations) {
							for (const node of extract_identifiers(declarator.id)) {
								analysis.exports.push({ name: node.name, alias: null });
							}
						}
					} else {
						for (const declarator of node.declaration.declarations) {
							for (const id of extract_identifiers(declarator.id)) {
								const binding = /** @type {Binding} */ (instance.scope.get(id.name));
								binding.kind = 'bindable_prop';
							}
						}
					}
				}
			} else {
				for (const specifier of node.specifiers) {
					if (specifier.local.type !== 'Identifier' || specifier.exported.type !== 'Identifier') {
						continue;
					}

					const binding = instance.scope.get(specifier.local.name);

					if (
						binding &&
						(binding.declaration_kind === 'var' || binding.declaration_kind === 'let')
					) {
						binding.kind = 'bindable_prop';

						if (specifier.exported.name !== specifier.local.name) {
							binding.prop_alias = specifier.exported.name;
						}
					} else {
						analysis.exports.push({ name: specifier.local.name, alias: specifier.exported.name });
					}
				}
			}
		}

		// if reassigned/mutated bindings are referenced in `$:` blocks
		// or the template, turn them into state
		for (const binding of instance.scope.declarations.values()) {
			if (binding.kind !== 'normal') continue;

			for (const { node, path } of binding.references) {
				if (node === binding.node) continue;

				if (binding.updated) {
					if (
						path[path.length - 1].type === 'StyleDirective' ||
						path.some((node) => node.type === 'Fragment') ||
						(path[1].type === 'LabeledStatement' && path[1].label.name === '$')
					) {
						binding.kind = 'state';
					}
				}
			}
		}

		// more legacy nonsense: if an `each` binding is reassigned/mutated,
		// treat the expression as being mutated as well
		walk$1(/** @type {AST.SvelteNode} */ (template.ast), null, {
			EachBlock(node) {
				const scope = /** @type {Scope} */ (template.scopes.get(node));

				for (const binding of scope.declarations.values()) {
					if (binding.updated) {
						const state = { scope: /** @type {Scope} */ (scope.parent), scopes: template.scopes };

						walk$1(node.expression, state, {
							// @ts-expect-error
							_: set_scope,
							Identifier(node, context) {
								const parent = /** @type {ESTree.Expression} */ (context.path.at(-1));

								if (is_reference(node, parent)) {
									const binding = context.state.scope.get(node.name);

									if (
										binding &&
										binding.kind === 'normal' &&
										binding.declaration_kind !== 'import'
									) {
										binding.kind = 'state';
										binding.mutated = true;
									}
								}
							}
						});

						break;
					}
				}
			}
		});
	}

	if (root.options) {
		for (const attribute of root.options.attributes) {
			if (attribute.name === 'accessors' && analysis.runes) {
				options_deprecated_accessors(attribute);
			}

			if (attribute.name === 'customElement' && !options.customElement) {
				options_missing_custom_element(attribute);
			}

			if (attribute.name === 'immutable' && analysis.runes) {
				options_deprecated_immutable(attribute);
			}
		}
	}

	calculate_blockers(instance, scopes, analysis);

	if (analysis.runes) {
		const props_refs = module.scope.references.get('$$props');
		if (props_refs) {
			legacy_props_invalid(props_refs[0].node);
		}

		const rest_props_refs = module.scope.references.get('$$restProps');
		if (rest_props_refs) {
			legacy_rest_props_invalid(rest_props_refs[0].node);
		}

		for (const { ast, scope, scopes } of [module, instance, template]) {
			/** @type {AnalysisState} */
			const state = {
				scope,
				scopes,
				analysis,
				options,
				ast_type: ast === instance.ast ? 'instance' : ast === template.ast ? 'template' : 'module',
				fragment: ast === template.ast ? ast : null,
				parent_element: null,
				has_props_rune: false,
				component_slots: new Set(),
				expression: null,
				state_fields: new Map(),
				function_depth: scope.function_depth,
				reactive_statement: null,
				derived_function_depth: -1
			};

			walk$1(/** @type {AST.SvelteNode} */ (ast), state, visitors$2);
		}

		// warn on any nonstate declarations that are a) reassigned and b) referenced in the template
		for (const scope of [module.scope, instance.scope]) {
			outer: for (const [name, binding] of scope.declarations) {
				if (binding.kind === 'normal' && binding.reassigned) {
					inner: for (const { path } of binding.references) {
						if (path[0].type !== 'Fragment') continue;
						for (let i = 1; i < path.length; i += 1) {
							const type = path[i].type;
							if (
								type === 'FunctionDeclaration' ||
								type === 'FunctionExpression' ||
								type === 'ArrowFunctionExpression'
							) {
								continue inner;
							}
							// bind:this doesn't need to be a state reference if it will never change
							if (
								type === 'BindDirective' &&
								/** @type {AST.BindDirective} */ (path[i]).name === 'this'
							) {
								for (let j = i - 1; j >= 0; j -= 1) {
									const type = path[j].type;
									if (
										type === 'IfBlock' ||
										type === 'EachBlock' ||
										type === 'AwaitBlock' ||
										type === 'KeyBlock'
									) {
										non_reactive_update(binding.node, name);
										continue outer;
									}
								}
								continue inner;
							}
						}

						non_reactive_update(binding.node, name);
						continue outer;
					}
				}
			}
		}
	} else {
		instance.scope.declare(id$2('$$props'), 'rest_prop', 'synthetic');
		instance.scope.declare(id$2('$$restProps'), 'rest_prop', 'synthetic');

		for (const { ast, scope, scopes } of [module, instance, template]) {
			/** @type {AnalysisState} */
			const state = {
				scope,
				scopes,
				analysis,
				options,
				fragment: ast === template.ast ? ast : null,
				parent_element: null,
				has_props_rune: false,
				ast_type: ast === instance.ast ? 'instance' : ast === template.ast ? 'template' : 'module',
				reactive_statement: null,
				component_slots: new Set(),
				expression: null,
				state_fields: new Map(),
				function_depth: scope.function_depth,
				derived_function_depth: -1
			};

			walk$1(/** @type {AST.SvelteNode} */ (ast), state, visitors$2);
		}

		for (const [name, binding] of instance.scope.declarations) {
			if (
				(binding.kind === 'prop' || binding.kind === 'bindable_prop') &&
				binding.node.name !== '$$props'
			) {
				const references = binding.references.filter(
					(r) => r.node !== binding.node && r.path.at(-1)?.type !== 'ExportSpecifier'
				);
				if (!references.length && !instance.scope.declarations.has(`$${name}`)) {
					export_let_unused(binding.node, name);
				}
			}
		}

		analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements);
	}

	for (const node of analysis.module.ast.body) {
		if (node.type === 'ExportNamedDeclaration' && node.specifiers !== null && node.source == null) {
			for (const specifier of node.specifiers) {
				if (specifier.local.type !== 'Identifier') continue;
				const name = specifier.local.name;
				const binding = analysis.module.scope.get(name);
				if (!binding) {
					if ([...analysis.snippets].find((snippet) => snippet.expression.name === name)) {
						snippet_invalid_export(specifier);
					} else {
						export_undefined(specifier, name);
					}
				}
			}
		}
	}

	if (analysis.event_directive_node && analysis.uses_event_attributes) {
		mixed_event_handler_syntaxes(
			analysis.event_directive_node,
			analysis.event_directive_node.name
		);
	}

	for (const [node, resolved] of analysis.snippet_renderers) {
		if (!resolved) {
			node.metadata.snippets = analysis.snippets;
		}

		for (const snippet of node.metadata.snippets) {
			snippet.metadata.sites.add(node);
		}
	}

	if (
		analysis.uses_render_tags &&
		(analysis.uses_slots || (!analysis.custom_element && analysis.slot_names.size > 0))
	) {
		const pos = analysis.slot_names.values().next().value ?? analysis.source.indexOf('$$slot');
		slot_snippet_conflict(pos);
	}

	if (analysis.css.ast) {
		analyze_css(analysis.css.ast, analysis);

		// mark nodes as scoped/unused/empty etc
		for (const node of analysis.elements) {
			prune(analysis.css.ast, node);
		}

		const { comment } = analysis.css.ast.content;
		const should_ignore_unused =
			comment &&
			extract_svelte_ignore(comment.start, comment.data, analysis.runes).includes(
				'css_unused_selector'
			);

		if (!should_ignore_unused) {
			warn_unused(analysis.css.ast);
		}
	}

	for (const node of analysis.elements) {
		if (node.metadata.scoped && is_custom_element_node(node)) {
			mark_subtree_dynamic(node.metadata.path);
		}

		let has_class = false;
		let has_style = false;
		let has_spread = false;
		let has_class_directive = false;
		let has_style_directive = false;

		for (const attribute of node.attributes) {
			// The spread method appends the hash to the end of the class attribute on its own
			if (attribute.type === 'SpreadAttribute') {
				has_spread = true;
				break;
			} else if (attribute.type === 'Attribute') {
				has_class ||= attribute.name.toLowerCase() === 'class';
				has_style ||= attribute.name.toLowerCase() === 'style';
			} else if (attribute.type === 'ClassDirective') {
				has_class_directive = true;
			} else if (attribute.type === 'StyleDirective') {
				has_style_directive = true;
			}
		}

		// We need an empty class to generate the set_class() or class="" correctly
		if (!has_spread && !has_class && (node.metadata.scoped || has_class_directive)) {
			node.attributes.push(
				create_attribute('class', null, -1, -1, [
					{
						type: 'Text',
						data: '',
						raw: '',
						start: -1,
						end: -1
					}
				])
			);
		}

		// We need an empty style to generate the set_style() correctly
		if (!has_spread && !has_style && has_style_directive) {
			node.attributes.push(
				create_attribute('style', null, -1, -1, [
					{
						type: 'Text',
						data: '',
						raw: '',
						start: -1,
						end: -1
					}
				])
			);
		}
	}

	// TODO
	// analysis.stylesheet.warn_on_unused_selectors(analysis);

	return analysis;
}

/**
 * Analyzes the instance's top level statements to calculate which bindings need to wait on which
 * top level statements. This includes indirect blockers such as functions referencing async top level statements.
 *
 * @param {Js} instance
 * @param {Map<AST.SvelteNode, Scope>} scopes
 * @param {ComponentAnalysis} analysis
 * @returns {void}
 */
function calculate_blockers(instance, scopes, analysis) {
	/**
	 * @param {ESTree.Node} expression
	 * @param {Scope} scope
	 * @param {Set<Binding>} touched
	 * @param {Set<ESTree.Node>} seen
	 */
	const touch = (expression, scope, touched, seen = new Set()) => {
		if (seen.has(expression)) return;
		seen.add(expression);

		walk$1(
			expression,
			{ scope },
			{
				ImportDeclaration(node) {},
				Identifier(node, context) {
					const parent = /** @type {ESTree.Node} */ (context.path.at(-1));
					if (is_reference(node, parent)) {
						const binding = context.state.scope.get(node.name);
						if (binding) {
							touched.add(binding);

							for (const assignment of binding.assignments) {
								touch(assignment.value, assignment.scope, touched, seen);
							}
						}
					}
				}
			}
		);
	};

	/**
	 * @param {ESTree.Node} node
	 * @param {Set<ESTree.Node>} seen
	 * @param {Set<Binding>} reads
	 * @param {Set<Binding>} writes
	 */
	const trace_references = (node, reads, writes, seen = new Set()) => {
		if (seen.has(node)) return;
		seen.add(node);

		/**
		 * @param {ESTree.Pattern} node
		 * @param {Scope} scope
		 */
		function update(node, scope) {
			for (const pattern of unwrap_pattern(node)) {
				const node = object$1(pattern);
				if (!node) return;

				const binding = scope.get(node.name);
				if (!binding) return;

				writes.add(binding);
			}
		}

		walk$1(
			node,
			{ scope: instance.scope },
			{
				_(node, context) {
					const scope = scopes.get(node);
					if (scope) {
						context.next({ scope });
					} else {
						context.next();
					}
				},
				AssignmentExpression(node, context) {
					update(node.left, context.state.scope);
				},
				UpdateExpression(node, context) {
					update(
						/** @type {ESTree.Identifier | ESTree.MemberExpression} */ (node.argument),
						context.state.scope
					);
				},
				CallExpression(node, context) {
					// for now, assume everything touched by the callee ends up mutating the object
					// TODO optimise this better

					// special case — no need to peek inside effects as they only run once async work has completed
					const rune = get_rune(node, context.state.scope);
					if (rune === '$effect') return;

					/** @type {Set<Binding>} */
					const touched = new Set();
					touch(node, context.state.scope, touched);

					for (const b of touched) {
						writes.add(b);
					}
				},
				// don't look inside functions until they are called
				ArrowFunctionExpression(_, context) {},
				FunctionDeclaration(_, context) {},
				FunctionExpression(_, context) {},
				Identifier(node, context) {
					const parent = /** @type {ESTree.Node} */ (context.path.at(-1));
					if (is_reference(node, parent)) {
						const binding = context.state.scope.get(node.name);
						if (binding) {
							reads.add(binding);
						}
					}
				}
			}
		);
	};

	let awaited = false;

	// TODO this should probably be attached to the scope?
	const promises = id$2('$$promises');

	/**
	 * @param {ESTree.Identifier} id
	 * @param {NonNullable<Binding['blocker']>} blocker
	 */
	function push_declaration(id, blocker) {
		analysis.instance_body.declarations.push(id);

		const binding = /** @type {Binding} */ (instance.scope.get(id.name));
		binding.blocker = blocker;
	}

	/**
	 * Analysis of blockers for functions is deferred until we know which statements are async/blockers
	 * @type {Array<ESTree.FunctionDeclaration | ESTree.VariableDeclarator>}
	 */
	const functions = [];

	for (let node of instance.ast.body) {
		if (node.type === 'ImportDeclaration') {
			analysis.instance_body.hoisted.push(node);
			continue;
		}

		if (node.type === 'ExportDefaultDeclaration' || node.type === 'ExportAllDeclaration') {
			// these can't exist inside `<script>` but TypeScript doesn't know that
			continue;
		}

		if (node.type === 'ExportNamedDeclaration') {
			if (node.declaration) {
				node = node.declaration;
			} else {
				continue;
			}
		}

		const has_await = has_await_expression(node);
		awaited ||= has_await;

		if (node.type === 'FunctionDeclaration') {
			analysis.instance_body.sync.push(node);
			functions.push(node);
		} else if (node.type === 'VariableDeclaration') {
			for (const declarator of node.declarations) {
				if (get_rune(declarator.init, instance.scope) === '$props.id') {
					// special case
					continue;
				}

				if (
					declarator.init?.type === 'ArrowFunctionExpression' ||
					declarator.init?.type === 'FunctionExpression'
				) {
					// One declarator per declaration, makes things simpler. The ternary ensures more accurate source maps in the common case
					analysis.instance_body.sync.push(
						node.declarations.length === 1 ? node : declaration$2(node.kind, [declarator])
					);
					functions.push(declarator);
				} else if (!awaited) {
					// One declarator per declaration, makes things simpler. The ternary ensures more accurate source maps in the common case
					analysis.instance_body.sync.push(
						node.declarations.length === 1 ? node : declaration$2(node.kind, [declarator])
					);
				} else {
					/** @type {Set<Binding>} */
					const reads = new Set(); // TODO we're not actually using this yet

					/** @type {Set<Binding>} */
					const writes = new Set();

					trace_references(declarator, reads, writes);

					const blocker = /** @type {NonNullable<Binding['blocker']>} */ (
						member(promises, literal(analysis.instance_body.async.length), true)
					);

					for (const binding of writes) {
						binding.blocker = blocker;
					}

					for (const id of extract_identifiers(declarator.id)) {
						push_declaration(id, blocker);
					}

					// one declarator per declaration, makes things simpler
					analysis.instance_body.async.push({
						node: declarator,
						has_await
					});
				}
			}
		} else if (awaited) {
			/** @type {Set<Binding>} */
			const reads = new Set(); // TODO we're not actually using this yet

			/** @type {Set<Binding>} */
			const writes = new Set();

			trace_references(node, reads, writes);

			const blocker = /** @type {NonNullable<Binding['blocker']>} */ (
				member(promises, literal(analysis.instance_body.async.length), true)
			);

			for (const binding of writes) {
				binding.blocker = blocker;
			}

			if (node.type === 'ClassDeclaration') {
				push_declaration(node.id, blocker);
				analysis.instance_body.async.push({ node, has_await });
			} else {
				analysis.instance_body.async.push({ node, has_await });
			}
		} else {
			analysis.instance_body.sync.push(node);
		}
	}

	for (const fn of functions) {
		/** @type {Set<Binding>} */
		const reads_writes = new Set();
		const body =
			fn.type === 'VariableDeclarator'
				? /** @type {ESTree.FunctionExpression | ESTree.ArrowFunctionExpression} */ (fn.init).body
				: fn.body;

		trace_references(body, reads_writes, reads_writes);

		const max = [...reads_writes].reduce((max, binding) => {
			if (binding.blocker) {
				let property = /** @type {ESTree.SimpleLiteral & { value: number }} */ (
					binding.blocker.property
				);

				return Math.max(property.value, max);
			}

			return max;
		}, -1);

		if (max === -1) continue;

		const blocker = member(promises, literal(max), true);
		const binding = /** @type {Binding} */ (
			fn.type === 'FunctionDeclaration'
				? instance.scope.get(fn.id.name)
				: instance.scope.get(/** @type {ESTree.Identifier} */ (fn.id).name)
		);

		binding.blocker = /** @type {typeof binding['blocker']} */ (blocker);
	}
}

/**
 * @param {Map<import('estree').LabeledStatement, ReactiveStatement>} unsorted_reactive_declarations
 */
function order_reactive_statements(unsorted_reactive_declarations) {
	/** @typedef {[import('estree').LabeledStatement, ReactiveStatement]} Tuple */

	/** @type {Map<string, Array<Tuple>>} */
	const lookup = new Map();

	for (const [node, declaration] of unsorted_reactive_declarations) {
		for (const binding of declaration.assignments) {
			const statements = lookup.get(binding.node.name) ?? [];
			statements.push([node, declaration]);
			lookup.set(binding.node.name, statements);
		}
	}

	/** @type {Array<[string, string]>} */
	const edges = [];

	for (const [, { assignments, dependencies }] of unsorted_reactive_declarations) {
		for (const assignment of assignments) {
			for (const dependency of dependencies) {
				if (!assignments.has(dependency)) {
					edges.push([assignment.node.name, dependency.node.name]);
				}
			}
		}
	}

	const cycle = check_graph_for_cycles(edges);
	if (cycle?.length) {
		const declaration = /** @type {Tuple[]} */ (lookup.get(cycle[0]))[0];
		reactive_declaration_cycle(declaration[0], cycle.join(' → '));
	}

	// We use a map and take advantage of the fact that the spec says insertion order is preserved when iterating
	/** @type {Map<import('estree').LabeledStatement, ReactiveStatement>} */
	const reactive_declarations = new Map();

	/**
	 *
	 * @param {import('estree').LabeledStatement} node
	 * @param {ReactiveStatement} declaration
	 * @returns
	 */
	const add_declaration = (node, declaration) => {
		if ([...reactive_declarations.values()].includes(declaration)) return;

		for (const binding of declaration.dependencies) {
			if (declaration.assignments.has(binding)) continue;
			for (const [node, earlier] of lookup.get(binding.node.name) ?? []) {
				add_declaration(node, earlier);
			}
		}

		reactive_declarations.set(node, declaration);
	};

	for (const [node, declaration] of unsorted_reactive_declarations) {
		add_declaration(node, declaration);
	}

	return reactive_declarations;
}

// src/vlq.ts
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function decodeInteger(reader, relative) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = reader.next();
    integer = charToInt[c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative + value;
}
function encodeInteger(builder, num, relative) {
  let delta = num - relative;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0) clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta > 0);
  return num;
}
function hasMoreVlq(reader, max) {
  if (reader.pos >= max) return false;
  return reader.peek() !== comma;
}

// src/strings.ts
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = "";
    this.buffer = new Uint8Array(bufLength);
  }
  write(v) {
    const { buffer } = this;
    buffer[this.pos++] = v;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer, out, pos } = this;
    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
  }
};
var StringReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};

// src/sourcemap-codec.ts
function decode(mappings) {
  const { length } = mappings;
  const reader = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn < lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
  return a[0] - b[0];
}
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) writer.write(semicolon);
    if (line.length === 0) continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0) writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1) continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4) continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}

/** @import { TSESTree } from '@typescript-eslint/types' */
/** @import { BaseNode, Command, Visitors } from './types' */

const margin = 0;
const newline = 1;
const indent = 2;
const dedent = 3;
const space = 4;

class Context {
	#visitors;
	#commands;
	#has_newline = false;

	multiline = false;

	/**
	 *
	 * @param {Visitors} visitors
	 * @param {Command[]} commands
	 */
	constructor(visitors, commands = []) {
		this.#visitors = visitors;
		this.#commands = commands;
	}

	indent() {
		this.#commands.push(indent);
	}

	dedent() {
		this.#commands.push(dedent);
	}

	margin() {
		this.#commands.push(margin);
	}

	newline() {
		this.#has_newline = true;
		this.#commands.push(newline);
	}

	space() {
		this.#commands.push(space);
	}

	/**
	 * @param {Context} context
	 */
	append(context) {
		this.#commands.push(context.#commands);

		if (this.#has_newline) {
			this.multiline = true;
		}
	}

	/**
	 *
	 * @param {string} content
	 * @param {BaseNode} [node]
	 */
	write(content, node) {
		if (node?.loc) {
			this.location(node.loc.start.line, node.loc.start.column);
			this.#commands.push(content);
			this.location(node.loc.end.line, node.loc.end.column);
		} else {
			this.#commands.push(content);
		}

		if (this.#has_newline) {
			this.multiline = true;
		}
	}

	/**
	 *
	 * @param {number} line
	 * @param {number} column
	 */
	location(line, column) {
		this.#commands.push({ type: 'Location', line, column });
	}

	/**
	 * @param {{ type: string }} node
	 */
	visit(node) {
		const visitor = this.#visitors[node.type];

		if (!visitor) {
			let message = `Not implemented: ${node.type}`;

			if (node.type.includes('TS')) {
				message += ` (consider using 'esrap/languages/ts')`;
			}

			if (node.type.includes('JSX')) {
				message += ` (consider using 'esrap/languages/tsx')`;
			}

			throw new Error(message);
		}

		if (this.#visitors._) {
			// @ts-ignore
			this.#visitors._(node, this, (node) => visitor(node, this));
		} else {
			// @ts-ignore
			visitor(node, this);
		}
	}

	empty() {
		return !this.#commands.some(has_content);
	}

	measure() {
		return measure(this.#commands);
	}

	new() {
		return new Context(this.#visitors);
	}
}

/**
 *
 * @param {Command[]} commands
 * @param {number} [from]
 * @param {number} [to]
 */
function measure(commands, from = 0, to = commands.length) {
	let total = 0;

	for (let i = from; i < to; i += 1) {
		const command = commands[i];

		if (typeof command === 'string') {
			total += command.length;
		} else if (Array.isArray(command)) {
			total += measure(command);
		}
	}

	return total;
}

/**
 * @param {Command} command
 */
function has_content(command) {
	if (Array.isArray(command)) {
		return command.some(has_content);
	}

	if (typeof command === 'string') {
		return command.length > 0;
	}

	return false;
}

/** @import { BaseNode, Command, Visitors, PrintOptions } from './types' */

/** @type {(str: string) => string} str */
let btoa$2 = () => {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};

if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa$2 = (str) => window.btoa(unescape(encodeURIComponent(str)));
} else if (typeof Buffer === 'function') {
	btoa$2 = (str) => Buffer.from(str, 'utf-8').toString('base64');
}

let SourceMap$2 = class SourceMap {
	version = 3;

	/** @type {string[]} */
	names = [];

	/**
	 * @param {[number, number, number, number][][]} mappings
	 * @param {PrintOptions} opts
	 */
	constructor(mappings, opts) {
		this.sources = [opts.sourceMapSource || null];
		this.sourcesContent = [opts.sourceMapContent || null];
		this.mappings = opts.sourceMapEncodeMappings === false ? mappings : encode(mappings);
	}

	/**
	 * Returns a JSON representation suitable for saving as a `*.map` file
	 */
	toString() {
		return JSON.stringify(this);
	}

	/**
	 * Returns a base64-encoded JSON representation suitable for inlining at the bottom of a file with `//# sourceMappingURL={...}`
	 */
	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa$2(this.toString());
	}
};

/**
 * @template {BaseNode} [T=BaseNode]
 * @param {T} node
 * @param {Visitors<T>} visitors
 * @param {PrintOptions} opts
 * @returns {{ code: string, map: any }} // TODO
 */
function print(node, visitors, opts = {}) {
	/** @type {Command[]} */
	const commands = [];

	// @ts-expect-error some nonsense I don't understand
	const context = new Context(visitors, commands);

	context.visit(node);

	/** @typedef {[number, number, number, number]} Segment */

	let code = '';
	let current_column = 0;

	/** @type {Segment[][]} */
	let mappings = [];

	/** @type {Segment[]} */
	let current_line = [];

	/** @param {string} str */
	function append(str) {
		code += str;

		for (let i = 0; i < str.length; i += 1) {
			if (str[i] === '\n') {
				mappings.push(current_line);
				current_line = [];
				current_column = 0;
			} else {
				current_column += 1;
			}
		}
	}

	let current_newline = '\n';
	const indent_str = opts.indent ?? '\t';

	let needs_newline = false;
	let needs_margin = false;
	let needs_space = false;

	/** @param {Command} command */
	function run(command) {
		if (Array.isArray(command)) {
			for (let i = 0; i < command.length; i += 1) {
				run(command[i]);
			}
			return;
		}

		if (typeof command === 'number') {
			if (command === newline) {
				needs_newline = true;
			} else if (command === margin) {
				needs_margin = true;
			} else if (command === space) {
				needs_space = true;
			} else if (command === indent) {
				current_newline += indent_str;
			} else if (command === dedent) {
				current_newline = current_newline.slice(0, -indent_str.length);
			}

			return;
		}

		if (needs_newline) {
			append(needs_margin ? '\n' + current_newline : current_newline);
		} else if (needs_space) {
			append(' ');
		}

		needs_margin = needs_newline = needs_space = false;

		if (typeof command === 'string') {
			append(command);
			return;
		}

		if (command.type === 'Location') {
			current_line.push([
				current_column,
				0, // source index is always zero
				command.line - 1,
				command.column
			]);
		}
	}

	for (let i = 0; i < commands.length; i += 1) {
		run(commands[i]);
	}

	mappings.push(current_line);

	/** @type {SourceMap} */
	let map;

	return {
		code,
		// create sourcemap lazily in case we don't need it
		get map() {
			return (map ??= new SourceMap$2(mappings, opts));
		}
	};
}

/** @import { TSESTree } from '@typescript-eslint/types' */
/** @import { Visitors } from '../../types.js' */
/** @import { TSOptions, BaseComment } from '../types.js' */

/** @typedef {TSESTree.Node} Node */

/** @type {Record<TSESTree.Expression['type'] | 'Super' | 'RestElement', number>} */
const EXPRESSIONS_PRECEDENCE = {
	JSXFragment: 20,
	JSXElement: 20,
	ArrayPattern: 20,
	ObjectPattern: 20,
	ArrayExpression: 20,
	TaggedTemplateExpression: 20,
	ThisExpression: 20,
	Identifier: 20,
	TemplateLiteral: 20,
	Super: 20,
	SequenceExpression: 20,
	MemberExpression: 19,
	MetaProperty: 19,
	CallExpression: 19,
	ChainExpression: 19,
	ImportExpression: 19,
	NewExpression: 19,
	Literal: 18,
	TSSatisfiesExpression: 18,
	TSInstantiationExpression: 18,
	TSNonNullExpression: 18,
	TSTypeAssertion: 18,
	AwaitExpression: 17,
	ClassExpression: 17,
	FunctionExpression: 17,
	ObjectExpression: 17,
	TSAsExpression: 16,
	UpdateExpression: 16,
	UnaryExpression: 15,
	BinaryExpression: 14,
	LogicalExpression: 13,
	ConditionalExpression: 4,
	ArrowFunctionExpression: 3,
	AssignmentExpression: 3,
	YieldExpression: 2,
	RestElement: 1
};

const OPERATOR_PRECEDENCE = {
	'||': 2,
	'&&': 3,
	'??': 4,
	'|': 5,
	'^': 6,
	'&': 7,
	'==': 8,
	'!=': 8,
	'===': 8,
	'!==': 8,
	'<': 9,
	'>': 9,
	'<=': 9,
	'>=': 9,
	in: 9,
	instanceof: 9,
	'<<': 10,
	'>>': 10,
	'>>>': 10,
	'+': 11,
	'-': 11,
	'*': 12,
	'%': 12,
	'/': 12,
	'**': 13
};

/**
 * @param {BaseComment} comment
 * @param {Context} context
 */
function write_comment(comment, context) {
	if (comment.type === 'Line') {
		context.write(`//${comment.value}`);
	} else {
		context.write('/*');
		const lines = comment.value.split('\n');

		for (let i = 0; i < lines.length; i += 1) {
			if (i > 0) context.newline();
			context.write(lines[i]);
		}

		context.write('*/');
		if (lines.length > 1) context.newline();
	}
}

/**
 * @param {TSOptions} [options]
 * @returns {Visitors<TSESTree.Node>}
 */
const ts = (options = {}) => {
	const quote_char = options.quotes === 'double' ? '"' : "'";

	const comments = options.comments ?? [];

	let comment_index = 0;

	/**
	 * Write additional comments for a node
	 * @param {Context} context
	 * @param {BaseComment[] | undefined} comments
	 * @param {('leading' | 'trailing')} position
	 */
	function write_additional_comments(context, comments, position) {
		if (!comments) {
			return;
		}

		for (let i = 0; i < comments.length; i += 1) {
			const comment = comments[i];

			if (position === 'trailing' && i === 0) {
				context.write(' ');
			}

			write_comment(comment, context);

			if (position === 'leading') {
				if (comment.type === 'Line') {
					context.newline();
				} else if (comment.type === 'Block' && !comment.value.includes('\n')) {
					context.write(' ');
				}
			}
		}
	}

	/**
	 * Set `comment_index` to be the first comment after `start`.
	 * Most of the time this is already correct, but if nodes
	 * have been moved around we may need to search for it
	 * @param {TSESTree.Node} node
	 */
	function reset_comment_index(node) {
		if (!node.loc) {
			comment_index = comments.length;
			return;
		}

		let previous = comments[comment_index - 1];
		let comment = comments[comment_index];

		if (
			comment &&
			comment.loc &&
			!before(comment.loc.start, node.loc.start) &&
			(!previous || (previous.loc && before(previous.loc.start, node.loc.start)))
		) {
			return;
		}

		// TODO use a binary search here, account for synthetic nodes (without `loc`)
		comment_index = comments.findIndex(
			(comment) => comment.loc && node.loc && !before(comment.loc.start, node.loc.start)
		);
		if (comment_index === -1) comment_index = comments.length;
	}

	/**
	 * @param {Context} context
	 * @param {{ line: number, column: number } | null} prev
	 * @param {{ line: number, column: number } | null} next
	 */
	function flush_trailing_comments(context, prev, next) {
		while (comment_index < comments.length) {
			const comment = comments[comment_index];

			if (
				comment &&
				prev &&
				comment.loc.start.line === prev.line &&
				(next === null || before(comment.loc.end, next))
			) {
				context.write(' ');
				write_comment(comment, context);

				comment_index += 1;

				if (comment.type === 'Line') {
					context.newline();
				} else {
					continue;
				}
			}

			break;
		}
	}

	/**
	 * @param {Context} context
	 * @param {{ line: number, column: number } | null} from
	 * @param {{ line: number, column: number }} to
	 * @param {boolean} pad
	 */
	function flush_comments_until(context, from, to, pad) {
		let first = true;

		while (comment_index < comments.length) {
			const comment = comments[comment_index];

			if (comment && comment.loc && to && before(comment.loc.start, to)) {
				if (first && from !== null && comment.loc.start.line > from.line) {
					context.margin();
					context.newline();
				}

				first = false;

				write_comment(comment, context);

				if (comment.loc.end.line < to.line) {
					context.newline();
				} else if (pad) {
					context.write(' ');
				}

				comment_index += 1;
			} else {
				break;
			}
		}
	}

	/**
	 * @param {Context} context
	 * @param {TSESTree.Node[]} nodes
	 * @param {{ line: number, column: number }} until
	 * @param {boolean} pad
	 */
	function sequence(context, nodes, until, pad, separator = ',') {
		let multiline = false;
		let length = -1;

		/** @type {boolean[]} */
		const multiline_nodes = [];

		const children = nodes.map((child, i) => {
			const child_context = context.new();
			if (child) child_context.visit(child);

			multiline_nodes[i] = child_context.multiline;

			if (i < nodes.length - 1 || !child) {
				child_context.write(separator);
			}

			const next = i === nodes.length - 1 ? until : nodes[i + 1]?.loc?.start || null;
			flush_trailing_comments(child_context, child?.loc?.end || null, next);

			length += child_context.measure() + 1;
			multiline ||= child_context.multiline;

			return child_context;
		});

		multiline ||= length > 60;

		if (multiline) {
			context.indent();
			context.newline();
		} else if (pad && length > 0) {
			context.write(' ');
		}

		/** @type {Context | null} */
		let prev = null;

		for (let i = 0; i < nodes.length; i += 1) {
			const child = children[i];

			if (prev !== null) {
				if (multiline_nodes[i - 1] || multiline_nodes[i]) {
					context.margin();
				}

				if (nodes[i]) {
					if (multiline) {
						context.newline();
					} else {
						context.write(' ');
					}
				}
			}

			context.append(child);

			prev = child;
		}

		flush_comments_until(context, nodes[nodes.length - 1]?.loc?.end ?? null, until, false);

		if (multiline) {
			context.dedent();
			context.newline();
		} else if (pad && length > 0) {
			context.write(' ');
		}
	}

	/**
	 * Push a sequence of nodes onto separate lines, separating them with
	 * an extra newline where appropriate
	 * @param {Context} context
	 * @param {TSESTree.Node & { body: TSESTree.Node[] }} node
	 */
	function body(context, node) {
		reset_comment_index(node);

		/** @type {string | null} */
		let prev_type = null;
		let prev_multiline = false;

		for (let i = 0; i < node.body.length; i += 1) {
			const child = node.body[i];
			if (child.type === 'EmptyStatement') continue;

			const child_context = context.new();
			child_context.visit(child);

			if (prev_type !== null) {
				if (child_context.multiline || prev_multiline || child.type !== prev_type) {
					context.margin();
				}

				context.newline();
			}

			context.append(child_context);

			flush_trailing_comments(
				context,
				child.loc?.end || null,
				node.body[i + 1]?.loc?.end ?? node.loc?.end ?? null
			);

			prev_type = child.type;
			prev_multiline = child_context.multiline;
		}

		if (node.loc) {
			context.newline();
			flush_comments_until(
				context,
				node.body[node.body.length - 1]?.loc?.end ?? null,
				node.loc.end,
				false
			);
		}
	}

	const shared = {
		/**
		 * @param {TSESTree.ArrayExpression | TSESTree.ArrayPattern} node
		 * @param {Context} context
		 */
		'ArrayExpression|ArrayPattern': (node, context) => {
			context.write('[');
			sequence(
				context,
				/** @type {TSESTree.Node[]} */ (node.elements),
				node.loc?.end ?? null,
				false
			);
			context.write(']');
		},

		/**
		 * @param {TSESTree.BinaryExpression | TSESTree.LogicalExpression} node
		 * @param {Context} context
		 */
		'BinaryExpression|LogicalExpression': (node, context) => {
			// TODO
			// const is_in = node.operator === 'in';
			// if (is_in) {
			// 	// Avoids confusion in `for` loops initializers
			// 	chunks.write('(');
			// }
			if (needs_parens(node.left, node, false)) {
				context.write('(');
				context.visit(node.left);
				context.write(')');
			} else {
				context.visit(node.left);
			}

			context.write(` ${node.operator} `);

			if (needs_parens(node.right, node, true)) {
				context.write('(');
				context.visit(node.right);
				context.write(')');
			} else {
				context.visit(node.right);
			}
		},

		/**
		 * @param {TSESTree.BlockStatement | TSESTree.ClassBody} node
		 * @param {Context} context
		 */
		'BlockStatement|ClassBody': (node, context) => {
			if (node.loc) {
				const { line, column } = node.loc.start;
				context.location(line, column);
				context.write('{');
				context.location(line, column + 1);
			} else {
				context.write('{');
			}

			const child_context = context.new();
			body(child_context, node);

			if (!child_context.empty()) {
				context.indent();
				context.newline();
				context.append(child_context);
				context.dedent();
				context.newline();
			}

			if (node.loc) {
				const { line, column } = node.loc.end;

				context.location(line, column - 1);
				context.write('}');
				context.location(line, column);
			} else {
				context.write('}');
			}
		},

		/**
		 * @param {TSESTree.CallExpression | TSESTree.NewExpression} node
		 * @param {Context} context
		 */
		'CallExpression|NewExpression': (node, context) => {
			if (node.type === 'NewExpression') {
				context.write('new ');
			}

			const needs_parens =
				EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression ||
				(node.type === 'NewExpression' && has_call_expression(node.callee));

			if (needs_parens) {
				context.write('(');
				context.visit(node.callee);
				context.write(')');
			} else {
				context.visit(node.callee);
			}

			if (/** @type {TSESTree.CallExpression} */ (node).optional) {
				context.write('?.');
			}

			if (node.typeArguments) context.visit(node.typeArguments);

			const open = context.new();
			const join = context.new();

			context.write('(');
			context.append(open);

			// if the final argument is multiline, it doesn't need to force all the
			// other arguments to also be multiline
			const child_context = context.new();
			const final_context = context.new();

			context.append(child_context);
			context.append(final_context);

			for (let i = 0; i < node.arguments.length; i += 1) {
				const is_last = i === node.arguments.length - 1;
				const context = is_last ? final_context : child_context;
				const arg = node.arguments[i];

				// special case — if final argument has a comment above it,
				// we make the whole sequence multiline
				if (
					is_last &&
					arg.loc &&
					comments[comment_index] &&
					comments[comment_index].loc &&
					comments[comment_index].loc.start.line < arg.loc.start.line
				) {
					child_context.multiline = true;
				}

				context.visit(arg);

				if (!is_last) context.write(',');

				const next = is_last
					? (node.loc?.end ?? null)
					: (node.arguments[i + 1]?.loc?.start ?? null);

				flush_trailing_comments(context, arg.loc?.end ?? null, next);

				if (!is_last) context.append(join);
			}

			context.multiline ||= child_context.multiline || final_context.multiline;

			if (child_context.multiline) {
				open.indent();
				open.newline();
				join.newline();
				context.dedent();
				context.newline();
			} else {
				join.write(' ');
			}

			context.write(')');
		},

		/**
		 * @param {TSESTree.ClassDeclaration | TSESTree.ClassExpression} node
		 * @param {Context} context
		 */
		'ClassDeclaration|ClassExpression': (node, context) => {
			if (node.decorators) {
				for (const decorator of node.decorators) {
					context.visit(decorator);
				}
			}

			if (node.declare) {
				context.write('declare ');
			}

			if (node.abstract) context.write('abstract ');

			context.write('class ');

			if (node.id) {
				context.visit(node.id);
				context.write(' ');
			}

			if (node.superClass) {
				context.write('extends ');
				context.visit(node.superClass);
				context.write(' ');
			}

			if (node.implements && node.implements.length > 0) {
				context.write('implements');
				sequence(context, node.implements, node.body.loc?.start ?? null, true);
			}

			context.visit(node.body);
		},

		/**
		 * @param {TSESTree.ForInStatement | TSESTree.ForOfStatement} node
		 * @param {Context} context
		 */
		'ForInStatement|ForOfStatement': (node, context) => {
			context.write('for ');
			if (node.type === 'ForOfStatement' && node.await) context.write('await ');
			context.write('(');

			if (node.left.type === 'VariableDeclaration') {
				handle_var_declaration(node.left, context);
			} else {
				context.visit(node.left);
			}

			context.write(node.type === 'ForInStatement' ? ' in ' : ' of ');
			context.visit(node.right);
			context.write(') ');
			context.visit(node.body);
		},

		/**
		 * @param {TSESTree.FunctionDeclaration | TSESTree.FunctionExpression} node
		 * @param {Context} context
		 */
		'FunctionDeclaration|FunctionExpression': (node, context) => {
			if (node.async) context.write('async ');
			context.write(node.generator ? 'function* ' : 'function ');
			if (node.id) context.visit(node.id);

			if (node.typeParameters) {
				context.visit(node.typeParameters);
			}

			context.write('(');
			sequence(context, node.params, (node.returnType ?? node.body).loc?.start ?? null, false);
			context.write(')');

			if (node.returnType) context.visit(node.returnType);

			context.write(' ');

			context.visit(node.body);
		},

		/**
		 * @param {TSESTree.MethodDefinition | TSESTree.TSAbstractMethodDefinition} node
		 * @param {Context} context
		 */
		'MethodDefinition|TSAbstractMethodDefinition': (node, context) => {
			if (node.decorators) {
				for (const decorator of node.decorators) {
					context.visit(decorator);
				}
			}

			// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
			if (node.abstract || node.type === 'TSAbstractMethodDefinition') {
				context.write('abstract ');
			}

			if (node.static) {
				context.write('static ');
			}

			if (node.kind === 'get' || node.kind === 'set') {
				// Getter or setter
				context.write(node.kind + ' ');
			}

			if (node.value.async) {
				context.write('async ');
			}

			if (node.value.generator) {
				context.write('*');
			}

			if (node.computed) context.write('[');
			context.visit(node.key);
			if (node.computed) context.write(']');

			context.write('(');
			sequence(
				context,
				node.value.params,
				(node.value.returnType ?? node.value.body)?.loc?.start ?? node.loc?.end ?? null,
				false
			);
			context.write(')');

			if (node.value.returnType) context.visit(node.value.returnType);

			context.write(' ');

			if (node.value.body) context.visit(node.value.body);
		},

		/**
		 * @param {TSESTree.PropertyDefinition | TSESTree.TSAbstractPropertyDefinition | TSESTree.AccessorProperty | TSESTree.TSAbstractAccessorProperty} node
		 * @param {Context} context
		 */
		'PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty': (
			node,
			context
		) => {
			if (node.decorators) {
				for (const decorator of node.decorators) {
					context.visit(decorator);
				}
			}

			if (node.accessibility) {
				context.write(node.accessibility + ' ');
			}

			if (
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				node.abstract ||
				node.type === 'TSAbstractPropertyDefinition' ||
				node.type === 'TSAbstractAccessorProperty'
			) {
				context.write('abstract ');
			}

			if (node.static) {
				context.write('static ');
			}

			if (
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				node.accessor ||
				node.type === 'AccessorProperty' ||
				node.type === 'TSAbstractAccessorProperty'
			) {
				context.write('accessor ');
			}

			if (node.computed) {
				context.write('[');
				context.visit(node.key);
				context.write(']');
			} else {
				context.visit(node.key);
			}

			if (node.typeAnnotation) {
				if (node.type === 'AccessorProperty' || node.type === 'TSAbstractAccessorProperty') {
					context.visit(node.typeAnnotation);
				} else {
					context.write(': ');
					context.visit(node.typeAnnotation.typeAnnotation);
				}
			}

			if (node.value) {
				context.write(' = ');
				context.visit(node.value);
			}

			context.write(';');

			flush_trailing_comments(
				context,
				(node.value ?? node.typeAnnotation ?? node.key).loc?.end ?? null,
				null
			);
		},

		/**
		 * @param {TSESTree.RestElement | TSESTree.SpreadElement} node
		 * @param {Context} context
		 */
		'RestElement|SpreadElement': (node, context) => {
			context.write('...');
			context.visit(node.argument);

			// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
			if (node.typeAnnotation) context.visit(node.typeAnnotation);
		},

		/**
		 * @param {TSESTree.TSConstructSignatureDeclaration | TSESTree.TSCallSignatureDeclaration} node
		 * @param {Context} context
		 */
		'TSConstructSignatureDeclaration|TSCallSignatureDeclaration': (node, context) => {
			if (node.type === 'TSConstructSignatureDeclaration') context.write('new');

			if (node.typeParameters) {
				context.visit(node.typeParameters);
			}

			context.write('(');

			sequence(
				context,
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				node.parameters ?? node.params,
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				(node.typeAnnotation ?? node.returnType)?.loc?.start ?? null,
				false
			);
			context.write(')');

			// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
			if (node.typeAnnotation || node.returnType) {
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				context.visit(node.typeAnnotation ?? node.returnType);
			}
		},

		/**
		 * @param {TSESTree.TSFunctionType | TSESTree.TSConstructorType} node
		 * @param {Context} context
		 */
		'TSFunctionType|TSConstructorType': (node, context) => {
			if (node.type === 'TSConstructorType') context.write('new ');
			if (node.typeParameters) context.visit(node.typeParameters);

			context.write('(');

			sequence(
				context,
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				node.parameters ?? node.params,
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				node.typeAnnotation?.typeAnnotation?.loc?.start ??
					node.returnType?.typeAnnotation?.loc?.start ??
					null,
				false
			);

			context.write(') => ');

			// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
			context.visit(node.typeAnnotation?.typeAnnotation ?? node.returnType?.typeAnnotation);
		}
	};

	return {
		_(node, context, visit) {
			write_additional_comments(context, options.getLeadingComments?.(node), 'leading');

			if (node.loc) {
				flush_comments_until(context, null, node.loc.start, true);
			}

			visit(node);

			write_additional_comments(context, options.getTrailingComments?.(node), 'trailing');
		},

		AccessorProperty:
			shared[
				'PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty'
			],

		ArrayExpression: shared['ArrayExpression|ArrayPattern'],

		ArrayPattern: shared['ArrayExpression|ArrayPattern'],

		ArrowFunctionExpression: (node, context) => {
			if (node.async) context.write('async ');

			context.write('(');
			sequence(context, node.params, node.body.loc?.start ?? null, false);
			context.write(') => ');

			if (
				node.body.type === 'ObjectExpression' ||
				(node.body.type === 'AssignmentExpression' && node.body.left.type === 'ObjectPattern') ||
				(node.body.type === 'LogicalExpression' && node.body.left.type === 'ObjectExpression') ||
				(node.body.type === 'ConditionalExpression' && node.body.test.type === 'ObjectExpression')
			) {
				context.write('(');
				context.visit(node.body);
				context.write(')');
			} else {
				context.visit(node.body);
			}
		},

		AssignmentExpression(node, context) {
			context.visit(node.left);
			context.write(` ${node.operator} `);
			context.visit(node.right);
		},

		AssignmentPattern(node, context) {
			context.visit(node.left);
			context.write(' = ');
			context.visit(node.right);
		},

		AwaitExpression(node, context) {
			if (node.argument) {
				const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];

				if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
					context.write('await (');
					context.visit(node.argument);
					context.write(')');
				} else {
					context.write('await ');
					context.visit(node.argument);
				}
			} else {
				context.write('await');
			}
		},

		BinaryExpression: shared['BinaryExpression|LogicalExpression'],

		BlockStatement: shared['BlockStatement|ClassBody'],

		BreakStatement(node, context) {
			if (node.label) {
				context.write('break ');
				context.visit(node.label);
				context.write(';');
			} else {
				context.write('break;');
			}
		},

		CallExpression: shared['CallExpression|NewExpression'],

		ChainExpression(node, context) {
			context.visit(node.expression);
		},

		ClassBody: shared['BlockStatement|ClassBody'],

		ClassDeclaration: shared['ClassDeclaration|ClassExpression'],

		ClassExpression: shared['ClassDeclaration|ClassExpression'],

		ConditionalExpression(node, context) {
			if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
				context.visit(node.test);
			} else {
				context.write('(');
				context.visit(node.test);
				context.write(')');
			}

			const consequent = context.new();
			const alternate = context.new();

			// TODO flush comments here, rather than in visitors

			consequent.visit(node.consequent);
			alternate.visit(node.alternate);

			if (
				consequent.multiline ||
				alternate.multiline ||
				consequent.measure() + alternate.measure() > 50
			) {
				context.indent();
				context.newline();
				context.write('? ');
				context.append(consequent);
				context.newline();
				context.write(': ');
				context.append(alternate);
				context.dedent();
			} else {
				context.write(' ? ');
				context.append(consequent);
				context.write(' : ');
				context.append(alternate);
			}
		},

		ContinueStatement(node, context) {
			if (node.label) {
				context.write('continue ');
				context.visit(node.label);
				context.write(';');
			} else {
				context.write('continue;');
			}
		},

		DebuggerStatement(node, context) {
			context.write('debugger', node);
			context.write(';');
		},

		Decorator(node, context) {
			context.write('@');
			context.visit(node.expression);
			context.newline();
		},

		DoWhileStatement(node, context) {
			context.write('do ');
			context.visit(node.body);
			context.write(' while (');
			context.visit(node.test);
			context.write(');');
		},

		EmptyStatement(node, context) {
			context.write(';');
		},

		ExportAllDeclaration(node, context) {
			context.write(node.exportKind === 'type' ? 'export type * ' : 'export * ');

			if (node.exported) {
				context.write('as ');
				context.visit(node.exported);
			}

			context.write(' from ');
			context.visit(node.source);
			context.write(';');
		},

		ExportDefaultDeclaration(node, context) {
			context.write('export default ');

			context.visit(node.declaration);

			if (node.declaration.type !== 'FunctionDeclaration') {
				context.write(';');
			}
		},

		ExportNamedDeclaration(node, context) {
			if (node.declaration) {
				// Check if declaration has decorators (ClassDeclaration, ClassExpression can have them)
				const decl = /** @type {any} */ (node.declaration);
				if (decl.decorators && decl.decorators.length > 0) {
					for (const decorator of decl.decorators) {
						context.visit(decorator);
					}
					context.write('export ');
					// Temporarily remove decorators so ClassDeclaration doesn't print them again
					const savedDecorators = decl.decorators;
					decl.decorators = [];
					context.visit(node.declaration);
					decl.decorators = savedDecorators;
				} else {
					context.write('export ');
					context.visit(node.declaration);
				}
				return;
			}

			context.write('export ');

			if (node.exportKind === 'type') {
				context.write('type ');
			}

			context.write('{');
			sequence(context, node.specifiers, node.source?.loc?.start ?? node.loc?.end ?? null, true);
			context.write('}');

			if (node.source) {
				context.write(' from ');
				context.visit(node.source);
			}

			context.write(';');
		},

		ExportSpecifier(node, context) {
			if (node.exportKind === 'type') {
				context.write('type ');
			}

			context.visit(node.local);

			if (
				node.local.type === 'Identifier' &&
				node.exported.type === 'Identifier' &&
				node.local.name !== node.exported.name
			) {
				context.write(' as ');
				context.visit(node.exported);
			}
		},

		ExpressionStatement(node, context) {
			if (
				node.expression.type === 'ObjectExpression' ||
				(node.expression.type === 'AssignmentExpression' &&
					node.expression.left.type === 'ObjectPattern') ||
				node.expression.type === 'FunctionExpression'
			) {
				// is an AssignmentExpression to an ObjectPattern
				context.write('(');
				context.visit(node.expression);
				context.write(');');
				return;
			}

			context.visit(node.expression);
			context.write(';');
		},

		ForStatement: (node, context) => {
			context.write('for (');

			if (node.init) {
				if (node.init.type === 'VariableDeclaration') {
					handle_var_declaration(node.init, context);
				} else {
					context.visit(node.init);
				}
			}

			context.write('; ');
			if (node.test) context.visit(node.test);
			context.write('; ');
			if (node.update) context.visit(node.update);

			context.write(') ');
			context.visit(node.body);
		},

		ForInStatement: shared['ForInStatement|ForOfStatement'],

		ForOfStatement: shared['ForInStatement|ForOfStatement'],

		FunctionDeclaration: shared['FunctionDeclaration|FunctionExpression'],

		FunctionExpression: shared['FunctionDeclaration|FunctionExpression'],

		Identifier(node, context) {
			let name = node.name;
			context.write(name, node);

			if (node.typeAnnotation) context.visit(node.typeAnnotation);
		},

		IfStatement(node, context) {
			context.write('if (');
			context.visit(node.test);
			context.write(') ');
			context.visit(node.consequent);

			if (node.alternate) {
				context.space();
				context.write('else ');
				context.visit(node.alternate);
			}
		},

		ImportDeclaration(node, context) {
			if (node.specifiers.length === 0) {
				context.write('import ');
				context.visit(node.source);
				context.write(';');
				return;
			}

			/** @type {TSESTree.ImportNamespaceSpecifier | null} */
			let namespace_specifier = null;

			/** @type {TSESTree.ImportDefaultSpecifier | null} */
			let default_specifier = null;

			/** @type {TSESTree.ImportSpecifier[]} */
			const named_specifiers = [];

			for (const s of node.specifiers) {
				if (s.type === 'ImportNamespaceSpecifier') {
					namespace_specifier = s;
				} else if (s.type === 'ImportDefaultSpecifier') {
					default_specifier = s;
				} else {
					named_specifiers.push(s);
				}
			}

			context.write('import ');
			if (node.importKind == 'type') context.write('type ');

			if (default_specifier) {
				context.write(default_specifier.local.name, default_specifier);
				if (namespace_specifier || named_specifiers.length > 0) context.write(', ');
			}

			if (namespace_specifier) {
				context.write('* as ' + namespace_specifier.local.name, namespace_specifier);
			}

			if (named_specifiers.length > 0) {
				context.write('{');
				sequence(context, named_specifiers, node.source.loc?.start ?? null, true);
				context.write('}');
			}

			context.write(' from ');
			context.visit(node.source);
			if (node.attributes && node.attributes.length > 0) {
				context.write(' with { ');
				for (let index = 0; index < node.attributes.length; index++) {
					const { key, value } = node.attributes[index];
					context.visit(key);
					context.write(': ');
					context.visit(value);
					if (index + 1 !== node.attributes.length) {
						context.write(', ');
					}
				}
				context.write(' }');
			}
			context.write(';');
		},

		ImportExpression(node, context) {
			context.write('import(');
			context.visit(node.source);
			//@ts-expect-error for some reason the types haven't been updated
			if (node.arguments) {
				//@ts-expect-error
				for (let index = 0; index < node.arguments.length; index++) {
					context.write(', ');
					//@ts-expect-error
					context.visit(node.arguments[index]);
				}
			}
			if (node.options) {
				context.write(', ');
				context.visit(node.options);
			}
			context.write(')');
		},

		ImportSpecifier(node, context) {
			if (
				node.local.type === 'Identifier' &&
				node.imported.type === 'Identifier' &&
				node.local.name !== node.imported.name
			) {
				context.visit(node.imported);
				context.write(' as ');
			}

			if (node.importKind == 'type') context.write('type ');
			context.visit(node.local);
		},

		LabeledStatement(node, context) {
			context.visit(node.label);
			context.write(': ');
			context.visit(node.body);
		},

		Literal(node, context) {
			// TODO do we need to handle weird unicode characters somehow?
			// str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))

			const value =
				node.raw ||
				(typeof node.value === 'string' ? quote(node.value, quote_char) : String(node.value));

			context.write(value, node);
		},

		LogicalExpression: shared['BinaryExpression|LogicalExpression'],

		MemberExpression(node, context) {
			if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
				context.write('(');
				context.visit(node.object);
				context.write(')');
			} else {
				context.visit(node.object);
			}

			if (node.computed) {
				if (node.optional) {
					context.write('?.');
				}
				context.write('[');
				context.visit(node.property);
				context.write(']');
			} else {
				context.write(node.optional ? '?.' : '.');
				context.visit(node.property);
			}
		},

		MetaProperty(node, context) {
			context.visit(node.meta);
			context.write('.');
			context.visit(node.property);
		},

		MethodDefinition: shared['MethodDefinition|TSAbstractMethodDefinition'],

		NewExpression: shared['CallExpression|NewExpression'],

		ObjectExpression(node, context) {
			context.write('{');
			sequence(context, node.properties, node.loc?.end ?? null, true);
			context.write('}');
		},

		ObjectPattern(node, context) {
			context.write('{');
			sequence(context, node.properties, node.loc?.end ?? null, true);
			context.write('}');

			if (node.typeAnnotation) context.visit(node.typeAnnotation);
		},

		// @ts-expect-error this isn't a real node type, but Acorn produces it
		ParenthesizedExpression(node, context) {
			context.write('(');
			context.visit(node.expression);
			context.write(')');
		},

		PrivateIdentifier(node, context) {
			context.write('#');
			context.write(node.name, node);
		},

		Program(node, context) {
			body(context, node);
		},

		Property(node, context) {
			const value = node.value.type === 'AssignmentPattern' ? node.value.left : node.value;

			const shorthand =
				!node.computed &&
				node.kind === 'init' &&
				node.key.type === 'Identifier' &&
				value.type === 'Identifier' &&
				node.key.name === value.name;

			if (shorthand) {
				context.visit(node.value);
				return;
			}

			// shorthand methods
			if (node.value.type === 'FunctionExpression') {
				if (node.kind !== 'init') context.write(node.kind + ' ');
				if (node.value.async) context.write('async ');
				if (node.value.generator) context.write('*');
				if (node.computed) context.write('[');
				context.visit(node.key);
				if (node.computed) context.write(']');
				context.write('(');
				sequence(
					context,
					node.value.params,
					(node.value.returnType ?? node.value.body).loc?.start ?? null,
					false
				);
				context.write(')');

				if (node.value.returnType) context.visit(node.value.returnType);

				context.write(' ');
				context.visit(node.value.body);
			} else {
				if (node.computed) context.write('[');
				if (node.kind === 'get' || node.kind === 'set') context.write(node.kind + ' ');
				context.visit(node.key);
				context.write(node.computed ? ']: ' : ': ');
				context.visit(node.value);
			}
		},

		PropertyDefinition:
			shared[
				'PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty'
			],

		RestElement: shared['RestElement|SpreadElement'],

		ReturnStatement(node, context) {
			if (node.argument) {
				const contains_comment =
					comments[comment_index] &&
					comments[comment_index].loc &&
					node.argument.loc &&
					before(comments[comment_index].loc.start, node.argument.loc.start);

				context.write(contains_comment ? 'return (' : 'return ');
				context.visit(node.argument);
				context.write(contains_comment ? ');' : ';');
			} else {
				context.write('return;');
			}
		},

		SequenceExpression(node, context) {
			context.write('(');
			sequence(context, node.expressions, node.loc?.end ?? null, false);
			context.write(')');
		},

		SpreadElement: shared['RestElement|SpreadElement'],

		StaticBlock(node, context) {
			context.write('static {');
			context.indent();
			context.newline();

			body(context, node);

			context.dedent();
			context.newline();
			context.write('}');
		},

		Super(node, context) {
			context.write('super', node);
		},

		SwitchStatement(node, context) {
			context.write('switch (');
			context.visit(node.discriminant);
			context.write(') {');
			context.indent();

			let first = true;

			for (const block of node.cases) {
				if (!first) {
					context.margin();
				}

				first = false;

				if (block.test) {
					context.newline();
					context.write('case ');
					context.visit(block.test);
					context.write(':');
				} else {
					context.newline();
					context.write('default:');
				}

				context.indent();

				for (const statement of block.consequent) {
					context.newline();
					context.visit(statement);
				}

				context.dedent();
			}

			context.dedent();
			context.newline();
			context.write('}');
		},

		TaggedTemplateExpression(node, context) {
			context.visit(node.tag);
			context.visit(node.quasi);
		},

		TemplateLiteral(node, context) {
			context.write('`');

			const { quasis, expressions } = node;

			for (let i = 0; i < expressions.length; i++) {
				const raw = quasis[i].value.raw;

				context.write(raw + '${');
				context.visit(expressions[i]);
				context.write('}');

				if (/\n/.test(raw)) context.multiline = true;
			}

			const raw = quasis[quasis.length - 1].value.raw;

			context.write(raw + '`');
			if (/\n/.test(raw)) context.multiline = true;
		},

		ThisExpression(node, context) {
			context.write('this', node);
		},

		ThrowStatement(node, context) {
			context.write('throw ');
			if (node.argument) context.visit(node.argument);
			context.write(';');
		},

		TryStatement(node, context) {
			context.write('try ');
			context.visit(node.block);

			if (node.handler) {
				if (node.handler.param) {
					context.write(' catch(');
					context.visit(node.handler.param);
					context.write(') ');
				} else {
					context.write(' catch ');
				}

				context.visit(node.handler.body);
			}

			if (node.finalizer) {
				context.write(' finally ');
				context.visit(node.finalizer);
			}
		},

		UnaryExpression(node, context) {
			context.write(node.operator);

			if (node.operator.length > 1) {
				context.write(' ');
			}

			if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
				context.write('(');
				context.visit(node.argument);
				context.write(')');
			} else {
				context.visit(node.argument);
			}
		},

		UpdateExpression(node, context) {
			if (node.prefix) {
				context.write(node.operator);
				context.visit(node.argument);
			} else {
				context.visit(node.argument);
				context.write(node.operator);
			}
		},

		VariableDeclaration(node, context) {
			handle_var_declaration(node, context);
			context.write(';');
		},

		VariableDeclarator(node, context) {
			context.visit(node.id);

			if (node.init) {
				context.write(' = ');
				context.visit(node.init);
			}
		},

		WhileStatement(node, context) {
			context.write('while (');
			context.visit(node.test);
			context.write(') ');
			context.visit(node.body);
		},

		WithStatement(node, context) {
			context.write('with (');
			context.visit(node.object);
			context.write(') ');
			context.visit(node.body);
		},

		YieldExpression(node, context) {
			if (node.argument) {
				context.write(node.delegate ? `yield* ` : `yield `);
				context.visit(node.argument);
			} else {
				context.write(node.delegate ? `yield*` : `yield`);
			}
		},

		TSAbstractMethodDefinition: shared['MethodDefinition|TSAbstractMethodDefinition'],

		TSAbstractAccessorProperty:
			shared[
				'PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty'
			],

		TSAbstractPropertyDefinition:
			shared[
				'PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty'
			],

		TSDeclareFunction(node, context) {
			context.write('declare ');

			if (node.async) {
				context.write('async ');
			}

			context.write('function');

			if (node.generator) {
				context.write('*');
			}

			if (node.id) {
				context.write(' ');
				context.visit(node.id);
			}

			if (node.typeParameters) {
				context.visit(node.typeParameters);
			}

			context.write('(');
			sequence(context, node.params, node.returnType?.loc?.start ?? node.loc?.end ?? null, false);
			context.write(')');

			if (node.returnType) {
				context.visit(node.returnType);
			}

			context.write(';');
		},

		TSNumberKeyword(node, context) {
			context.write('number', node);
		},

		TSStringKeyword(node, context) {
			context.write('string', node);
		},

		TSBooleanKeyword(node, context) {
			context.write('boolean', node);
		},

		TSAnyKeyword(node, context) {
			context.write('any', node);
		},

		TSVoidKeyword(node, context) {
			context.write('void', node);
		},

		TSUnknownKeyword(node, context) {
			context.write('unknown', node);
		},

		TSNeverKeyword(node, context) {
			context.write('never', node);
		},

		TSSymbolKeyword(node, context) {
			context.write('symbol', node);
		},

		TSNullKeyword(node, context) {
			context.write('null', node);
		},

		TSUndefinedKeyword(node, context) {
			context.write('undefined', node);
		},

		TSObjectKeyword(node, context) {
			context.write('object', node);
		},

		TSBigIntKeyword(node, context) {
			context.write('bigint', node);
		},

		TSIntrinsicKeyword(node, context) {
			context.write('intrinsic', node);
		},

		TSArrayType(node, context) {
			context.visit(node.elementType);
			context.write('[]');
		},

		TSTypeAnnotation(node, context) {
			context.write(': ');
			context.visit(node.typeAnnotation);
		},

		TSTypeLiteral(node, context) {
			context.write('{ ');
			sequence(context, node.members, node.loc?.end ?? null, false, ';');
			context.write(' }');
		},

		TSPropertySignature(node, context) {
			context.visit(node.key);
			if (node.optional) context.write('?');
			if (node.typeAnnotation) context.visit(node.typeAnnotation);
		},

		TSTypeReference(node, context) {
			context.visit(node.typeName);

			if (node.typeArguments) {
				context.visit(node.typeArguments);
			}
		},

		TSTypeOperator(node, context) {
			context.write(node.operator + ' ');
			if (node.typeAnnotation) {
				context.visit(node.typeAnnotation);
			}
		},

		TSTemplateLiteralType(node, context) {
			context.write('`');
			const { quasis, types } = node;
			for (let i = 0; i < types.length; i++) {
				const raw = quasis[i].value.raw;

				context.write(raw + '${');
				context.visit(types[i]);
				context.write('}');

				if (/\n/.test(raw)) context.multiline = true;
			}
			context.write('`');
		},

		TSParameterProperty(node, context) {
			if (node.accessibility) {
				context.write(node.accessibility + ' ');
			}

			if (node.readonly) {
				context.write('readonly ');
			}

			context.visit(node.parameter);
		},

		TSExportAssignment(node, context) {
			context.write('export = ');
			context.visit(node.expression);
			context.write(';');
		},

		TSNamespaceExportDeclaration(node, context) {
			context.write('export as namespace ');
			context.visit(node.id);
			context.write(';');
		},

		//@ts-expect-error I don't know why, but this is relied upon in the tests, but doesn't exist in the TSESTree types
		TSExpressionWithTypeArguments(node, context) {
			context.visit(node.expression);
		},

		TSTypeAssertion(node, context) {
			context.write('<');
			context.visit(node.typeAnnotation);
			context.write('>');
			if (EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSTypeAssertion) {
				context.write('(');
				context.visit(node.expression);
				context.write(')');
			} else {
				context.visit(node.expression);
			}
		},

		TSTypeParameterInstantiation(node, context) {
			context.write('<');
			for (let i = 0; i < node.params.length; i++) {
				context.visit(node.params[i]);
				if (i != node.params.length - 1) context.write(', ');
			}
			context.write('>');
		},

		TSTypeParameterDeclaration(node, context) {
			context.write('<');
			for (let i = 0; i < node.params.length; i++) {
				context.visit(node.params[i]);
				if (i != node.params.length - 1) context.write(', ');
			}
			context.write('>');
		},

		TSTypeParameter(node, context) {
			if (node.name && node.name.type) context.visit(node.name);
			// @ts-expect-error type mismatch TSESTree and acorn-typescript?
			else context.write(node.name, node);

			if (node.constraint) {
				context.write(' extends ');
				context.visit(node.constraint);
			}
		},

		TSTypePredicate(node, context) {
			if (node.parameterName) {
				context.visit(node.parameterName);
			} else if (node.typeAnnotation) {
				context.visit(node.typeAnnotation);
			}

			if (node.asserts) {
				context.write(' asserts ');
			} else {
				context.write(' is ');
			}

			if (node.typeAnnotation) {
				context.visit(node.typeAnnotation.typeAnnotation);
			}
		},

		TSTypeQuery(node, context) {
			context.write('typeof ');
			context.visit(node.exprName);
		},

		TSClassImplements(node, context) {
			if (node.expression) {
				context.visit(node.expression);
			}
		},

		TSEnumMember(node, context) {
			context.visit(node.id);
			if (node.initializer) {
				context.write(' = ');
				context.visit(node.initializer);
			}
		},

		TSFunctionType: shared['TSFunctionType|TSConstructorType'],

		TSIndexSignature(node, context) {
			context.write('[');

			// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
			sequence(context, node.parameters, node.typeAnnotation?.loc?.start ?? null, false);
			context.write(']');

			// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
			context.visit(node.typeAnnotation);
		},

		TSMappedType(node, context) {
			context.write('{[');

			if (node.typeParameter) {
				context.visit(node.typeParameter);
			} else {
				context.visit(node.key);
				context.write(' in ');
				context.visit(node.constraint);
			}

			context.write(']');
			if (node.typeAnnotation) {
				context.write(': ');
				context.visit(node.typeAnnotation);
			}
			context.write('}');
		},

		TSMethodSignature(node, context) {
			context.visit(node.key);

			context.write('(');

			sequence(
				context,
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				node.parameters ?? node.params,
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				(node.typeAnnotation ?? node.returnType)?.loc?.start ?? null,
				false
			);
			context.write(')');

			// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
			if (node.typeAnnotation || node.returnType) {
				// @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
				context.visit(node.typeAnnotation ?? node.returnType);
			}
		},

		TSTupleType(node, context) {
			context.write('[');
			sequence(context, node.elementTypes, node.loc?.end ?? null, false);
			context.write(']');
		},

		TSNamedTupleMember(node, context) {
			context.visit(node.label);
			context.write(': ');
			context.visit(node.elementType);
		},

		TSUnionType(node, context) {
			sequence(context, node.types, node.loc?.end ?? null, false, ' |');
		},

		TSIntersectionType(node, context) {
			sequence(context, node.types, node.loc?.end ?? null, false, ' &');
		},

		TSInferType(node, context) {
			context.write('infer ');
			context.visit(node.typeParameter);
		},

		TSLiteralType(node, context) {
			context.visit(node.literal);
		},

		TSCallSignatureDeclaration:
			shared['TSConstructSignatureDeclaration|TSCallSignatureDeclaration'],

		TSConditionalType(node, context) {
			context.visit(node.checkType);
			context.write(' extends ');
			context.visit(node.extendsType);
			context.write(' ? ');
			context.visit(node.trueType);
			context.write(' : ');
			context.visit(node.falseType);
		},

		TSConstructSignatureDeclaration:
			shared['TSConstructSignatureDeclaration|TSCallSignatureDeclaration'],

		TSConstructorType: shared['TSFunctionType|TSConstructorType'],

		TSExternalModuleReference(node, context) {
			context.write('require(');
			context.visit(node.expression);
			context.write(');');
		},

		TSIndexedAccessType(node, context) {
			context.visit(node.objectType);
			context.write('[');
			context.visit(node.indexType);
			context.write(']');
		},

		TSImportEqualsDeclaration(node, context) {
			context.write('import ');
			context.visit(node.id);
			context.write(' = ');
			context.visit(node.moduleReference);
		},

		TSImportType(node, context) {
			context.write('import(');
			context.visit(node.argument);
			context.write(')');

			if (node.qualifier) {
				context.write('.');
				context.visit(node.qualifier);
			}
		},

		TSOptionalType(node, context) {
			context.visit(node.typeAnnotation);
			context.write('?');
		},

		TSRestType(node, context) {
			context.write('...');
			context.visit(node.typeAnnotation);
		},

		TSThisType(node, context) {
			context.write('this', node);
		},

		TSAsExpression(node, context) {
			if (node.expression) {
				const needs_parens =
					EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSAsExpression;

				if (needs_parens) {
					context.write('(');
					context.visit(node.expression);
					context.write(')');
				} else {
					context.visit(node.expression);
				}
			}
			context.write(' as ');
			context.visit(node.typeAnnotation);
		},

		TSEnumDeclaration(node, context) {
			context.write('enum ');
			context.visit(node.id);
			context.write(' {');
			context.indent();
			context.newline();
			sequence(context, node.members ?? node.body.members, node.loc?.end ?? null, false);
			context.dedent();
			context.newline();
			context.write('}');
		},

		TSModuleBlock(node, context) {
			context.write(' {');
			context.indent();
			context.newline();
			body(context, node);
			context.dedent();
			context.newline();
			context.write('}');
		},

		TSModuleDeclaration(node, context) {
			if (node.declare) context.write('declare ');
			else context.write('namespace ');

			context.visit(node.id);

			if (!node.body) return;
			context.visit(node.body);
		},

		TSNonNullExpression(node, context) {
			context.visit(node.expression);
			context.write('!');
		},

		TSInterfaceBody(node, context) {
			sequence(context, node.body, node.loc?.end ?? null, true, ';');
		},

		TSInterfaceDeclaration(node, context) {
			context.write('interface ');
			context.visit(node.id);
			if (node.typeParameters) context.visit(node.typeParameters);
			if (node.extends && node.extends.length > 0) {
				context.write(' extends ');
				sequence(context, node.extends, node.body.loc?.start ?? null, false);
			}
			context.write(' {');
			context.visit(node.body);
			context.write('}');
		},

		TSInstantiationExpression(node, context) {
			context.visit(node.expression);
			context.visit(node.typeArguments);
		},

		TSInterfaceHeritage(node, context) {
			if (node.expression) {
				context.visit(node.expression);
			}
		},

		//@ts-expect-error I don't know why, but this is relied upon in the tests, but doesn't exist in the TSESTree types
		TSParenthesizedType(node, context) {
			context.write('(');
			context.visit(node.typeAnnotation);
			context.write(')');
		},

		TSSatisfiesExpression(node, context) {
			if (node.expression) {
				const needs_parens =
					EXPRESSIONS_PRECEDENCE[node.expression.type] <
					EXPRESSIONS_PRECEDENCE.TSSatisfiesExpression;

				if (needs_parens) {
					context.write('(');
					context.visit(node.expression);
					context.write(')');
				} else {
					context.visit(node.expression);
				}
			}
			context.write(' satisfies ');
			context.visit(node.typeAnnotation);
		},

		TSTypeAliasDeclaration(node, context) {
			context.write('type ');
			context.visit(node.id);
			if (node.typeParameters) context.visit(node.typeParameters);
			context.write(' = ');
			context.visit(node.typeAnnotation);
			context.write(';');
		},

		TSQualifiedName(node, context) {
			context.visit(node.left);
			context.write('.');
			context.visit(node.right);
		}
	};
};

/** @satisfies {Visitors} */

/**
 *
 * @param {TSESTree.Expression | TSESTree.PrivateIdentifier} node
 * @param {TSESTree.BinaryExpression | TSESTree.LogicalExpression} parent
 * @param {boolean} is_right
 * @returns
 */
function needs_parens(node, parent, is_right) {
	if (node.type === 'PrivateIdentifier') return false;

	// special case where logical expressions and coalesce expressions cannot be mixed,
	// either of them need to be wrapped with parentheses
	if (
		node.type === 'LogicalExpression' &&
		parent.type === 'LogicalExpression' &&
		((parent.operator === '??' && node.operator !== '??') ||
			(parent.operator !== '??' && node.operator === '??'))
	) {
		return true;
	}

	const precedence = EXPRESSIONS_PRECEDENCE[node.type];
	const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];

	if (precedence !== parent_precedence) {
		// Different node types
		return (
			(!is_right && precedence === 15 && parent_precedence === 14 && parent.operator === '**') ||
			precedence < parent_precedence
		);
	}

	if (precedence !== 13 && precedence !== 14) {
		// Not a `LogicalExpression` or `BinaryExpression`
		return false;
	}

	if (
		/** @type {TSESTree.BinaryExpression} */ (node).operator === '**' &&
		parent.operator === '**'
	) {
		// Exponentiation operator has right-to-left associativity
		return !is_right;
	}

	if (is_right) {
		// Parenthesis are used if both operators have the same precedence
		return (
			OPERATOR_PRECEDENCE[/** @type {TSESTree.BinaryExpression} */ (node).operator] <=
			OPERATOR_PRECEDENCE[parent.operator]
		);
	}

	return (
		OPERATOR_PRECEDENCE[/** @type {TSESTree.BinaryExpression} */ (node).operator] <
		OPERATOR_PRECEDENCE[parent.operator]
	);
}

/** @param {TSESTree.Node} node */
function has_call_expression(node) {
	while (node) {
		if (node.type === 'CallExpression') {
			return true;
		} else if (node.type === 'MemberExpression') {
			node = node.object;
		} else {
			return false;
		}
	}
}

/**
 * @param {TSESTree.VariableDeclaration} node
 * @param {Context} context
 */
function handle_var_declaration(node, context) {
	const open = context.new();
	const join = context.new();
	const child_context = context.new();

	context.append(child_context);

	if (node.declare) {
		child_context.write('declare ');
	}

	child_context.write(`${node.kind} `);
	child_context.append(open);

	let first = true;

	for (const d of node.declarations) {
		if (!first) child_context.append(join);
		first = false;

		child_context.visit(d);
	}

	const length = child_context.measure() + 2 * (node.declarations.length - 1);

	const multiline = child_context.multiline || (node.declarations.length > 1 && length > 50);

	if (multiline) {
		context.multiline = true;

		if (node.declarations.length > 1) open.indent();
		join.write(',');
		join.newline();
		if (node.declarations.length > 1) context.dedent();
	} else {
		join.write(', ');
	}
}

/**
 * @param {string} string
 * @param {string} char
 */
function quote(string, char) {
	let out = char;

	for (const c of string) {
		if (c === '\\') {
			out += '\\\\';
		} else if (c === char) {
			out += '\\' + c;
		} else if (c === '\n') {
			out += '\\n';
		} else if (c === '\r') {
			out += '\\r';
		} else {
			out += c;
		}
	}

	return out + char;
}

/**
 *
 * @param {{ line: number, column: number }} a
 * @param {{ line: number, column: number }} b
 */
function before(a, b) {
	if (a.line < b.line) return true;
	if (a.line > b.line) return false;
	return a.column < b.column;
}

// generated during release, do not modify

/**
 * The current version, as set in package.json.
 * @type {string}
 */
const VERSION = '5.46.0';

class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}

	add(n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	}

	has(n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	}
}

class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		{
			this.previous = null;
			this.next = null;
		}
	}

	appendLeft(content) {
		this.outro += content;
	}

	appendRight(content) {
		this.intro = this.intro + content;
	}

	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	}

	contains(index) {
		return this.start < index && index < this.end;
	}

	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}

	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}

	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	}

	prependLeft(content) {
		this.outro = content + this.outro;
	}

	prependRight(content) {
		this.intro = content + this.intro;
	}

	reset() {
		this.intro = '';
		this.outro = '';
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}

	split(index) {
		const sliceIndex = index - this.start;

		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// after split we should save the edit content record into the correct chunk
			// to make sure sourcemap correct
			// For example:
			// '  test'.trim()
			//     split   -> '  ' + 'test'
			//   ✔️ edit    -> '' + 'test'
			//   ✖️ edit    -> 'test' + ''
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	}

	toString() {
		return this.intro + this.content + this.outro;
	}

	trimEnd(rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
				if (this.edited) {
					// save the change, if it has been edited
					this.edit(trimmed, this.storeName, true);
				}
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) return true;
		}
	}

	trimStart(rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) {
					// save the change, if it has been edited
					newChunk.edit(trimmed, this.storeName, true);
				}
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) return true;
		}
	}
}

function getBtoa() {
	if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
		return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	} else if (typeof Buffer === 'function') {
		return (str) => Buffer.from(str, 'utf-8').toString('base64');
	} else {
		return () => {
			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
		};
	}
}

const btoa$1 = /*#__PURE__*/ getBtoa();

let SourceMap$1 = class SourceMap {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== 'undefined') {
			this.x_google_ignoreList = properties.x_google_ignoreList;
		}
		if (typeof properties.debugId !== 'undefined') {
			this.debugId = properties.debugId;
		}
	}

	toString() {
		return JSON.stringify(this);
	}

	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa$1(this.toString());
	}
};

function guessIndent(code) {
	const lines = code.split('\n');

	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		let i = fromParts.length;
		while (i--) fromParts[i] = '..';
	}

	return fromParts.concat(toParts).join('/');
}

const toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	const originalLines = source.split('\n');
	const lineOffsets = [];

	for (let i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		let i = 0;
		let j = lineOffsets.length;
		while (i < j) {
			const m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		const line = i - 1;
		const column = index - lineOffsets[line];
		return { line, column };
	};
}

const wordRegex = /\w/;

class Mappings {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}

	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf('\n', 0);
			let previousContentLineEnd = -1;
			// Loop through each line in the content and add a segment, but stop if the last line is empty,
			// else code afterwards would fill one line too many
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
				if (nameIndex >= 0) {
					segment.push(nameIndex);
				}
				this.rawSegments.push(segment);

				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;

				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
			}

			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);

			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}

		this.pending = null;
	}

	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		// when iterating each char, check if it's in a word boundary
		let charInHiresBoundary = false;

		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];

					if (this.hires === 'boundary') {
						// in hires "boundary", group segments per word boundary than per char
						if (wordRegex.test(original[originalCharIndex])) {
							// for first char in the boundary found, start the boundary by pushing a segment
							if (!charInHiresBoundary) {
								this.rawSegments.push(segment);
								charInHiresBoundary = true;
							}
						} else {
							// for non-word char, end the boundary by pushing a segment
							this.rawSegments.push(segment);
							charInHiresBoundary = false;
						}
					} else {
						this.rawSegments.push(segment);
					}
				}

				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIndex += 1;
		}

		this.pending = null;
	}

	advance(str) {
		if (!str) return;

		const lines = str.split('\n');

		if (lines.length > 1) {
			for (let i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}

		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
}

const n = '\n';

const warned$1 = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);

		Object.defineProperties(this, {
			original: { writable: true, value: string },
			outro: { writable: true, value: '' },
			intro: { writable: true, value: '' },
			firstChunk: { writable: true, value: chunk },
			lastChunk: { writable: true, value: chunk },
			lastSearchedChunk: { writable: true, value: chunk },
			byStart: { writable: true, value: {} },
			byEnd: { writable: true, value: {} },
			filename: { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations: { writable: true, value: new BitSet() },
			storedNames: { writable: true, value: {} },
			indentStr: { writable: true, value: undefined },
			ignoreList: { writable: true, value: options.ignoreList },
			offset: { writable: true, value: options.offset || 0 },
		});

		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}

	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}

	append(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.outro += content;
		return this;
	}

	appendLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.appendLeft(content);
		} else {
			this.intro += content;
		}
		return this;
	}

	appendRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.appendRight(content);
		} else {
			this.outro += content;
		}
		return this;
	}

	clone() {
		const cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });

		let originalChunk = this.firstChunk;
		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;

			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

		cloned.intro = this.intro;
		cloned.outro = this.outro;

		return cloned;
	}

	generateDecodedMap(options) {
		options = options || {};

		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);

		const locate = getLocator(this.original);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);

			if (chunk.intro.length) mappings.advance(chunk.intro);

			if (chunk.edited) {
				mappings.addEdit(
					sourceIndex,
					chunk.content,
					loc,
					chunk.storeName ? names.indexOf(chunk.original) : -1,
				);
			} else {
				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			}

			if (chunk.outro.length) mappings.advance(chunk.outro);
		});

		if (this.outro) {
			mappings.advance(this.outro);
		}

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: [
				options.source ? getRelativePath(options.file || '', options.source) : options.file || '',
			],
			sourcesContent: options.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,
		};
	}

	generateMap(options) {
		return new SourceMap$1(this.generateDecodedMap(options));
	}

	_ensureindentStr() {
		if (this.indentStr === undefined) {
			this.indentStr = guessIndent(this.original);
		}
	}

	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}

	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? '\t' : this.indentStr;
	}

	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;

		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || '\t';
		}

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		const isExcluded = {};

		if (options.exclude) {
			const exclusions =
				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach((exclusion) => {
				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		let charIndex = 0;
		let chunk = this.firstChunk;

		while (chunk) {
			const end = chunk.end;

			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);

					if (chunk.content.length) {
						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];

						if (char === '\n') {
							shouldIndentNextCharacter = true;
						} else if (char !== '\r' && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;

							if (charIndex === chunk.start) {
								chunk.prependRight(indentStr);
							} else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	}

	insert() {
		throw new Error(
			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',
		);
	}

	insertLeft(index, content) {
		if (!warned$1.insertLeft) {
			console.warn(
				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',
			);
			warned$1.insertLeft = true;
		}

		return this.appendLeft(index, content);
	}

	insertRight(index, content) {
		if (!warned$1.insertRight) {
			console.warn(
				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',
			);
			warned$1.insertRight = true;
		}

		return this.prependRight(index, content);
	}

	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;

		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

		this._split(start);
		this._split(end);
		this._split(index);

		const first = this.byStart[start];
		const last = this.byEnd[end];

		const oldLeft = first.previous;
		const oldRight = last.next;

		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;

		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;

		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;

		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}

	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
	}

	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;

		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (end > this.original.length) throw new Error('end is out of bounds');
		if (start === end)
			throw new Error(
				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',
			);

		this._split(start);
		this._split(end);

		if (options === true) {
			if (!warned$1.storeName) {
				console.warn(
					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',
				);
				warned$1.storeName = true;
			}

			options = { storeName: true };
		}
		const storeName = options !== undefined ? options.storeName : false;
		const overwrite = options !== undefined ? options.overwrite : false;

		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true,
			});
		}

		const first = this.byStart[start];
		const last = this.byEnd[end];

		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) {
					throw new Error('Cannot overwrite across a split point');
				}
				chunk = chunk.next;
				chunk.edit('', false);
			}

			first.edit(content, storeName, !overwrite);
		} else {
			// must be inserting at the end
			const newChunk = new Chunk(start, end, '').edit(content, storeName);

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}

	prepend(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.intro = content + this.intro;
		return this;
	}

	prependLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.prependLeft(content);
		} else {
			this.intro = content + this.intro;
		}
		return this;
	}

	prependRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.prependRight(content);
		} else {
			this.outro = content + this.outro;
		}
		return this;
	}

	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit('');

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.reset();

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while ((chunk = chunk.previous));
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return '';
	}

	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}

			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}

			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while ((chunk = chunk.previous));
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}

	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		let result = '';

		// find start chunk
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			// found end chunk before start
			if (chunk.start < end && chunk.end >= end) {
				return result;
			}

			chunk = chunk.next;
		}

		if (chunk && chunk.edited && chunk.start !== start)
			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);

		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
				result += chunk.intro;
			}

			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end)
				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);

			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice(sliceStart, sliceEnd);

			if (chunk.outro && (!containsEnd || chunk.end === end)) {
				result += chunk.outro;
			}

			if (containsEnd) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	}

	// TODO deprecate this? not really very useful
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	}

	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;

		let chunk = this.lastSearchedChunk;
		let previousChunk = chunk;
		const searchForward = index > chunk.end;

		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);

			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];

			// Prevent infinite loop (e.g. via empty chunks, where start === end)
			if (chunk === previousChunk) return;

			previousChunk = chunk;
		}
	}

	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			// zero-length edited chunks are a special case (overlapping replacements)
			const loc = getLocator(this.original)(index);
			throw new Error(
				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`,
			);
		}

		const newChunk = chunk.split(index);

		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;

		if (chunk === this.lastChunk) this.lastChunk = newChunk;

		this.lastSearchedChunk = chunk;
		return true;
	}

	toString() {
		let str = this.intro;

		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	}

	isEmpty() {
		let chunk = this.firstChunk;
		do {
			if (
				(chunk.intro.length && chunk.intro.trim()) ||
				(chunk.content.length && chunk.content.trim()) ||
				(chunk.outro.length && chunk.outro.trim())
			)
				return false;
		} while ((chunk = chunk.next));
		return true;
	}

	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do {
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		} while ((chunk = chunk.next));
		return length;
	}

	trimLines() {
		return this.trim('[\\r\\n]');
	}

	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}

	trimEndAborted(charType) {
		const rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		let chunk = this.lastChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);

			// if chunk was trimmed, we have a new lastChunk
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) {
					this.lastChunk = chunk.next;
				}

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);

		return false;
	}

	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		let chunk = this.firstChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);

			if (chunk.end !== end) {
				// special case...
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);

		return false;
	}

	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}

	hasChanged() {
		return this.original !== this.toString();
	}

	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === 'string') {
				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
					if (i === '$') return '$';
					if (i === '&') return match[0];
					const num = +i;
					if (num < match.length) return match[+i];
					return `$${i}`;
				});
			} else {
				return replacement(...match, match.index, str, match.groups);
			}
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while ((match = re.exec(str))) {
				matches.push(match);
			}
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement = getReplacement(match, this.original);
					if (replacement !== match[0]) {
						this.overwrite(match.index, match.index + match[0].length, replacement);
					}
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement = getReplacement(match, this.original);
				if (replacement !== match[0]) {
					this.overwrite(match.index, match.index + match[0].length, replacement);
				}
			}
		}
		return this;
	}

	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);

		if (index !== -1) {
			if (typeof replacement === 'function') {
				replacement = replacement(string, index, original);
			}
			if (string !== replacement) {
				this.overwrite(index, index + string.length, replacement);
			}
		}

		return this;
	}

	replace(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceString(searchValue, replacement);
		}

		return this._replaceRegexp(searchValue, replacement);
	}

	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (
			let index = original.indexOf(string);
			index !== -1;
			index = original.indexOf(string, index + stringLength)
		) {
			const previous = original.slice(index, index + stringLength);
			let _replacement = replacement;
			if (typeof replacement === 'function') {
				_replacement = replacement(previous, index, original);
			}
			if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
		}

		return this;
	}

	replaceAll(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceAllString(searchValue, replacement);
		}

		if (!searchValue.global) {
			throw new TypeError(
				'MagicString.prototype.replaceAll called with a non-global RegExp argument',
			);
		}

		return this._replaceRegexp(searchValue, replacement);
	}
}

// Matches the scheme of a URL, eg "http://"
const schemeRegex = /^[\w+.-]+:\/\//;
/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}
function isAbsolutePath(input) {
    return input.startsWith('/');
}
function isFileUrl(input) {
    return input.startsWith('file:');
}
function isRelative(input) {
    return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}
function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: 7 /* Absolute */,
    };
}
function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
        const url = parseAbsoluteUrl('http:' + input);
        url.scheme = '';
        url.type = 6 /* SchemeRelative */;
        return url;
    }
    if (isAbsolutePath(input)) {
        const url = parseAbsoluteUrl('http://foo.com' + input);
        url.scheme = '';
        url.host = '';
        url.type = 5 /* AbsolutePath */;
        return url;
    }
    if (isFileUrl(input))
        return parseFileUrl(input);
    if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    url.scheme = '';
    url.host = '';
    url.type = input
        ? input.startsWith('?')
            ? 3 /* Query */
            : input.startsWith('#')
                ? 2 /* Hash */
                : 4 /* RelativePath */
        : 1 /* Empty */;
    return url;
}
function stripPathFilename(path) {
    // If a path ends with a parent directory "..", then it's a relative path with excess parent
    // paths. It's not a file, so we can't strip it.
    if (path.endsWith('/..'))
        return path;
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}
function mergePaths(url, base) {
    normalizePath(base, base.type);
    // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
    // path).
    if (url.path === '/') {
        url.path = base.path;
    }
    else {
        // Resolution happens relative to the base path's directory, not the file.
        url.path = stripPathFilename(base.path) + url.path;
    }
}
/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */
function normalizePath(url, type) {
    const rel = type <= 4 /* RelativePath */;
    const pieces = url.path.split('/');
    // We need to preserve the first piece always, so that we output a leading slash. The item at
    // pieces[0] is an empty string.
    let pointer = 1;
    // Positive is the number of real directories we've output, used for popping a parent directory.
    // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
    let positive = 0;
    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
    // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
    // real directory, we won't need to append, unless the other conditions happen again.
    let addTrailingSlash = false;
    for (let i = 1; i < pieces.length; i++) {
        const piece = pieces[i];
        // An empty directory, could be a trailing slash, or just a double "//" in the path.
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        // If we encounter a real directory, then we don't need to append anymore.
        addTrailingSlash = false;
        // A current directory, which we can always drop.
        if (piece === '.')
            continue;
        // A parent directory, we need to see if there are any real directories we can pop. Else, we
        // have an excess of parents, and we'll need to keep the "..".
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            }
            else if (rel) {
                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
            }
            continue;
        }
        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
        // any popped or dropped directories.
        pieces[pointer++] = piece;
        positive++;
    }
    let path = '';
    for (let i = 1; i < pointer; i++) {
        path += '/' + pieces[i];
    }
    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
        path += '/';
    }
    url.path = path;
}
/**
 * Attempts to resolve `input` URL/path relative to `base`.
 */
function resolve(input, base) {
    if (!input && !base)
        return '';
    const url = parseUrl(input);
    let inputType = url.type;
    if (base && inputType !== 7 /* Absolute */) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch (inputType) {
            case 1 /* Empty */:
                url.hash = baseUrl.hash;
            // fall through
            case 2 /* Hash */:
                url.query = baseUrl.query;
            // fall through
            case 3 /* Query */:
            case 4 /* RelativePath */:
                mergePaths(url, baseUrl);
            // fall through
            case 5 /* AbsolutePath */:
                // The host, user, and port are joined, you can't copy one without the others.
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
            // fall through
            case 6 /* SchemeRelative */:
                // The input doesn't have a schema at least, so we need to copy at least that over.
                url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType)
            inputType = baseType;
    }
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    switch (inputType) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2 /* Hash */:
        case 3 /* Query */:
            return queryHash;
        case 4 /* RelativePath */: {
            // The first char is always a "/", and we need it to be relative.
            const path = url.path.slice(1);
            if (!path)
                return queryHash || '.';
            if (isRelative(base || input) && !isRelative(path)) {
                // If base started with a leading ".", or there is no base and input started with a ".",
                // then we need to ensure that the relative path starts with a ".". We don't know if
                // relative starts with a "..", though, so check before prepending.
                return './' + path + queryHash;
            }
            return path + queryHash;
        }
        case 5 /* AbsolutePath */:
            return url.path + queryHash;
        default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}

// src/trace-mapping.ts

// src/strip-filename.ts
function stripFilename(path) {
  if (!path) return "";
  const index = path.lastIndexOf("/");
  return path.slice(0, index + 1);
}

// src/resolve.ts
function resolver(mapUrl, sourceRoot) {
  const from = stripFilename(mapUrl);
  const prefix = sourceRoot ? sourceRoot + "/" : "";
  return (source) => resolve(prefix + (source || ""), from);
}

// src/sourcemap-segment.ts
var COLUMN$1 = 0;

// src/sort.ts
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length) return mappings;
  if (!owned) mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++) {
    if (!isSorted(mappings[i])) return i;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned) line = line.slice();
  return line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[COLUMN$1] - b[COLUMN$1];
}

// src/binary-search.ts
var found = false;
function binarySearch$1(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN$1] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function lowerBound(haystack, needle, index) {
  for (let i = index - 1; i >= 0; index = i--) {
    if (haystack[i][COLUMN$1] !== needle) break;
  }
  return index;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch$1(haystack, needle, low, high);
}

// src/types.ts
function parse$2(map) {
  return typeof map === "string" ? JSON.parse(map) : map;
}
var TraceMap = class {
  constructor(map, mapUrl) {
    const isString = typeof map === "string";
    if (!isString && map._decodedMemo) return map;
    const parsed = parse$2(map);
    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version;
    this.file = file;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    const resolve = resolver(mapUrl, sourceRoot);
    this.resolvedSources = sources.map(resolve);
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else if (Array.isArray(mappings)) {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    } else if (parsed.sections) {
      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
    } else {
      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
function cast$1(map) {
  return map;
}
function decodedMappings(map) {
  var _a;
  return (_a = cast$1(map))._decoded || (_a._decoded = decode(cast$1(map)._encoded));
}
function traceSegment(map, line, column) {
  const decoded = decodedMappings(map);
  if (line >= decoded.length) return null;
  const segments = decoded[line];
  const index = traceSegmentInternal(
    segments,
    cast$1(map)._decodedMemo,
    line,
    column);
  return index === -1 ? null : segments[index];
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (lowerBound)(segments, column, index);
  }
  if (index === -1 || index === segments.length) return -1;
  return index;
}

// src/set-array.ts
var SetArray = class {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
};
function cast(set) {
  return set;
}
function get(setarr, key) {
  return cast(setarr)._indexes[key];
}
function put(setarr, key) {
  const index = get(setarr, key);
  if (index !== void 0) return index;
  const { array, _indexes: indexes } = cast(setarr);
  const length = array.push(key);
  return indexes[key] = length - 1;
}
function remove(setarr, key) {
  const index = get(setarr, key);
  if (index === void 0) return;
  const { array, _indexes: indexes } = cast(setarr);
  for (let i = index + 1; i < array.length; i++) {
    const k = array[i];
    array[i - 1] = k;
    indexes[k]--;
  }
  indexes[key] = void 0;
  array.pop();
}

// src/sourcemap-segment.ts
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;

// src/gen-mapping.ts
var NO_NAME = -1;
var GenMapping = class {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
    this._ignoreList = new SetArray();
  }
};
function cast2(map) {
  return map;
}
var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
  return addSegmentInternal(
    true,
    map,
    genLine,
    genColumn,
    source,
    sourceLine,
    sourceColumn,
    name);
};
function setSourceContent(map, source, content) {
  const {
    _sources: sources,
    _sourcesContent: sourcesContent
    // _originalScopes: originalScopes,
  } = cast2(map);
  const index = put(sources, source);
  sourcesContent[index] = content;
}
function setIgnore(map, source, ignore = true) {
  const {
    _sources: sources,
    _sourcesContent: sourcesContent,
    _ignoreList: ignoreList
    // _originalScopes: originalScopes,
  } = cast2(map);
  const index = put(sources, source);
  if (index === sourcesContent.length) sourcesContent[index] = null;
  if (ignore) put(ignoreList, index);
  else remove(ignoreList, index);
}
function toDecodedMap(map) {
  const {
    _mappings: mappings,
    _sources: sources,
    _sourcesContent: sourcesContent,
    _names: names,
    _ignoreList: ignoreList
    // _originalScopes: originalScopes,
    // _generatedRanges: generatedRanges,
  } = cast2(map);
  removeEmptyFinalLines(mappings);
  return {
    version: 3,
    file: map.file || void 0,
    names: names.array,
    sourceRoot: map.sourceRoot || void 0,
    sources: sources.array,
    sourcesContent,
    mappings,
    // originalScopes,
    // generatedRanges,
    ignoreList: ignoreList.array
  };
}
function toEncodedMap(map) {
  const decoded = toDecodedMap(map);
  return Object.assign({}, decoded, {
    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
    mappings: encode(decoded.mappings)
  });
}
function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
  const {
    _mappings: mappings,
    _sources: sources,
    _sourcesContent: sourcesContent,
    _names: names
    // _originalScopes: originalScopes,
  } = cast2(map);
  const line = getIndex(mappings, genLine);
  const index = getColumnIndex(line, genColumn);
  if (!source) {
    if (skipSourceless(line, index)) return;
    return insert(line, index, [genColumn]);
  }
  const sourcesIndex = put(sources, source);
  const namesIndex = name ? put(names, name) : NO_NAME;
  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;
  if (skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
    return;
  }
  return insert(
    line,
    index,
    name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]
  );
}
function getIndex(arr, index) {
  for (let i = arr.length; i <= index; i++) {
    arr[i] = [];
  }
  return arr[index];
}
function getColumnIndex(line, genColumn) {
  let index = line.length;
  for (let i = index - 1; i >= 0; index = i--) {
    const current = line[i];
    if (genColumn >= current[COLUMN]) break;
  }
  return index;
}
function insert(array, index, value) {
  for (let i = array.length; i > index; i--) {
    array[i] = array[i - 1];
  }
  array[index] = value;
}
function removeEmptyFinalLines(mappings) {
  const { length } = mappings;
  let len = length;
  for (let i = len - 1; i >= 0; len = i, i--) {
    if (mappings[i].length > 0) break;
  }
  if (len < length) mappings.length = len;
}
function skipSourceless(line, index) {
  if (index === 0) return true;
  const prev = line[index - 1];
  return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
  if (index === 0) return false;
  const prev = line[index - 1];
  if (prev.length === 1) return false;
  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
}

// src/build-source-map-tree.ts
var SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null, false);
var EMPTY_SOURCES = [];
function SegmentObject(source, line, column, name, content, ignore) {
  return { source, line, column, name, content, ignore };
}
function Source(map, sources, source, content, ignore) {
  return {
    map,
    sources,
    source,
    content,
    ignore
  };
}
function MapSource(map, sources) {
  return Source(map, sources, "", null, false);
}
function OriginalSource(source, content, ignore) {
  return Source(null, EMPTY_SOURCES, source, content, ignore);
}
function traceMappings(tree) {
  const gen = new GenMapping({ file: tree.map.file });
  const { sources: rootSources, map } = tree;
  const rootNames = map.names;
  const rootMappings = decodedMappings(map);
  for (let i = 0; i < rootMappings.length; i++) {
    const segments = rootMappings[i];
    for (let j = 0; j < segments.length; j++) {
      const segment = segments[j];
      const genCol = segment[0];
      let traced = SOURCELESS_MAPPING;
      if (segment.length !== 1) {
        const source2 = rootSources[segment[1]];
        traced = originalPositionFor(
          source2,
          segment[2],
          segment[3],
          segment.length === 5 ? rootNames[segment[4]] : ""
        );
        if (traced == null) continue;
      }
      const { column, line, name, content, source, ignore } = traced;
      maybeAddSegment(gen, i, genCol, source, line, column, name);
      if (source && content != null) setSourceContent(gen, source, content);
      if (ignore) setIgnore(gen, source, true);
    }
  }
  return gen;
}
function originalPositionFor(source, line, column, name) {
  if (!source.map) {
    return SegmentObject(source.source, line, column, name, source.content, source.ignore);
  }
  const segment = traceSegment(source.map, line, column);
  if (segment == null) return null;
  if (segment.length === 1) return SOURCELESS_MAPPING;
  return originalPositionFor(
    source.sources[segment[1]],
    segment[2],
    segment[3],
    segment.length === 5 ? source.map.names[segment[4]] : name
  );
}

// src/build-source-map-tree.ts
function asArray(value) {
  if (Array.isArray(value)) return value;
  return [value];
}
function buildSourceMapTree(input, loader) {
  const maps = asArray(input).map((m) => new TraceMap(m, ""));
  const map = maps.pop();
  for (let i = 0; i < maps.length; i++) {
    if (maps[i].sources.length > 1) {
      throw new Error(
        `Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`
      );
    }
  }
  let tree = build(map, loader, "", 0);
  for (let i = maps.length - 1; i >= 0; i--) {
    tree = MapSource(maps[i], [tree]);
  }
  return tree;
}
function build(map, loader, importer, importerDepth) {
  const { resolvedSources, sourcesContent, ignoreList } = map;
  const depth = importerDepth + 1;
  const children = resolvedSources.map((sourceFile, i) => {
    const ctx = {
      importer,
      depth,
      source: sourceFile || "",
      content: void 0,
      ignore: void 0
    };
    const sourceMap = loader(ctx.source, ctx);
    const { source} = ctx;
    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);
    const sourceContent = sourcesContent ? sourcesContent[i] : null;
    const ignored = ignoreList ? ignoreList.includes(i) : false;
    return OriginalSource(source, sourceContent, ignored);
  });
  return MapSource(map, children);
}
var SourceMap = class {
  constructor(map, options) {
    const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);
    this.version = out.version;
    this.file = out.file;
    this.mappings = out.mappings;
    this.names = out.names;
    this.ignoreList = out.ignoreList;
    this.sourceRoot = out.sourceRoot;
    this.sources = out.sources;
    if (!options.excludeContent) {
      this.sourcesContent = out.sourcesContent;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};

// src/remapping.ts
function remapping(input, loader, options) {
  const opts = { excludeContent: true, decodedMappings: false };
  const tree = buildSourceMapTree(input, loader);
  return new SourceMap(traceMappings(tree), opts);
}

/**
 * Pushes all `items` into `array` using `push`, therefore mutating the array.
 * We do this for memory and perf reasons, and because `array.push(...items)` would
 * run into a "max call stack size exceeded" error with too many items (~65k).
 * @template T
 * @param {T[]} array
 * @param {T[]} items
 */
function push_array(array, items) {
	for (let i = 0; i < items.length; i++) {
		array.push(items[i]);
	}
}

/** @import { ValidatedCompileOptions } from '#compiler' */
/** @import { Processed } from '../preprocess/public.js' */
/** @import { SourceMap } from 'magic-string' */
/** @import { Source } from '../preprocess/private.js' */
/** @import { DecodedSourceMap, SourceMapSegment, RawSourceMap } from '@jridgewell/remapping' */

/**
 * @param {string} s
 */
function last_line_length(s) {
	return s.length - s.lastIndexOf('\n') - 1;
}
// mutate map in-place

/**
 * @param {DecodedSourceMap} map
 * @param {{ line: number; column: number; }} offset
 * @param {number} source_index
 */
function sourcemap_add_offset(map, offset, source_index) {
	if (map.mappings.length == 0) return;
	for (let line = 0; line < map.mappings.length; line++) {
		const segment_list = map.mappings[line];
		for (let segment = 0; segment < segment_list.length; segment++) {
			const seg = segment_list[segment];
			// shift only segments that belong to component source file
			if (seg[1] === source_index) {
				// also ensures that seg.length >= 4
				// shift column if it points at the first line
				if (seg[2] === 0) {
					/** @type {any} */ (seg[3]) += offset.column;
				}
				// shift line
				/** @type {any} */ (seg[2]) += offset.line;
			}
		}
	}
}

/**
 * @template T
 * @param {T[]} this_table
 * @param {T[]} other_table
 * @returns {[T[], number[], boolean, boolean]}
 */
function merge_tables(this_table, other_table) {
	const new_table = this_table.slice();
	const idx_map = [];
	other_table = other_table || [];
	let val_changed = false;
	for (const [other_idx, other_val] of other_table.entries()) {
		const this_idx = this_table.indexOf(other_val);
		if (this_idx >= 0) {
			idx_map[other_idx] = this_idx;
		} else {
			const new_idx = new_table.length;
			new_table[new_idx] = other_val;
			idx_map[other_idx] = new_idx;
			val_changed = true;
		}
	}
	let idx_changed = val_changed;
	if (val_changed) {
		if (idx_map.find((val, idx) => val != idx) === undefined) {
			// idx_map is identity map [0, 1, 2, 3, 4, ....]
			idx_changed = false;
		}
	}
	return [new_table, idx_map, val_changed, idx_changed];
}
const regex_line_token = /([^\w\s]|\s+)/g;
/** */
class MappedCode {
	/**
	 * @type {string}
	 */
	string = /** @type {any} */ (undefined);

	/**
	 * @type {DecodedSourceMap}
	 */
	map = /** @type {any} */ (undefined);

	/**
	 * @param {string} string
	 * @param {DecodedSourceMap | null} map
	 */
	constructor(string = '', map = null) {
		this.string = string;
		if (map) {
			this.map = map;
		} else {
			this.map = {
				version: 3,
				mappings: [],
				sources: [],
				names: []
			};
		}
	}
	/**
	 * concat in-place (mutable), return this (chainable)
	 * will also mutate the `other` object
	 * @param {MappedCode} other
	 * @returns {MappedCode}
	 */
	concat(other) {
		// noop: if one is empty, return the other
		if (other.string == '') return this;
		if (this.string == '') {
			this.string = other.string;
			this.map = other.map;
			return this;
		}
		// compute last line length before mutating
		const column_offset = last_line_length(this.string);
		this.string += other.string;
		const m1 = this.map;
		const m2 = other.map;
		if (m2.mappings.length == 0) return this;
		// combine sources and names
		const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
			m1.sources,
			m2.sources
		);
		const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
			m1.names,
			m2.names
		);
		if (sources_changed) m1.sources = sources;
		if (names_changed) m1.names = names;
		// unswitched loops are faster
		if (sources_idx_changed && names_idx_changed) {
			for (let line = 0; line < m2.mappings.length; line++) {
				const segment_list = m2.mappings[line];
				for (let segment = 0; segment < segment_list.length; segment++) {
					const seg = segment_list[segment];
					// @ts-ignore
					if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
					// @ts-ignore
					if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
				}
			}
		} else if (sources_idx_changed) {
			for (let line = 0; line < m2.mappings.length; line++) {
				const segment_list = m2.mappings[line];
				for (let segment = 0; segment < segment_list.length; segment++) {
					const seg = segment_list[segment];
					// @ts-ignore
					if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
				}
			}
		} else if (names_idx_changed) {
			for (let line = 0; line < m2.mappings.length; line++) {
				const segment_list = m2.mappings[line];
				for (let segment = 0; segment < segment_list.length; segment++) {
					const seg = segment_list[segment];
					// @ts-ignore
					if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
				}
			}
		}
		// combine the mappings
		// combine
		// 1. last line of first map
		// 2. first line of second map
		// columns of 2 must be shifted
		if (m2.mappings.length > 0 && column_offset > 0) {
			const first_line = m2.mappings[0];
			for (let i = 0; i < first_line.length; i++) {
				first_line[i][0] += column_offset;
			}
		}
		// combine last line + first line
		push_array(
			m1.mappings[m1.mappings.length - 1],
			/** @type {SourceMapSegment[]} */ (m2.mappings.shift())
		);
		// append other lines
		push_array(m1.mappings, m2.mappings);
		return this;
	}

	/**
	 * @static
	 * @param {string} string
	 * @param {DecodedSourceMap} [map]
	 * @returns {MappedCode}
	 */
	static from_processed(string, map) {
		const line_count = string.split('\n').length;
		if (map) {
			// ensure that count of source map mappings lines
			// is equal to count of generated code lines
			// (some tools may produce less)
			const missing_lines = line_count - map.mappings.length;
			for (let i = 0; i < missing_lines; i++) {
				map.mappings.push([]);
			}
			return new MappedCode(string, map);
		}
		if (string == '') return new MappedCode();
		map = { version: 3, names: [], sources: [], mappings: [] };
		// add empty SourceMapSegment[] for every line
		for (let i = 0; i < line_count; i++) map.mappings.push([]);
		return new MappedCode(string, map);
	}

	/**
	 * @static
	 * @param {Source} opts
	 * @returns {MappedCode}
	 */
	static from_source({ source, file_basename, get_location }) {
		/**
		 * @type {{ line: number; column: number; }}
		 */
		let offset = get_location(0);
		if (!offset) offset = { line: 0, column: 0 };

		/**
		 * @type {DecodedSourceMap}
		 */
		const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
		if (source == '') return new MappedCode(source, map);
		// we create a high resolution identity map here,
		// we know that it will eventually be merged with svelte's map,
		// at which stage the resolution will decrease.
		const line_list = source.split('\n');
		for (let line = 0; line < line_list.length; line++) {
			map.mappings.push([]);
			const token_list = line_list[line].split(regex_line_token);
			for (let token = 0, column = 0; token < token_list.length; token++) {
				if (token_list[token] == '') continue;
				map.mappings[line].push([column, 0, offset.line + line, column]);
				column += token_list[token].length;
			}
		}
		// shift columns in first line
		const segment_list = map.mappings[0];
		for (let segment = 0; segment < segment_list.length; segment++) {
			// @ts-ignore
			segment_list[segment][3] += offset.column;
		}
		return new MappedCode(source, map);
	}
}

// browser vs node.js
const b64enc =
	typeof window !== 'undefined' && typeof btoa === 'function'
		? /** @param {string} str */ (str) => btoa(unescape(encodeURIComponent(str)))
		: /** @param {string} str */ (str) => Buffer.from(str).toString('base64');
const b64dec =
	typeof window !== 'undefined' && typeof atob === 'function'
		? atob
		: /** @param {any} a */ (a) => Buffer.from(a, 'base64').toString();

/**
 * @param {string} filename Basename of the input file
 * @param {Array<DecodedSourceMap | RawSourceMap>} sourcemap_list
 */
function combine_sourcemaps(filename, sourcemap_list) {
	if (sourcemap_list.length == 0) return null;
	let map_idx = 1;
	const map =
		sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === undefined
			? remapping(
					// use array interface
					// only the oldest sourcemap can have multiple sources
					sourcemap_list,
					() => null)
			: remapping(
					// use loader interface
					sourcemap_list[0], // last map
					(sourcefile) => {
						// TODO the equality check assumes that the preprocessor map has the input file as a relative path in sources,
						// e.g. when the input file is `src/foo/bar.svelte`, then sources is expected to contain just `bar.svelte`.
						// Therefore filename also needs to be the basename of the path. This feels brittle, investigate how we can
						// harden this (without breaking other tooling that assumes this behavior).
						if (sourcefile === filename && sourcemap_list[map_idx]) {
							return sourcemap_list[map_idx++]; // idx 1, 2, ...
							// bundle file = branch node
						} else {
							return null; // source file = leaf node
						}
					});
	if (!map.file) delete map.file; // skip optional field `file`
	// When source maps are combined and the leading map is empty, sources is not set.
	// Add the filename to the empty array in this case.
	// Further improvements to remapping may help address this as well https://github.com/ampproject/remapping/issues/116
	if (!map.sources.length) map.sources = [filename];
	return map;
}

/**
 * @param {string} filename
 * @param {SourceMap} svelte_map
 * @param {string | DecodedSourceMap | RawSourceMap} preprocessor_map_input
 * @returns {SourceMap}
 */
function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) {
	if (!svelte_map || !preprocessor_map_input) return svelte_map;
	const preprocessor_map =
		typeof preprocessor_map_input === 'string'
			? JSON.parse(preprocessor_map_input)
			: preprocessor_map_input;
	const result_map = combine_sourcemaps(filename, [svelte_map, preprocessor_map]);
	// Svelte expects a SourceMap which includes toUrl and toString. Instead of wrapping our output in a class,
	// we just tack on the extra properties.
	Object.defineProperties(result_map, {
		toString: {
			enumerable: false,
			value: function toString() {
				return JSON.stringify(this);
			}
		},
		toUrl: {
			enumerable: false,
			value: function toUrl() {
				return 'data:application/json;charset=utf-8;base64,' + b64enc(this.toString());
			}
		}
	});
	return /** @type {any} */ (result_map);
}
const regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
// parse attached sourcemap in processed.code

/**
 * @param {Processed} processed
 * @param {'script' | 'style'} tag_name
 * @returns {void}
 */
function parse_attached_sourcemap(processed, tag_name) {
	const r_in = '[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)';
	const regex =
		tag_name == 'script'
			? new RegExp('(?://' + r_in + ')|(?:/\\*' + r_in + '\\s*\\*/)$')
			: new RegExp('/\\*' + r_in + '\\s*\\*/$');

	/**
	 * @param {any} message
	 */
	function log_warning(message) {
		// code_start: help to find preprocessor
		const code_start =
			processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + ' [...]';
		// eslint-disable-next-line no-console
		console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
	}
	processed.code = processed.code.replace(regex, (_, match1, match2) => {
		const map_url = tag_name == 'script' ? match1 || match2 : match1;
		const map_data = (map_url.match(regex_data_uri) || [])[1];
		if (map_data) {
			// sourceMappingURL is data URL
			if (processed.map) {
				log_warning(
					'Not implemented. ' +
						'Found sourcemap in both processed.code and processed.map. ' +
						'Please update your preprocessor to return only one sourcemap.'
				);
				// ignore attached sourcemap
				return '';
			}
			processed.map = b64dec(map_data); // use attached sourcemap
			return ''; // remove from processed.code
		}
		// sourceMappingURL is path or URL
		if (!processed.map) {
			log_warning(
				`Found sourcemap path ${JSON.stringify(
					map_url
				)} in processed.code, but no sourcemap data. ` +
					'Please update your preprocessor to return sourcemap data directly.'
			);
		}
		// ignore sourcemap path
		return ''; // remove from processed.code
	});
}

/**
 * @param {{ code: string, map: SourceMap}} result
 * @param {ValidatedCompileOptions} options
 * @param {string} source_name
 */
function merge_with_preprocessor_map(result, options, source_name) {
	if (options.sourcemap) {
		const file_basename = get_basename(options.filename);
		// The preprocessor map is expected to contain `sources: [basename_of_filename]`, but our own
		// map may contain a different file name. Patch our map beforehand to align sources so merging
		// with the preprocessor map works correctly.
		result.map.sources = [file_basename];
		Object.assign(
			result.map,
			apply_preprocessor_sourcemap(
				file_basename,
				result.map,
				/** @type {any} */ (options.sourcemap)
			)
		);
		// After applying the preprocessor map, we need to do the inverse and make the sources
		// relative to the input file again in case the output code is in a different directory.
		if (file_basename !== source_name) {
			result.map.sources = result.map.sources.map(
				/** @param {string} source */ (source) => get_relative_path(source_name, source)
			);
		}
	}
}

/**
 * @param {string} from
 * @param {string} to
 */
function get_relative_path(from, to) {
	// Don't use node's utils here to ensure the compiler is usable in a browser environment
	const from_parts = from.split(/[/\\]/);
	const to_parts = to.split(/[/\\]/);
	from_parts.pop(); // get dirname
	while (from_parts[0] === to_parts[0]) {
		from_parts.shift();
		to_parts.shift();
	}
	if (from_parts.length) {
		let i = from_parts.length;
		while (i--) from_parts[i] = '..';
	}
	return from_parts.concat(to_parts).join('/');
}

/**
 * Like node's `basename`, but doesn't use it to ensure the compiler is usable in a browser environment
 * @param {string} filename
 */
function get_basename(filename) {
	return /** @type {string} */ (filename.split(/[/\\]/).pop());
}

/**
 * @param {string} filename
 * @param {string | undefined} output_filename
 * @param {string} fallback
 */
function get_source_name(filename, output_filename, fallback) {
	return output_filename ? get_relative_path(output_filename, filename) : get_basename(filename);
}

/** @import { Visitors } from 'zimmerframe' */
/** @import { AST, ValidatedCompileOptions } from '#compiler' */
/** @import { ComponentAnalysis } from '../../types.js' */

/**
 * @typedef {{
 *   code: MagicString;
 *   hash: string;
 *   minify: boolean;
 *   selector: string;
 *   keyframes: string[];
 *   specificity: {
 *     bumped: boolean
 *   }
 * }} State
 */

/**
 *
 * @param {string} source
 * @param {ComponentAnalysis} analysis
 * @param {ValidatedCompileOptions} options
 */
function render_stylesheet(source, analysis, options) {
	const code = new MagicString(source);

	/** @type {State} */
	const state = {
		code,
		hash: analysis.css.hash,
		minify: analysis.inject_styles && !options.dev,
		selector: `.${analysis.css.hash}`,
		keyframes: analysis.css.keyframes,
		specificity: {
			bumped: false
		}
	};

	const ast = /** @type {AST.CSS.StyleSheet} */ (analysis.css.ast);

	walk$1(/** @type {AST.CSS.Node} */ (ast), state, visitors$1);

	code.remove(0, ast.content.start);
	code.remove(/** @type {number} */ (ast.content.end), source.length);
	if (state.minify) {
		remove_preceding_whitespace(ast.content.end, state);
	}

	const css = {
		code: code.toString(),
		map: code.generateMap({
			// include source content; makes it easier/more robust looking up the source map code
			includeContent: true,
			// generateMap takes care of calculating source relative to file
			source: options.filename,
			file: options.cssOutputFilename || options.filename
		}),
		hasGlobal: analysis.css.has_global
	};

	merge_with_preprocessor_map(css, options, css.map.sources[0]);

	if (dev && options.css === 'injected' && css.code) {
		css.code += `\n/*# sourceMappingURL=${css.map.toUrl()} */`;
	}

	return css;
}

/** @type {Visitors<AST.CSS.Node, State>} */
const visitors$1 = {
	_: (node, context) => {
		context.state.code.addSourcemapLocation(node.start);
		context.state.code.addSourcemapLocation(node.end);
		context.next();
	},
	Atrule(node, { state, next, path }) {
		if (is_keyframes_node(node)) {
			let start = node.start + node.name.length + 1;
			while (state.code.original[start] === ' ') start += 1;
			let end = start;
			while (state.code.original[end] !== '{' && state.code.original[end] !== ' ') end += 1;

			if (node.prelude.startsWith('-global-')) {
				state.code.remove(start, start + 8);
			} else if (!is_in_global_block(path)) {
				state.code.prependRight(start, `${state.hash}-`);
			}

			return; // don't transform anything within
		}

		next();
	},
	Declaration(node, { state }) {
		const property = node.property && remove_css_prefix(node.property.toLowerCase());
		if (property === 'animation' || property === 'animation-name') {
			let index = node.start + node.property.length + 1;
			let name = '';

			while (index < state.code.original.length) {
				const character = state.code.original[index];

				if (regex_css_name_boundary.test(character)) {
					if (state.keyframes.includes(name)) {
						state.code.prependRight(index - name.length, `${state.hash}-`);
					}

					if (character === ';' || character === '}') {
						break;
					}

					name = '';
				} else {
					name += character;
				}

				index++;
			}
		} else if (state.minify) {
			remove_preceding_whitespace(node.start, state);

			// Don't minify whitespace in custom properties, since some browsers (Chromium < 99)
			// treat --foo: ; and --foo:; differently
			if (!node.property.startsWith('--')) {
				let start = node.start + node.property.length + 1;
				let end = start;
				while (/\s/.test(state.code.original[end])) end++;
				if (end > start) state.code.remove(start, end);
			}
		}
	},
	Rule(node, { state, next, visit, path }) {
		if (state.minify) {
			remove_preceding_whitespace(node.start, state);
			remove_preceding_whitespace(node.block.end - 1, state);
		}

		// keep empty rules in dev, because it's convenient to
		// see them in devtools
		if (!dev && is_empty(node, is_in_global_block(path))) {
			if (state.minify) {
				state.code.remove(node.start, node.end);
			} else {
				state.code.prependRight(node.start, '/* (empty) ');
				state.code.appendLeft(node.end, '*/');
				escape_comment_close(node, state.code);
			}

			return;
		}

		if (!is_used(node) && !is_in_global_block(path)) {
			if (state.minify) {
				state.code.remove(node.start, node.end);
			} else {
				state.code.prependRight(node.start, '/* (unused) ');
				state.code.appendLeft(node.end, '*/');
				escape_comment_close(node, state.code);
			}

			return;
		}

		if (node.metadata.is_global_block) {
			const selector = node.prelude.children[0];

			if (
				node.prelude.children.length === 1 &&
				selector.children.length === 1 &&
				selector.children[0].selectors.length === 1
			) {
				// `:global {...}`
				if (state.minify) {
					state.code.remove(node.start, node.block.start + 1);
					state.code.remove(node.block.end - 1, node.end);
				} else {
					state.code.prependRight(node.start, '/* ');
					state.code.appendLeft(node.block.start + 1, '*/');

					state.code.prependRight(node.block.end - 1, '/*');
					state.code.appendLeft(node.block.end, '*/');
				}

				// don't recurse into selectors but visit the body
				visit(node.block);
				return;
			}
		}

		next();
	},
	SelectorList(node, { state, next, path }) {
		const parent = path.at(-1);

		// Only add comments if we're not inside a complex selector that itself is unused or a global block
		if (
			(!is_in_global_block(path) ||
				(node.children.length > 1 && parent?.type === 'Rule' && parent.metadata.is_global_block)) &&
			!path.find((n) => n.type === 'ComplexSelector' && !n.metadata.used)
		) {
			const children = node.children;
			let pruning = false;
			let prune_start = children[0].start;
			let last = prune_start;
			let has_previous_used = false;

			for (let i = 0; i < children.length; i += 1) {
				const selector = children[i];

				if (selector.metadata.used === pruning) {
					if (pruning) {
						let i = selector.start;
						while (state.code.original[i] !== ',') i--;

						if (state.minify) {
							state.code.remove(prune_start, has_previous_used ? i : i + 1);
						} else {
							state.code.appendRight(has_previous_used ? i : i + 1, '*/');
						}
					} else {
						if (i === 0) {
							if (state.minify) {
								prune_start = selector.start;
							} else {
								state.code.prependRight(selector.start, '/* (unused) ');
							}
						} else {
							if (state.minify) {
								prune_start = last;
							} else {
								state.code.overwrite(last, selector.start, ` /* (unused) `);
							}
						}
					}

					pruning = !pruning;
				}

				if (!pruning && selector.metadata.used) {
					has_previous_used = true;
				}

				last = selector.end;
			}

			if (pruning) {
				if (state.minify) {
					state.code.remove(prune_start, last);
				} else {
					state.code.appendLeft(last, '*/');
				}
			}
		}

		// if we're in a `:is(...)` or whatever, keep existing specificity bump state
		let specificity = state.specificity;

		// if this selector list belongs to a rule, require a specificity bump for the
		// first scoped selector but only if we're at the top level
		if (parent?.type === 'Rule') {
			specificity = { bumped: false };

			/** @type {AST.CSS.Rule | null} */
			let rule = parent.metadata.parent_rule;

			while (rule) {
				if (rule.metadata.has_local_selectors) {
					specificity = { bumped: true };
					break;
				}
				rule = rule.metadata.parent_rule;
			}
		}

		next({ ...state, specificity });
	},
	ComplexSelector(node, context) {
		const before_bumped = context.state.specificity.bumped;

		for (const relative_selector of node.children) {
			if (relative_selector.metadata.is_global) {
				const global = /** @type {AST.CSS.PseudoClassSelector} */ (relative_selector.selectors[0]);
				remove_global_pseudo_class(global, relative_selector.combinator, context.state);

				const parent_rule = node.metadata.rule?.metadata.parent_rule;
				if (parent_rule && global.args === null) {
					if (relative_selector.combinator === null) {
						// div { :global.x { ... } } becomes div { &.x { ... } }
						context.state.code.prependRight(global.start, '&');
					}

					// In case of multiple :global selectors in a selector list we gotta delete the comma, too, but only if
					// the next selector is used; if it's unused then the comma deletion happens as part of removal of that next selector
					if (
						parent_rule.prelude.children.length > 1 &&
						node.children.length === node.children.findIndex((s) => s === relative_selector) - 1
					) {
						const next_selector = parent_rule.prelude.children.find((s) => s.start > global.end);
						if (next_selector && next_selector.metadata.used) {
							context.state.code.update(global.end, next_selector.start, '');
						}
					}
				}
				continue;
			} else {
				// for any :global() or :global at the middle of compound selector
				for (const selector of relative_selector.selectors) {
					if (selector.type === 'PseudoClassSelector' && selector.name === 'global') {
						remove_global_pseudo_class(selector, null, context.state);
					}
				}
			}

			if (relative_selector.metadata.scoped) {
				if (relative_selector.selectors.length === 1) {
					// skip standalone :is/:where/& selectors
					const selector = relative_selector.selectors[0];
					if (
						selector.type === 'PseudoClassSelector' &&
						(selector.name === 'is' || selector.name === 'where')
					) {
						continue;
					}
				}

				if (relative_selector.selectors.some((s) => s.type === 'NestingSelector')) {
					continue;
				}

				// for the first occurrence, we use a classname selector, so that every
				// encapsulated selector gets a +0-1-0 specificity bump. thereafter,
				// we use a `:where` selector, which does not affect specificity
				let modifier = context.state.selector;
				if (context.state.specificity.bumped) modifier = `:where(${modifier})`;

				context.state.specificity.bumped = true;

				let i = relative_selector.selectors.length;
				while (i--) {
					const selector = relative_selector.selectors[i];

					if (
						selector.type === 'PseudoElementSelector' ||
						selector.type === 'PseudoClassSelector'
					) {
						if (selector.name !== 'root' && selector.name !== 'host') {
							if (i === 0) context.state.code.prependRight(selector.start, modifier);
						}
						continue;
					}

					if (selector.type === 'TypeSelector' && selector.name === '*') {
						context.state.code.update(selector.start, selector.end, modifier);
					} else {
						context.state.code.appendLeft(selector.end, modifier);
					}

					break;
				}
			}
		}

		context.next();

		context.state.specificity.bumped = before_bumped;
	},
	PseudoClassSelector(node, context) {
		if (node.name === 'is' || node.name === 'where' || node.name === 'has' || node.name === 'not') {
			context.next();
		}
	}
};

/**
 * @param {Array<AST.CSS.Node>} path
 */
function is_in_global_block(path) {
	return path.some((node) => node.type === 'Rule' && node.metadata.is_global_block);
}

/**
 * @param {AST.CSS.PseudoClassSelector} selector
 * @param {AST.CSS.Combinator | null} combinator
 * @param {State} state
 */
function remove_global_pseudo_class(selector, combinator, state) {
	if (selector.args === null) {
		let start = selector.start;
		if (combinator?.name === ' ') {
			// div :global.x becomes div.x
			while (/\s/.test(state.code.original[start - 1])) start--;
		}

		// update(...), not remove(...) because there could be a closing unused comment at the end
		state.code.update(start, selector.start + ':global'.length, '');
	} else {
		state.code
			.remove(selector.start, selector.start + ':global('.length)
			.remove(selector.end - 1, selector.end);
	}
}

/**
 * Walk backwards until we find a non-whitespace character
 * @param {number} end
 * @param {State} state
 */
function remove_preceding_whitespace(end, state) {
	let start = end;
	while (/\s/.test(state.code.original[start - 1])) start--;
	if (start < end) state.code.remove(start, end);
}

/**
 *  @param {AST.CSS.Rule} rule
 * @param {boolean} is_in_global_block
 */
function is_empty(rule, is_in_global_block) {
	if (rule.metadata.is_global_block) {
		return rule.block.children.length === 0;
	}

	for (const child of rule.block.children) {
		if (child.type === 'Declaration') {
			return false;
		}

		if (child.type === 'Rule') {
			if ((is_used(child) || is_in_global_block) && !is_empty(child, is_in_global_block)) {
				return false;
			}
		}

		if (child.type === 'Atrule') {
			if (child.block === null || child.block.children.length > 0) return false;
		}
	}

	return true;
}

/** @param {AST.CSS.Rule} rule */
function is_used(rule) {
	return rule.prelude.children.some((selector) => selector.metadata.used);
}

/**
 *
 * @param {AST.CSS.Rule} node
 * @param {MagicString} code
 */
function escape_comment_close(node, code) {
	let escaped = false;
	let in_comment = false;

	for (let i = node.start; i < node.end; i++) {
		if (escaped) {
			escaped = false;
		} else {
			const char = code.original[i];
			if (in_comment) {
				if (char === '*' && code.original[i + 1] === '/') {
					code.prependRight(++i, '\\');
					in_comment = false;
				}
			} else if (char === '\\') {
				escaped = true;
			} else if (char === '/' && code.original[++i] === '*') {
				in_comment = true;
			}
		}
	}
}

/** @import { Identifier } from 'estree' */
/** @import { ComponentContext, Context } from '../../types' */

/**
 * Turns `foo` into `$.get(foo)`
 * @param {Identifier} node
 */
function get_value(node) {
	return call('$.get', node);
}

/**
 *
 * @param {Context | ComponentContext} context
 */
function add_state_transformers(context) {
	for (const [name, binding] of context.state.scope.declarations) {
		if (
			is_state_source(binding, context.state.analysis) ||
			binding.kind === 'derived' ||
			binding.kind === 'legacy_reactive'
		) {
			context.state.transform[name] = {
				read: binding.declaration_kind === 'var' ? (node) => call('$.safe_get', node) : get_value,
				assign: (node, value, proxy = false) => {
					let call$1 = call('$.set', node, value, proxy && true_instance);

					if (context.state.scope.get(`$${node.name}`)?.kind === 'store_sub') {
						call$1 = call('$.store_unsub', call$1, literal(`$${node.name}`), id$2('$$stores'));
					}

					return call$1;
				},
				mutate: (node, mutation) => {
					if (context.state.analysis.runes) {
						return mutation;
					}

					return call('$.mutate', node, mutation);
				},
				update: (node) => {
					return call(
						node.prefix ? '$.update_pre' : '$.update',
						node.argument,
						node.operator === '--' && literal(-1)
					);
				}
			};
		}
	}
}

/** @import { AssignmentExpression, AssignmentOperator, Expression, Node, Pattern, Statement } from 'estree' */
/** @import { Context as ClientContext } from '../client/types.js' */
/** @import { Context as ServerContext } from '../server/types.js' */

/**
 * @template {ClientContext | ServerContext} Context
 * @param {AssignmentExpression} node
 * @param {Context} context
 * @param {(operator: AssignmentOperator, left: Pattern, right: Expression, context: Context) => Expression | null} build_assignment
 * @returns
 */
function visit_assignment_expression(node, context, build_assignment) {
	if (
		node.left.type === 'ArrayPattern' ||
		node.left.type === 'ObjectPattern' ||
		node.left.type === 'RestElement'
	) {
		const value = /** @type {Expression} */ (context.visit(node.right));
		const should_cache = value.type !== 'Identifier';
		const rhs = should_cache ? id$2('$$value') : value;

		let changed = false;

		const { inserts, paths } = extract_paths(node.left, rhs);

		for (const { id } of inserts) {
			id.name = context.state.scope.generate('$$array');
		}

		const assignments = paths.map((path) => {
			const value = path.expression;

			let assignment$1 = build_assignment('=', path.node, value, context);
			if (assignment$1 !== null) changed = true;

			return (
				assignment$1 ??
				assignment(
					'=',
					/** @type {Pattern} */ (context.visit(path.node)),
					/** @type {Expression} */ (context.visit(value))
				)
			);
		});

		if (!changed) {
			// No change to output -> nothing to transform -> we can keep the original assignment
			return null;
		}

		const is_standalone = /** @type {Node} */ (context.path.at(-1)).type.endsWith('Statement');

		if (inserts.length > 0 || should_cache) {
			/** @type {Statement[]} */
			const statements = [
				...inserts.map(({ id, value }) => var_builder(id, value)),
				...assignments.map(stmt)
			];

			if (!is_standalone) {
				// this is part of an expression, we need the sequence to end with the value
				statements.push(return_builder(rhs));
			}

			const async =
				is_expression_async(value) ||
				assignments.some((assignment) => is_expression_async(assignment));

			const iife = arrow([rhs], block(statements), async);
			const call$1 = call(iife, value);

			return async ? await_builder(call$1) : call$1;
		}

		const sequence$1 = sequence(assignments);

		if (!is_standalone) {
			// this is part of an expression, we need the sequence to end with the value
			sequence$1.expressions.push(rhs);
		}

		return sequence$1;
	}

	if (node.left.type !== 'Identifier' && node.left.type !== 'MemberExpression') {
		throw new Error(`Unexpected assignment type ${node.left.type}`);
	}

	return build_assignment(node.operator, node.left, node.right, context);
}

/** @import { AssignmentExpression, AssignmentOperator, Expression, Pattern } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { Context, ServerTransformState } from '../types.js' */

/**
 * @param {AssignmentExpression} node
 * @param {Context} context
 */
function AssignmentExpression$1(node, context) {
	return visit_assignment_expression(node, context, build_assignment$1) ?? context.next();
}

/**
 * Only returns an expression if this is not a `$store` assignment, as others can be kept as-is
 * @param {AssignmentOperator} operator
 * @param {Pattern} left
 * @param {Expression} right
 * @param {import('zimmerframe').Context<AST.SvelteNode, ServerTransformState>} context
 * @returns {Expression | null}
 */
function build_assignment$1(operator, left, right, context) {
	if (
		context.state.analysis.runes &&
		left.type === 'MemberExpression' &&
		left.object.type === 'ThisExpression' &&
		!left.computed
	) {
		const name = get_name(left.property);
		const field = name && context.state.state_fields.get(name);

		// special case — state declaration in class constructor
		if (field && field.node.type === 'AssignmentExpression' && left === field.node.left) {
			const rune = get_rune(right, context.state.scope);

			if (rune) {
				const key =
					left.property.type === 'PrivateIdentifier' || rune === '$state' || rune === '$state.raw'
						? left.property
						: field.key;

				return assignment(
					operator,
					member(this_instance, key, key.type === 'Literal'),
					/** @type {Expression} */ (context.visit(right))
				);
			}
		} else if (
			field &&
			(field.type === '$derived' || field.type === '$derived.by') &&
			left.property.type === 'PrivateIdentifier'
		) {
			let value = /** @type {Expression} */ (
				context.visit(build_assignment_value(operator, left, right))
			);
			return call(member(this_instance, name), value);
		}
	}

	let object = left;

	while (object.type === 'MemberExpression') {
		// @ts-expect-error
		object = object.object;
	}

	if (object.type !== 'Identifier' || !is_store_name(object.name)) {
		return null;
	}

	const name = object.name.slice(1);

	if (!context.state.scope.get(name)) {
		return null;
	}

	if (object === left) {
		let value = /** @type {Expression} */ (
			context.visit(build_assignment_value(operator, left, right))
		);

		return call('$.store_set', id$2(name), value);
	}

	return call(
		'$.store_mutate',
		assignment('??=', id$2('$$store_subs'), object$2([])),
		literal(object.name),
		id$2(name),
		assignment(
			operator,
			/** @type {Pattern} */ (context.visit(left)),
			/** @type {Expression} */ (context.visit(right))
		)
	);
}

/**
 * @param {string} name
 */
function is_store_name(name) {
	return name[0] === '$' && /[A-Za-z_]/.test(name[1]);
}

/** @import { Expression, Identifier, Node, Statement, BlockStatement, ArrayExpression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext, ServerTransformState } from '../../types.js' */


/** Opens an if/each block, so that we can remove nodes in the case of a mismatch */
const block_open = literal(BLOCK_OPEN);

/** Opens an if/each block, so that we can remove nodes in the case of a mismatch */
const block_open_else = literal(BLOCK_OPEN_ELSE);

/** Closes an if/each block, so that we can remove nodes in the case of a mismatch. Also serves as an anchor for these blocks */
const block_close = literal(BLOCK_CLOSE);

/** Empty comment to keep text nodes separate, or provide an anchor node for blocks */
const empty_comment = literal(EMPTY_COMMENT);

/**
 * Processes an array of template nodes, joining sibling text/expression nodes and
 * recursing into child nodes.
 * @param {Array<AST.SvelteNode>} nodes
 * @param {ComponentContext} context
 */
function process_children$1(nodes, { visit, state }) {
	/** @type {Array<AST.Text | AST.Comment | AST.ExpressionTag>} */
	let sequence = [];

	function flush() {
		if (sequence.length === 0) {
			return;
		}

		let quasi$1 = quasi('', false);
		const quasis = [quasi$1];

		/** @type {Expression[]} */
		const expressions = [];

		for (let i = 0; i < sequence.length; i++) {
			const node = sequence[i];

			if (node.type === 'Text' || node.type === 'Comment') {
				quasi$1.value.cooked +=
					node.type === 'Comment' ? `<!--${node.data}-->` : escape_html(node.data);
			} else {
				const evaluated = state.scope.evaluate(node.expression);

				if (evaluated.is_known) {
					quasi$1.value.cooked += escape_html((evaluated.value ?? '') + '');
				} else {
					expressions.push(call('$.escape', /** @type {Expression} */ (visit(node.expression))));

					quasi$1 = quasi('', i + 1 === sequence.length);
					quasis.push(quasi$1);
				}
			}
		}

		for (const quasi of quasis) {
			quasi.value.raw = sanitize_template_string(/** @type {string} */ (quasi.value.cooked));
		}

		state.template.push(template(quasis, expressions));
		sequence = [];
	}

	for (const node of nodes) {
		if (node.type === 'ExpressionTag' && node.metadata.expression.is_async()) {
			flush();

			const expression = /** @type {Expression} */ (visit(node.expression));
			state.template.push(create_push(call('$.escape', expression), node.metadata.expression));
		} else if (node.type === 'Text' || node.type === 'Comment' || node.type === 'ExpressionTag') {
			sequence.push(node);
		} else {
			flush();
			visit(node, { ...state });
		}
	}

	flush();
}

/**
 * @param {Node} node
 * @returns {node is Statement}
 */
function is_statement(node) {
	return node.type.endsWith('Statement') || node.type.endsWith('Declaration');
}

/**
 * @param {Array<Statement | Expression>} template
 * @returns {Statement[]}
 */
function build_template(template$1) {
	/** @type {string[]} */
	let strings = [];

	/** @type {Expression[]} */
	let expressions = [];

	/** @type {Statement[]} */
	const statements = [];

	const flush = () => {
		statements.push(
			stmt(
				call(
					id$2('$$renderer.push'),
					template(
						strings.map((cooked, i) => quasi(cooked, i === strings.length - 1)),
						expressions
					)
				)
			)
		);

		strings = [];
		expressions = [];
	};

	for (let i = 0; i < template$1.length; i++) {
		const node = template$1[i];

		if (is_statement(node)) {
			if (strings.length !== 0) {
				flush();
			}

			statements.push(node);
		} else {
			if (strings.length === 0) {
				strings.push('');
			}

			if (node.type === 'Literal') {
				strings[strings.length - 1] += node.value;
			} else if (node.type === 'TemplateLiteral') {
				strings[strings.length - 1] += node.quasis[0].value.cooked;
				strings.push(...node.quasis.slice(1).map((q) => /** @type {string} */ (q.value.cooked)));
				expressions.push(...node.expressions);
			} else {
				expressions.push(node);
				strings.push('');
			}
		}
	}

	if (strings.length !== 0) {
		flush();
	}

	return statements;
}

/**
 *
 * @param {AST.Attribute['value']} value
 * @param {ComponentContext} context
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 * @param {boolean} trim_whitespace
 * @param {boolean} is_component
 * @returns {Expression}
 */
function build_attribute_value$1(
	value,
	context,
	transform,
	trim_whitespace = false,
	is_component = false
) {
	if (value === true) {
		return true_instance;
	}

	if (!Array.isArray(value) || value.length === 1) {
		const chunk = Array.isArray(value) ? value[0] : value;

		if (chunk.type === 'Text') {
			const data = trim_whitespace
				? chunk.data.replace(regex_whitespaces_strict, ' ').trim()
				: chunk.data;

			return literal(is_component ? data : escape_html(data, true));
		}

		return transform(
			/** @type {Expression} */ (context.visit(chunk.expression)),
			chunk.metadata.expression
		);
	}

	let quasi$1 = quasi('', false);
	const quasis = [quasi$1];

	/** @type {Expression[]} */
	const expressions = [];

	for (let i = 0; i < value.length; i++) {
		const node = value[i];

		if (node.type === 'Text') {
			quasi$1.value.raw += trim_whitespace
				? node.data.replace(regex_whitespaces_strict, ' ')
				: node.data;
		} else {
			expressions.push(
				call(
					'$.stringify',
					transform(
						/** @type {Expression} */ (context.visit(node.expression)),
						node.metadata.expression
					)
				)
			);

			quasi$1 = quasi('', i + 1 === value.length);
			quasis.push(quasi$1);
		}
	}

	return template(quasis, expressions);
}

/**
 * @param {Identifier} node
 * @param {ServerTransformState} state
 * @returns {Expression}
 */
function build_getter(node, state) {
	const binding = state.scope.get(node.name);

	if (binding === null || node === binding.node) {
		// No associated binding or the declaration itself which shouldn't be transformed
		return node;
	}

	if (binding.kind === 'store_sub') {
		const store_id = id$2(node.name.slice(1));
		return call(
			'$.store_get',
			assignment('??=', id$2('$$store_subs'), object$2([])),
			literal(node.name),
			build_getter(store_id, state)
		);
	}

	return node;
}

/**
 * Creates a `$$renderer.child(...)` expression statement
 * @param {BlockStatement | Expression} body
 * @param {boolean} async
 * @returns {Statement}
 */
function create_child_block(body, async) {
	return stmt(call('$$renderer.child', arrow([id$2('$$renderer')], body, async)));
}

/**
 * Creates a `$$renderer.async(...)` expression statement
 * @param {BlockStatement | Expression} body
 * @param {ArrayExpression} blockers
 * @param {boolean} has_await
 * @param {boolean} needs_hydration_markers
 */
function create_async_block(
	body,
	blockers = array([]),
	has_await = true,
	needs_hydration_markers = true
) {
	return stmt(
		call(
			needs_hydration_markers ? '$$renderer.async_block' : '$$renderer.async',
			blockers,
			arrow([id$2('$$renderer')], body, has_await)
		)
	);
}

/**
 * @param {Expression} expression
 * @param {ExpressionMetadata} metadata
 * @param {boolean} needs_hydration_markers
 * @returns {Expression | Statement}
 */
function create_push(expression, metadata, needs_hydration_markers = false) {
	if (metadata.is_async()) {
		let statement = stmt(call('$$renderer.push', thunk(expression, metadata.has_await)));

		const blockers = metadata.blockers();

		if (blockers.elements.length > 0) {
			statement = create_async_block(
				block([statement]),
				blockers,
				false,
				needs_hydration_markers
			);
		}

		return statement;
	}

	return expression;
}

/**
 * @param {BlockStatement | Expression} body
 * @param {Identifier | false} component_fn_id
 * @returns {Statement}
 */
function call_component_renderer(body, component_fn_id) {
	return stmt(
		call('$$renderer.component', arrow([id$2('$$renderer')], body, false), component_fn_id)
	);
}

/**
 * A utility for optimising promises in templates. Without it code like
 * `<Component foo={await fetch()} bar={await other()} />` would be transformed
 * into two blocking promises, with it it's using `Promise.all` to await them.
 * It also keeps track of blocking promises, i.e. those that need to be resolved before continuing.
 */
class PromiseOptimiser {
	/** @type {Expression[]} */
	expressions = [];

	has_await = false;

	/** @type {Set<Expression>} */
	#blockers = new Set();

	/**
	 * @param {Expression} expression
	 * @param {ExpressionMetadata} metadata
	 */
	transform = (expression, metadata) => {
		this.check_blockers(metadata);

		if (metadata.has_await) {
			this.has_await = true;

			const length = this.expressions.push(expression);
			return id$2(`$$${length - 1}`);
		}

		return expression;
	};

	/**
	 * @param {ExpressionMetadata} metadata
	 */
	check_blockers(metadata) {
		for (const binding of metadata.dependencies) {
			if (binding.blocker) {
				this.#blockers.add(binding.blocker);
			}
		}
	}

	apply() {
		if (this.expressions.length === 0) {
			return empty;
		}

		if (this.expressions.length === 1) {
			return const_builder('$$0', this.expressions[0]);
		}

		const promises = array(
			this.expressions.map((expression) => {
				return expression.type === 'AwaitExpression' && !has_await_expression(expression.argument)
					? expression.argument
					: call(thunk(expression, true));
			})
		);

		return const_builder(
			array_pattern(this.expressions.map((_, i) => id$2(`$$${i}`))),
			await_builder(call('Promise.all', promises))
		);
	}

	blockers() {
		return array([...this.#blockers]);
	}

	is_async() {
		return this.expressions.length > 0 || this.#blockers.size > 0;
	}
}

/** @import { BlockStatement, Expression, Pattern, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.AwaitBlock} node
 * @param {ComponentContext} context
 */
function AwaitBlock$1(node, context) {
	/** @type {Statement} */
	let statement = stmt(
		call(
			'$.await',
			id$2('$$renderer'),
			/** @type {Expression} */ (context.visit(node.expression)),
			thunk(
				node.pending ? /** @type {BlockStatement} */ (context.visit(node.pending)) : block([])
			),
			arrow(
				node.value ? [/** @type {Pattern} */ (context.visit(node.value))] : [],
				node.then ? /** @type {BlockStatement} */ (context.visit(node.then)) : block([])
			)
		)
	);

	if (node.metadata.expression.is_async()) {
		statement = create_async_block(
			block([statement]),
			node.metadata.expression.blockers(),
			node.metadata.expression.has_await
		);
	}

	context.state.template.push(statement, block_close);
}

/** @import { AwaitExpression, Expression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {AwaitExpression} node
 * @param {Context} context
 */
function AwaitExpression$1(node, context) {
	const argument = /** @type {Expression} */ (context.visit(node.argument));

	if (context.state.analysis.pickled_awaits.has(node)) {
		return save(argument);
	}

	// we also need to restore context after block expressions
	let i = context.path.length;
	while (i--) {
		const parent = context.path[i];

		if (
			parent.type === 'ArrowFunctionExpression' ||
			parent.type === 'FunctionExpression' ||
			parent.type === 'FunctionDeclaration'
		) {
			break;
		}

		// @ts-ignore
		if (parent.metadata) {
			if (parent.type !== 'ExpressionTag' && parent.type !== 'Fragment') {
				return save(argument);
			}

			break;
		}
	}

	return argument === node.argument ? node : { ...node, argument };
}

/** @import { TransformState } from './types.js' */
/** @import { AST, Binding, Namespace, ValidatedCompileOptions } from '#compiler' */
/** @import { Node, Expression, CallExpression, MemberExpression } from 'estree' */

/**
 * Match Svelte 4 behaviour by sorting ConstTag nodes in topological order
 * @param {AST.SvelteNode[]} nodes
 * @param {TransformState} state
 */
function sort_const_tags(nodes, state) {
	/**
	 * @typedef {{
	 *   node: AST.ConstTag;
	 *   deps: Set<Binding>;
	 * }} Tag
	 */

	const other = [];

	/** @type {Map<Binding, Tag>} */
	const tags = new Map();

	for (const node of nodes) {
		if (node.type === 'ConstTag') {
			const declaration = node.declaration.declarations[0];

			const bindings = extract_identifiers(declaration.id).map((id) => {
				return /** @type {Binding} */ (state.scope.get(id.name));
			});

			/** @type {Set<Binding>} */
			const deps = new Set();

			walk$1(declaration.init, state, {
				// @ts-expect-error don't know, don't care
				_: set_scope,
				Identifier(node, context) {
					const parent = /** @type {Expression} */ (context.path.at(-1));

					if (is_reference(node, parent)) {
						const binding = context.state.scope.get(node.name);
						if (binding) deps.add(binding);
					}
				}
			});

			for (const binding of bindings) {
				tags.set(binding, { node, deps });
			}
		} else {
			other.push(node);
		}
	}

	if (tags.size === 0) {
		return nodes;
	}

	/** @type {Array<[Binding, Binding]>} */
	const edges = [];

	for (const [id, tag] of tags) {
		for (const dep of tag.deps) {
			if (tags.has(dep)) {
				edges.push([id, dep]);
			}
		}
	}

	const cycle = check_graph_for_cycles(edges);
	if (cycle?.length) {
		const tag = /** @type {Tag} */ (tags.get(cycle[0]));
		const_tag_cycle(tag.node, cycle.map((binding) => binding.node.name).join(' → '));
	}

	/** @type {AST.ConstTag[]} */
	const sorted = [];

	/** @param {Tag} tag */
	function add(tag) {
		if (sorted.includes(tag.node)) {
			return;
		}

		for (const dep of tag.deps) {
			const dep_tag = tags.get(dep);
			if (dep_tag) add(dep_tag);
		}

		sorted.push(tag.node);
	}

	for (const tag of tags.values()) {
		add(tag);
	}

	return [...sorted, ...other];
}

/**
 * Extract nodes that are hoisted and trim whitespace according to the following rules:
 * - trim leading and trailing whitespace, regardless of surroundings
 * - keep leading / trailing whitespace of inbetween text nodes,
 *   unless it's whitespace-only, in which case collapse to a single whitespace for all cases
 *   except when it's children of certain elements where we know ignore whitespace (like td/option/head),
 *   in which case we remove it entirely
 * @param {AST.SvelteNode} parent
 * @param {AST.SvelteNode[]} nodes
 * @param {AST.SvelteNode[]} path
 * @param {Namespace} namespace
 * @param {TransformState & { options: ValidatedCompileOptions }} state
 * @param {boolean} preserve_whitespace
 * @param {boolean} preserve_comments
 */
function clean_nodes(
	parent,
	nodes,
	path,
	namespace = 'html',
	state,
	// TODO give these defaults (state.options.preserveWhitespace and state.options.preserveComments).
	// first, we need to make `Component(Client|Server)TransformState` inherit from a new `ComponentTransformState`
	// rather than from `ClientTransformState` and `ServerTransformState`
	preserve_whitespace,
	preserve_comments
) {
	if (!state.analysis.runes) {
		nodes = sort_const_tags(nodes, state);
	}

	/** @type {AST.SvelteNode[]} */
	const hoisted = [];

	/** @type {AST.SvelteNode[]} */
	const regular = [];

	for (const node of nodes) {
		if (node.type === 'Comment' && !preserve_comments) {
			continue;
		}

		if (
			node.type === 'ConstTag' ||
			node.type === 'DebugTag' ||
			node.type === 'SvelteBody' ||
			node.type === 'SvelteWindow' ||
			node.type === 'SvelteDocument' ||
			node.type === 'SvelteHead' ||
			node.type === 'TitleElement' ||
			node.type === 'SnippetBlock'
		) {
			// TODO others?
			hoisted.push(node);
		} else {
			regular.push(node);
		}
	}

	let trimmed = regular;

	if (!preserve_whitespace) {
		trimmed = [];

		let first, last;

		while (
			(first = regular[0]) &&
			first.type === 'Text' &&
			!regex_not_whitespace.test(first.data)
		) {
			regular.shift();
		}

		if (first?.type === 'Text') {
			first.raw = first.raw.replace(regex_starts_with_whitespaces, '');
			first.data = first.data.replace(regex_starts_with_whitespaces, '');
		}

		while (
			(last = regular.at(-1)) &&
			last.type === 'Text' &&
			!regex_not_whitespace.test(last.data)
		) {
			regular.pop();
		}

		if (last?.type === 'Text') {
			last.raw = last.raw.replace(regex_ends_with_whitespaces, '');
			last.data = last.data.replace(regex_ends_with_whitespaces, '');
		}

		const can_remove_entirely =
			(namespace === 'svg' &&
				(parent.type !== 'RegularElement' || parent.name !== 'text') &&
				!path.some((n) => n.type === 'RegularElement' && n.name === 'text')) ||
			(parent.type === 'RegularElement' &&
				// TODO others?
				(parent.name === 'select' ||
					parent.name === 'tr' ||
					parent.name === 'table' ||
					parent.name === 'tbody' ||
					parent.name === 'thead' ||
					parent.name === 'tfoot' ||
					parent.name === 'colgroup' ||
					parent.name === 'datalist'));

		// Replace any whitespace between a text and non-text node with a single spaceand keep whitespace
		// as-is within text nodes, or between text nodes and expression tags (because in the end they count
		// as one text). This way whitespace is mostly preserved when using CSS with `white-space: pre-line`
		// and default slot content going into a pre tag (which we can't see).
		for (let i = 0; i < regular.length; i++) {
			const prev = regular[i - 1];
			const node = regular[i];
			const next = regular[i + 1];

			if (node.type === 'Text') {
				if (prev?.type !== 'ExpressionTag') {
					const prev_is_text_ending_with_whitespace =
						prev?.type === 'Text' && regex_ends_with_whitespaces.test(prev.data);
					node.data = node.data.replace(
						regex_starts_with_whitespaces,
						prev_is_text_ending_with_whitespace ? '' : ' '
					);
					node.raw = node.raw.replace(
						regex_starts_with_whitespaces,
						prev_is_text_ending_with_whitespace ? '' : ' '
					);
				}
				if (next?.type !== 'ExpressionTag') {
					node.data = node.data.replace(regex_ends_with_whitespaces, ' ');
					node.raw = node.raw.replace(regex_ends_with_whitespaces, ' ');
				}
				if (node.data && (node.data !== ' ' || !can_remove_entirely)) {
					trimmed.push(node);
				}
			} else {
				trimmed.push(node);
			}
		}
	}

	var first = trimmed[0];

	// if first text node inside a <pre> is a single newline, discard it, because otherwise
	// the browser will do it for us which could break hydration
	if (parent.type === 'RegularElement' && parent.name === 'pre' && first?.type === 'Text') {
		if (first.data === '\n' || first.data === '\r\n') {
			trimmed.shift();
			first = trimmed[0];
		}
	}

	// Special case: Add a comment if this is a lone script tag. This ensures that our run_scripts logic in template.js
	// will always be able to call node.replaceWith() on the script tag in order to make it run. If we don't add this
	// and would still call node.replaceWith() on the script tag, it would be a no-op because the script tag has no parent.
	if (trimmed.length === 1 && first.type === 'RegularElement' && first.name === 'script') {
		trimmed.push({
			type: 'Comment',
			data: '',
			start: -1,
			end: -1
		});
	}

	return {
		hoisted,
		trimmed,
		/**
		 * In a case like `{#if x}<Foo />{/if}`, we don't need to wrap the child in
		 * comments — we can just use the parent block's anchor for the component.
		 * TODO extend this optimisation to other cases
		 */
		is_standalone:
			trimmed.length === 1 &&
			((first.type === 'RenderTag' && !first.metadata.dynamic) ||
				(first.type === 'Component' &&
					!state.options.hmr &&
					!first.metadata.dynamic &&
					!first.attributes.some(
						(attribute) => attribute.type === 'Attribute' && attribute.name.startsWith('--')
					))),
		/** if a component/snippet/each block starts with text, we need to add an anchor comment so that its text node doesn't get fused with its surroundings */
		is_text_first:
			(parent.type === 'Fragment' ||
				parent.type === 'SnippetBlock' ||
				parent.type === 'EachBlock' ||
				parent.type === 'SvelteComponent' ||
				parent.type === 'SvelteBoundary' ||
				parent.type === 'Component' ||
				parent.type === 'SvelteSelf') &&
			first &&
			(first?.type === 'Text' || first?.type === 'ExpressionTag')
	};
}

/**
 * Infers the namespace for the children of a node that should be used when creating the fragment
 * @param {Namespace} namespace
 * @param {AST.SvelteNode} parent
 * @param {AST.SvelteNode[]} nodes
 */
function infer_namespace(namespace, parent, nodes) {
	if (parent.type === 'RegularElement' && parent.name === 'foreignObject') {
		return 'html';
	}

	if (parent.type === 'RegularElement' || parent.type === 'SvelteElement') {
		if (parent.metadata.svg) {
			return 'svg';
		}
		return parent.metadata.mathml ? 'mathml' : 'html';
	}

	// Re-evaluate the namespace inside slot nodes that reset the namespace
	if (
		parent.type === 'Fragment' ||
		parent.type === 'Root' ||
		parent.type === 'Component' ||
		parent.type === 'SvelteComponent' ||
		parent.type === 'SvelteFragment' ||
		parent.type === 'SnippetBlock' ||
		parent.type === 'SlotElement'
	) {
		const new_namespace = check_nodes_for_namespace(nodes, 'keep');
		if (new_namespace !== 'keep' && new_namespace !== 'maybe_html') {
			return new_namespace;
		}
	}

	/** @type {Namespace | null} */
	let new_namespace = null;

	// Check the elements within the fragment and look for consistent namespaces.
	// If we have no namespaces or they are mixed, then fallback to existing namespace
	for (const node of nodes) {
		if (node.type !== 'RegularElement') continue;

		if (node.metadata.mathml) {
			new_namespace = new_namespace === null || new_namespace === 'mathml' ? 'mathml' : 'html';
		} else if (node.metadata.svg) {
			new_namespace = new_namespace === null || new_namespace === 'svg' ? 'svg' : 'html';
		} else {
			return 'html';
		}
	}

	return new_namespace ?? namespace;
}

/**
 * Heuristic: Keep current namespace, unless we find a regular element,
 * in which case we always want html, or we only find svg nodes,
 * in which case we assume svg.
 * @param {AST.SvelteNode[]} nodes
 * @param {Namespace | 'keep' | 'maybe_html'} namespace
 */
function check_nodes_for_namespace(nodes, namespace) {
	/**
	 * @param {AST.SvelteElement | AST.RegularElement} node}
	 * @param {{stop: () => void}} context
	 */
	const RegularElement = (node, { stop }) => {
		if (!node.metadata.svg && !node.metadata.mathml) {
			namespace = 'html';
			stop();
		} else if (namespace === 'keep') {
			namespace = node.metadata.svg ? 'svg' : 'mathml';
		}
	};

	for (const node of nodes) {
		walk$1(
			node,
			{},
			{
				_(node, { next }) {
					if (
						node.type === 'EachBlock' ||
						node.type === 'IfBlock' ||
						node.type === 'AwaitBlock' ||
						node.type === 'Fragment' ||
						node.type === 'KeyBlock' ||
						node.type === 'RegularElement' ||
						node.type === 'SvelteElement' ||
						node.type === 'Text'
					) {
						next();
					}
				},
				SvelteElement: RegularElement,
				RegularElement,
				Text(node) {
					if (node.data.trim() !== '') {
						namespace = 'maybe_html';
					}
				}
			}
		);

		if (namespace === 'html') return namespace;
	}

	return namespace;
}

/**
 * Determines the namespace the children of this node are in.
 * @param {AST.RegularElement | AST.SvelteElement} node
 * @param {Namespace} namespace
 * @returns {Namespace}
 */
function determine_namespace_for_children(node, namespace) {
	if (node.name === 'foreignObject') {
		return 'html';
	}

	if (node.metadata.svg) {
		return 'svg';
	}

	return node.metadata.mathml ? 'mathml' : 'html';
}

/**
 * @param {'$inspect' | '$inspect().with'} rune
 * @param {CallExpression} node
 * @param {(node: AST.SvelteNode) => AST.SvelteNode} visit
 */
function get_inspect_args(rune, node, visit) {
	const call =
		rune === '$inspect'
			? node
			: /** @type {CallExpression} */ (/** @type {MemberExpression} */ (node.callee).object);

	return {
		args: call.arguments.map((arg) => /** @type {Expression} */ (visit(arg))),
		inspector:
			rune === '$inspect' ? 'console.log' : /** @type {Expression} */ (visit(node.arguments[0]))
	};
}

/** @import { CallExpression, Expression, MemberExpression } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {CallExpression} node
 * @param {Context} context
 */
function CallExpression$1(node, context) {
	const rune = get_rune(node, context.state.scope);

	if (
		rune === '$host' ||
		rune === '$effect' ||
		rune === '$effect.pre' ||
		rune === '$inspect.trace'
	) {
		// we will only encounter `$effect` etc if they are top-level statements in the <script>
		// following an `await`, otherwise they are removed by the ExpressionStatement visitor
		return void0;
	}

	if (rune === '$effect.tracking') {
		return false_instance;
	}

	if (rune === '$effect.root') {
		// ignore $effect.root() calls, just return a noop which mimics the cleanup function
		return arrow([], block([]));
	}

	if (rune === '$effect.pending') {
		return literal(0);
	}

	if (rune === '$state' || rune === '$state.raw') {
		return node.arguments[0] ? context.visit(node.arguments[0]) : void0;
	}

	if (rune === '$derived' || rune === '$derived.by') {
		const fn = /** @type {Expression} */ (context.visit(node.arguments[0]));
		return call('$.derived', rune === '$derived' ? thunk(fn) : fn);
	}

	if (rune === '$state.eager') {
		return node.arguments[0];
	}

	if (rune === '$state.snapshot') {
		return call(
			'$.snapshot',
			/** @type {Expression} */ (context.visit(node.arguments[0])),
			is_ignored(node, 'state_snapshot_uncloneable') && true_instance
		);
	}

	if (rune === '$inspect' || rune === '$inspect().with') {
		if (!dev) return empty;

		const { args, inspector } = get_inspect_args(rune, node, context.visit);

		return rune === '$inspect'
			? call(inspector, literal('$inspect('), ...args, literal(')'))
			: call(inspector, literal('init'), ...args);
	}

	context.next();
}

/** @import { CallExpression, ClassBody, MethodDefinition, PropertyDefinition, StaticBlock } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {ClassBody} node
 * @param {Context} context
 */
function ClassBody$1(node, context) {
	const state_fields = context.state.analysis.classes.get(node);

	if (!state_fields) {
		// in legacy mode, do nothing
		context.next();
		return;
	}

	/** @type {Array<MethodDefinition | PropertyDefinition | StaticBlock>} */
	const body = [];

	const child_state = { ...context.state, state_fields };

	for (const [name, field] of state_fields) {
		if (name[0] === '#') {
			continue;
		}

		// insert backing fields for stuff declared in the constructor
		if (
			field &&
			field.node.type === 'AssignmentExpression' &&
			(field.type === '$derived' || field.type === '$derived.by')
		) {
			const member$1 = member(this_instance, field.key);

			body.push(
				prop_def(field.key, null),
				method('get', key(name), [], [return_builder(call(member$1))]),
				method('set', key(name), [id$2('$$value')], [return_builder(call(member$1, id$2('$$value')))])
			);
		}
	}

	// Replace parts of the class body
	for (const definition of node.body) {
		if (definition.type !== 'PropertyDefinition') {
			body.push(
				/** @type {MethodDefinition | StaticBlock} */ (context.visit(definition, child_state))
			);
			continue;
		}

		const name = get_name(definition.key);
		const field = name && state_fields.get(name);

		if (!field) {
			body.push(/** @type {PropertyDefinition} */ (context.visit(definition, child_state)));
			continue;
		}

		if (name[0] === '#' || field.type === '$state' || field.type === '$state.raw') {
			body.push(/** @type {PropertyDefinition} */ (context.visit(definition, child_state)));
		} else if (field.node === definition) {
			// $derived / $derived.by
			const member$1 = member(this_instance, field.key);

			body.push(
				prop_def(
					field.key,
					/** @type {CallExpression} */ (context.visit(field.value, child_state))
				),

				method('get', definition.key, [], [return_builder(call(member$1))]),
				method('set', key(name), [id$2('$$value')], [return_builder(call(member$1, id$2('$$value')))])
			);
		}
	}

	return { ...node, body };
}

/** @import { BlockStatement, Expression, Pattern, Property, SequenceExpression, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../../types.js' */

/**
 * @param {AST.Component | AST.SvelteComponent | AST.SvelteSelf} node
 * @param {Expression} expression
 * @param {ComponentContext} context
 */
function build_inline_component(node, expression, context) {
	/** @type {Array<Property[] | Expression>} */
	const props_and_spreads = [];
	/** @type {Array<() => void>} */
	const delayed_props = [];

	/** @type {Property[]} */
	const custom_css_props = [];

	/** @type {Record<string, AST.LetDirective[]>} */
	const lets = { default: [] };

	/**
	 * Children in the default slot are evaluated in the component scope,
	 * children in named slots are evaluated in the parent scope
	 */
	const child_state = {
		...context.state,
		scope: node.metadata.scopes.default
	};

	/** @type {Record<string, AST.TemplateNode[]>} */
	const children = {};

	/**
	 * If this component has a slot property, it is a named slot within another component. In this case
	 * the slot scope applies to the component itself, too, and not just its children.
	 */
	const slot_scope_applies_to_itself = node.attributes.some(
		(node) => node.type === 'Attribute' && node.name === 'slot'
	);

	/**
	 * Components may have a children prop and also have child nodes. In this case, we assume
	 * that the child component isn't using render tags yet and pass the slot as $$slots.default.
	 * We're not doing it for spread attributes, as this would result in too many false positives.
	 */
	let has_children_prop = false;

	/**
	 * @param {Property} prop
	 * @param {boolean} [delay]
	 */
	function push_prop(prop, delay = false) {
		const do_push = () => {
			const current = props_and_spreads.at(-1);
			const current_is_props = Array.isArray(current);
			const props = current_is_props ? current : [];
			props.push(prop);
			if (!current_is_props) {
				props_and_spreads.push(props);
			}
		};

		if (delay) {
			delayed_props.push(do_push);
		} else {
			do_push();
		}
	}

	const optimiser = new PromiseOptimiser();

	for (const attribute of node.attributes) {
		if (attribute.type === 'LetDirective') {
			if (!slot_scope_applies_to_itself) {
				lets.default.push(attribute);
			}
		} else if (attribute.type === 'SpreadAttribute') {
			let expression = /** @type {Expression} */ (context.visit(attribute));
			props_and_spreads.push(optimiser.transform(expression, attribute.metadata.expression));
		} else if (attribute.type === 'Attribute') {
			const value = build_attribute_value$1(
				attribute.value,
				context,
				optimiser.transform,
				false,
				true
			);

			if (attribute.name.startsWith('--')) {
				custom_css_props.push(init(attribute.name, value));
				continue;
			}

			if (attribute.name === 'children') {
				has_children_prop = true;
			}

			push_prop(prop('init', key(attribute.name), value));
		} else if (attribute.type === 'BindDirective' && attribute.name !== 'this') {
			// Bindings are a bit special: we don't want to add them to (async) deriveds but we need to check if they have blockers
			optimiser.check_blockers(attribute.metadata.expression);

			if (attribute.expression.type === 'SequenceExpression') {
				const [get, set$1] = /** @type {SequenceExpression} */ (context.visit(attribute.expression))
					.expressions;
				const get_id = id$2(context.state.scope.generate('bind_get'));
				const set_id = id$2(context.state.scope.generate('bind_set'));

				context.state.init.push(var_builder(get_id, get));
				context.state.init.push(var_builder(set_id, set$1));

				push_prop(get$1(attribute.name, [return_builder(call(get_id))]));
				push_prop(set(attribute.name, [stmt(call(set_id, id$2('$$value')))]));
			} else {
				// Delay prop pushes so bindings come at the end, to avoid spreads overwriting them
				push_prop(
					get$1(attribute.name, [
						return_builder(/** @type {Expression} */ (context.visit(attribute.expression)))
					]),
					true
				);

				push_prop(
					set(attribute.name, [
						stmt(
							/** @type {Expression} */ (
								context.visit(assignment('=', attribute.expression, id$2('$$value')))
							)
						),
						stmt(assignment('=', id$2('$$settled'), false_instance))
					]),
					true
				);
			}
		} else if (attribute.type === 'AttachTag') {
			// While we don't run attachments on the server, on the client they might generate a surrounding blocker function which generates
			// extra comments, and to prevent hydration mismatches we therefore have to account for them here to generate similar comments on the server.
			optimiser.check_blockers(attribute.metadata.expression);
		}
	}

	delayed_props.forEach((fn) => fn());

	/** @type {Statement[]} */
	const snippet_declarations = [];

	/** @type {Property[]} */
	const serialized_slots = [];

	// Group children by slot
	for (const child of node.fragment.nodes) {
		if (child.type === 'SnippetBlock') {
			// the SnippetBlock visitor adds a declaration to `init`, but if it's directly
			// inside a component then we want to hoist them into a block so that they
			// can be used as props without creating conflicts
			context.visit(child, {
				...context.state,
				init: snippet_declarations
			});

			push_prop(prop('init', child.expression, child.expression));

			// Interop: allows people to pass snippets when component still uses slots
			serialized_slots.push(
				init(child.expression.name === 'children' ? 'default' : child.expression.name, true_instance)
			);

			continue;
		}

		let slot_name = 'default';
		if (is_element_node(child)) {
			const slot = /** @type {AST.Attribute | undefined} */ (
				child.attributes.find(
					(attribute) => attribute.type === 'Attribute' && attribute.name === 'slot'
				)
			);

			if (slot !== undefined) {
				slot_name = /** @type {AST.Text[]} */ (slot.value)[0].data;

				lets[slot_name] = child.attributes.filter((attribute) => attribute.type === 'LetDirective');
			} else if (child.type === 'SvelteFragment') {
				lets.default.push(
					...child.attributes.filter((attribute) => attribute.type === 'LetDirective')
				);
			}
		}

		children[slot_name] = children[slot_name] || [];
		children[slot_name].push(child);
	}

	// Serialize each slot
	for (const slot_name of Object.keys(children)) {
		const block$1 = /** @type {BlockStatement} */ (
			context.visit(
				{
					...node.fragment,
					// @ts-expect-error
					nodes: children[slot_name]
				},
				slot_name === 'default'
					? child_state
					: {
							...context.state,
							scope: node.metadata.scopes[slot_name]
						}
			)
		);

		if (block$1.body.length === 0) continue;

		/** @type {Pattern[]} */
		const params = [id$2('$$renderer')];

		if (lets[slot_name].length > 0) {
			const pattern = object_pattern(
				lets[slot_name].map((node) => {
					if (node.expression === null) {
						return init(node.name, id$2(node.name));
					}

					if (node.expression.type === 'ObjectExpression') {
						// @ts-expect-error it gets parsed as an `ObjectExpression` but is really an `ObjectPattern`
						return init(node.name, object_pattern(node.expression.properties));
					}

					if (node.expression.type === 'ArrayExpression') {
						// @ts-expect-error it gets parsed as an `ArrayExpression` but is really an `ArrayPattern`
						return init(node.name, array_pattern(node.expression.elements));
					}

					return init(node.name, node.expression);
				})
			);

			params.push(pattern);
		}

		const slot_fn = arrow(params, block(block$1.body));

		if (slot_name === 'default' && !has_children_prop) {
			if (
				lets.default.length === 0 &&
				children.default.every(
					(node) =>
						node.type !== 'SvelteFragment' ||
						!node.attributes.some((attr) => attr.type === 'LetDirective')
				)
			) {
				// create `children` prop...
				push_prop(
					prop(
						'init',
						id$2('children'),
						dev ? call('$.prevent_snippet_stringification', slot_fn) : slot_fn
					)
				);

				// and `$$slots.default: true` so that `<slot>` on the child works
				serialized_slots.push(init(slot_name, true_instance));
			} else {
				// create `$$slots.default`...
				serialized_slots.push(init(slot_name, slot_fn));

				// and a `children` prop that errors
				push_prop(init('children', id$2('$.invalid_default_snippet')));
			}
		} else {
			serialized_slots.push(init(slot_name, slot_fn));
		}
	}

	if (serialized_slots.length > 0) {
		push_prop(prop('init', id$2('$$slots'), object$2(serialized_slots)));
	}

	const props_expression =
		props_and_spreads.length === 0 ||
		(props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]))
			? object$2(/** @type {Property[]} */ (props_and_spreads[0] || []))
			: call(
					'$.spread_props',
					array(props_and_spreads.map((p) => (Array.isArray(p) ? object$2(p) : p)))
				);

	/** @type {Statement} */
	let statement = stmt(
		(node.type === 'SvelteComponent' ? maybe_call : call)(
			expression,
			id$2('$$renderer'),
			props_expression
		)
	);

	if (snippet_declarations.length > 0) {
		statement = block([...snippet_declarations, statement]);
	}

	const dynamic =
		node.type === 'SvelteComponent' || (node.type === 'Component' && node.metadata.dynamic);

	if (custom_css_props.length > 0) {
		statement = stmt(
			call(
				'$.css_props',
				id$2('$$renderer'),
				literal(context.state.namespace === 'svg' ? false : true),
				object$2(custom_css_props),
				thunk(block([statement])),
				dynamic && true_instance
			)
		);
	}

	if (node.type !== 'SvelteSelf') {
		// Component name itself could be blocked on async values
		optimiser.check_blockers(node.metadata.expression);
	}

	const is_async = optimiser.is_async();

	if (is_async) {
		statement = create_async_block(
			block([
				optimiser.apply(),
				dynamic && custom_css_props.length === 0
					? stmt(call('$$renderer.push', empty_comment))
					: empty,
				statement
			]),
			optimiser.blockers(),
			optimiser.has_await
		);
	} else if (dynamic && custom_css_props.length === 0) {
		context.state.template.push(empty_comment);
	}

	context.state.template.push(statement);

	if (
		!is_async &&
		!context.state.skip_hydration_boundaries &&
		custom_css_props.length === 0 &&
		optimiser.expressions.length === 0
	) {
		context.state.template.push(empty_comment);
	}
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.Component} node
 * @param {ComponentContext} context
 */
function Component$1(node, context) {
	build_inline_component(node, id$2(node.name), context);
}

/** @import { Expression, Pattern } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.ConstTag} node
 * @param {ComponentContext} context
 */
function ConstTag$1(node, context) {
	const declaration = node.declaration.declarations[0];
	const id = /** @type {Pattern} */ (context.visit(declaration.id));
	const init = /** @type {Expression} */ (context.visit(declaration.init));
	const has_await = node.metadata.expression.has_await;
	const blockers = [...node.metadata.expression.dependencies]
		.map((dep) => dep.blocker)
		.filter((b) => b !== null);

	if (has_await || context.state.async_consts || blockers.length > 0) {
		const run = (context.state.async_consts ??= {
			id: id$2(context.state.scope.generate('promises')),
			thunks: []
		});

		const identifiers = extract_identifiers(declaration.id);
		const bindings = context.state.scope.get_bindings(declaration);

		for (const identifier of identifiers) {
			context.state.init.push(let_builder(identifier.name));
		}

		if (blockers.length > 0) {
			run.thunks.push(thunk(call('Promise.all', array(blockers))));
		}

		const assignment$1 = assignment('=', id, init);
		run.thunks.push(thunk(block([stmt(assignment$1)]), has_await));

		const blocker = member(run.id, literal(run.thunks.length - 1), true);
		for (const binding of bindings) {
			binding.blocker = blocker;
		}
	} else {
		context.state.init.push(const_builder(id, init));
	}
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.DebugTag} node
 * @param {ComponentContext} context
 */
function DebugTag$1(node, context) {
	context.state.template.push(
		stmt(
			call(
				'console.log',
				object$2(
					node.identifiers.map((identifier) =>
						prop('init', identifier, /** @type {Expression} */ (context.visit(identifier)))
					)
				)
			)
		),
		debugger_builder
	);
}

/** @import { BlockStatement, Expression, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.EachBlock} node
 * @param {ComponentContext} context
 */
function EachBlock$1(node, context) {
	const state = context.state;

	const each_node_meta = node.metadata;
	const collection = /** @type {Expression} */ (context.visit(node.expression));
	const index =
		each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id$2(node.index);

	const array_id = state.scope.root.unique('each_array');

	/** @type {Statement} */
	let block$1 = block([const_builder(array_id, call('$.ensure_array_like', collection))]);

	/** @type {Statement[]} */
	const each = [];

	if (node.context) {
		each.push(let_builder(node.context, member(array_id, index, true)));
	}

	if (index.name !== node.index && node.index != null) {
		each.push(let_builder(node.index, index));
	}

	const new_body = /** @type {BlockStatement} */ (context.visit(node.body)).body;

	if (node.body) each.push(...new_body);

	const for_loop = for_builder(
		declaration$2('let', [
			declarator(index, literal(0)),
			declarator('$$length', member(array_id, 'length'))
		]),
		binary$1('<', index, id$2('$$length')),
		update('++', index, false),
		block(each)
	);

	if (node.fallback) {
		const open = stmt(call(id$2('$$renderer.push'), block_open));

		const fallback = /** @type {BlockStatement} */ (context.visit(node.fallback));

		fallback.body.unshift(stmt(call(id$2('$$renderer.push'), block_open_else)));

		block$1.body.push(
			if_builder(
				binary$1('!==', member(array_id, 'length'), literal(0)),
				block([open, for_loop]),
				fallback
			)
		);
	} else {
		state.template.push(block_open);
		block$1.body.push(for_loop);
	}

	if (node.metadata.expression.is_async()) {
		state.template.push(
			create_async_block(
				block$1,
				node.metadata.expression.blockers(),
				node.metadata.expression.has_await
			),
			block_close
		);
	} else {
		state.template.push(...block$1.body, block_close);
	}
}

/** @import { ExpressionStatement } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {ExpressionStatement} node
 * @param {Context} context
 */
function ExpressionStatement$1(node, context) {
	const rune = get_rune(node.expression, context.state.scope);

	if (
		rune === '$effect' ||
		rune === '$effect.pre' ||
		rune === '$effect.root' ||
		rune === '$inspect.trace'
	) {
		return empty;
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext, ComponentServerTransformState } from '../types.js' */

/**
 * @param {AST.Fragment} node
 * @param {ComponentContext} context
 */
function Fragment$1(node, context) {
	const parent = context.path.at(-1) ?? node;
	const namespace = infer_namespace(context.state.namespace, parent, node.nodes);

	const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
		parent,
		node.nodes,
		context.path,
		namespace,
		context.state,
		context.state.preserve_whitespace,
		context.state.options.preserveComments
	);

	/** @type {ComponentServerTransformState} */
	const state = {
		...context.state,
		init: [],
		template: [],
		namespace,
		skip_hydration_boundaries: is_standalone,
		async_consts: undefined
	};

	for (const node of hoisted) {
		context.visit(node, state);
	}

	if (is_text_first) {
		// insert `<!---->` to prevent this from being glued to the previous fragment
		state.template.push(empty_comment);
	}

	process_children$1(trimmed, { ...context, state });

	if (state.async_consts && state.async_consts.thunks.length > 0) {
		state.init.push(
			var_builder(state.async_consts.id, call('$$renderer.run', array(state.async_consts.thunks)))
		);
	}

	return block([...state.init, ...build_template(state.template)]);
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.HtmlTag} node
 * @param {ComponentContext} context
 */
function HtmlTag$1(node, context) {
	const expression = /** @type {Expression} */ (context.visit(node.expression));
	const call$1 = call('$.html', expression);

	context.state.template.push(create_push(call$1, node.metadata.expression, true));
}

/** @import { Identifier, Node } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {Identifier} node
 * @param {Context} context
 */
function Identifier$1(node, context) {
	if (is_reference(node, /** @type {Node} */ (context.path.at(-1)))) {
		if (node.name === '$$props') {
			return id$2('$$sanitized_props');
		}

		return build_getter(node, context.state);
	}
}

/** @import { BlockStatement, Expression, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.IfBlock} node
 * @param {ComponentContext} context
 */
function IfBlock$1(node, context) {
	const test = /** @type {Expression} */ (context.visit(node.test));
	const consequent = /** @type {BlockStatement} */ (context.visit(node.consequent));

	const alternate = node.alternate
		? /** @type {BlockStatement} */ (context.visit(node.alternate))
		: block([]);

	consequent.body.unshift(stmt(call(id$2('$$renderer.push'), block_open)));

	alternate.body.unshift(stmt(call(id$2('$$renderer.push'), block_open_else)));

	/** @type {Statement} */
	let statement = if_builder(test, consequent, alternate);

	const is_async = node.metadata.expression.is_async();

	const has_await = node.metadata.expression.has_await;

	if (is_async || has_await) {
		statement = create_async_block(
			block([statement]),
			node.metadata.expression.blockers(),
			!!has_await
		);
	}

	context.state.template.push(statement, block_close);
}

/** @import { BlockStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.KeyBlock} node
 * @param {ComponentContext} context
 */
function KeyBlock$1(node, context) {
	const is_async = node.metadata.expression.is_async();

	if (is_async) context.state.template.push(block_open);

	context.state.template.push(
		empty_comment,
		/** @type {BlockStatement} */ (context.visit(node.fragment)),
		empty_comment
	);

	if (is_async) context.state.template.push(block_close);
}

/** @import { ExpressionStatement, LabeledStatement } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {LabeledStatement} node
 * @param {Context} context
 */
function LabeledStatement$1(node, context) {
	if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== '$') {
		return;
	}

	// TODO bail out if we're in module context

	// these statements will be topologically ordered later
	context.state.legacy_reactive_statements.set(
		node,
		// people could do "break $" inside, so we need to keep the label
		labeled('$', /** @type {ExpressionStatement} */ (context.visit(node.body)))
	);

	return empty;
}

/** @import { ClassBody, MemberExpression } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {MemberExpression} node
 * @param {Context} context
 */
function MemberExpression$1(node, context) {
	if (context.state.analysis.runes && node.property.type === 'PrivateIdentifier') {
		const field = context.state.state_fields?.get(`#${node.property.name}`);

		if (field?.type === '$derived' || field?.type === '$derived.by') {
			return call(node);
		}
	}

	context.next();
}

/** @import * as ESTree from 'estree' */
/** @import { ComponentAnalysis } from '../../types' */

/**
 * Transforms the body of the instance script in such a way that await expressions are made non-blocking as much as possible.
 *
 * Example Transformation:
 * ```js
 * let x = 1;
 * let data = await fetch('/api');
 * let y = data.value;
 * ```
 * becomes:
 * ```js
 * let x = 1;
 * var data, y;
 * var $$promises = $.run([
 *   () => data = await fetch('/api'),
 *   () => y = data.value
 * ]);
 * ```
 * where `$$promises` is an array of promises that are resolved in the order they are declared,
 * and which expressions in the template can await on like `await $$promises[0]` which means they
 * wouldn't have to wait for e.g. `$$promises[1]` to resolve.
 *
 * @param {ComponentAnalysis['instance_body']} instance_body
 * @param {ESTree.Expression} runner
 * @param {(node: ESTree.Node) => ESTree.Node} transform
 * @returns {Array<ESTree.Statement | ESTree.VariableDeclaration>}
 */
function transform_body(instance_body, runner, transform) {
	// Any sync statements before the first await expression
	const statements = instance_body.sync.map(
		(node) => /** @type {ESTree.Statement | ESTree.VariableDeclaration} */ (transform(node))
	);

	// Declarations for the await expressions (they will assign to them; need to be hoisted to be available in whole instance scope)
	if (instance_body.declarations.length > 0) {
		statements.push(
			declaration$2(
				'var',
				instance_body.declarations.map((id) => declarator(id))
			)
		);
	}

	// Thunks for the await expressions
	if (instance_body.async.length > 0) {
		const thunks = instance_body.async.map((s) => {
			if (s.node.type === 'VariableDeclarator') {
				const visited = /** @type {ESTree.VariableDeclaration} */ (
					transform(var_builder(s.node.id, s.node.init))
				);

				const statements = visited.declarations.map((node) => {
					if (
						node.id.type === 'Identifier' &&
						(node.id.name.startsWith('$$d') || node.id.name.startsWith('$$array'))
					) {
						// this is an intermediate declaration created in VariableDeclaration.js;
						// subsequent statements depend on it
						return var_builder(node.id, node.init);
					}

					return stmt(assignment('=', node.id, node.init ?? void0));
				});

				if (statements.length === 1) {
					const statement = /** @type {ESTree.ExpressionStatement} */ (statements[0]);
					return thunk(statement.expression, s.has_await);
				}

				return thunk(block(statements), s.has_await);
			}

			if (s.node.type === 'ClassDeclaration') {
				return thunk(
					assignment(
						'=',
						s.node.id,
						/** @type {ESTree.ClassExpression} */ ({ ...s.node, type: 'ClassExpression' })
					),
					s.has_await
				);
			}

			if (s.node.type === 'ExpressionStatement') {
				const expression = /** @type {ESTree.Expression} */ (transform(s.node.expression));

				return expression.type === 'AwaitExpression'
					? thunk(expression, true)
					: thunk(unary$1('void', expression), s.has_await);
			}

			return thunk(block([/** @type {ESTree.Statement} */ (transform(s.node))]), s.has_await);
		});

		// TODO get the `$$promises` ID from scope
		statements.push(var_builder('$$promises', call(runner, array(thunks))));
	}

	return statements;
}

/** @import { Node, Program } from 'estree' */
/** @import { Context, ComponentServerTransformState } from '../types' */

/**
 * @param {Program} node
 * @param {Context} context
 */
function Program$1(node, context) {
	if (context.state.is_instance) {
		const state = /** @type {ComponentServerTransformState} */ (context.state);

		return {
			...node,
			body: transform_body(
				state.analysis.instance_body,
				id$2('$$renderer.run'),
				(node) => /** @type {Node} */ (context.visit(node))
			)
		};
	}

	context.next();
}

/** @import { Expression, PropertyDefinition } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {PropertyDefinition} node
 * @param {Context} context
 */
function PropertyDefinition(node, context) {
	if (context.state.analysis.runes && node.value != null && node.value.type === 'CallExpression') {
		const rune = get_rune(node.value, context.state.scope);

		if (rune === '$state' || rune === '$state.raw') {
			return {
				...node,
				value:
					node.value.arguments.length === 0
						? null
						: /** @type {Expression} */ (context.visit(node.value.arguments[0]))
			};
		}

		if (rune === '$derived.by' || rune === '$derived') {
			const fn = /** @type {Expression} */ (context.visit(node.value.arguments[0]));
			return {
				...node,
				value:
					node.value.arguments.length === 0
						? null
						: call('$.derived', rune === '$derived' ? thunk(fn) : fn)
			};
		}
	}

	context.next();
}

/** @import { ArrayExpression, Expression, Literal, ObjectExpression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext, ComponentServerTransformState } from '../../types.js' */

const WHITESPACE_INSENSITIVE_ATTRIBUTES = ['class', 'style'];

/**
 * Writes the output to the template output. Some elements may have attributes on them that require the
 * their output to be the child content instead. In this case, an object is returned.
 * @param {AST.RegularElement | AST.SvelteElement} node
 * @param {import('zimmerframe').Context<AST.SvelteNode, ComponentServerTransformState>} context
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 */
function build_element_attributes(node, context, transform) {
	/** @type {Array<AST.Attribute | AST.SpreadAttribute>} */
	const attributes = [];

	/** @type {AST.ClassDirective[]} */
	const class_directives = [];

	/** @type {AST.StyleDirective[]} */
	const style_directives = [];

	/** @type {Expression | null} */
	let content = null;

	let has_spread = false;
	let events_to_capture = new Set();

	for (const attribute of node.attributes) {
		if (attribute.type === 'Attribute') {
			if (attribute.name === 'value') {
				if (node.name === 'textarea') {
					if (
						attribute.value !== true &&
						Array.isArray(attribute.value) &&
						attribute.value[0].type === 'Text' &&
						regex_starts_with_newline.test(attribute.value[0].data)
					) {
						// Two or more leading newlines are required to restore the leading newline immediately after `<textarea>`.
						// see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
						// also see related code in analysis phase
						attribute.value[0].data = '\n' + attribute.value[0].data;
					}

					content = call('$.escape', build_attribute_value$1(attribute.value, context, transform));
				} else if (node.name !== 'select') {
					// omit value attribute for select elements, it's irrelevant for the initially selected value and has no
					// effect on the selected value after the user interacts with the select element (the value _property_ does, but not the attribute)
					attributes.push(attribute);
				}

				// omit event handlers except for special cases
			} else if (is_event_attribute(attribute)) {
				if (
					(attribute.name === 'onload' || attribute.name === 'onerror') &&
					is_load_error_element(node.name)
				) {
					events_to_capture.add(attribute.name);
				}
				// the defaultValue/defaultChecked properties don't exist as attributes
			} else if (attribute.name !== 'defaultValue' && attribute.name !== 'defaultChecked') {
				if (attribute.name === 'class') {
					if (attribute.metadata.needs_clsx) {
						attributes.push({
							...attribute,
							value: {
								.../** @type {AST.ExpressionTag} */ (attribute.value),
								expression: call(
									'$.clsx',
									/** @type {AST.ExpressionTag} */ (attribute.value).expression
								)
							}
						});
					} else {
						attributes.push(attribute);
					}
				} else {
					attributes.push(attribute);
				}
			}
		} else if (attribute.type === 'BindDirective') {
			if (attribute.name === 'value' && node.name === 'select') continue;
			if (
				attribute.name === 'value' &&
				attributes.some(
					(attr) =>
						attr.type === 'Attribute' &&
						attr.name === 'type' &&
						is_text_attribute(attr) &&
						attr.value[0].data === 'file'
				)
			) {
				continue;
			}
			if (attribute.name === 'this') continue;

			const binding = binding_properties[attribute.name];
			if (binding?.omit_in_ssr) continue;

			let expression = /** @type {Expression} */ (context.visit(attribute.expression));

			if (expression.type === 'SequenceExpression') {
				expression = call(expression.expressions[0]);
			}

			expression = transform(expression, attribute.metadata.expression);

			if (is_content_editable_binding(attribute.name)) {
				content = expression;
			} else if (attribute.name === 'value' && node.name === 'textarea') {
				content = call('$.escape', expression);
			} else if (attribute.name === 'group' && attribute.expression.type !== 'SequenceExpression') {
				const value_attribute = /** @type {AST.Attribute | undefined} */ (
					node.attributes.find((attr) => attr.type === 'Attribute' && attr.name === 'value')
				);
				if (!value_attribute) continue;

				const is_checkbox = node.attributes.some(
					(attr) =>
						attr.type === 'Attribute' &&
						attr.name === 'type' &&
						is_text_attribute(attr) &&
						attr.value[0].data === 'checkbox'
				);

				attributes.push(
					create_attribute('checked', null, -1, -1, [
						{
							type: 'ExpressionTag',
							start: -1,
							end: -1,
							expression: is_checkbox
								? call(
										member(attribute.expression, 'includes'),
										build_attribute_value$1(value_attribute.value, context, transform)
									)
								: binary$1(
										'===',
										attribute.expression,
										build_attribute_value$1(value_attribute.value, context, transform)
									),
							metadata: {
								expression: new ExpressionMetadata()
							}
						}
					])
				);
			} else {
				attributes.push(
					create_attribute(attribute.name, null, -1, -1, [
						{
							type: 'ExpressionTag',
							start: -1,
							end: -1,
							expression,
							metadata: {
								expression: new ExpressionMetadata()
							}
						}
					])
				);
			}
		} else if (attribute.type === 'SpreadAttribute') {
			attributes.push(attribute);
			has_spread = true;
			if (is_load_error_element(node.name)) {
				events_to_capture.add('onload');
				events_to_capture.add('onerror');
			}
		} else if (attribute.type === 'UseDirective') {
			if (is_load_error_element(node.name)) {
				events_to_capture.add('onload');
				events_to_capture.add('onerror');
			}
		} else if (attribute.type === 'ClassDirective') {
			class_directives.push(attribute);
		} else if (attribute.type === 'StyleDirective') {
			style_directives.push(attribute);
		} else if (attribute.type === 'LetDirective') ; else {
			context.visit(attribute);
		}
	}

	if (has_spread) {
		build_element_spread_attributes(
			node,
			attributes,
			style_directives,
			class_directives,
			context,
			transform
		);
	} else {
		const css_hash = node.metadata.scoped ? context.state.analysis.css.hash : null;

		for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) {
			const name = get_attribute_name$1(node, attribute);
			const can_use_literal =
				(name !== 'class' || class_directives.length === 0) &&
				(name !== 'style' || style_directives.length === 0);

			if (can_use_literal && (attribute.value === true || is_text_attribute(attribute))) {
				let literal_value = /** @type {Literal} */ (
					build_attribute_value$1(
						attribute.value,
						context,
						transform,
						WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
					)
				).value;

				if (name === 'class' && css_hash) {
					literal_value = (String(literal_value) + ' ' + css_hash).trim();
				}

				if (name !== 'class' || literal_value) {
					context.state.template.push(
						literal(
							` ${attribute.name}${
								is_boolean_attribute(name) && literal_value === true
									? ''
									: `="${literal_value === true ? '' : String(literal_value)}"`
							}`
						)
					);
				}

				continue;
			}

			const value = build_attribute_value$1(
				attribute.value,
				context,
				transform,
				WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
			);

			// pre-escape and inline literal attributes :
			if (can_use_literal && value.type === 'Literal' && typeof value.value === 'string') {
				if (name === 'class' && css_hash) {
					value.value = (value.value + ' ' + css_hash).trim();
				}
				context.state.template.push(literal(` ${name}="${escape_html(value.value, true)}"`));
			} else if (name === 'class') {
				context.state.template.push(
					build_attr_class(class_directives, value, context, css_hash, transform)
				);
			} else if (name === 'style') {
				context.state.template.push(build_attr_style(style_directives, value, context, transform));
			} else {
				context.state.template.push(
					call('$.attr', literal(name), value, is_boolean_attribute(name) && true_instance)
				);
			}
		}
	}

	if (events_to_capture.size !== 0) {
		for (const event of events_to_capture) {
			context.state.template.push(literal(` ${event}="this.__e=event"`));
		}
	}

	return content;
}

/**
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {AST.Attribute | AST.BindDirective} attribute
 */
function get_attribute_name$1(element, attribute) {
	let name = attribute.name;
	if (!element.metadata.svg && !element.metadata.mathml) {
		name = name.toLowerCase();
		// don't lookup boolean aliases here, the server runtime function does only
		// check for the lowercase variants of boolean attributes
	}
	return name;
}

/**
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {Array<AST.Attribute | AST.SpreadAttribute | AST.BindDirective>} attributes
 * @param {ComponentContext} context
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 */
function build_spread_object(element, attributes, context, transform) {
	const object = object$2(
		attributes.map((attribute) => {
			if (attribute.type === 'Attribute') {
				const name = get_attribute_name$1(element, attribute);
				const value = build_attribute_value$1(
					attribute.value,
					context,
					transform,
					WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
				);

				return prop('init', key(name), value);
			} else if (attribute.type === 'BindDirective') {
				const name = get_attribute_name$1(element, attribute);
				const value =
					attribute.expression.type === 'SequenceExpression'
						? call(attribute.expression.expressions[0])
						: /** @type {Expression} */ (context.visit(attribute.expression));

				return prop('init', key(name), value);
			}

			return spread(
				transform(
					/** @type {Expression} */ (context.visit(attribute)),
					attribute.metadata.expression
				)
			);
		})
	);

	return object;
}

/**
 *
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {Array<AST.Attribute | AST.SpreadAttribute>} attributes
 * @param {AST.StyleDirective[]} style_directives
 * @param {AST.ClassDirective[]} class_directives
 * @param {ComponentContext} context
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 */
function build_element_spread_attributes(
	element,
	attributes,
	style_directives,
	class_directives,
	context,
	transform
) {
	const args = prepare_element_spread(
		element,
		/** @type {Array<AST.Attribute | AST.SpreadAttribute | AST.BindDirective>} */ (attributes),
		style_directives,
		class_directives,
		context,
		transform
	);

	let call$1 = call('$.attributes', ...args);

	context.state.template.push(call$1);
}

/**
 * Prepare args for $.attributes(...): compute object, css_hash, classes, styles and flags.
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {ComponentContext} context
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 * @returns {[ObjectExpression,Literal | undefined, ObjectExpression | undefined, ObjectExpression | undefined, Literal | undefined]}
 */
function prepare_element_spread_object(element, context, transform) {
	/** @type {Array<AST.Attribute | AST.SpreadAttribute | AST.BindDirective>} */
	const select_attributes = [];
	/** @type {AST.ClassDirective[]} */
	const class_directives = [];
	/** @type {AST.StyleDirective[]} */
	const style_directives = [];

	for (const attribute of element.attributes) {
		if (
			attribute.type === 'Attribute' ||
			attribute.type === 'BindDirective' ||
			attribute.type === 'SpreadAttribute'
		) {
			select_attributes.push(attribute);
		} else if (attribute.type === 'ClassDirective') {
			class_directives.push(attribute);
		} else if (attribute.type === 'StyleDirective') {
			style_directives.push(attribute);
		}
	}

	return prepare_element_spread(
		element,
		select_attributes,
		style_directives,
		class_directives,
		context,
		transform
	);
}

/**
 * Prepare args for $.attributes(...): compute object, css_hash, classes, styles and flags.
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {Array<AST.Attribute | AST.SpreadAttribute | AST.BindDirective>} attributes
 * @param {AST.StyleDirective[]} style_directives
 * @param {AST.ClassDirective[]} class_directives
 * @param {ComponentContext} context
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 * @returns {[ObjectExpression,Literal | undefined, ObjectExpression | undefined, ObjectExpression | undefined, Literal | undefined]}
 */
function prepare_element_spread(
	element,
	attributes,
	style_directives,
	class_directives,
	context,
	transform
) {
	/** @type {ObjectExpression | undefined} */
	let classes;
	/** @type {ObjectExpression | undefined} */
	let styles;
	let flags = 0;

	if (class_directives.length) {
		const properties = class_directives.map((directive) =>
			init(
				directive.name,
				directive.expression.type === 'Identifier' && directive.expression.name === directive.name
					? id$2(directive.name)
					: transform(
							/** @type {Expression} */ (context.visit(directive.expression)),
							directive.metadata.expression
						)
			)
		);

		classes = object$2(properties);
	}

	if (style_directives.length > 0) {
		const properties = style_directives.map((directive) =>
			init(
				directive.name,
				directive.value === true
					? id$2(directive.name)
					: build_attribute_value$1(directive.value, context, transform, true)
			)
		);
		styles = object$2(properties);
	}

	if (element.metadata.svg || element.metadata.mathml) {
		flags |= ELEMENT_IS_NAMESPACED | ELEMENT_PRESERVE_ATTRIBUTE_CASE;
	} else if (is_custom_element_node(element)) {
		flags |= ELEMENT_PRESERVE_ATTRIBUTE_CASE;
	} else if (element.type === 'RegularElement' && element.name === 'input') {
		flags |= ELEMENT_IS_INPUT;
	}

	const object = build_spread_object(element, attributes, context, transform);
	const css_hash =
		element.metadata.scoped && context.state.analysis.css.hash
			? literal(context.state.analysis.css.hash)
			: undefined;

	return [object, css_hash, classes, styles, flags ? literal(flags) : undefined];
}

/**
 *
 * @param {AST.ClassDirective[]} class_directives
 * @param {Expression} expression
 * @param {ComponentContext} context
 * @param {string | null} hash
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 */
function build_attr_class(class_directives, expression, context, hash, transform) {
	/** @type {ObjectExpression | undefined} */
	let directives;

	if (class_directives.length) {
		directives = object$2(
			class_directives.map((directive) =>
				prop(
					'init',
					literal(directive.name),
					transform(
						/** @type {Expression} */ (context.visit(directive.expression, context.state)),
						directive.metadata.expression
					)
				)
			)
		);
	}

	let css_hash;

	if (hash) {
		if (expression.type === 'Literal' && typeof expression.value === 'string') {
			expression.value = (expression.value + ' ' + hash).trim();
		} else {
			css_hash = literal(hash);
		}
	}

	return call('$.attr_class', expression, css_hash, directives);
}

/**
 *
 * @param {AST.StyleDirective[]} style_directives
 * @param {Expression} expression
 * @param {ComponentContext} context,
 * @param {(expression: Expression, metadata: ExpressionMetadata) => Expression} transform
 */
function build_attr_style(style_directives, expression, context, transform) {
	/** @type {ArrayExpression | ObjectExpression | undefined} */
	let directives;

	if (style_directives.length) {
		let normal_properties = [];
		let important_properties = [];

		for (const directive of style_directives) {
			const expression =
				directive.value === true
					? id$2(directive.name)
					: build_attribute_value$1(directive.value, context, transform, true);

			let name = directive.name;
			if (name[0] !== '-' || name[1] !== '-') {
				name = name.toLowerCase();
			}

			const property = init(directive.name, expression);
			if (directive.modifiers.includes('important')) {
				important_properties.push(property);
			} else {
				normal_properties.push(property);
			}
		}

		if (important_properties.length) {
			directives = array([object$2(normal_properties), object$2(important_properties)]);
		} else {
			directives = object$2(normal_properties);
		}
	}

	return call('$.attr_style', expression, directives);
}

/** @import { Expression } from 'estree' */
/** @import { Location } from 'locate-character' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext, ComponentServerTransformState } from '../types.js' */
/** @import { Scope } from '../../../scope.js' */

/**
 * @param {AST.RegularElement} node
 * @param {ComponentContext} context
 */
function RegularElement$1(node, context) {
	const namespace = determine_namespace_for_children(node, context.state.namespace);

	/** @type {ComponentServerTransformState} */
	const state = {
		...context.state,
		namespace,
		preserve_whitespace:
			context.state.preserve_whitespace || node.name === 'pre' || node.name === 'textarea',
		init: [],
		template: []
	};

	const node_is_void = is_void(node.name);

	const optimiser = new PromiseOptimiser();

	// If this element needs special handling (like <select value> / <option>),
	// avoid calling build_element_attributes here to prevent evaluating/awaiting
	// attribute expressions twice. We'll handle attributes in the special branch.
	const is_select_special =
		node.name === 'select' &&
		node.attributes.some(
			(attribute) =>
				((attribute.type === 'Attribute' || attribute.type === 'BindDirective') &&
					attribute.name === 'value') ||
				attribute.type === 'SpreadAttribute'
		);
	const is_option_special = node.name === 'option';
	const is_special = is_select_special || is_option_special;

	let body = /** @type {Expression | null} */ (null);
	if (!is_special) {
		// only open the tag in the non-special path
		state.template.push(literal(`<${node.name}`));
		body = build_element_attributes(node, { ...context, state }, optimiser.transform);
		state.template.push(literal(node_is_void ? '/>' : '>')); // add `/>` for XHTML compliance
	}

	if ((node.name === 'script' || node.name === 'style') && node.fragment.nodes.length === 1) {
		state.template.push(
			literal(/** @type {AST.Text} */ (node.fragment.nodes[0]).data),
			literal(`</${node.name}>`)
		);

		// TODO this is a real edge case, would be good to DRY this out
		if (optimiser.expressions.length > 0) {
			context.state.template.push(
				create_child_block(
					block([optimiser.apply(), ...state.init, ...build_template(state.template)]),
					true
				)
			);
		} else {
			context.state.init.push(...state.init);
			context.state.template.push(...state.template);
		}

		return;
	}

	const { hoisted, trimmed } = clean_nodes(
		node,
		node.fragment.nodes,
		context.path,
		namespace,
		{
			...state,
			scope: /** @type {Scope} */ (state.scopes.get(node.fragment))
		},
		state.preserve_whitespace,
		state.options.preserveComments
	);

	for (const node of hoisted) {
		context.visit(node, state);
	}

	if (dev) {
		const location = locator(node.start);
		state.template.push(
			stmt(
				call(
					'$.push_element',
					id$2('$$renderer'),
					literal(node.name),
					literal(location.line),
					literal(location.column)
				)
			)
		);
	}

	if (is_select_special) {
		const inner_state = { ...state, template: [], init: [] };
		process_children$1(trimmed, { ...context, state: inner_state });

		const fn = arrow(
			[id$2('$$renderer')],
			block([...state.init, ...build_template(inner_state.template)])
		);

		const [attributes, ...rest] = prepare_element_spread_object(node, context, optimiser.transform);

		const statement = stmt(call('$$renderer.select', attributes, fn, ...rest));

		if (optimiser.expressions.length > 0) {
			context.state.template.push(
				create_child_block(block([optimiser.apply(), ...state.init, statement]), true)
			);
		} else {
			context.state.template.push(...state.init, statement);
		}

		return;
	}

	if (is_option_special) {
		let body;

		if (node.metadata.synthetic_value_node) {
			body = optimiser.transform(
				node.metadata.synthetic_value_node.expression,
				node.metadata.synthetic_value_node.metadata.expression
			);
		} else {
			const inner_state = { ...state, template: [], init: [] };
			process_children$1(trimmed, { ...context, state: inner_state });

			body = arrow(
				[id$2('$$renderer')],
				block([...state.init, ...build_template(inner_state.template)])
			);
		}

		const [attributes, ...rest] = prepare_element_spread_object(node, context, optimiser.transform);

		const statement = stmt(call('$$renderer.option', attributes, body, ...rest));

		if (optimiser.expressions.length > 0) {
			context.state.template.push(
				create_child_block(block([optimiser.apply(), ...state.init, statement]), true)
			);
		} else {
			context.state.template.push(...state.init, statement);
		}

		return;
	}

	if (body !== null) {
		// if this is a `<textarea>` value or a contenteditable binding, we only add
		// the body if the attribute/binding is falsy
		const inner_state = { ...state, template: [], init: [] };
		process_children$1(trimmed, { ...context, state: inner_state });

		let id = /** @type {Expression} */ (body);

		if (body.type !== 'Identifier') {
			id = id$2(state.scope.generate('$$body'));
			state.template.push(const_builder(id, body));
		}

		// Use the body expression as the body if it's truthy, otherwise use the inner template
		state.template.push(
			if_builder(
				id,
				block(build_template([id])),
				block([...inner_state.init, ...build_template(inner_state.template)])
			)
		);
	} else {
		process_children$1(trimmed, { ...context, state });
	}

	if (!node_is_void) {
		state.template.push(literal(`</${node.name}>`));
	}

	if (dev) {
		state.template.push(stmt(call('$.pop_element')));
	}

	if (optimiser.is_async()) {
		let statement = create_child_block(
			block([optimiser.apply(), ...state.init, ...build_template(state.template)]),
			true
		);

		const blockers = optimiser.blockers();

		if (blockers.elements.length > 0) {
			statement = create_async_block(block([statement]), blockers, false, false);
		}

		context.state.template.push(statement);
	} else {
		context.state.init.push(...state.init);
		context.state.template.push(...state.template);
	}
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.RenderTag} node
 * @param {ComponentContext} context
 */
function RenderTag$1(node, context) {
	const optimiser = new PromiseOptimiser();

	const callee = unwrap_optional(node.expression).callee;
	const raw_args = unwrap_optional(node.expression).arguments;

	const snippet_function = optimiser.transform(
		/** @type {Expression} */ (context.visit(callee)),
		node.metadata.expression
	);

	const snippet_args = raw_args.map((arg, i) => {
		return optimiser.transform(
			/** @type {Expression} */ (context.visit(arg)),
			node.metadata.arguments[i]
		);
	});

	let statement = stmt(
		(node.expression.type === 'CallExpression' ? call : maybe_call)(
			snippet_function,
			id$2('$$renderer'),
			...snippet_args
		)
	);

	if (optimiser.is_async()) {
		statement = create_async_block(
			block([optimiser.apply(), statement]),
			optimiser.blockers(),
			optimiser.has_await
		);
	}

	context.state.template.push(statement);

	if (!context.state.skip_hydration_boundaries) {
		context.state.template.push(empty_comment);
	}
}

/** @import { BlockStatement, Expression, Literal, Property } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.SlotElement} node
 * @param {ComponentContext} context
 */
function SlotElement$1(node, context) {
	/** @type {Property[]} */
	const props = [];

	/** @type {Expression[]} */
	const spreads = [];

	const optimiser = new PromiseOptimiser();

	let name = literal('default');

	for (const attribute of node.attributes) {
		if (attribute.type === 'SpreadAttribute') {
			let expression = /** @type {Expression} */ (context.visit(attribute));
			spreads.push(optimiser.transform(expression, attribute.metadata.expression));
		} else if (attribute.type === 'Attribute') {
			const value = build_attribute_value$1(
				attribute.value,
				context,
				optimiser.transform,
				false,
				true
			);

			if (attribute.name === 'name') {
				name = /** @type {Literal} */ (value);
			} else if (attribute.name !== 'slot') {
				props.push(init(attribute.name, value));
			}
		}
	}

	const props_expression =
		spreads.length === 0
			? object$2(props)
			: call('$.spread_props', array([object$2(props), ...spreads]));

	const fallback =
		node.fragment.nodes.length === 0
			? null_instance
			: thunk(/** @type {BlockStatement} */ (context.visit(node.fragment)));

	const slot = call(
		'$.slot',
		id$2('$$renderer'),
		id$2('$$props'),
		name,
		props_expression,
		fallback
	);

	const statement = optimiser.is_async()
		? create_async_block(
				block([optimiser.apply(), stmt(slot)]),
				optimiser.blockers(),
				optimiser.has_await
			)
		: stmt(slot);

	context.state.template.push(block_open, statement, block_close);
}

/** @import { BlockStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.SnippetBlock} node
 * @param {ComponentContext} context
 */
function SnippetBlock$1(node, context) {
	let fn = function_declaration(
		node.expression,
		[id$2('$$renderer'), ...node.parameters],
		/** @type {BlockStatement} */ (context.visit(node.body))
	);

	// @ts-expect-error - TODO remove this hack once $$render_inner for legacy bindings is gone
	fn.___snippet = true;

	const statements = node.metadata.can_hoist ? context.state.hoisted : context.state.init;

	if (dev) {
		fn.body.body.unshift(stmt(call('$.validate_snippet_args', id$2('$$renderer'))));
		statements.push(stmt(call('$.prevent_snippet_stringification', fn.id)));
	}

	statements.push(fn);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SpreadAttribute} node
 * @param {ComponentContext} context
 */
function SpreadAttribute$1(node, context) {
	return context.visit(node.expression);
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.SvelteComponent} node
 * @param {ComponentContext} context
 */
function SvelteComponent$1(node, context) {
	build_inline_component(node, /** @type {Expression} */ (context.visit(node.expression)), context);
}

/** @import { Location } from 'locate-character' */
/** @import { BlockStatement, Expression, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.SvelteElement} node
 * @param {ComponentContext} context
 */
function SvelteElement$1(node, context) {
	let tag = /** @type {Expression} */ (context.visit(node.tag));

	if (dev) {
		// Ensure getters/function calls aren't called multiple times.
		// If we ever start referencing `tag` more than once in prod, move this out of the if block.
		if (tag.type !== 'Identifier') {
			const tag_id = context.state.scope.generate('$$tag');
			context.state.init.push(const_builder(tag_id, tag));
			tag = id$2(tag_id);
		}

		if (node.fragment.nodes.length > 0) {
			context.state.init.push(stmt(call('$.validate_void_dynamic_element', thunk(tag))));
		}
		context.state.init.push(stmt(call('$.validate_dynamic_element_tag', thunk(tag))));
	}

	const state = {
		...context.state,
		namespace: determine_namespace_for_children(node, context.state.namespace),
		template: [],
		init: []
	};

	const optimiser = new PromiseOptimiser();

	/** @type {Statement[]} */
	let statements = [];

	build_element_attributes(node, { ...context, state }, optimiser.transform);

	if (dev) {
		const location = locator(node.start);
		statements.push(
			stmt(
				call(
					'$.push_element',
					id$2('$$renderer'),
					tag,
					literal(location.line),
					literal(location.column)
				)
			)
		);
	}

	const attributes = block([...state.init, ...build_template(state.template)]);
	const children = /** @type {BlockStatement} */ (context.visit(node.fragment, state));

	/** @type {Statement} */
	let statement = stmt(
		call(
			'$.element',
			id$2('$$renderer'),
			tag,
			attributes.body.length > 0 && thunk(attributes),
			children.body.length > 0 && thunk(children)
		)
	);

	if (optimiser.expressions.length > 0) {
		statement = create_child_block(block([optimiser.apply(), statement]), true);
	}

	statements.push(statement);

	if (dev) {
		statements.push(stmt(call('$.pop_element')));
	}

	if (node.metadata.expression.is_async()) {
		statements = [
			create_async_block(
				block(statements),
				node.metadata.expression.blockers(),
				node.metadata.expression.has_await
			)
		];
	}

	context.state.template.push(...statements);
}

/** @import { BlockStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteFragment} node
 * @param {ComponentContext} context
 */
function SvelteFragment$1(node, context) {
	context.state.template.push(/** @type {BlockStatement} */ (context.visit(node.fragment)));
}

/** @import { BlockStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.SvelteHead} node
 * @param {ComponentContext} context
 */
function SvelteHead$1(node, context) {
	const block = /** @type {BlockStatement} */ (context.visit(node.fragment));

	context.state.template.push(
		stmt(
			call(
				'$.head',
				literal(hash(filename)),
				id$2('$$renderer'),
				arrow([id$2('$$renderer')], block)
			)
		)
	);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.SvelteSelf} node
 * @param {ComponentContext} context
 */
function SvelteSelf$1(node, context) {
	build_inline_component(node, id$2(context.state.analysis.name), context);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types.js' */

/**
 * @param {AST.TitleElement} node
 * @param {ComponentContext} context
 */
function TitleElement$1(node, context) {
	// title is guaranteed to contain only text/expression tag children
	const template = [literal('<title>')];
	process_children$1(node.fragment.nodes, { ...context, state: { ...context.state, template } });
	template.push(literal('</title>'));

	context.state.init.push(
		stmt(
			call('$$renderer.title', arrow([id$2('$$renderer')], block(build_template(template))))
		)
	);
}

/** @import { UpdateExpression } from 'estree' */
/** @import { Context } from '../types.js' */

/**
 * @param {UpdateExpression} node
 * @param {Context} context
 */
function UpdateExpression$1(node, context) {
	const argument = node.argument;

	if (
		argument.type === 'Identifier' &&
		context.state.scope.get(argument.name)?.kind === 'store_sub'
	) {
		return call(
			node.prefix ? '$.update_store_pre' : '$.update_store',
			assignment('??=', id$2('$$store_subs'), object$2([])),
			literal(argument.name),
			id$2(argument.name.slice(1)),
			node.operator === '--' && literal(-1)
		);
	}

	return context.next();
}

/** @import { VariableDeclaration, VariableDeclarator, Expression, CallExpression, Pattern, Identifier } from 'estree' */
/** @import { Binding } from '#compiler' */
/** @import { Context } from '../types.js' */
/** @import { ComponentAnalysis } from '../../../types.js' */
/** @import { Scope } from '../../../scope.js' */

/**
 * @param {VariableDeclaration} node
 * @param {Context} context
 */
function VariableDeclaration$1(node, context) {
	/** @type {VariableDeclarator[]} */
	const declarations = [];

	if (context.state.analysis.runes) {
		for (const declarator$1 of node.declarations) {
			const init = declarator$1.init;
			const rune = get_rune(init, context.state.scope);
			if (!rune || rune === '$effect.tracking' || rune === '$inspect' || rune === '$effect.root') {
				declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator$1)));
				continue;
			}

			if (rune === '$props.id') {
				// skip
				continue;
			}

			if (rune === '$props') {
				let has_rest = false;
				// remove $bindable() from props declaration
				let id = walk$1(declarator$1.id, null, {
					RestElement(node, context) {
						if (context.path.at(-1) === declarator$1.id) {
							has_rest = true;
						}
					},
					AssignmentPattern(node) {
						if (
							node.right.type === 'CallExpression' &&
							get_rune(node.right, context.state.scope) === '$bindable'
						) {
							const right = node.right.arguments.length
								? /** @type {Expression} */ (context.visit(node.right.arguments[0]))
								: void0;
							return assignment_pattern(node.left, right);
						}
					}
				});

				// if `$$slots` is declared separately, deconflict
				const slots_name = /** @type {ComponentAnalysis} */ (context.state.analysis).uses_slots
					? id$2('$$slots_')
					: id$2('$$slots');

				if (id.type === 'ObjectPattern' && has_rest) {
					// If a rest pattern is used within an object pattern, we need to ensure we don't expose $$slots or $$events
					id.properties.splice(
						id.properties.length - 1,
						0,
						// @ts-ignore
						prop('init', id$2('$$slots'), slots_name),
						prop('init', id$2('$$events'), id$2('$$events'))
					);
				} else if (id.type === 'Identifier') {
					// If $props is referenced as an identifier, we need to ensure we don't expose $$slots or $$events as properties
					// on the identifier reference
					id = object_pattern([
						prop('init', id$2('$$slots'), slots_name),
						prop('init', id$2('$$events'), id$2('$$events')),
						rest(id$2(id.name))
					]);
				}
				declarations.push(
					declarator(/** @type {Pattern} */ (context.visit(id)), id$2('$$props'))
				);
				continue;
			}

			const args = /** @type {CallExpression} */ (init).arguments;
			const value = args.length > 0 ? /** @type {Expression} */ (context.visit(args[0])) : void0;

			if (rune === '$derived.by') {
				declarations.push(
					declarator(/** @type {Pattern} */ (context.visit(declarator$1.id)), call(value))
				);
				continue;
			}

			if (declarator$1.id.type === 'Identifier') {
				declarations.push(declarator(declarator$1.id, value));
				continue;
			}

			if (rune === '$derived') {
				declarations.push(
					declarator(/** @type {Pattern} */ (context.visit(declarator$1.id)), value)
				);
				continue;
			}

			declarations.push(...create_state_declarators$1(declarator$1, context.state.scope, value));
		}
	} else {
		for (const declarator$1 of node.declarations) {
			const bindings = /** @type {Binding[]} */ (context.state.scope.get_bindings(declarator$1));
			const has_state = bindings.some((binding) => binding.kind === 'state');
			const has_props = bindings.some((binding) => binding.kind === 'bindable_prop');

			if (!has_state && !has_props) {
				declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator$1)));
				continue;
			}

			if (has_props) {
				if (declarator$1.id.type !== 'Identifier') {
					// Turn export let into props. It's really really weird because export let { x: foo, z: [bar]} = ..
					// means that foo and bar are the props (i.e. the leaves are the prop names), not x and z.
					const tmp = id$2(context.state.scope.generate('tmp'));
					const { inserts, paths } = extract_paths(declarator$1.id, tmp);

					declarations.push(
						declarator(
							tmp,
							/** @type {Expression} */ (context.visit(/** @type {Expression} */ (declarator$1.init)))
						)
					);

					for (const { id, value } of inserts) {
						id.name = context.state.scope.generate('$$array');
						declarations.push(declarator(id, value));
					}

					for (const path of paths) {
						const value = path.expression;
						const name = /** @type {Identifier} */ (path.node).name;
						const binding = /** @type {Binding} */ (context.state.scope.get(name));
						const prop = member(id$2('$$props'), literal(binding.prop_alias ?? name), true);
						declarations.push(declarator(path.node, build_fallback(prop, value)));
					}

					continue;
				}

				const binding = /** @type {Binding} */ (context.state.scope.get(declarator$1.id.name));
				const prop = member(
					id$2('$$props'),
					literal(binding.prop_alias ?? declarator$1.id.name),
					true
				);

				/** @type {Expression} */
				let init = prop;
				if (declarator$1.init) {
					const default_value = /** @type {Expression} */ (context.visit(declarator$1.init));
					init = build_fallback(prop, default_value);
				}

				declarations.push(declarator(declarator$1.id, init));

				continue;
			}

			declarations.push(
				...create_state_declarators$1(
					declarator$1,
					context.state.scope,
					/** @type {Expression} */ (declarator$1.init && context.visit(declarator$1.init))
				)
			);
		}
	}

	if (declarations.length === 0) {
		return empty;
	}

	return {
		...node,
		declarations
	};
}

/**
 * @param {VariableDeclarator} declarator
 * @param {Scope} scope
 * @param {Expression} value
 * @returns {VariableDeclarator[]}
 */
function create_state_declarators$1(declarator$1, scope, value) {
	if (declarator$1.id.type === 'Identifier') {
		return [declarator(declarator$1.id, value)];
	}

	const tmp = id$2(scope.generate('tmp'));
	const { paths, inserts } = extract_paths(declarator$1.id, tmp);
	return [
		declarator(tmp, value), // TODO inject declarator for opts, so we can use it below
		...inserts.map(({ id, value }) => {
			id.name = scope.generate('$$array');
			return declarator(id, value);
		}),
		...paths.map((path) => {
			const value = path.expression;
			return declarator(path.node, value);
		})
	];
}

/** @import { BlockStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteBoundary} node
 * @param {ComponentContext} context
 */
function SvelteBoundary$1(node, context) {
	// if this has a `pending` snippet, render it
	const pending_attribute = /** @type {AST.Attribute} */ (
		node.attributes.find((node) => node.type === 'Attribute' && node.name === 'pending')
	);
	const is_pending_attr_nullish =
		pending_attribute &&
		typeof pending_attribute.value === 'object' &&
		!Array.isArray(pending_attribute.value) &&
		!context.state.scope.evaluate(pending_attribute.value.expression).is_defined;

	const pending_snippet = /** @type {AST.SnippetBlock} */ (
		node.fragment.nodes.find(
			(node) => node.type === 'SnippetBlock' && node.expression.name === 'pending'
		)
	);

	if (pending_attribute || pending_snippet) {
		if (pending_attribute && is_pending_attr_nullish && !pending_snippet) {
			const callee = build_attribute_value$1(
				pending_attribute.value,
				context,
				(expression) => expression,
				false,
				true
			);
			const pending = call(callee, id$2('$$renderer'));
			const block$1 = /** @type {BlockStatement} */ (context.visit(node.fragment));
			context.state.template.push(
				if_builder(
					callee,
					block(build_template([block_open_else, stmt(pending), block_close])),
					block(build_template([block_open, block$1, block_close]))
				)
			);
		} else {
			const pending = pending_attribute
				? call(
						build_attribute_value$1(
							pending_attribute.value,
							context,
							(expression) => expression,
							false,
							true
						),
						id$2('$$renderer')
					)
				: /** @type {BlockStatement} */ (context.visit(pending_snippet.body));
			context.state.template.push(block_open_else, pending, block_close);
		}
	} else {
		const block = /** @type {BlockStatement} */ (context.visit(node.fragment));
		context.state.template.push(block_open, block, block_close);
	}
}

/** @import * as ESTree from 'estree' */
/** @import { AST, ValidatedCompileOptions, ValidatedModuleCompileOptions } from '#compiler' */
/** @import { ComponentServerTransformState, ComponentVisitors, ServerTransformState, Visitors } from './types.js' */
/** @import { Analysis, ComponentAnalysis } from '../../types.js' */

/** @type {Visitors} */
const global_visitors = {
	_: set_scope,
	AssignmentExpression: AssignmentExpression$1,
	AwaitExpression: AwaitExpression$1,
	CallExpression: CallExpression$1,
	ClassBody: ClassBody$1,
	ExpressionStatement: ExpressionStatement$1,
	Identifier: Identifier$1,
	LabeledStatement: LabeledStatement$1,
	MemberExpression: MemberExpression$1,
	Program: Program$1,
	PropertyDefinition,
	UpdateExpression: UpdateExpression$1,
	VariableDeclaration: VariableDeclaration$1
};

/** @type {ComponentVisitors} */
const template_visitors = {
	AwaitBlock: AwaitBlock$1,
	Component: Component$1,
	ConstTag: ConstTag$1,
	DebugTag: DebugTag$1,
	EachBlock: EachBlock$1,
	Fragment: Fragment$1,
	HtmlTag: HtmlTag$1,
	IfBlock: IfBlock$1,
	KeyBlock: KeyBlock$1,
	RegularElement: RegularElement$1,
	RenderTag: RenderTag$1,
	SlotElement: SlotElement$1,
	SnippetBlock: SnippetBlock$1,
	SpreadAttribute: SpreadAttribute$1,
	SvelteComponent: SvelteComponent$1,
	SvelteElement: SvelteElement$1,
	SvelteFragment: SvelteFragment$1,
	SvelteHead: SvelteHead$1,
	SvelteSelf: SvelteSelf$1,
	TitleElement: TitleElement$1,
	SvelteBoundary: SvelteBoundary$1
};

/**
 * @param {ComponentAnalysis} analysis
 * @param {ValidatedCompileOptions} options
 * @returns {ESTree.Program}
 */
function server_component(analysis, options) {
	/** @type {ComponentServerTransformState} */
	const state = {
		analysis,
		options,
		scope: analysis.module.scope,
		scopes: analysis.module.scopes,
		hoisted: [import_all('$', 'svelte/internal/server'), ...analysis.instance_body.hoisted],
		legacy_reactive_statements: new Map(),
		// these are set inside the `Fragment` visitor, and cannot be used until then
		init: /** @type {any} */ (null),
		template: /** @type {any} */ (null),
		namespace: options.namespace,
		preserve_whitespace: options.preserveWhitespace,
		state_fields: new Map(),
		skip_hydration_boundaries: false,
		is_instance: false
	};

	const module = /** @type {ESTree.Program} */ (
		walk$1(/** @type {AST.SvelteNode} */ (analysis.module.ast), state, global_visitors)
	);

	const instance = /** @type {ESTree.Program} */ (
		walk$1(
			/** @type {AST.SvelteNode} */ (analysis.instance.ast),
			{ ...state, scopes: analysis.instance.scopes, is_instance: true },
			{
				...global_visitors,
				ImportDeclaration(node) {
					state.hoisted.push(node);
					return empty;
				},
				ExportNamedDeclaration(node, context) {
					if (node.declaration) {
						return context.visit(node.declaration);
					}

					return empty;
				}
			}
		)
	);

	const template = /** @type {ESTree.Program} */ (
		walk$1(
			/** @type {AST.SvelteNode} */ (analysis.template.ast),
			{ ...state, scopes: analysis.template.scopes },
			// @ts-expect-error don't know, don't care
			{ ...global_visitors, ...template_visitors }
		)
	);

	/** @type {ESTree.VariableDeclarator[]} */
	const legacy_reactive_declarations = [];

	for (const [node] of analysis.reactive_statements) {
		const statement = [...state.legacy_reactive_statements].find(([n]) => n === node);
		if (statement === undefined) {
			throw new Error('Could not find reactive statement');
		}

		if (
			node.body.type === 'ExpressionStatement' &&
			node.body.expression.type === 'AssignmentExpression'
		) {
			for (const id of extract_identifiers(node.body.expression.left)) {
				const binding = analysis.instance.scope.get(id.name);
				if (binding?.kind === 'legacy_reactive') {
					legacy_reactive_declarations.push(declarator(id));
				}
			}
		}

		instance.body.push(statement[1]);
	}

	if (legacy_reactive_declarations.length > 0) {
		instance.body.unshift({
			type: 'VariableDeclaration',
			kind: 'let',
			declarations: legacy_reactive_declarations
		});
	}

	// If the component binds to a child, we need to put the template in a loop and repeat until legacy bindings are stable.
	// We can remove this once the legacy syntax is gone.
	if (analysis.uses_component_bindings) {
		const snippets = template.body.filter(
			// @ts-expect-error
			(node) => node.type === 'FunctionDeclaration' && node.___snippet
		);

		const rest = template.body.filter(
			// @ts-expect-error
			(node) => node.type !== 'FunctionDeclaration' || !node.___snippet
		);

		template.body = [
			...snippets,
			let_builder('$$settled', true_instance),
			let_builder('$$inner_renderer'),
			function_declaration(
				id$2('$$render_inner'),
				[id$2('$$renderer')],
				block(/** @type {ESTree.Statement[]} */ (rest))
			),
			do_while(
				unary$1('!', id$2('$$settled')),
				block([
					stmt(assignment('=', id$2('$$settled'), true_instance)),
					stmt(assignment('=', id$2('$$inner_renderer'), call('$$renderer.copy'))),
					stmt(call('$$render_inner', id$2('$$inner_renderer')))
				])
			),
			stmt(call('$$renderer.subsume', id$2('$$inner_renderer')))
		];
	}

	if (
		[...analysis.instance.scope.declarations.values()].some(
			(binding) => binding.kind === 'store_sub'
		)
	) {
		instance.body.unshift(var_builder('$$store_subs'));
		template.body.push(
			if_builder(id$2('$$store_subs'), stmt(call('$.unsubscribe_stores', id$2('$$store_subs'))))
		);
	}

	// Propagate values of bound props upwards if they're undefined in the parent and have a value.
	// Don't do this as part of the props retrieval because people could eagerly mutate the prop in the instance script.
	/** @type {ESTree.Property[]} */
	const props = [];

	for (const [name, binding] of analysis.instance.scope.declarations) {
		if (binding.kind === 'bindable_prop' && !name.startsWith('$$')) {
			props.push(init(binding.prop_alias ?? name, id$2(name)));
		}
	}

	for (const { name, alias } of analysis.exports) {
		props.push(init(alias ?? name, id$2(name)));
	}

	if (props.length > 0) {
		// This has no effect in runes mode other than throwing an error when someone passes
		// undefined to a binding that has a default value.
		template.body.push(stmt(call('$.bind_props', id$2('$$props'), object$2(props))));
	}

	let component_block = block([
		.../** @type {ESTree.Statement[]} */ (instance.body),
		.../** @type {ESTree.Statement[]} */ (template.body)
	]);

	// trick esrap into including comments
	component_block.loc = instance.loc;

	if (analysis.props_id) {
		// need to be placed on first line of the component for hydration
		component_block.body.unshift(
			const_builder(analysis.props_id, call('$.props_id', id$2('$$renderer')))
		);
	}

	let should_inject_context = dev || analysis.needs_context;

	if (should_inject_context) {
		component_block = block([
			call_component_renderer(component_block, dev && id$2(component_name))
		]);
	}

	if (analysis.uses_rest_props) {
		/** @type {string[]} */
		const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
		for (const [name, binding] of analysis.instance.scope.declarations) {
			if (binding.kind === 'bindable_prop') named_props.push(binding.prop_alias ?? name);
		}

		component_block.body.unshift(
			const_builder(
				'$$restProps',
				call(
					'$.rest_props',
					id$2('$$sanitized_props'),
					array(named_props.map((name) => literal(name)))
				)
			)
		);
	}

	if (analysis.uses_props || analysis.uses_rest_props) {
		component_block.body.unshift(
			const_builder('$$sanitized_props', call('$.sanitize_props', id$2('$$props')))
		);
	}

	if (analysis.uses_slots) {
		component_block.body.unshift(const_builder('$$slots', call('$.sanitize_slots', id$2('$$props'))));
	}

	const body = [...state.hoisted, ...module.body];

	if (analysis.css.ast !== null && options.css === 'injected' && !options.customElement) {
		const hash = literal(analysis.css.hash);
		const code = literal(render_stylesheet(analysis.source, analysis, options).code);

		body.push(const_builder('$$css', object$2([init('hash', hash), init('code', code)])));
		component_block.body.unshift(stmt(call('$$renderer.global.css.add', id$2('$$css'))));
	}

	let should_inject_props =
		should_inject_context ||
		props.length > 0 ||
		analysis.needs_props ||
		analysis.uses_props ||
		analysis.uses_rest_props ||
		analysis.uses_slots ||
		analysis.slot_names.size > 0;

	const component_function = function_declaration(
		id$2(analysis.name),
		should_inject_props ? [id$2('$$renderer'), id$2('$$props')] : [id$2('$$renderer')],
		component_block
	);

	if (options.compatibility.componentApi === 4) {
		body.unshift(imports([['render', '$$_render']], 'svelte/server'));
		body.push(
			component_function,
			stmt(
				assignment(
					'=',
					member_id(`${analysis.name}.render`),
					function_builder(
						null,
						[id$2('$$props'), id$2('$$opts')],
						block([
							return_builder(
								call(
									'$$_render',
									id$2(analysis.name),
									object$2([
										init('props', id$2('$$props')),
										init('context', member(id$2('$$opts'), 'context', false, true))
									])
								)
							)
						])
					)
				)
			),
			export_default(id$2(analysis.name))
		);
	} else if (dev) {
		body.push(
			component_function,
			stmt(
				assignment(
					'=',
					member_id(`${analysis.name}.render`),
					function_builder(
						null,
						[],
						block([
							throw_error$1(
								`Component.render(...) is no longer valid in Svelte 5. ` +
									'See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information'
							)
						])
					)
				)
			),
			export_default(id$2(analysis.name))
		);
	} else {
		body.push(export_default(component_function));
	}

	if (dev) {
		// add `App[$.FILENAME] = 'App.svelte'` so that we can print useful messages later
		body.unshift(
			stmt(
				assignment('=', member(id$2(analysis.name), '$.FILENAME', true), literal(filename))
			)
		);
	}

	if (options.experimental.async) {
		body.unshift(imports([], 'svelte/internal/flags/async'));
	}

	return {
		type: 'Program',
		sourceType: 'module',
		body
	};
}

/**
 * @param {Analysis} analysis
 * @param {ValidatedModuleCompileOptions} options
 * @returns {ESTree.Program}
 */
function server_module(analysis, options) {
	/** @type {ServerTransformState} */
	const state = {
		analysis,
		options,
		scope: analysis.module.scope,
		scopes: analysis.module.scopes,
		// this is an anomaly — it can only be used in components, but it needs
		// to be present for `javascript_visitors_legacy` and so is included in module
		// transform state as well as component transform state
		legacy_reactive_statements: new Map(),
		state_fields: new Map(),
		is_instance: false
	};

	const module = /** @type {ESTree.Program} */ (
		walk$1(/** @type {AST.SvelteNode} */ (analysis.module.ast), state, global_visitors)
	);

	return {
		type: 'Program',
		sourceType: 'module',
		body: [import_all('$', 'svelte/internal/server'), ...module.body]
	};
}

/** @import { AssignmentExpression, Expression, Identifier, MemberExpression, SequenceExpression, Literal, Super, UpdateExpression, ExpressionStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentClientTransformState, ComponentContext, Context } from '../../types' */

/**
 * A utility for extracting complex expressions (such as call expressions)
 * from templates and replacing them with `$0`, `$1` etc
 */
class Memoizer {
	/** @type {Array<{ id: Identifier, expression: Expression }>} */
	#sync = [];

	/** @type {Array<{ id: Identifier, expression: Expression }>} */
	#async = [];

	/** @type {Set<Expression>} */
	#blockers = new Set();

	/**
	 * @param {Expression} expression
	 * @param {ExpressionMetadata} metadata
	 * @param {boolean} memoize_if_state
	 */
	add(expression, metadata, memoize_if_state = false) {
		this.check_blockers(metadata);

		const should_memoize =
			metadata.has_call || metadata.has_await || (memoize_if_state && metadata.has_state);

		if (!should_memoize) {
			// no memoization required
			return expression;
		}

		const id = id$2('#'); // filled in later

		(metadata.has_await ? this.#async : this.#sync).push({ id, expression });

		return id;
	}

	/**
	 * @param {ExpressionMetadata} metadata
	 */
	check_blockers(metadata) {
		for (const binding of metadata.dependencies) {
			if (binding.blocker) {
				this.#blockers.add(binding.blocker);
			}
		}
	}

	apply() {
		return [...this.#sync, ...this.#async].map((memo, i) => {
			memo.id.name = `$${i}`;
			return memo.id;
		});
	}

	blockers() {
		return this.#blockers.size > 0 ? array([...this.#blockers]) : undefined;
	}

	deriveds(runes = true) {
		return this.#sync.map((memo) =>
			let_builder(memo.id, call(runes ? '$.derived' : '$.derived_safe_equal', thunk(memo.expression)))
		);
	}

	async_ids() {
		return this.#async.map((memo) => memo.id);
	}

	async_values() {
		if (this.#async.length === 0) return;
		return array(this.#async.map((memo) => thunk(memo.expression, true)));
	}

	sync_values() {
		if (this.#sync.length === 0) return;
		return array(this.#sync.map((memo) => thunk(memo.expression)));
	}
}

/**
 * @param {Array<AST.Text | AST.ExpressionTag>} values
 * @param {ComponentContext} context
 * @param {ComponentClientTransformState} state
 * @param {(value: Expression, metadata: ExpressionMetadata) => Expression} memoize
 * @returns {{ value: Expression, has_state: boolean }}
 */
function build_template_chunk(
	values,
	context,
	state = context.state,
	memoize = (value, metadata) => state.memoizer.add(value, metadata)
) {
	/** @type {Expression[]} */
	const expressions = [];

	let quasi$1 = quasi('');
	const quasis = [quasi$1];

	let has_state = false;
	let has_await = false;

	for (let i = 0; i < values.length; i++) {
		const node = values[i];

		if (node.type === 'Text') {
			quasi$1.value.cooked += node.data;
		} else if (node.expression.type === 'Literal') {
			if (node.expression.value != null) {
				quasi$1.value.cooked += node.expression.value + '';
			}
		} else if (
			node.expression.type !== 'Identifier' ||
			node.expression.name !== 'undefined' ||
			state.scope.get('undefined')
		) {
			let value = memoize(
				build_expression(context, node.expression, node.metadata.expression, state),
				node.metadata.expression
			);

			const evaluated = state.scope.evaluate(value);

			has_await ||= node.metadata.expression.has_await;
			has_state ||= has_await || (node.metadata.expression.has_state && !evaluated.is_known);

			if (values.length === 1) {
				// If we have a single expression, then pass that in directly to possibly avoid doing
				// extra work in the template_effect (instead we do the work in set_text).
				if (evaluated.is_known) {
					value = literal((evaluated.value ?? '') + '');
				}

				return { value, has_state };
			}

			if (
				value.type === 'LogicalExpression' &&
				value.right.type === 'Literal' &&
				(value.operator === '??' || value.operator === '||')
			) {
				// `foo ?? null` -=> `foo ?? ''`
				// otherwise leave the expression untouched
				if (value.right.value === null) {
					value = { ...value, right: literal('') };
				}
			}

			if (evaluated.is_known) {
				quasi$1.value.cooked += (evaluated.value ?? '') + '';
			} else {
				if (!evaluated.is_defined) {
					// add `?? ''` where necessary
					value = logical$1('??', value, literal(''));
				}

				expressions.push(value);

				quasi$1 = quasi('', i + 1 === values.length);
				quasis.push(quasi$1);
			}
		}
	}

	for (const quasi of quasis) {
		quasi.value.raw = sanitize_template_string(/** @type {string} */ (quasi.value.cooked));
	}

	const value =
		expressions.length > 0
			? template(quasis, expressions)
			: literal(/** @type {string} */ (quasi$1.value.cooked));

	return { value, has_state };
}

/**
 * @param {ComponentClientTransformState} state
 */
function build_render_statement(state) {
	const { memoizer } = state;

	const ids = memoizer.apply();

	return stmt(
		call(
			'$.template_effect',
			arrow(
				ids,
				state.update.length === 1 && state.update[0].type === 'ExpressionStatement'
					? state.update[0].expression
					: block(state.update)
			),
			memoizer.sync_values(),
			memoizer.async_values(),
			memoizer.blockers()
		)
	);
}

/**
 * For unfortunate legacy reasons, directive names can look like this `use:a.b-c`
 * This turns that string into a member expression
 * @param {string} name
 */
function parse_directive_name(name) {
	// this allow for accessing members of an object
	const parts = name.split('.');
	let part = /** @type {string} */ (parts.shift());

	/** @type {Identifier | MemberExpression} */
	let expression = id$2(part);

	while ((part = /** @type {string} */ (parts.shift()))) {
		const computed = !regex_is_valid_identifier.test(part);
		expression = member(expression, computed ? literal(part) : id$2(part), computed);
	}

	return expression;
}

/**
 * Serializes `bind:this` for components and elements.
 * @param {Identifier | MemberExpression | SequenceExpression} expression
 * @param {Expression} value
 * @param {import('zimmerframe').Context<AST.SvelteNode, ComponentClientTransformState>} context
 */
function build_bind_this(expression, value, { state, visit }) {
	const [getter, setter] =
		expression.type === 'SequenceExpression' ? expression.expressions : [null, null];

	/** @type {Identifier[]} */
	const ids = [];

	/** @type {Expression[]} */
	const values = [];

	/** @type {string[]} */
	const seen = [];

	const transform = { ...state.transform };

	// Pass in each context variables to the get/set functions, so that we can null out old values on teardown.
	// Note that we only do this for each context variables, the consequence is that the value might be stale in
	// some scenarios where the value is a member expression with changing computed parts or using a combination of multiple
	// variables, but that was the same case in Svelte 4, too. Once legacy mode is gone completely, we can revisit this.
	walk$1(getter ?? expression, null, {
		Identifier(node, { path }) {
			if (seen.includes(node.name)) return;
			seen.push(node.name);

			const parent = /** @type {Expression} */ (path.at(-1));
			if (!is_reference(node, parent)) return;

			const binding = state.scope.get(node.name);
			if (!binding) return;

			for (const [owner, scope] of state.scopes) {
				if (owner.type === 'EachBlock' && scope === binding.scope) {
					ids.push(node);
					values.push(/** @type {Expression} */ (visit(node)));

					if (transform[node.name]) {
						transform[node.name] = {
							...transform[node.name],
							read: (node) => node
						};
					}

					break;
				}
			}
		}
	});

	const child_state = { ...state, transform };

	let get = /** @type {Expression} */ (visit(getter ?? expression, child_state));
	let set = /** @type {Expression} */ (
		visit(
			setter ??
				assignment(
					'=',
					/** @type {Identifier | MemberExpression} */ (expression),
					id$2('$$value')
				),
			child_state
		)
	);

	// If we're mutating a property, then it might already be non-existent.
	// If we make all the object nodes optional, then it avoids any runtime exceptions.
	/** @type {Expression | Super} */
	let node = get;

	while (node.type === 'MemberExpression') {
		node.optional = true;
		node = node.object;
	}

	get =
		get.type === 'ArrowFunctionExpression'
			? arrow([...ids], get.body)
			: get.type === 'FunctionExpression'
				? function_builder(null, [...ids], get.body)
				: getter
					? get
					: arrow([...ids], get);

	set =
		set.type === 'ArrowFunctionExpression'
			? arrow([set.params[0] ?? id$2('_'), ...ids], set.body)
			: set.type === 'FunctionExpression'
				? function_builder(null, [set.params[0] ?? id$2('_'), ...ids], set.body)
				: setter
					? set
					: arrow([id$2('$$value'), ...ids], set);

	return call('$.bind_this', value, set, get, values.length > 0 && thunk(array(values)));
}

/**
 * @param {ComponentClientTransformState} state
 * @param {AST.BindDirective} binding
 * @param {MemberExpression} expression
 */
function validate_binding(state, binding, expression) {
	if (binding.expression.type === 'SequenceExpression') {
		return;
	}
	// If we are referencing a $store.foo then we don't need to add validation
	const left = object$1(binding.expression);
	const left_binding = left && state.scope.get(left.name);
	if (left_binding?.kind === 'store_sub') return;

	const loc = locator(binding.start);

	const obj = /** @type {Expression} */ (expression.object);

	state.init.push(
		stmt(
			call(
				'$.validate_binding',
				literal(state.analysis.source.slice(binding.start, binding.end)),
				binding.metadata.expression.blockers(),
				thunk(
					state.store_to_invalidate ? sequence([call('$.mark_store_binding'), obj]) : obj
				),
				thunk(
					/** @type {Expression} */ (
						expression.computed
							? expression.property
							: literal(/** @type {Identifier} */ (expression.property).name)
					)
				),
				literal(loc.line),
				literal(loc.column)
			)
		)
	);
}

/**
 * In dev mode validate mutations to props
 * @param {AssignmentExpression | UpdateExpression} node
 * @param {Context} context
 * @param {Expression} expression
 */
function validate_mutation(node, context, expression) {
	let left = /** @type {Expression | Super} */ (
		node.type === 'AssignmentExpression' ? node.left : node.argument
	);

	if (!dev || left.type !== 'MemberExpression' || is_ignored(node, 'ownership_invalid_mutation')) {
		return expression;
	}

	const name = object$1(left);
	if (!name) return expression;

	const binding = context.state.scope.get(name.name);
	if (binding?.kind !== 'prop' && binding?.kind !== 'bindable_prop') return expression;

	const state = /** @type {ComponentClientTransformState} */ (context.state);
	state.analysis.needs_mutation_validation = true;

	/** @type {Array<Identifier | Literal | Expression>} */
	const path = [];

	while (left.type === 'MemberExpression') {
		if (left.property.type === 'Literal') {
			path.unshift(left.property);
		} else if (left.property.type === 'Identifier') {
			const transform = Object.hasOwn(context.state.transform, left.property.name)
				? context.state.transform[left.property.name]
				: null;
			if (left.computed) {
				path.unshift(transform?.read ? transform.read(left.property) : left.property);
			} else {
				path.unshift(literal(left.property.name));
			}
		} else {
			return expression;
		}

		left = left.object;
	}

	path.unshift(literal(name.name));

	const loc = locator(/** @type {number} */ (left.start));

	return call(
		'$$ownership_validator.mutation',
		literal(binding.prop_alias),
		array(path),
		expression,
		loc && literal(loc.line),
		loc && literal(loc.column)
	);
}

/**
 *
 * @param {ComponentContext} context
 * @param {Expression} expression
 * @param {ExpressionMetadata} metadata
 */
function build_expression(context, expression, metadata, state = context.state) {
	const value = /** @type {Expression} */ (context.visit(expression, state));

	// Components not explicitly in legacy mode might be expected to be in runes mode (especially since we didn't
	// adjust this behavior until recently, which broke people's existing components), so we also bail in this case.
	// Kind of an in-between-mode.
	if (context.state.analysis.runes || context.state.analysis.maybe_runes) {
		return value;
	}

	if (!metadata.has_call && !metadata.has_member_expression && !metadata.has_assignment) {
		return value;
	}

	// Legacy reactivity is coarse-grained, looking at the statically visible dependencies. Replicate that here
	const sequence$1 = sequence([]);

	for (const binding of metadata.references) {
		if (binding.kind === 'normal' && binding.declaration_kind !== 'import') {
			continue;
		}

		var getter = build_getter$1({ ...binding.node }, state);

		if (
			binding.kind === 'bindable_prop' ||
			binding.kind === 'template' ||
			binding.declaration_kind === 'import' ||
			binding.node.name === '$$props' ||
			binding.node.name === '$$restProps'
		) {
			getter = call('$.deep_read_state', getter);
		}

		sequence$1.expressions.push(getter);
	}

	sequence$1.expressions.push(call('$.untrack', thunk(value)));

	return sequence$1;
}

/**
 * Wraps a statement/expression with dev stack tracking in dev mode
 * @param {Expression} expression - The function call to wrap (e.g., $.if, $.each, etc.)
 * @param {{ start?: number }} node - AST node for location info
 * @param {'component' | 'if' | 'each' | 'await' | 'key' | 'render'} type - Type of block/component
 * @param {Record<string, number | string>} [additional] - Any additional properties to add to the dev stack entry
 * @returns {ExpressionStatement} - Statement with or without dev stack wrapping
 */
function add_svelte_meta(expression, node, type, additional) {
	if (!dev) {
		return stmt(expression);
	}

	const location = node.start !== undefined && locator(node.start);
	if (!location) {
		return stmt(expression);
	}

	return stmt(
		call(
			'$.add_svelte_meta',
			arrow([], expression),
			literal(type),
			id$2(component_name),
			literal(location.line),
			literal(location.column),
			additional && object$2(Object.entries(additional).map(([k, v]) => init(k, literal(v))))
		)
	);
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.AnimateDirective} node
 * @param {ComponentContext} context
 */
function AnimateDirective(node, context) {
	const expression =
		node.expression === null
			? null_instance
			: thunk(/** @type {Expression} */ (context.visit(node.expression)));

	// in after_update to ensure it always happens after bind:this
	let statement = stmt(
		call(
			'$.animation',
			context.state.node,
			thunk(/** @type {Expression} */ (context.visit(parse_directive_name(node.name)))),
			expression
		)
	);

	if (node.metadata.expression.is_async()) {
		statement = stmt(
			call(
				'$.run_after_blockers',
				node.metadata.expression.blockers(),
				thunk(block([statement]))
			)
		);
	}

	context.state.after_update.push(statement);
}

/** @import { ArrowFunctionExpression, FunctionExpression, Node } from 'estree' */
/** @import { ComponentContext } from '../../types' */

/**
 * @param {ArrowFunctionExpression | FunctionExpression} node
 * @param {ComponentContext} context
 */
const visit_function = (node, context) => {
	let state = { ...context.state, in_constructor: false, in_derived: false };

	if (node.type === 'FunctionExpression') {
		const parent = /** @type {Node} */ (context.path.at(-1));
		state.in_constructor = parent.type === 'MethodDefinition' && parent.kind === 'constructor';
	}

	context.next(state);
};

/** @import { ArrowFunctionExpression } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {ArrowFunctionExpression} node
 * @param {ComponentContext} context
 */
function ArrowFunctionExpression(node, context) {
	return visit_function(node, context);
}

/** @import { AssignmentExpression, AssignmentOperator, Expression, Identifier, Pattern } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { Context } from '../types.js' */

/**
 * @param {AssignmentExpression} node
 * @param {Context} context
 */
function AssignmentExpression(node, context) {
	const expression = /** @type {Expression} */ (
		visit_assignment_expression(node, context, build_assignment) ?? context.next()
	);

	return validate_mutation(node, context, expression);
}

/**
 * Determines whether the value will be coerced on assignment (as with e.g. `+=`).
 * If not, we may need to proxify the value, or warn that the value will not be
 * proxified in time
 * @param {AssignmentOperator} operator
 */
function is_non_coercive_operator(operator) {
	return ['=', '||=', '&&=', '??='].includes(operator);
}

/** @type {Record<string, string>} */
const callees = {
	'=': '$.assign',
	'&&=': '$.assign_and',
	'||=': '$.assign_or',
	'??=': '$.assign_nullish'
};

/**
 * @param {AssignmentOperator} operator
 * @param {Pattern} left
 * @param {Expression} right
 * @param {Context} context
 * @returns {Expression | null}
 */
function build_assignment(operator, left, right, context) {
	if (context.state.analysis.runes && left.type === 'MemberExpression') {
		const name = get_name(left.property);
		const field = name && context.state.state_fields.get(name);

		if (field) {
			// special case — state declaration in class constructor
			if (field.node.type === 'AssignmentExpression' && left === field.node.left) {
				const rune = get_rune(right, context.state.scope);

				if (rune) {
					const child_state = {
						...context.state,
						in_constructor: rune !== '$derived' && rune !== '$derived.by'
					};

					let value = /** @type {Expression} */ (context.visit(right, child_state));

					if (dev) {
						const declaration = context.path.findLast(
							(parent) => parent.type === 'ClassDeclaration' || parent.type === 'ClassExpression'
						);
						value = call(
							'$.tag',
							value,
							literal(`${declaration?.id?.name ?? '[class]'}.${name}`)
						);
					}

					return assignment(operator, member(this_instance, field.key), value);
				}
			}

			// special case — assignment to private state field
			if (left.property.type === 'PrivateIdentifier') {
				let value = /** @type {Expression} */ (
					context.visit(build_assignment_value(operator, left, right))
				);

				const needs_proxy =
					field.type === '$state' &&
					is_non_coercive_operator(operator) &&
					should_proxy(value, context.state.scope);

				return call('$.set', left, value, needs_proxy && true_instance);
			}
		}
	}

	let object = left;

	while (object.type === 'MemberExpression') {
		// @ts-expect-error
		object = object.object;
	}

	if (object.type !== 'Identifier') {
		return null;
	}

	const binding = context.state.scope.get(object.name);
	if (!binding) return null;

	const transform = Object.hasOwn(context.state.transform, object.name)
		? context.state.transform[object.name]
		: null;

	const path = context.path.map((node) => node.type);

	// reassignment
	if (object === left && transform?.assign) {
		// special case — if an element binding, we know it's a primitive

		const is_primitive = path.at(-1) === 'BindDirective' && path.at(-2) === 'RegularElement';

		let value = /** @type {Expression} */ (
			context.visit(build_assignment_value(operator, left, right))
		);

		return transform.assign(
			object,
			value,
			!is_primitive &&
				binding.kind !== 'prop' &&
				binding.kind !== 'bindable_prop' &&
				binding.kind !== 'raw_state' &&
				binding.kind !== 'derived' &&
				binding.kind !== 'store_sub' &&
				context.state.analysis.runes &&
				should_proxy(right, context.state.scope) &&
				is_non_coercive_operator(operator)
		);
	}

	// mutation
	if (transform?.mutate) {
		return transform.mutate(
			object,
			assignment(
				operator,
				/** @type {Pattern} */ (context.visit(left)),
				/** @type {Expression} */ (context.visit(right))
			)
		);
	}

	// in cases like `(object.items ??= []).push(value)`, we may need to warn
	// if the value gets proxified, since the proxy _isn't_ the thing that
	// will be pushed to. we do this by transforming it to something like
	// `$.assign_nullish(object, 'items', [])`
	let should_transform =
		dev && path.at(-1) !== 'ExpressionStatement' && is_non_coercive_operator(operator);

	// special case — ignore `onclick={() => (...)}`
	if (
		path.at(-1) === 'ArrowFunctionExpression' &&
		(path.at(-2) === 'RegularElement' || path.at(-2) === 'SvelteElement')
	) {
		const element = /** @type {AST.RegularElement} */ (context.path.at(-2));

		const attribute = element.attributes.find((attribute) => {
			if (attribute.type !== 'Attribute' || !is_event_attribute(attribute)) {
				return false;
			}

			const expression = get_attribute_expression(attribute);

			return expression === context.path.at(-1);
		});

		if (attribute) {
			should_transform = false;
		}
	}

	// special case — ignore `bind:prop={getter, (v) => (...)}` / `bind:value={x.y}`
	if (
		path.at(-1) === 'BindDirective' ||
		path.at(-1) === 'Component' ||
		path.at(-1) === 'SvelteComponent' ||
		(path.at(-1) === 'ArrowFunctionExpression' &&
			(path.at(-2) === 'BindDirective' ||
				(path.at(-2) === 'Component' && path.at(-3) === 'Fragment') ||
				(path.at(-2) === 'SequenceExpression' &&
					(path.at(-3) === 'Component' ||
						path.at(-3) === 'SvelteComponent' ||
						path.at(-3) === 'BindDirective'))))
	) {
		should_transform = false;
	}

	if (left.type === 'MemberExpression' && should_transform) {
		const callee = callees[operator];
		return /** @type {Expression} */ (
			context.visit(
				call(
					callee,
					/** @type {Expression} */ (left.object),
					/** @type {Expression} */ (
						left.computed
							? left.property
							: literal(/** @type {Identifier} */ (left.property).name)
					),
					right,
					literal(locate_node(left))
				)
			)
		);
	}

	return null;
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../../types' */

/**
 * @param {AST.Attribute} node
 * @param {ComponentContext} context
 */
function visit_event_attribute(node, context) {
	let capture = false;

	let event_name = node.name.slice(2);
	if (is_capture_event(event_name)) {
		event_name = event_name.slice(0, -7);
		capture = true;
	}

	// we still need to support the weird `onclick="{() => {...}}" form
	const tag = Array.isArray(node.value)
		? /** @type {AST.ExpressionTag} */ (node.value[0])
		: /** @type {AST.ExpressionTag} */ (node.value);

	let handler = build_event_handler(tag.expression, tag.metadata.expression, context);

	if (node.metadata.delegated) {
		if (!context.state.events.has(event_name)) {
			context.state.events.add(event_name);
		}

		context.state.init.push(
			stmt(
				assignment(
					'=',
					member(context.state.node, id$2('__' + event_name, node.name_loc)),
					handler
				)
			)
		);
	} else {
		const statement = stmt(
			build_event(
				event_name,
				context.state.node,
				handler,
				capture,
				is_passive_event(event_name) ? true : undefined
			)
		);

		const type = /** @type {AST.SvelteNode} */ (context.path.at(-1)).type;

		if (type === 'SvelteDocument' || type === 'SvelteWindow' || type === 'SvelteBody') {
			// These nodes are above the component tree, and its events should run parent first
			context.state.init.push(statement);
		} else {
			context.state.after_update.push(statement);
		}
	}
}

/**
 * Creates a `$.event(...)` call for non-delegated event handlers
 * @param {string} event_name
 * @param {Expression} node
 * @param {Expression} handler
 * @param {boolean} capture
 * @param {boolean | undefined} passive
 */
function build_event(event_name, node, handler, capture, passive) {
	return call(
		'$.event',
		literal(event_name),
		node,
		handler,
		capture && true_instance,
		passive === undefined ? undefined : literal(passive)
	);
}

/**
 * Creates an event handler
 * @param {Expression | null} node
 * @param {ExpressionMetadata} metadata
 * @param {ComponentContext} context
 * @returns {Expression}
 */
function build_event_handler(node, metadata, context) {
	if (node === null) {
		// bubble event
		return function_builder(
			null,
			[id$2('$$arg')],
			block([stmt(call('$.bubble_event.call', this_instance, id$2('$$props'), id$2('$$arg')))])
		);
	}

	let handler = /** @type {Expression} */ (context.visit(node));

	// inline handler
	if (handler.type === 'ArrowFunctionExpression' || handler.type === 'FunctionExpression') {
		return handler;
	}

	// function declared in the script
	if (handler.type === 'Identifier') {
		const binding = context.state.scope.get(handler.name);

		if (binding?.is_function()) {
			return handler;
		}

		// local variable can be assigned directly
		// except in dev mode where when need $.apply()
		// in order to handle warnings.
		if (!dev && binding?.declaration_kind !== 'import') {
			return handler;
		}
	}

	if (metadata.has_call) {
		// memoize where necessary
		const id = id$2(context.state.scope.generate('event_handler'));

		context.state.init.push(var_builder(id, call('$.derived', thunk(handler))));
		handler = call('$.get', id);
	}

	// wrap the handler in a function, so the expression is re-evaluated for each event
	let call$1 = call(member(handler, 'apply', false, true), this_instance, id$2('$$args'));

	if (dev) {
		const loc = locator(/** @type {number} */ (node.start));

		const remove_parens =
			node.type === 'CallExpression' &&
			node.arguments.length === 0 &&
			node.callee.type === 'Identifier';

		call$1 = call(
			'$.apply',
			thunk(handler),
			this_instance,
			id$2('$$args'),
			id$2(context.state.analysis.name),
			array([literal(loc.line), literal(loc.column)]),
			has_side_effects(node) && true_instance,
			remove_parens && true_instance
		);
	}

	return function_builder(null, [rest(id$2('$$args'))], block([stmt(call$1)]));
}

/**
 * @param {Expression} node
 */
function has_side_effects(node) {
	if (
		node.type === 'CallExpression' ||
		node.type === 'NewExpression' ||
		node.type === 'AssignmentExpression' ||
		node.type === 'UpdateExpression'
	) {
		return true;
	}

	if (node.type === 'SequenceExpression') {
		return node.expressions.some(has_side_effects);
	}

	return false;
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.Attribute} node
 * @param {ComponentContext} context
 */
function Attribute(node, context) {
	if (is_event_attribute(node)) {
		visit_event_attribute(node, context);
	}
}

/** @import { BlockStatement, Pattern, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentClientTransformState, ComponentContext } from '../types' */

/**
 * @param {AST.AwaitBlock} node
 * @param {ComponentContext} context
 */
function AwaitBlock(node, context) {
	context.state.template.push_comment();

	// Visit {#await <expression>} first to ensure that scopes are in the correct order
	const expression = thunk(
		build_expression(context, node.expression, node.metadata.expression),
		node.metadata.expression.has_await
	);

	let then_block;
	let catch_block;

	if (node.then) {
		const then_context = {
			...context,
			state: { ...context.state, transform: { ...context.state.transform } }
		};
		const argument = node.value && create_derived_block_argument(node.value, then_context);

		/** @type {Pattern[]} */
		const args = [id$2('$$anchor')];
		if (argument) args.push(argument.id);

		const declarations = argument?.declarations ?? [];
		const block$1 = /** @type {BlockStatement} */ (then_context.visit(node.then, then_context.state));

		then_block = arrow(args, block([...declarations, ...block$1.body]));
	}

	if (node.catch) {
		const catch_context = { ...context, state: { ...context.state } };
		const argument = node.error && create_derived_block_argument(node.error, catch_context);

		/** @type {Pattern[]} */
		const args = [id$2('$$anchor')];
		if (argument) args.push(argument.id);

		const declarations = argument?.declarations ?? [];
		const block$1 = /** @type {BlockStatement} */ (
			catch_context.visit(node.catch, catch_context.state)
		);

		catch_block = arrow(args, block([...declarations, ...block$1.body]));
	}

	const stmt$1 = add_svelte_meta(
		call(
			'$.await',
			context.state.node,
			expression,
			node.pending
				? arrow([id$2('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.pending)))
				: null_instance,
			then_block,
			catch_block
		),
		node,
		'await'
	);

	if (node.metadata.expression.has_blockers()) {
		context.state.init.push(
			stmt(
				call(
					'$.async',
					context.state.node,
					node.metadata.expression.blockers(),
					array([]),
					arrow([context.state.node], block([stmt$1]))
				)
			)
		);
	} else {
		context.state.init.push(stmt$1);
	}
}

/**
 * @param {Pattern} node
 * @param {import('zimmerframe').Context<AST.SvelteNode, ComponentClientTransformState>} context
 * @returns {{ id: Pattern, declarations: null | Statement[] }}
 */
function create_derived_block_argument(node, context) {
	if (node.type === 'Identifier') {
		context.state.transform[node.name] = { read: get_value };
		return { id: node, declarations: null };
	}

	const pattern = /** @type {Pattern} */ (context.visit(node));
	const identifiers = extract_identifiers(node);

	const id = id$2('$$source');
	const value = id$2('$$value');

	const block$1 = block([
		var_builder(pattern, call('$.get', id)),
		return_builder(object$2(identifiers.map((identifier) => prop('init', identifier, identifier))))
	]);

	const declarations = [var_builder(value, create_derived(context.state, block$1))];

	for (const id of identifiers) {
		context.state.transform[id.name] = { read: get_value };

		declarations.push(
			var_builder(id, create_derived(context.state, member(call('$.get', value), id)))
		);
	}

	return { id, declarations };
}

/** @import { AwaitExpression, Expression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {AwaitExpression} node
 * @param {Context} context
 */
function AwaitExpression(node, context) {
	const argument = /** @type {Expression} */ (context.visit(node.argument));

	if (context.state.analysis.pickled_awaits.has(node)) {
		return save(argument);
	}

	// in dev, note which values are read inside a reactive expression,
	// but don't track them
	else if (dev && !is_ignored(node, 'await_reactivity_loss')) {
		return call(await_builder(call('$.track_reactivity_loss', argument)));
	}

	return argument === node.argument ? node : { ...node, argument };
}

/** @import { Expression, BinaryExpression } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {BinaryExpression} node
 * @param {ComponentContext} context
 */
function BinaryExpression(node, context) {
	if (dev) {
		const operator = node.operator;

		if (operator === '===' || operator === '!==') {
			return call(
				'$.strict_equals',
				/** @type {Expression} */ (context.visit(node.left)),
				/** @type {Expression} */ (context.visit(node.right)),
				operator === '!==' && false_instance
			);
		}

		if (operator === '==' || operator === '!=') {
			return call(
				'$.equals',
				/** @type {Expression} */ (context.visit(node.left)),
				/** @type {Expression} */ (context.visit(node.right)),
				operator === '!=' && false_instance
			);
		}
	}

	context.next();
}

/** @import { Expression, Identifier, SourceLocation } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../../types' */

/**
 * Processes an array of template nodes, joining sibling text/expression nodes
 * (e.g. `{a} b {c}`) into a single update function. Along the way it creates
 * corresponding template node references these updates are applied to.
 * @param {AST.SvelteNode[]} nodes
 * @param {(is_text: boolean) => Expression} initial
 * @param {boolean} is_element
 * @param {ComponentContext} context
 */
function process_children(nodes, initial, is_element, context) {
	const within_bound_contenteditable = context.state.metadata.bound_contenteditable;
	let prev = initial;
	let skipped = 0;

	/** @typedef {Array<AST.Text | AST.ExpressionTag>} Sequence */
	/** @type {Sequence} */
	let sequence = [];

	/** @param {boolean} is_text */
	function get_node(is_text) {
		if (skipped === 0) {
			return prev(is_text);
		}

		return call(
			'$.sibling',
			prev(false),
			(is_text || skipped !== 1) && literal(skipped),
			is_text && true_instance
		);
	}

	/**
	 * @param {boolean} is_text
	 * @param {string} name
	 * @param {SourceLocation | null} [loc]
	 */
	function flush_node(is_text, name, loc) {
		const expression = get_node(is_text);
		let id = expression;

		if (id.type !== 'Identifier') {
			id = id$2(context.state.scope.generate(name), loc);
			context.state.init.push(var_builder(id, expression));
		}

		prev = () => id;
		skipped = 1; // the next node is `$.sibling(id)`

		return id;
	}

	/**
	 * @param {Sequence} sequence
	 */
	function flush_sequence(sequence) {
		if (sequence.every((node) => node.type === 'Text')) {
			skipped += 1;
			context.state.template.push_text(sequence);
			return;
		}

		context.state.template.push_text([{ type: 'Text', data: ' ', raw: ' ', start: -1, end: -1 }]);

		const { has_state, value } = build_template_chunk(sequence, context);

		// if this is a standalone `{expression}`, make sure we handle the case where
		// no text node was created because the expression was empty during SSR
		const is_text = sequence.length === 1;
		const id = flush_node(is_text, 'text');

		const update = stmt(call('$.set_text', id, value));

		if (has_state && !within_bound_contenteditable) {
			context.state.update.push(update);
		} else {
			context.state.init.push(stmt(assignment('=', member(id, 'nodeValue'), value)));
		}
	}

	for (const node of nodes) {
		if (node.type === 'Text' || node.type === 'ExpressionTag') {
			sequence.push(node);
		} else {
			if (sequence.length > 0) {
				flush_sequence(sequence);
				sequence = [];
			}

			let child_state = context.state;

			if (is_static_element(node, context.state)) {
				skipped += 1;
			} else if (
				node.type === 'EachBlock' &&
				nodes.length === 1 &&
				is_element &&
				// In case it's wrapped in async the async logic will want to skip sibling nodes up until the end, hence we cannot make this controlled
				// TODO switch this around and instead optimize for elements with a single block child and not require extra comments (neither for async nor normally)
				!node.metadata.expression.is_async()
			) {
				node.metadata.is_controlled = true;
			} else {
				const id = flush_node(
					false,
					node.type === 'RegularElement' ? node.name : 'node',
					node.type === 'RegularElement' ? node.name_loc : null
				);

				child_state = { ...context.state, node: id };
			}

			context.visit(node, child_state);
		}
	}

	if (sequence.length > 0) {
		flush_sequence(sequence);
	}

	// if there are trailing static text nodes/elements,
	// traverse to the last (n - 1) one when hydrating
	if (skipped > 1) {
		skipped -= 1;
		context.state.init.push(stmt(call('$.next', skipped !== 1 && literal(skipped))));
	}
}

/**
 * @param {AST.SvelteNode} node
 * @param {ComponentContext["state"]} state
 */
function is_static_element(node, state) {
	if (node.type !== 'RegularElement') return false;
	if (node.fragment.metadata.dynamic) return false;
	if (is_custom_element_node(node)) return false; // we're setting all attributes on custom elements through properties

	for (const attribute of node.attributes) {
		if (attribute.type !== 'Attribute') {
			return false;
		}

		if (is_event_attribute(attribute)) {
			return false;
		}

		if (cannot_be_set_statically(attribute.name)) {
			return false;
		}

		if (attribute.name === 'dir') {
			return false;
		}

		if (
			['input', 'textarea'].includes(node.name) &&
			['value', 'checked'].includes(attribute.name)
		) {
			return false;
		}

		if (node.name === 'option' && attribute.name === 'value') {
			return false;
		}

		// We need to apply src and loading after appending the img to the DOM for lazy loading to work
		if (node.name === 'img' && attribute.name === 'loading') {
			return false;
		}

		if (attribute.value !== true && !is_text_attribute(attribute)) {
			return false;
		}
	}

	return true;
}

/** @import { ArrayExpression, Expression, ExpressionStatement, Identifier, MemberExpression, ObjectExpression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentClientTransformState, ComponentContext } from '../types' */
/** @import { Scope } from '../../../scope' */

/**
 * @param {AST.RegularElement} node
 * @param {ComponentContext} context
 */
function RegularElement(node, context) {
	context.state.template.push_element(node.name, node.start);

	if (node.name === 'noscript') {
		context.state.template.pop_element();
		return;
	}

	const is_custom_element = is_custom_element_node(node);

	// cloneNode is faster, but it does not instantiate the underlying class of the
	// custom element until the template is connected to the dom, which would
	// cause problems when setting properties on the custom element.
	// Therefore we need to use importNode instead, which doesn't have this caveat.
	// Additionally, Webkit browsers need importNode for video elements for autoplay
	// to work correctly.
	context.state.template.needs_import_node ||= node.name === 'video' || is_custom_element;

	context.state.template.contains_script_tag ||= node.name === 'script';

	/** @type {Array<AST.Attribute | AST.SpreadAttribute>} */
	const attributes = [];

	/** @type {AST.ClassDirective[]} */
	const class_directives = [];

	/** @type {AST.StyleDirective[]} */
	const style_directives = [];

	/** @type {Array<AST.AnimateDirective | AST.BindDirective | AST.OnDirective | AST.TransitionDirective | AST.UseDirective | AST.AttachTag>} */
	const other_directives = [];

	/** @type {ExpressionStatement[]} */
	const lets = [];

	/** @type {Map<string, AST.Attribute>} */
	const lookup = new Map();

	/** @type {Map<string, AST.BindDirective>} */
	const bindings = new Map();

	let has_spread = node.metadata.has_spread;
	let has_use = false;
	let should_remove_defaults = false;

	for (const attribute of node.attributes) {
		switch (attribute.type) {
			case 'AnimateDirective':
				other_directives.push(attribute);
				break;

			case 'Attribute':
				// `is` attributes need to be part of the template, otherwise they break
				if (attribute.name === 'is' && context.state.metadata.namespace === 'html') {
					const { value } = build_attribute_value(attribute.value, context);

					if (value.type === 'Literal' && typeof value.value === 'string') {
						context.state.template.set_prop('is', value.value);
						continue;
					}
				}

				attributes.push(attribute);
				lookup.set(attribute.name, attribute);
				break;

			case 'BindDirective':
				bindings.set(attribute.name, attribute);
				other_directives.push(attribute);
				break;

			case 'ClassDirective':
				class_directives.push(attribute);
				break;

			case 'LetDirective':
				// visit let directives before everything else, to set state
				context.visit(attribute, { ...context.state, let_directives: lets });
				break;

			case 'OnDirective':
				other_directives.push(attribute);
				break;

			case 'SpreadAttribute':
				attributes.push(attribute);
				break;

			case 'StyleDirective':
				style_directives.push(attribute);
				break;

			case 'TransitionDirective':
				other_directives.push(attribute);
				break;

			case 'UseDirective':
				has_use = true;
				other_directives.push(attribute);
				break;

			case 'AttachTag':
				other_directives.push(attribute);
				break;
		}
	}

	/** @type {typeof state} */
	const element_state = { ...context.state, init: [], after_update: [] };

	for (const attribute of other_directives) {
		if (attribute.type === 'OnDirective') {
			const handler = /** @type {Expression} */ (context.visit(attribute));

			if (has_use) {
				element_state.init.push(stmt(call('$.effect', thunk(handler))));
			} else {
				element_state.after_update.push(stmt(handler));
			}
		} else {
			context.visit(attribute, element_state);
		}
	}

	if (node.name === 'input') {
		const has_value_attribute = attributes.some(
			(attribute) =>
				attribute.type === 'Attribute' &&
				(attribute.name === 'value' || attribute.name === 'checked') &&
				!is_text_attribute(attribute)
		);
		const has_default_value_attribute = attributes.some(
			(attribute) =>
				attribute.type === 'Attribute' &&
				(attribute.name === 'defaultValue' || attribute.name === 'defaultChecked')
		);
		if (
			!has_default_value_attribute &&
			(has_spread ||
				bindings.has('value') ||
				bindings.has('checked') ||
				bindings.has('group') ||
				(!bindings.has('group') && has_value_attribute))
		) {
			if (has_spread) {
				// remove_input_defaults will be called inside set_attributes
				should_remove_defaults = true;
			} else {
				context.state.init.push(stmt(call('$.remove_input_defaults', context.state.node)));
			}
		}
	}

	if (node.name === 'textarea') {
		const attribute = lookup.get('value') ?? lookup.get('checked');
		const needs_content_reset = attribute && !is_text_attribute(attribute);

		if (has_spread || bindings.has('value') || needs_content_reset) {
			context.state.init.push(stmt(call('$.remove_textarea_child', context.state.node)));
		}
	}

	if (node.name === 'select' && bindings.has('value')) {
		setup_select_synchronization(/** @type {AST.BindDirective} */ (bindings.get('value')), context);
	}

	// Let bindings first, they can be used on attributes
	context.state.init.push(...lets);

	const node_id = context.state.node;

	/** If true, needs `__value` for inputs */
	const needs_special_value_handling =
		node.name === 'option' ||
		node.name === 'select' ||
		bindings.has('group') ||
		bindings.has('checked');

	if (has_spread) {
		build_attribute_effect(
			attributes,
			class_directives,
			style_directives,
			context,
			node,
			node_id,
			should_remove_defaults
		);
	} else {
		for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) {
			if (is_event_attribute(attribute)) {
				visit_event_attribute(attribute, context);
				continue;
			}

			if (needs_special_value_handling && attribute.name === 'value') {
				continue;
			}

			const name = get_attribute_name(node, attribute);

			if (
				!is_custom_element &&
				!cannot_be_set_statically(attribute.name) &&
				(attribute.value === true || is_text_attribute(attribute)) &&
				(name !== 'class' || class_directives.length === 0) &&
				(name !== 'style' || style_directives.length === 0)
			) {
				let value = is_text_attribute(attribute) ? attribute.value[0].data : true;

				if (name === 'class' && node.metadata.scoped && context.state.analysis.css.hash) {
					if (value === true || value === '') {
						value = context.state.analysis.css.hash;
					} else {
						value += ' ' + context.state.analysis.css.hash;
					}
				}

				if (name !== 'class' || value) {
					context.state.template.set_prop(
						attribute.name,
						is_boolean_attribute(name) && value === true ? undefined : value === true ? '' : value
					);
				}
			} else if (name === 'autofocus') {
				let { value } = build_attribute_value(attribute.value, context);
				context.state.init.push(stmt(call('$.autofocus', node_id, value)));
			} else if (name === 'class') {
				const is_html = context.state.metadata.namespace === 'html' && node.name !== 'svg';
				build_set_class(node, node_id, attribute, class_directives, context, is_html);
			} else if (name === 'style') {
				build_set_style(node_id, attribute, style_directives, context);
			} else if (is_custom_element) {
				build_custom_element_attribute_update_assignment(node_id, attribute, context);
			} else {
				const { value, has_state } = build_attribute_value(
					attribute.value,
					context,
					(value, metadata) => context.state.memoizer.add(value, metadata)
				);

				const update = build_element_attribute_update(node, node_id, name, value, attributes);

				(has_state ? context.state.update : context.state.init).push(stmt(update));
			}
		}
	}

	if (
		is_load_error_element(node.name) &&
		(has_spread || has_use || lookup.has('onload') || lookup.has('onerror'))
	) {
		context.state.after_update.push(stmt(call('$.replay_events', node_id)));
	}

	const metadata = {
		...context.state.metadata,
		namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
	};

	if (bindings.has('innerHTML') || bindings.has('innerText') || bindings.has('textContent')) {
		const contenteditable = lookup.get('contenteditable');

		if (
			contenteditable &&
			(contenteditable.value === true ||
				(is_text_attribute(contenteditable) && contenteditable.value[0].data === 'true'))
		) {
			metadata.bound_contenteditable = true;
		}
	}

	/** @type {ComponentClientTransformState} */
	const state = {
		...context.state,
		metadata,
		scope: /** @type {Scope} */ (context.state.scopes.get(node.fragment)),
		preserve_whitespace:
			context.state.preserve_whitespace || node.name === 'pre' || node.name === 'textarea'
	};

	const { hoisted, trimmed } = clean_nodes(
		node,
		node.fragment.nodes,
		context.path,
		state.metadata.namespace,
		state,
		node.name === 'script' || state.preserve_whitespace,
		state.options.preserveComments
	);

	/** @type {typeof state} */
	const child_state = { ...state, init: [], update: [], after_update: [] };

	for (const node of hoisted) {
		context.visit(node, child_state);
	}

	// special case — if an element that only contains text, we don't need
	// to descend into it if the text is non-reactive
	// in the rare case that we have static text that can't be inlined
	// (e.g. `<span>{location}</span>`), set `textContent` programmatically
	const use_text_content =
		trimmed.every((node) => node.type === 'Text' || node.type === 'ExpressionTag') &&
		trimmed.every(
			(node) =>
				node.type === 'Text' ||
				(!node.metadata.expression.has_state && !node.metadata.expression.has_await)
		) &&
		trimmed.some((node) => node.type === 'ExpressionTag');

	if (use_text_content) {
		const { value } = build_template_chunk(trimmed, context, child_state);
		const empty_string = value.type === 'Literal' && value.value === '';

		if (!empty_string) {
			child_state.init.push(
				stmt(assignment('=', member(context.state.node, 'textContent'), value))
			);
		}
	} else {
		/** @type {Expression} */
		let arg = context.state.node;

		// If `hydrate_node` is set inside the element, we need to reset it
		// after the element has been hydrated
		let needs_reset = trimmed.some((node) => node.type !== 'Text');

		// The same applies if it's a `<template>` element, since we need to
		// set the value of `hydrate_node` to `node.content`
		if (node.name === 'template') {
			needs_reset = true;
			child_state.init.push(stmt(call('$.hydrate_template', arg)));
			arg = member(arg, 'content');
		}

		process_children(trimmed, (is_text) => call('$.child', arg, is_text && true_instance), true, {
			...context,
			state: child_state
		});

		if (needs_reset) {
			child_state.init.push(stmt(call('$.reset', context.state.node)));
		}
	}

	if (node.fragment.nodes.some((node) => node.type === 'SnippetBlock')) {
		// Wrap children in `{...}` to avoid declaration conflicts
		context.state.init.push(
			block([
				...child_state.init,
				...element_state.init,
				child_state.update.length > 0 ? build_render_statement(child_state) : empty,
				...child_state.after_update,
				...element_state.after_update
			])
		);
	} else if (node.fragment.metadata.dynamic) {
		context.state.init.push(...child_state.init, ...element_state.init);
		context.state.update.push(...child_state.update);
		context.state.after_update.push(...child_state.after_update, ...element_state.after_update);
	} else {
		context.state.init.push(...element_state.init);
		context.state.after_update.push(...element_state.after_update);
	}

	if (lookup.has('dir')) {
		// This fixes an issue with Chromium where updates to text content within an element
		// does not update the direction when set to auto. If we just re-assign the dir, this fixes it.
		const dir = member(node_id, 'dir');
		context.state.update.push(stmt(assignment('=', dir, dir)));
	}

	if (!has_spread && needs_special_value_handling) {
		if (node.metadata.synthetic_value_node) {
			const synthetic_node = node.metadata.synthetic_value_node;
			const synthetic_attribute = create_attribute(
				'value',
				null,
				synthetic_node.start,
				synthetic_node.end,
				[synthetic_node]
			);
			// this node is an `option` that didn't have a `value` attribute, but had
			// a single-expression child, so we treat the value of that expression as
			// the value of the option
			build_element_special_value_attribute(node.name, node_id, synthetic_attribute, context, true);
		} else {
			for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) {
				if (attribute.name === 'value') {
					build_element_special_value_attribute(node.name, node_id, attribute, context);
					break;
				}
			}
		}
	}

	context.state.template.pop_element();
}

/**
 * Special case: if we have a value binding on a select element, we need to set up synchronization
 * between the value binding and inner signals, for indirect updates
 * @param {AST.BindDirective} value_binding
 * @param {ComponentContext} context
 */
function setup_select_synchronization(value_binding, context) {
	if (context.state.analysis.runes) return;

	let bound = value_binding.expression;

	if (bound.type === 'SequenceExpression') {
		return;
	}

	while (bound.type === 'MemberExpression') {
		bound = /** @type {Identifier | MemberExpression} */ (bound.object);
	}

	/** @type {string[]} */
	const names = [];

	for (const [name, refs] of context.state.scope.references) {
		if (
			refs.length > 0 &&
			// prevent infinite loop
			name !== bound.name
		) {
			names.push(name);
		}
	}

	const invalidator = call(
		'$.invalidate_inner_signals',
		thunk(
			block(
				names.map((name) => {
					const serialized = build_getter$1(id$2(name), context.state);
					return stmt(serialized);
				})
			)
		)
	);

	context.state.init.push(
		stmt(
			call(
				'$.template_effect',
				thunk(
					block([stmt(/** @type {Expression} */ (context.visit(bound))), stmt(invalidator)])
				)
			)
		)
	);
}

/**
 * @param {AST.ClassDirective[]} class_directives
 * @param {ComponentContext} context
 * @param {Memoizer} memoizer
 */
function build_class_directives_object(
	class_directives,
	context,
	memoizer = context.state.memoizer
) {
	let properties = [];

	const metadata = new ExpressionMetadata();

	for (const d of class_directives) {
		metadata.merge(d.metadata.expression);

		const expression = /** @type Expression */ (context.visit(d.expression));
		properties.push(init(d.name, expression));
	}

	const directives = object$2(properties);

	return memoizer.add(directives, metadata);
}

/**
 * @param {AST.StyleDirective[]} style_directives
 * @param {ComponentContext} context
 * @param {Memoizer} memoizer
 */
function build_style_directives_object(
	style_directives,
	context,
	memoizer = context.state.memoizer
) {
	const normal = object$2([]);
	const important = object$2([]);

	const metadata = new ExpressionMetadata();

	for (const d of style_directives) {
		metadata.merge(d.metadata.expression);

		const expression =
			d.value === true
				? build_getter$1(id$2(d.name), context.state)
				: build_attribute_value(d.value, context).value;

		const object = d.modifiers.includes('important') ? important : normal;
		object.properties.push(init(d.name, expression));
	}

	const directives = important.properties.length ? array([normal, important]) : normal;

	return memoizer.add(directives, metadata);
}

/**
 * Serializes an assignment to an element property by adding relevant statements to either only
 * the init or the init and update arrays, depending on whether or not the value is dynamic.
 * Resulting code for static looks something like this:
 * ```js
 * element.property = value;
 * // or
 * $.set_attribute(element, property, value);
 * });
 * ```
 * Resulting code for dynamic looks something like this:
 * ```js
 * let value;
 * $.template_effect(() => {
 * 	if (value !== (value = 'new value')) {
 * 		element.property = value;
 * 		// or
 * 		$.set_attribute(element, property, value);
 * 	}
 * });
 * ```
 * Returns true if attribute is deemed reactive, false otherwise.
 * @param {AST.RegularElement} element
 * @param {Identifier} node_id
 * @param {string} name
 * @param {Expression} value
 * @param {Array<AST.Attribute | AST.SpreadAttribute>} attributes
 */
function build_element_attribute_update(element, node_id, name, value, attributes) {
	if (name === 'muted') {
		// Special case for Firefox who needs it set as a property in order to work
		return assignment('=', member(node_id, id$2('muted')), value);
	}

	if (name === 'value') {
		return call('$.set_value', node_id, value);
	}

	if (name === 'checked') {
		return call('$.set_checked', node_id, value);
	}

	if (name === 'selected') {
		return call('$.set_selected', node_id, value);
	}

	if (
		// If we would just set the defaultValue property, it would override the value property,
		// because it is set in the template which implicitly means it's also setting the default value,
		// and if one updates the default value while the input is pristine it will also update the
		// current value, which is not what we want, which is why we need to do some extra work.
		name === 'defaultValue' &&
		(attributes.some(
			(attr) => attr.type === 'Attribute' && attr.name === 'value' && is_text_attribute(attr)
		) ||
			(element.name === 'textarea' && element.fragment.nodes.length > 0))
	) {
		return call('$.set_default_value', node_id, value);
	}

	if (
		// See defaultValue comment
		name === 'defaultChecked' &&
		attributes.some(
			(attr) => attr.type === 'Attribute' && attr.name === 'checked' && attr.value === true
		)
	) {
		return call('$.set_default_checked', node_id, value);
	}

	if (is_dom_property(name)) {
		return assignment('=', member(node_id, name), value);
	}

	return call(
		name.startsWith('xlink') ? '$.set_xlink_attribute' : '$.set_attribute',
		node_id,
		literal(name),
		value,
		is_ignored(element, 'hydration_attribute_changed') && true_instance
	);
}

/**
 * Like `build_element_attribute_update` but without any special attribute treatment.
 * @param {Identifier}	node_id
 * @param {AST.Attribute} attribute
 * @param {ComponentContext} context
 */
function build_custom_element_attribute_update_assignment(node_id, attribute, context) {
	const { value, has_state } = build_attribute_value(attribute.value, context);

	// don't lowercase name, as we set the element's property, which might be case sensitive
	const call$1 = call('$.set_custom_element_data', node_id, literal(attribute.name), value);

	// this is different from other updates — it doesn't get grouped,
	// because set_custom_element_data may not be idempotent
	const update = has_state ? call('$.template_effect', thunk(call$1)) : call$1;

	context.state.init.push(stmt(update));
}

/**
 * Serializes an assignment to the value property of a `<select>`, `<option>` or `<input>` element
 * that needs the hidden `__value` property.
 * Returns true if attribute is deemed reactive, false otherwise.
 * @param {string} element
 * @param {Identifier} node_id
 * @param {AST.Attribute} attribute
 * @param {ComponentContext} context
 * @param {boolean} [synthetic] - true if this should not sync to the DOM
 */
function build_element_special_value_attribute(
	element,
	node_id,
	attribute,
	context,
	synthetic = false
) {
	const state = context.state;
	const is_select_with_value =
		// attribute.metadata.dynamic would give false negatives because even if the value does not change,
		// the inner options could still change, so we need to always treat it as reactive
		element === 'select' && attribute.value !== true && !is_text_attribute(attribute);

	const { value, has_state } = build_attribute_value(attribute.value, context, (value, metadata) =>
		state.memoizer.add(value, metadata)
	);

	const evaluated = context.state.scope.evaluate(value);
	const assignment$1 = assignment('=', member(node_id, '__value'), value);

	const set_value_assignment = assignment(
		'=',
		member(node_id, 'value'),
		evaluated.is_defined ? assignment$1 : logical$1('??', assignment$1, literal(''))
	);

	const update = stmt(
		is_select_with_value
			? sequence([
					set_value_assignment,
					// This ensures a one-way street to the DOM in case it's <select {value}>
					// and not <select bind:value>. We need it in addition to $.init_select
					// because the select value is not reflected as an attribute, so the
					// mutation observer wouldn't notice.
					call('$.select_option', node_id, value)
				])
			: synthetic
				? assignment$1
				: set_value_assignment
	);

	if (has_state) {
		const id = id$2(state.scope.generate(`${node_id.name}_value`));

		// `<option>` is a special case: The value property reflects to the DOM. If the value is set to undefined,
		// that means the value should be set to the empty string. To be able to do that when the value is
		// initially undefined, we need to set a value that is guaranteed to be different.
		const init = element === 'option' ? object$2([]) : undefined;

		state.init.push(var_builder(id, init));
		state.update.push(if_builder(binary$1('!==', id, assignment('=', id, value)), block([update])));
	} else {
		state.init.push(update);
	}

	if (is_select_with_value) {
		state.init.push(stmt(call('$.init_select', node_id)));
	}
}

/** @import { Expression, Identifier, ObjectExpression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../../types' */

/**
 * @param {Array<AST.Attribute | AST.SpreadAttribute>} attributes
 * @param {AST.ClassDirective[]} class_directives
 * @param {AST.StyleDirective[]} style_directives
 * @param {ComponentContext} context
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {Identifier} element_id
 * @param {boolean} [should_remove_defaults]
 */
function build_attribute_effect(
	attributes,
	class_directives,
	style_directives,
	context,
	element,
	element_id,
	should_remove_defaults = false
) {
	/** @type {ObjectExpression['properties']} */
	const values = [];

	const memoizer = new Memoizer();

	for (const attribute of attributes) {
		if (attribute.type === 'Attribute') {
			const { value } = build_attribute_value(attribute.value, context, (value, metadata) =>
				memoizer.add(value, metadata)
			);

			if (
				is_event_attribute(attribute) &&
				(value.type === 'ArrowFunctionExpression' || value.type === 'FunctionExpression')
			) {
				// Give the event handler a stable ID so it isn't removed and readded on every update
				const id = context.state.scope.generate('event_handler');
				context.state.init.push(var_builder(id, value));
				values.push(init(attribute.name, id$2(id)));
			} else {
				values.push(init(attribute.name, value));
			}
		} else {
			let value = /** @type {Expression} */ (context.visit(attribute));

			value = memoizer.add(value, attribute.metadata.expression);

			values.push(spread(value));
		}
	}

	if (class_directives.length) {
		values.push(
			prop(
				'init',
				array([id$2('$.CLASS')]),
				build_class_directives_object(class_directives, context, memoizer)
			)
		);
	}

	if (style_directives.length) {
		values.push(
			prop(
				'init',
				array([id$2('$.STYLE')]),
				build_style_directives_object(style_directives, context, memoizer)
			)
		);
	}

	const ids = memoizer.apply();

	context.state.init.push(
		stmt(
			call(
				'$.attribute_effect',
				element_id,
				arrow(ids, object$2(values)),
				memoizer.sync_values(),
				memoizer.async_values(),
				memoizer.blockers(),
				element.metadata.scoped &&
					context.state.analysis.css.hash !== '' &&
					literal(context.state.analysis.css.hash),
				should_remove_defaults && true_instance,
				is_ignored(element, 'hydration_attribute_changed') && true_instance
			)
		)
	);
}

/**
 * @param {AST.Attribute['value']} value
 * @param {ComponentContext} context
 * @param {(value: Expression, metadata: ExpressionMetadata) => Expression} memoize
 * @returns {{ value: Expression, has_state: boolean }}
 */
function build_attribute_value(value, context, memoize = (value) => value) {
	if (value === true) {
		return { value: true_instance, has_state: false };
	}

	if (!Array.isArray(value) || value.length === 1) {
		const chunk = Array.isArray(value) ? value[0] : value;

		if (chunk.type === 'Text') {
			return { value: literal(chunk.data), has_state: false };
		}

		let expression = build_expression(context, chunk.expression, chunk.metadata.expression);

		return {
			value: memoize(expression, chunk.metadata.expression),
			has_state: chunk.metadata.expression.has_state || chunk.metadata.expression.is_async()
		};
	}

	return build_template_chunk(value, context, context.state, memoize);
}

/**
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {AST.Attribute} attribute
 */
function get_attribute_name(element, attribute) {
	if (!element.metadata.svg && !element.metadata.mathml) {
		return normalize_attribute(attribute.name);
	}

	return attribute.name;
}

/**
 * @param {AST.RegularElement | AST.SvelteElement} element
 * @param {Identifier} node_id
 * @param {AST.Attribute} attribute
 * @param {AST.ClassDirective[]} class_directives
 * @param {ComponentContext} context
 * @param {boolean} is_html
 */
function build_set_class(element, node_id, attribute, class_directives, context, is_html) {
	let { value, has_state } = build_attribute_value(attribute.value, context, (value, metadata) => {
		if (attribute.metadata.needs_clsx) {
			value = call('$.clsx', value);
		}

		return context.state.memoizer.add(value, metadata);
	});

	/** @type {Identifier | undefined} */
	let previous_id;

	/** @type {ObjectExpression | Identifier | undefined} */
	let prev;

	/** @type {Expression | undefined} */
	let next;

	if (class_directives.length) {
		next = build_class_directives_object(class_directives, context);
		has_state ||= class_directives.some(
			(d) => d.metadata.expression.has_state || d.metadata.expression.is_async()
		);

		if (has_state) {
			previous_id = id$2(context.state.scope.generate('classes'));
			context.state.init.push(declaration$2('let', [declarator(previous_id)]));
			prev = previous_id;
		} else {
			prev = object$2([]);
		}
	}

	/** @type {Expression | undefined} */
	let css_hash;

	if (element.metadata.scoped && context.state.analysis.css.hash) {
		if (value.type === 'Literal' && (value.value === '' || value.value === null)) {
			value = literal(context.state.analysis.css.hash);
		} else if (value.type === 'Literal' && typeof value.value === 'string') {
			value = literal(escape_html(value.value, true) + ' ' + context.state.analysis.css.hash);
		} else {
			css_hash = literal(context.state.analysis.css.hash);
		}
	}

	if (!css_hash && next) {
		css_hash = null_instance;
	}

	/** @type {Expression} */
	let set_class = call(
		'$.set_class',
		node_id,
		is_html ? literal(1) : literal(0),
		value,
		css_hash,
		prev,
		next
	);

	if (previous_id) {
		set_class = assignment('=', previous_id, set_class);
	}

	(has_state ? context.state.update : context.state.init).push(stmt(set_class));
}

/**
 * @param {Identifier} node_id
 * @param {AST.Attribute} attribute
 * @param {AST.StyleDirective[]} style_directives
 * @param {ComponentContext} context
 */
function build_set_style(node_id, attribute, style_directives, context) {
	let { value, has_state } = build_attribute_value(attribute.value, context, (value, metadata) =>
		context.state.memoizer.add(value, metadata)
	);

	/** @type {Identifier | undefined} */
	let previous_id;

	/** @type {ObjectExpression | Identifier | undefined} */
	let prev;

	/** @type {Expression | undefined} */
	let next;

	if (style_directives.length) {
		next = build_style_directives_object(style_directives, context);
		has_state ||= style_directives.some(
			(d) => d.metadata.expression.has_state || d.metadata.expression.is_async()
		);

		if (has_state) {
			previous_id = id$2(context.state.scope.generate('styles'));
			context.state.init.push(declaration$2('let', [declarator(previous_id)]));
			prev = previous_id;
		} else {
			prev = object$2([]);
		}
	}

	/** @type {Expression} */
	let set_style = call('$.set_style', node_id, value, prev, next);

	if (previous_id) {
		set_style = assignment('=', previous_id, set_style);
	}

	(has_state ? context.state.update : context.state.init).push(stmt(set_style));
}

/** @import { CallExpression, Expression, Pattern } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.BindDirective} node
 * @param {ComponentContext} context
 */
function BindDirective(node, context) {
	const expression = /** @type {Expression} */ (context.visit(node.expression));
	const property = binding_properties[node.name];

	const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1));

	let get, set;

	if (expression.type === 'SequenceExpression') {
		[get, set] = expression.expressions;
	} else {
		if (
			dev &&
			context.state.analysis.runes &&
			expression.type === 'MemberExpression' &&
			(node.name !== 'this' ||
				context.path.some(
					({ type }) =>
						type === 'IfBlock' ||
						type === 'EachBlock' ||
						type === 'AwaitBlock' ||
						type === 'KeyBlock'
				)) &&
			!is_ignored(node, 'binding_property_non_reactive')
		) {
			validate_binding(context.state, node, expression);
		}

		const assignment$1 = /** @type {Expression} */ (
			context.visit(assignment('=', /** @type {Pattern} */ (node.expression), id$2('$$value')))
		);

		if (dev) {
			// in dev, create named functions, so that `$inspect(...)` delivers
			// useful stack traces
			get = function_builder(id$2('get', node.name_loc), [], block([return_builder(expression)]));
			set = function_builder(
				id$2('set', node.name_loc),
				[id$2('$$value')],
				block([stmt(assignment$1)])
			);
		} else {
			// in prod, optimise for brevity
			get = thunk(expression);

			/** @type {Expression | undefined} */
			set = unthunk(
				arrow(
					[id$2('$$value')],
					/** @type {Expression} */ (
						context.visit(
							assignment('=', /** @type {Pattern} */ (node.expression), id$2('$$value'))
						)
					)
				)
			);

			if (get === set) {
				set = undefined;
			}
		}
	}

	/** @type {CallExpression} */
	let call$1;

	if (property?.event) {
		call$1 = call(
			'$.bind_property',
			literal(node.name),
			literal(property.event),
			context.state.node,
			set ?? get,
			property.bidirectional && get
		);
	} else {
		// special cases
		switch (node.name) {
			// window
			case 'online':
				call$1 = call(`$.bind_online`, set ?? get);
				break;

			case 'scrollX':
			case 'scrollY':
				call$1 = call(
					'$.bind_window_scroll',
					literal(node.name === 'scrollX' ? 'x' : 'y'),
					get,
					set
				);
				break;

			case 'innerWidth':
			case 'innerHeight':
			case 'outerWidth':
			case 'outerHeight':
				call$1 = call('$.bind_window_size', literal(node.name), set ?? get);
				break;

			// document
			case 'activeElement':
				call$1 = call('$.bind_active_element', set ?? get);
				break;

			// media
			case 'muted':
				call$1 = call(`$.bind_muted`, context.state.node, get, set);
				break;
			case 'paused':
				call$1 = call(`$.bind_paused`, context.state.node, get, set);
				break;
			case 'volume':
				call$1 = call(`$.bind_volume`, context.state.node, get, set);
				break;
			case 'playbackRate':
				call$1 = call(`$.bind_playback_rate`, context.state.node, get, set);
				break;
			case 'currentTime':
				call$1 = call(`$.bind_current_time`, context.state.node, get, set);
				break;
			case 'buffered':
				call$1 = call(`$.bind_buffered`, context.state.node, set ?? get);
				break;
			case 'played':
				call$1 = call(`$.bind_played`, context.state.node, set ?? get);
				break;
			case 'seekable':
				call$1 = call(`$.bind_seekable`, context.state.node, set ?? get);
				break;
			case 'seeking':
				call$1 = call(`$.bind_seeking`, context.state.node, set ?? get);
				break;
			case 'ended':
				call$1 = call(`$.bind_ended`, context.state.node, set ?? get);
				break;
			case 'readyState':
				call$1 = call(`$.bind_ready_state`, context.state.node, set ?? get);
				break;

			// dimensions
			case 'contentRect':
			case 'contentBoxSize':
			case 'borderBoxSize':
			case 'devicePixelContentBoxSize':
				call$1 = call(
					'$.bind_resize_observer',
					context.state.node,
					literal(node.name),
					set ?? get
				);
				break;

			case 'clientWidth':
			case 'clientHeight':
			case 'offsetWidth':
			case 'offsetHeight':
				call$1 = call('$.bind_element_size', context.state.node, literal(node.name), set ?? get);
				break;

			// various
			case 'value': {
				if (parent?.type === 'RegularElement' && parent.name === 'select') {
					call$1 = call(`$.bind_select_value`, context.state.node, get, set);
				} else {
					call$1 = call(`$.bind_value`, context.state.node, get, set);
				}
				break;
			}

			case 'files':
				call$1 = call(`$.bind_files`, context.state.node, get, set);
				break;

			case 'this':
				call$1 = build_bind_this(node.expression, context.state.node, context);
				break;

			case 'textContent':
			case 'innerHTML':
			case 'innerText':
				call$1 = call(
					'$.bind_content_editable',
					literal(node.name),
					context.state.node,
					get,
					set
				);
				break;

			// checkbox/radio
			case 'checked':
				call$1 = call(`$.bind_checked`, context.state.node, get, set);
				break;

			case 'focused':
				call$1 = call(`$.bind_focused`, context.state.node, set ?? get);
				break;

			case 'group': {
				const indexes = node.metadata.parent_each_blocks.map((each) => {
					// if we have a keyed block with an index, the index is wrapped in a source
					return each.metadata.keyed && each.index
						? call('$.get', each.metadata.index)
						: each.metadata.index;
				});

				// We need to additionally invoke the value attribute signal to register it as a dependency,
				// so that when the value is updated, the group binding is updated
				let group_getter = get;

				if (parent?.type === 'RegularElement') {
					const value = /** @type {any[]} */ (
						/** @type {AST.Attribute} */ (
							parent.attributes.find(
								(a) =>
									a.type === 'Attribute' &&
									a.name === 'value' &&
									!is_text_attribute(a) &&
									a.value !== true
							)
						)?.value
					);

					if (value !== undefined) {
						group_getter = thunk(
							block([stmt(build_attribute_value(value, context).value), return_builder(expression)])
						);
					}
				}

				call$1 = call(
					'$.bind_group',
					node.metadata.binding_group_name,
					array(indexes),
					context.state.node,
					group_getter,
					set ?? get
				);
				break;
			}

			default:
				throw new Error('unknown binding ' + node.name);
		}
	}

	const defer =
		node.name !== 'this' &&
		parent.type === 'RegularElement' &&
		parent.attributes.find((a) => a.type === 'UseDirective');

	let statement = defer ? stmt(call('$.effect', thunk(call$1))) : stmt(call$1);

	if (node.metadata.expression.is_async()) {
		statement = stmt(
			call(
				'$.run_after_blockers',
				node.metadata.expression.blockers(),
				thunk(block([statement]))
			)
		);
	}

	// Bindings need to happen after attribute updates, therefore after the render effect, and in order with events/actions.
	// bind:this is a special case as it's one-way and could influence the render effect.
	if (node.name === 'this') {
		context.state.init.push(statement);
	} else {
		if (defer) {
			context.state.init.push(statement);
		} else {
			context.state.after_update.push(statement);
		}
	}
}

/** @import { ArrowFunctionExpression, BlockStatement, Expression, FunctionDeclaration, FunctionExpression, Statement } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {BlockStatement} node
 * @param {ComponentContext} context
 */
function BlockStatement(node, context) {
	add_state_transformers(context);
	const tracing = context.state.scope.tracing;

	if (tracing !== null) {
		const parent =
			/** @type {ArrowFunctionExpression | FunctionDeclaration | FunctionExpression} */ (
				context.path.at(-1)
			);

		const is_async = parent.async;

		const call$1 = call(
			'$.trace',
			/** @type {Expression} */ (tracing),
			thunk(block(node.body.map((n) => /** @type {Statement} */ (context.visit(n)))), is_async)
		);

		return block([return_builder(is_async ? await_builder(call$1) : call$1)]);
	}

	context.next();
}

/** @import { BreakStatement } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {BreakStatement} node
 * @param {ComponentContext} context
 */
function BreakStatement(node, context) {
	if (context.state.analysis.runes || !node.label || node.label.name !== '$') {
		return;
	}

	const in_reactive_statement =
		context.path[1].type === 'LabeledStatement' && context.path[1].label.name === '$';

	if (in_reactive_statement) {
		return return_builder();
	}
}

/** @import { CallExpression, Expression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {CallExpression} node
 * @param {Context} context
 */
function CallExpression(node, context) {
	const rune = get_rune(node, context.state.scope);

	switch (rune) {
		case '$host':
			return id$2('$$props.$$host');

		case '$effect.tracking':
			return call('$.effect_tracking');

		// transform state field assignments in constructors
		case '$state':
		case '$state.raw': {
			let arg = node.arguments[0];

			/** @type {Expression | undefined} */
			let value = undefined;

			if (arg) {
				value = /** @type {Expression} */ (context.visit(node.arguments[0]));

				if (
					rune === '$state' &&
					should_proxy(/** @type {Expression} */ (arg), context.state.scope)
				) {
					value = call('$.proxy', value);
				}
			}

			const callee = id$2('$.state', node.callee.loc);
			return call(callee, value);
		}

		case '$derived':
		case '$derived.by': {
			let fn = /** @type {Expression} */ (context.visit(node.arguments[0]));

			return call('$.derived', rune === '$derived' ? thunk(fn) : fn);
		}

		case '$state.eager':
			return call(
				'$.eager',
				thunk(/** @type {Expression} */ (context.visit(node.arguments[0])))
			);

		case '$state.snapshot':
			return call(
				'$.snapshot',
				/** @type {Expression} */ (context.visit(node.arguments[0])),
				is_ignored(node, 'state_snapshot_uncloneable') && true_instance
			);

		case '$effect':
		case '$effect.pre': {
			const callee = rune === '$effect' ? '$.user_effect' : '$.user_pre_effect';
			const func = /** @type {Expression} */ (context.visit(node.arguments[0]));

			const expr = call(callee, /** @type {Expression} */ (func));
			expr.callee.loc = node.callee.loc; // ensure correct mapping

			return expr;
		}

		case '$effect.root':
			return call(
				'$.effect_root',
				.../** @type {Expression[]} */ (node.arguments.map((arg) => context.visit(arg)))
			);

		case '$effect.pending':
			return call('$.eager', thunk(call('$.pending')));

		case '$inspect':
		case '$inspect().with':
			return transform_inspect_rune(rune, node, context);
	}

	if (
		dev &&
		node.callee.type === 'MemberExpression' &&
		node.callee.object.type === 'Identifier' &&
		node.callee.object.name === 'console' &&
		context.state.scope.get('console') === null &&
		node.callee.property.type === 'Identifier' &&
		['debug', 'dir', 'error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'].includes(
			node.callee.property.name
		) &&
		node.arguments.some(
			(arg) => arg.type === 'SpreadElement' || context.state.scope.evaluate(arg).has_unknown
		)
	) {
		return call(
			node.callee,
			spread(
				call(
					'$.log_if_contains_state',
					literal(node.callee.property.name),
					.../** @type {Expression[]} */ (node.arguments.map((arg) => context.visit(arg)))
				)
			)
		);
	}

	context.next();
}

/**
 * @param {'$inspect' | '$inspect().with'} rune
 * @param {CallExpression} node
 * @param {Context} context
 */
function transform_inspect_rune(rune, node, context) {
	if (!dev) return empty;

	const { args, inspector } = get_inspect_args(rune, node, context.visit);

	// by passing an arrow function, the log appears to come from the `$inspect` callsite
	// rather than the `inspect.js` file containing the utility
	const id = id$2('$$args');
	const fn = arrow([rest(id)], call(inspector, spread(id)));

	return call('$.inspect', thunk(array(args)), fn, rune === '$inspect' && true_instance);
}

/** @import { CallExpression, ClassBody, ClassDeclaration, ClassExpression, MethodDefinition, PropertyDefinition, StaticBlock } from 'estree' */
/** @import { StateField } from '#compiler' */
/** @import { Context } from '../types' */

/**
 * @param {ClassBody} node
 * @param {Context} context
 */
function ClassBody(node, context) {
	const state_fields = context.state.analysis.classes.get(node);

	if (!state_fields) {
		// in legacy mode, do nothing
		context.next();
		return;
	}

	/** @type {Array<MethodDefinition | PropertyDefinition | StaticBlock>} */
	const body = [];

	const child_state = { ...context.state, state_fields };

	for (const [name, field] of state_fields) {
		if (name[0] === '#') {
			continue;
		}

		// insert backing fields for stuff declared in the constructor
		if (field.node.type === 'AssignmentExpression') {
			const member$1 = member(this_instance, field.key);

			const should_proxy = field.type === '$state' && true; // TODO

			const key$1 = key(name);

			body.push(
				prop_def(field.key, null),

				method('get', key$1, [], [return_builder(call('$.get', member$1))]),

				method(
					'set',
					key$1,
					[id$2('value')],
					[stmt(call('$.set', member$1, id$2('value'), should_proxy && true_instance))]
				)
			);
		}
	}

	const declaration = /** @type {ClassDeclaration | ClassExpression} */ (
		get_parent(context.path, -1)
	);

	// Replace parts of the class body
	for (const definition of node.body) {
		if (definition.type !== 'PropertyDefinition') {
			body.push(
				/** @type {MethodDefinition | StaticBlock} */ (context.visit(definition, child_state))
			);
			continue;
		}

		const name = get_name(definition.key);
		const field = name && /** @type {StateField} */ (state_fields.get(name));

		if (!field) {
			body.push(/** @type {PropertyDefinition} */ (context.visit(definition, child_state)));
			continue;
		}

		if (name[0] === '#') {
			let value = definition.value
				? /** @type {CallExpression} */ (context.visit(definition.value, child_state))
				: undefined;

			if (dev && field.node === definition) {
				value = call('$.tag', value, literal(`${declaration.id?.name ?? '[class]'}.${name}`));
			}

			body.push(prop_def(definition.key, value));
		} else if (field.node === definition) {
			let call$1 = /** @type {CallExpression} */ (context.visit(field.value, child_state));

			if (dev) {
				call$1 = call('$.tag', call$1, literal(`${declaration.id?.name ?? '[class]'}.${name}`));
			}
			const member$1 = member(this_instance, field.key);
			const should_proxy = field.type === '$state' && true; // TODO

			body.push(
				prop_def(field.key, call$1),

				method('get', definition.key, [], [return_builder(call('$.get', member$1))]),

				method(
					'set',
					definition.key,
					[id$2('value')],
					[stmt(call('$.set', member$1, id$2('value'), should_proxy && true_instance))]
				)
			);
		}
	}

	return { ...node, body };
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.Comment} node
 * @param {ComponentContext} context
 */
function Comment(node, context) {
	// We'll only get here if comments are not filtered out, which they are unless preserveComments is true
	context.state.template.push_comment(node.data);
}

/** @import { BlockStatement, Expression, ExpressionStatement, Identifier, MemberExpression, Pattern, Property, SequenceExpression, SourceLocation, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../../types.js' */

/**
 * @param {AST.Component | AST.SvelteComponent | AST.SvelteSelf} node
 * @param {string} component_name
 * @param {SourceLocation | null} loc
 * @param {ComponentContext} context
 * @returns {Statement}
 */
function build_component(node, component_name, loc, context) {
	/** @type {Expression} */
	const anchor = context.state.node;

	/** @type {Array<Property[] | Expression>} */
	const props_and_spreads = [];

	/** @type {Array<() => void>} */
	const delayed_props = [];

	/** @type {ExpressionStatement[]} */
	const lets = [];

	/** @type {Record<string, typeof context.state>} */
	const states = {
		default: {
			...context.state,
			scope: node.metadata.scopes.default,
			transform: { ...context.state.transform }
		}
	};

	/** @type {Record<string, AST.TemplateNode[]>} */
	const children = {};

	/** @type {Record<string, Expression[]>} */
	const events = {};

	const memoizer = new Memoizer();

	/** @type {Property[]} */
	const custom_css_props = [];

	/** @type {Identifier | MemberExpression | SequenceExpression | null} */
	let bind_this = null;

	/** @type {ExpressionStatement[]} */
	const binding_initializers = [];

	const is_component_dynamic =
		node.type === 'SvelteComponent' || (node.type === 'Component' && node.metadata.dynamic);

	// The variable name used for the component inside $.component()
	const intermediate_name =
		node.type === 'Component' && node.metadata.dynamic
			? context.state.scope.generate(node.name)
			: '$$component';

	/**
	 * If this component has a slot property, it is a named slot within another component. In this case
	 * the slot scope applies to the component itself, too, and not just its children.
	 */
	let slot_scope_applies_to_itself = !!determine_slot(node);

	/**
	 * Components may have a children prop and also have child nodes. In this case, we assume
	 * that the child component isn't using render tags yet and pass the slot as $$slots.default.
	 * We're not doing it for spread attributes, as this would result in too many false positives.
	 */
	let has_children_prop = false;

	/**
	 * @param {Property} prop
	 * @param {boolean} [delay]
	 */
	function push_prop(prop, delay = false) {
		const do_push = () => {
			const current = props_and_spreads.at(-1);
			const current_is_props = Array.isArray(current);
			const props = current_is_props ? current : [];
			props.push(prop);
			if (!current_is_props) {
				props_and_spreads.push(props);
			}
		};

		if (delay) {
			delayed_props.push(do_push);
		} else {
			do_push();
		}
	}

	if (slot_scope_applies_to_itself) {
		for (const attribute of node.attributes) {
			if (attribute.type === 'LetDirective') {
				context.visit(attribute, { ...context.state, let_directives: lets });
			}
		}
	}

	for (const attribute of node.attributes) {
		if (attribute.type === 'LetDirective') {
			if (!slot_scope_applies_to_itself) {
				context.visit(attribute, { ...states.default, let_directives: lets });
			}
		} else if (attribute.type === 'OnDirective') {
			if (!attribute.expression) {
				context.state.analysis.needs_props = true;
			}

			let handler = build_event_handler(
				attribute.expression,
				attribute.metadata.expression,
				context
			);

			if (attribute.modifiers.includes('once')) {
				handler = call('$.once', handler);
			}

			(events[attribute.name] ||= []).push(handler);
		} else if (attribute.type === 'SpreadAttribute') {
			const expression = /** @type {Expression} */ (context.visit(attribute));
			const memoized_expression = memoizer.add(expression, attribute.metadata.expression);
			const is_memoized = expression !== memoized_expression;

			if (
				is_memoized ||
				attribute.metadata.expression.has_state ||
				attribute.metadata.expression.has_await
			) {
				props_and_spreads.push(
					thunk(is_memoized ? call('$.get', memoized_expression) : expression)
				);
			} else {
				props_and_spreads.push(expression);
			}
		} else if (attribute.type === 'Attribute') {
			if (attribute.name.startsWith('--')) {
				custom_css_props.push(
					init(
						attribute.name,
						build_attribute_value(attribute.value, context, (value, metadata) => {
							const memoized = memoizer.add(value, metadata);

							// TODO put the derived in the local block
							return value !== memoized ? call('$.get', memoized) : value;
						}).value
					)
				);
				continue;
			}

			if (attribute.name === 'slot') {
				slot_scope_applies_to_itself = true;
			}

			if (attribute.name === 'children') {
				has_children_prop = true;
			}

			const { value, has_state } = build_attribute_value(
				attribute.value,
				context,
				(value, metadata) => {
					// When we have a non-simple computation, anything other than an Identifier or Member expression,
					// then there's a good chance it needs to be memoized to avoid over-firing when read within the
					// child component (e.g. `active={i === index}`)
					const should_wrap_in_derived =
						metadata.has_await ||
						get_attribute_chunks(attribute.value).some((n) => {
							return (
								n.type === 'ExpressionTag' &&
								n.expression.type !== 'Identifier' &&
								n.expression.type !== 'MemberExpression'
							);
						});

					const memoized = memoizer.add(value, metadata, should_wrap_in_derived);

					return value !== memoized ? call('$.get', memoized) : value;
				}
			);

			if (has_state) {
				push_prop(get$1(attribute.name, [return_builder(value)]));
			} else {
				push_prop(init(attribute.name, value));
			}
		} else if (attribute.type === 'BindDirective') {
			const expression = /** @type {Expression} */ (
				context.visit(attribute.expression, { ...context.state, memoizer })
			);

			// Bindings are a bit special: we don't want to add them to (async) deriveds but we need to check if they have blockers
			memoizer.check_blockers(attribute.metadata.expression);

			if (
				dev &&
				attribute.name !== 'this' &&
				!is_ignored(node, 'ownership_invalid_binding') &&
				// bind:x={() => x.y, y => x.y = y} will be handled by the assignment expression binding validation
				attribute.expression.type !== 'SequenceExpression'
			) {
				const left = object$1(attribute.expression);
				const binding = left && context.state.scope.get(left.name);

				if (binding?.kind === 'bindable_prop' || binding?.kind === 'prop') {
					context.state.analysis.needs_mutation_validation = true;
					binding_initializers.push(
						stmt(
							call(
								'$$ownership_validator.binding',
								literal(binding.node.name),
								id$2(is_component_dynamic ? intermediate_name : component_name),
								thunk(expression)
							)
						)
					);
				}
			}

			if (expression.type === 'SequenceExpression') {
				if (attribute.name === 'this') {
					bind_this = attribute.expression;
				} else {
					const [get, set$1] = expression.expressions;
					const get_id = id$2(context.state.scope.generate('bind_get'));
					const set_id = id$2(context.state.scope.generate('bind_set'));

					context.state.init.push(var_builder(get_id, get));
					context.state.init.push(var_builder(set_id, set$1));

					push_prop(get$1(attribute.name, [return_builder(call(get_id))]));
					push_prop(set(attribute.name, [stmt(call(set_id, id$2('$$value')))]));
				}
			} else {
				if (
					dev &&
					expression.type === 'MemberExpression' &&
					context.state.analysis.runes &&
					!is_ignored(node, 'binding_property_non_reactive')
				) {
					validate_binding(context.state, attribute, expression);
				}

				if (attribute.name === 'this') {
					bind_this = attribute.expression;
				} else {
					const is_store_sub =
						attribute.expression.type === 'Identifier' &&
						context.state.scope.get(attribute.expression.name)?.kind === 'store_sub';

					const get = is_store_sub
						? get$1(attribute.name, [stmt(call('$.mark_store_binding')), return_builder(expression)])
						: get$1(attribute.name, [return_builder(expression)]);

					const assignment$1 = assignment(
						'=',
						/** @type {Pattern} */ (attribute.expression),
						id$2('$$value')
					);

					const set$1 = set(attribute.name, [
						stmt(/** @type {Expression} */ (context.visit(assignment$1)))
					]);

					get.key.loc = attribute.name_loc;
					set$1.key.loc = attribute.name_loc;

					// Delay prop pushes so bindings come at the end, to avoid spreads overwriting them
					push_prop(get, true);
					push_prop(set$1, true);
				}
			}
		} else if (attribute.type === 'AttachTag') {
			const evaluated = context.state.scope.evaluate(attribute.expression);

			let expression = /** @type {Expression} */ (context.visit(attribute.expression));

			if (attribute.metadata.expression.has_state) {
				expression = arrow(
					[id$2('$$node')],
					call(
						evaluated.is_function ? expression : logical$1('||', expression, id$2('$.noop')),
						id$2('$$node')
					)
				);
			}

			// TODO also support await expressions here?
			memoizer.check_blockers(attribute.metadata.expression);

			push_prop(prop('init', call('$.attachment'), expression, true));
		}
	}

	delayed_props.forEach((fn) => fn());

	if (slot_scope_applies_to_itself) {
		context.state.init.push(...lets);
	}

	if (Object.keys(events).length > 0) {
		const events_expression = object$2(
			Object.keys(events).map((name) =>
				init(name, events[name].length > 1 ? array(events[name]) : events[name][0])
			)
		);
		push_prop(init('$$events', events_expression));
	}

	/** @type {Statement[]} */
	const snippet_declarations = [];

	/** @type {import('estree').Property[]} */
	const serialized_slots = [];

	// Group children by slot
	for (const child of node.fragment.nodes) {
		if (child.type === 'SnippetBlock') {
			// the SnippetBlock visitor adds a declaration to `init`, but if it's directly
			// inside a component then we want to hoist them into a block so that they
			// can be used as props without creating conflicts
			context.visit(child, {
				...context.state,
				init: snippet_declarations
			});

			push_prop(prop('init', child.expression, child.expression));

			// Interop: allows people to pass snippets when component still uses slots
			serialized_slots.push(
				init(child.expression.name === 'children' ? 'default' : child.expression.name, true_instance)
			);

			continue;
		}

		let slot_name = determine_slot(child) ?? 'default';

		(children[slot_name] ||= []).push(child);
	}

	// Serialize each slot
	for (const slot_name of Object.keys(children)) {
		const block$1 = /** @type {BlockStatement} */ (
			context.visit(
				{
					...node.fragment,
					// @ts-expect-error
					nodes: children[slot_name]
				},
				slot_name === 'default'
					? slot_scope_applies_to_itself
						? context.state
						: states.default
					: {
							...context.state,
							scope: node.metadata.scopes[slot_name],
							transform: { ...context.state.transform }
						}
			)
		);

		if (block$1.body.length === 0) continue;

		const slot_fn = arrow(
			[id$2('$$anchor'), id$2('$$slotProps')],
			block([
				...(slot_name === 'default' && !slot_scope_applies_to_itself ? lets : []),
				...block$1.body
			])
		);

		if (slot_name === 'default' && !has_children_prop) {
			if (
				lets.length === 0 &&
				children.default.every(
					(node) =>
						node.type !== 'SvelteFragment' ||
						!node.attributes.some((attr) => attr.type === 'LetDirective')
				)
			) {
				// create `children` prop...
				push_prop(
					init(
						'children',
						dev ? call('$.wrap_snippet', id$2(context.state.analysis.name), slot_fn) : slot_fn
					)
				);

				// and `$$slots.default: true` so that `<slot>` on the child works
				serialized_slots.push(init(slot_name, true_instance));
			} else {
				// create `$$slots.default`...
				serialized_slots.push(init(slot_name, slot_fn));

				// and a `children` prop that errors
				push_prop(init('children', id$2('$.invalid_default_snippet')));
			}
		} else {
			serialized_slots.push(init(slot_name, slot_fn));
		}
	}

	if (serialized_slots.length > 0) {
		push_prop(init('$$slots', object$2(serialized_slots)));
	}

	if (
		!context.state.analysis.runes &&
		node.attributes.some((attribute) => attribute.type === 'BindDirective')
	) {
		push_prop(init('$$legacy', true_instance));
	}

	const props_expression =
		props_and_spreads.length === 0 ||
		(props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]))
			? object$2(/** @type {Property[]} */ (props_and_spreads[0]) || [])
			: call(
					'$.spread_props',
					...props_and_spreads.map((p) => (Array.isArray(p) ? object$2(p) : p))
				);

	/** @param {Expression} node_id */
	let fn = (node_id) => {
		// TODO We can remove this ternary once we remove legacy mode, since in runes mode dynamic components
		// will be handled separately through the `$.component` function, and then the component name will
		// always be referenced through just the identifier here.
		const callee = is_component_dynamic
			? id$2(intermediate_name)
			: /** @type {Expression} */ (context.visit(member_id(component_name)));

		// line up the `Foo` in `Foo(...)` and `<Foo>` for usable stack traces
		callee.loc = loc;

		return call(callee, node_id, props_expression);
	};

	if (bind_this !== null) {
		const prev = fn;

		fn = (node_id) => {
			return build_bind_this(bind_this, prev(node_id), context);
		};
	}

	if (node.type !== 'SvelteSelf') {
		// Component name itself could be blocked on async values
		memoizer.check_blockers(node.metadata.expression);
	}

	const statements = [...snippet_declarations, ...memoizer.deriveds(context.state.analysis.runes)];

	if (is_component_dynamic) {
		const prev = fn;

		fn = (node_id) => {
			return call(
				'$.component',
				node_id,
				thunk(
					/** @type {Expression} */ (
						context.visit(node.type === 'Component' ? member_id(component_name) : node.expression)
					)
				),
				arrow(
					[id$2('$$anchor'), id$2(intermediate_name)],
					block([...binding_initializers, stmt(prev(id$2('$$anchor')))])
				)
			);
		};
	} else {
		statements.push(...binding_initializers);
	}

	if (Object.keys(custom_css_props).length > 0) {
		if (context.state.metadata.namespace === 'svg') {
			// this boils down to <g><!></g>
			context.state.template.push_element('g', node.start);
		} else {
			// this boils down to <svelte-css-wrapper style='display: contents'><!></svelte-css-wrapper>
			context.state.template.push_element('svelte-css-wrapper', node.start);
			context.state.template.set_prop('style', 'display: contents');
		}

		context.state.template.push_comment();
		context.state.template.pop_element();

		statements.push(
			stmt(call('$.css_props', anchor, thunk(object$2(custom_css_props)))),
			stmt(fn(member(anchor, 'lastChild'))),
			stmt(call('$.reset', anchor))
		);
	} else {
		context.state.template.push_comment();

		statements.push(add_svelte_meta(fn(anchor), node, 'component', { componentTag: node.name }));
	}

	memoizer.apply();

	const async_values = memoizer.async_values();
	const blockers = memoizer.blockers();

	if (async_values || blockers) {
		return stmt(
			call(
				'$.async',
				anchor,
				blockers,
				async_values,
				arrow([id$2('$$anchor'), ...memoizer.async_ids()], block(statements))
			)
		);
	}

	return statements.length > 1 ? block(statements) : statements[0];
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.Component} node
 * @param {ComponentContext} context
 */
function Component(node, context) {
	const component = build_component(node, node.name, node.name_loc, context);
	context.state.init.push(component);
}

/** @import { Pattern } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */
/** @import { ExpressionMetadata } from '../../../nodes.js' */

/**
 * @param {AST.ConstTag} node
 * @param {ComponentContext} context
 */
function ConstTag(node, context) {
	const declaration = node.declaration.declarations[0];
	// TODO we can almost certainly share some code with $derived(...)
	if (declaration.id.type === 'Identifier') {
		const init = build_expression(context, declaration.init, node.metadata.expression);

		let expression = create_derived(context.state, init, node.metadata.expression.has_await);

		if (dev) {
			expression = call('$.tag', expression, literal(declaration.id.name));
		}

		context.state.transform[declaration.id.name] = { read: get_value };

		add_const_declaration(
			context.state,
			declaration.id,
			expression,
			node.metadata.expression,
			context.state.scope.get_bindings(declaration)
		);
	} else {
		const identifiers = extract_identifiers(declaration.id);
		const tmp = id$2(context.state.scope.generate('computed_const'));

		const transform = { ...context.state.transform };

		// Make all identifiers that are declared within the following computed regular
		// variables, as they are not signals in that context yet
		for (const node of identifiers) {
			delete transform[node.name];
		}

		const child_state = /** @type {ComponentContext['state']} */ ({
			...context.state,
			transform
		});

		// TODO optimise the simple `{ x } = y` case — we can just return `y`
		// instead of destructuring it only to return a new object
		const init = build_expression(
			{ ...context, state: child_state },
			declaration.init,
			node.metadata.expression
		);

		const block$1 = block([
			const_builder(/** @type {Pattern} */ (context.visit(declaration.id, child_state)), init),
			return_builder(object$2(identifiers.map((node) => prop('init', node, node))))
		]);

		let expression = create_derived(context.state, block$1, node.metadata.expression.has_await);

		if (dev) {
			expression = call('$.tag', expression, literal('[@const]'));
		}

		add_const_declaration(
			context.state,
			tmp,
			expression,
			node.metadata.expression,
			context.state.scope.get_bindings(declaration)
		);

		for (const node of identifiers) {
			context.state.transform[node.name] = {
				read: (node) => member(call('$.get', tmp), node)
			};
		}
	}
}

/**
 * @param {ComponentContext['state']} state
 * @param {import('estree').Identifier} id
 * @param {import('estree').Expression} expression
 * @param {ExpressionMetadata} metadata
 * @param {import('#compiler').Binding[]} bindings
 */
function add_const_declaration(state, id, expression, metadata, bindings) {
	// we need to eagerly evaluate the expression in order to hit any
	// 'Cannot access x before initialization' errors
	const after = dev ? [stmt(call('$.get', id))] : [];

	const has_await = metadata.has_await;
	const blockers = [...metadata.dependencies].map((dep) => dep.blocker).filter((b) => b !== null);

	if (has_await || state.async_consts || blockers.length > 0) {
		const run = (state.async_consts ??= {
			id: id$2(state.scope.generate('promises')),
			thunks: []
		});

		state.consts.push(let_builder(id));

		const assignment$1 = assignment('=', id, expression);
		const body = after.length === 0 ? assignment$1 : block([stmt(assignment$1), ...after]);

		if (blockers.length > 0) run.thunks.push(thunk(call('Promise.all', array(blockers))));

		run.thunks.push(thunk(body, has_await));

		const blocker = member(run.id, literal(run.thunks.length - 1), true);

		for (const binding of bindings) {
			binding.blocker = blocker;
		}
	} else {
		state.consts.push(const_builder(id, expression));
		state.consts.push(...after);
	}
}

/** @import { Expression} from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.DebugTag} node
 * @param {ComponentContext} context
 */
function DebugTag(node, context) {
	const object = object$2(
		node.identifiers.map((identifier) => {
			const visited = call('$.snapshot', /** @type {Expression} */ (context.visit(identifier)));

			return prop(
				'init',
				identifier,
				context.state.analysis.runes ? visited : call('$.untrack', thunk(visited))
			);
		})
	);

	const call$1 = call('console.log', object);

	context.state.init.push(
		stmt(call('$.template_effect', thunk(block([stmt(call$1), debugger_builder]))))
	);
}

/** @import { BlockStatement, Expression, Identifier, Pattern, Statement } from 'estree' */
/** @import { AST, Binding } from '#compiler' */
/** @import { ComponentContext } from '../types' */
/** @import { Scope } from '../../../scope' */

/**
 * @param {AST.EachBlock} node
 * @param {ComponentContext} context
 */
function EachBlock(node, context) {
	const each_node_meta = node.metadata;

	// expression should be evaluated in the parent scope, not the scope
	// created by the each block itself
	const parent_scope_state = {
		...context.state,
		scope: /** @type {Scope} */ (context.state.scope.parent)
	};

	const collection = build_expression(
		{
			...context,
			state: parent_scope_state
		},
		node.expression,
		node.metadata.expression
	);

	if (!each_node_meta.is_controlled) {
		context.state.template.push_comment();
	}

	let flags = 0;

	if (node.metadata.keyed && node.index) {
		flags |= EACH_INDEX_REACTIVE;
	}

	const key_is_item =
		node.key?.type === 'Identifier' &&
		node.context?.type === 'Identifier' &&
		node.context?.name === node.key.name;

	// if the each block expression references a store subscription, we need
	// to use mutable stores internally
	let uses_store;

	for (const binding of node.metadata.expression.dependencies) {
		if (binding.kind === 'store_sub') {
			uses_store = true;
			break;
		}
	}

	for (const binding of node.metadata.expression.dependencies) {
		// if the expression doesn't reference any external state, we don't need to
		// create a source for the item. TODO cover more cases (e.g. `x.filter(y)`
		// should also qualify if `y` doesn't reference state, and non-state
		// bindings should also be fine
		if (binding.scope.function_depth >= context.state.scope.function_depth) {
			continue;
		}

		if (!context.state.analysis.runes || !key_is_item || uses_store) {
			flags |= EACH_ITEM_REACTIVE;
			break;
		}
	}

	if (context.state.analysis.runes && !uses_store) {
		flags |= EACH_ITEM_IMMUTABLE;
	}

	// Since `animate:` can only appear on elements that are the sole child of a keyed each block,
	// we can determine at compile time whether the each block is animated or not (in which
	// case it should measure animated elements before and after reconciliation).
	if (
		node.key &&
		node.body.nodes.some((child) => {
			if (child.type !== 'RegularElement' && child.type !== 'SvelteElement') return false;
			return child.attributes.some((attr) => attr.type === 'AnimateDirective');
		})
	) {
		flags |= EACH_IS_ANIMATED;
	}

	if (each_node_meta.is_controlled) {
		flags |= EACH_IS_CONTROLLED;
	}

	// If the array is a store expression, we need to invalidate it when the array is changed.
	// This doesn't catch all cases, but all the ones that Svelte 4 catches, too.
	let store_to_invalidate = '';
	if (node.expression.type === 'Identifier' || node.expression.type === 'MemberExpression') {
		const id = object$1(node.expression);
		if (id) {
			const binding = context.state.scope.get(id.name);
			if (binding?.kind === 'store_sub') {
				store_to_invalidate = id.name;
			}
		}
	}

	/** @type {Identifier | null} */
	let collection_id = null;

	// Check if inner scope shadows something from outer scope.
	// This is necessary because we need access to the array expression of the each block
	// in the inner scope if bindings are used, in order to invalidate the array.
	for (const [name] of context.state.scope.declarations) {
		if (context.state.scope.parent?.get(name) != null) {
			collection_id = context.state.scope.root.unique('$$array');
			break;
		}
	}

	const child_state = {
		...context.state,
		transform: { ...context.state.transform },
		store_to_invalidate
	};

	/** The state used when generating the key function, if necessary */
	const key_state = {
		...context.state,
		transform: { ...context.state.transform }
	};

	// We need to generate a unique identifier in case there's a bind:group below
	// which needs a reference to the index
	const index =
		each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id$2(node.index);
	const item = node.context?.type === 'Identifier' ? node.context : id$2('$$item');

	let uses_index = each_node_meta.contains_group_binding;
	let key_uses_index = false;

	if (node.index) {
		child_state.transform[node.index] = {
			read: (node) => {
				uses_index = true;
				return (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(node) : node;
			}
		};

		key_state.transform[node.index] = {
			read: (node) => {
				key_uses_index = true;
				return node;
			}
		};
	}

	/** @type {Statement[]} */
	const declarations = [];

	const invalidate_store = store_to_invalidate
		? call('$.invalidate_store', id$2('$$stores'), literal(store_to_invalidate))
		: undefined;

	/** @type {Expression[]} */
	const sequence$1 = [];

	if (!context.state.analysis.runes) {
		/** @type {Set<Identifier>} */
		const transitive_deps = new Set();

		if (collection_id) {
			transitive_deps.add(collection_id);
			child_state.transform[collection_id.name] = { read: call };
		} else {
			for (const binding of each_node_meta.transitive_deps) {
				transitive_deps.add(binding.node);
			}
		}

		for (const block of collect_parent_each_blocks(context)) {
			for (const binding of block.metadata.transitive_deps) {
				transitive_deps.add(binding.node);
			}
		}

		if (transitive_deps.size > 0) {
			const invalidate = call(
				'$.invalidate_inner_signals',
				thunk(
					sequence(
						[...transitive_deps].map(
							(node) => /** @type {Expression} */ (context.visit({ ...node }, child_state))
						)
					)
				)
			);

			sequence$1.push(invalidate);
		}
	}

	if (invalidate_store) {
		sequence$1.push(invalidate_store);
	}

	if (node.context?.type === 'Identifier') {
		const binding = /** @type {Binding} */ (context.state.scope.get(node.context.name));

		child_state.transform[node.context.name] = {
			read: (node) => {
				if (binding.reassigned) {
					// we need to do `array[$$index]` instead of `$$item` or whatever
					// TODO 6.0 this only applies in legacy mode, reassignments are
					// forbidden in runes mode
					return member(
						collection_id ? call(collection_id) : collection,
						(flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
						true
					);
				}

				return (flags & EACH_ITEM_REACTIVE) !== 0 ? get_value(node) : node;
			},
			assign: (_, value) => {
				uses_index = true;

				const left = member(
					collection_id ? call(collection_id) : collection,
					(flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
					true
				);

				return sequence([assignment('=', left, value), ...sequence$1]);
			},
			mutate: (_, mutation) => {
				uses_index = true;
				return sequence([mutation, ...sequence$1]);
			}
		};

		delete key_state.transform[node.context.name];
	} else if (node.context) {
		const unwrapped = (flags & EACH_ITEM_REACTIVE) !== 0 ? call('$.get', item) : item;

		const { inserts, paths } = extract_paths(node.context, unwrapped);

		for (const { id, value } of inserts) {
			id.name = context.state.scope.generate('$$array');
			child_state.transform[id.name] = { read: get_value };

			const expression = /** @type {Expression} */ (context.visit(thunk(value), child_state));
			declarations.push(var_builder(id, call('$.derived', expression)));
		}

		for (const path of paths) {
			const name = /** @type {Identifier} */ (path.node).name;
			const needs_derived = path.has_default_value; // to ensure that default value is only called once

			const fn = thunk(/** @type {Expression} */ (context.visit(path.expression, child_state)));

			declarations.push(let_builder(path.node, needs_derived ? call('$.derived_safe_equal', fn) : fn));

			const read = needs_derived ? get_value : call;

			child_state.transform[name] = {
				read,
				assign: (_, value) => {
					const left = /** @type {Pattern} */ (path.update_expression);
					return sequence([assignment('=', left, value), ...sequence$1]);
				},
				mutate: (_, mutation) => {
					return sequence([mutation, ...sequence$1]);
				}
			};

			// we need to eagerly evaluate the expression in order to hit any
			// 'Cannot access x before initialization' errors
			if (dev) {
				declarations.push(stmt(read(id$2(name))));
			}

			delete key_state.transform[name];
		}
	}

	const block$1 = /** @type {BlockStatement} */ (context.visit(node.body, child_state));

	/** @type {Expression} */
	let key_function = id$2('$.index');

	if (node.metadata.keyed) {
		const pattern = /** @type {Pattern} */ (node.context); // can only be keyed when a context is provided
		const expression = /** @type {Expression} */ (
			context.visit(/** @type {Expression} */ (node.key), key_state)
		);

		key_function = arrow(key_uses_index ? [pattern, index] : [pattern], expression);
	}

	if (node.index && each_node_meta.contains_group_binding) {
		// We needed to create a unique identifier for the index above, but we want to use the
		// original index name in the template, therefore create another binding
		declarations.push(let_builder(node.index, index));
	}

	const is_async = node.metadata.expression.is_async();

	const get_collection = thunk(collection, node.metadata.expression.has_await);
	const thunk$1 = is_async ? thunk(call('$.get', id$2('$$collection'))) : get_collection;

	const render_args = [id$2('$$anchor'), item];
	if (uses_index || collection_id) render_args.push(index);
	if (collection_id) render_args.push(collection_id);

	/** @type {Expression[]} */
	const args = [
		context.state.node,
		literal(flags),
		thunk$1,
		key_function,
		arrow(render_args, block(declarations.concat(block$1.body)))
	];

	if (node.fallback) {
		args.push(
			arrow([id$2('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.fallback)))
		);
	}

	const statements = [add_svelte_meta(call('$.each', ...args), node, 'each')];

	if (dev && node.metadata.keyed) {
		statements.unshift(stmt(call('$.validate_each_keys', thunk$1, key_function)));
	}

	if (is_async) {
		context.state.init.push(
			stmt(
				call(
					'$.async',
					context.state.node,
					node.metadata.expression.blockers(),
					array([get_collection]),
					arrow([context.state.node, id$2('$$collection')], block(statements))
				)
			)
		);
	} else {
		context.state.init.push(...statements);
	}
}

/**
 * @param {ComponentContext} context
 */
function collect_parent_each_blocks(context) {
	return /** @type {AST.EachBlock[]} */ (context.path.filter((node) => node.type === 'EachBlock'));
}

/** @import { ExportNamedDeclaration } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {ExportNamedDeclaration} node
 * @param {ComponentContext} context
 */
function ExportNamedDeclaration(node, context) {
	if (context.state.is_instance) {
		if (node.declaration) {
			return context.visit(node.declaration);
		}

		return empty;
	}

	return context.next();
}

/** @import { ExpressionStatement } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {ExpressionStatement} node
 * @param {ComponentContext} context
 */
function ExpressionStatement(node, context) {
	if (node.expression.type === 'CallExpression') {
		const rune = get_rune(node.expression, context.state.scope);

		if (rune === '$inspect.trace') {
			return empty;
		}
	}

	context.next();
}

/** @import { Expression, ForOfStatement, Pattern, Statement, VariableDeclaration } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {ForOfStatement} node
 * @param {ComponentContext} context
 */
function ForOfStatement(node, context) {
	if (
		node.await &&
		dev &&
		!is_ignored(node, 'await_reactivity_loss') &&
		context.state.options.experimental.async
	) {
		const left = /** @type {VariableDeclaration | Pattern} */ (context.visit(node.left));
		const argument = /** @type {Expression} */ (context.visit(node.right));
		const body = /** @type {Statement} */ (context.visit(node.body));
		const right = call('$.for_await_track_reactivity_loss', argument);
		return for_of(left, right, body, true);
	}

	context.next();
}

/** @import { Namespace } from '#compiler' */
/** @import { ComponentClientTransformState } from '../types.js' */
/** @import { Node } from './types.js' */

/**
 * @param {Node[]} nodes
 */
function build_locations(nodes) {
	const array$1 = array([]);

	for (const node of nodes) {
		if (node.type !== 'element') continue;

		const { line, column } = locator(node.start);

		const expression = array([literal(line), literal(column)]);
		const children = build_locations(node.children);

		if (children.elements.length > 0) {
			expression.elements.push(children);
		}

		array$1.elements.push(expression);
	}

	return array$1;
}

/**
 * @param {ComponentClientTransformState} state
 * @param {Namespace} namespace
 * @param {number} [flags]
 */
function transform_template(state, namespace, flags = 0) {
	const tree = state.options.fragments === 'tree';

	const expression = tree ? state.template.as_tree() : state.template.as_html();

	if (tree) {
		if (namespace === 'svg') flags |= TEMPLATE_USE_SVG;
		if (namespace === 'mathml') flags |= TEMPLATE_USE_MATHML;
	}

	let call$1 = call(
		tree ? `$.from_tree` : `$.from_${namespace}`,
		expression,
		flags ? literal(flags) : undefined
	);

	if (state.template.contains_script_tag) {
		call$1 = call(`$.with_script`, call$1);
	}

	if (dev) {
		call$1 = call(
			'$.add_locations',
			call$1,
			member(id$2(state.analysis.name), '$.FILENAME', true),
			build_locations(state.template.nodes)
		);
	}

	return call$1;
}

const svg_attributes =
	'accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan'.split(
		' '
	);

const svg_attribute_lookup = new Map();

svg_attributes.forEach((name) => {
	svg_attribute_lookup.set(name.toLowerCase(), name);
});

/**
 * @param {string} name
 */
function fix_attribute_casing(name) {
	name = name.toLowerCase();
	return svg_attribute_lookup.get(name) || name;
}

/** @import { AST } from '#compiler' */
/** @import { Node, Element } from './types'; */

class Template {
	/**
	 * `true` if HTML template contains a `<script>` tag. In this case we need to invoke a special
	 * template instantiation function (see `create_fragment_with_script_from_html` for more info)
	 */
	contains_script_tag = false;

	/** `true` if the HTML template needs to be instantiated with `importNode` */
	needs_import_node = false;

	/** @type {Node[]} */
	nodes = [];

	/** @type {Node[][]} */
	#stack = [this.nodes];

	/** @type {Element | undefined} */
	#element;

	#fragment = this.nodes;

	/**
	 * @param {string} name
	 * @param {number} start
	 */
	push_element(name, start) {
		this.#element = {
			type: 'element',
			name,
			attributes: {},
			children: [],
			start
		};

		this.#fragment.push(this.#element);

		this.#fragment = /** @type {Element} */ (this.#element).children;
		this.#stack.push(this.#fragment);
	}

	/** @param {string} [data] */
	push_comment(data) {
		this.#fragment.push({ type: 'comment', data });
	}

	/** @param {AST.Text[]} nodes */
	push_text(nodes) {
		this.#fragment.push({ type: 'text', nodes });
	}

	pop_element() {
		this.#stack.pop();
		this.#fragment = /** @type {Node[]} */ (this.#stack.at(-1));
	}

	/**
	 * @param {string} key
	 * @param {string | undefined} value
	 */
	set_prop(key, value) {
		/** @type {Element} */ (this.#element).attributes[key] = value;
	}

	as_html() {
		return template([quasi(this.nodes.map(stringify).join(''), true)], []);
	}

	as_tree() {
		// if the first item is a comment we need to add another comment for effect.start
		if (this.nodes[0].type === 'comment') {
			this.nodes.unshift({ type: 'comment', data: undefined });
		}

		return array(this.nodes.map(objectify));
	}
}

/**
 * @param {Node} item
 */
function stringify(item) {
	if (item.type === 'text') {
		return item.nodes.map((node) => node.raw).join('');
	}

	if (item.type === 'comment') {
		return item.data ? `<!--${item.data}-->` : '<!>';
	}

	let str = `<${item.name}`;

	for (const key in item.attributes) {
		const value = item.attributes[key];

		str += ` ${key}`;
		if (value !== undefined) str += `="${escape_html(value, true)}"`;
	}

	if (is_void(item.name)) {
		str += '/>'; // XHTML compliance
	} else {
		str += `>`;
		str += item.children.map(stringify).join('');
		str += `</${item.name}>`;
	}

	return str;
}

/** @param {Node} item */
function objectify(item) {
	if (item.type === 'text') {
		return literal(item.nodes.map((node) => node.data).join(''));
	}

	if (item.type === 'comment') {
		return item.data ? array([literal(`// ${item.data}`)]) : null;
	}

	const element = array([literal(item.name)]);

	const attributes = object$2([]);

	for (const key$1 in item.attributes) {
		const value = item.attributes[key$1];

		attributes.properties.push(
			prop(
				'init',
				key(fix_attribute_casing(key$1)),
				value === undefined ? void0 : literal(value)
			)
		);
	}

	if (attributes.properties.length > 0 || item.children.length > 0) {
		element.elements.push(attributes.properties.length > 0 ? attributes : null_instance);
	}

	if (item.children.length > 0) {
		const children = item.children.map(objectify);
		element.elements.push(...children);

		// special case — strip leading newline from `<pre>` and `<textarea>`
		if (item.name === 'pre' || item.name === 'textarea') {
			const first = children[0];
			if (first?.type === 'Literal') {
				first.value = /** @type {string} */ (first.value).replace(regex_starts_with_newline, '');
			}
		}
	}

	return element;
}

/** @import { Expression, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentClientTransformState, ComponentContext } from '../types' */

/**
 * @param {AST.Fragment} node
 * @param {ComponentContext} context
 */
function Fragment(node, context) {
	// Creates a new block which looks roughly like this:
	// ```js
	// // hoisted:
	// const block_name = $.from_html(`...`);
	//
	// // for the main block:
	// const id = block_name();
	// // init stuff and possibly render effect
	// $.append($$anchor, id);
	// ```
	// Adds the hoisted parts to `context.state.hoisted` and returns the statements of the main block.

	const parent = context.path.at(-1) ?? node;

	const namespace = infer_namespace(context.state.metadata.namespace, parent, node.nodes);

	const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
		parent,
		node.nodes,
		context.path,
		namespace,
		context.state,
		context.state.preserve_whitespace,
		context.state.options.preserveComments
	);

	if (hoisted.length === 0 && trimmed.length === 0) {
		return block([]);
	}

	const is_single_element = trimmed.length === 1 && trimmed[0].type === 'RegularElement';
	const is_single_child_not_needing_template =
		trimmed.length === 1 &&
		(trimmed[0].type === 'SvelteFragment' || trimmed[0].type === 'TitleElement');
	const template_name = context.state.scope.root.unique('root'); // TODO infer name from parent

	/** @type {Statement[]} */
	const body = [];

	/** @type {Statement | undefined} */
	let close = undefined;

	/** @type {ComponentClientTransformState} */
	const state = {
		...context.state,
		init: [],
		consts: [],
		let_directives: [],
		update: [],
		after_update: [],
		memoizer: new Memoizer(),
		template: new Template(),
		transform: { ...context.state.transform },
		metadata: {
			namespace,
			bound_contenteditable: context.state.metadata.bound_contenteditable
		},
		async_consts: undefined
	};

	for (const node of hoisted) {
		context.visit(node, state);
	}

	if (is_single_element) {
		const element = /** @type {AST.RegularElement} */ (trimmed[0]);

		const id = id$2(context.state.scope.generate(element.name), element.name_loc);

		context.visit(element, {
			...state,
			node: id
		});

		let flags = state.template.needs_import_node ? TEMPLATE_USE_IMPORT_NODE : undefined;

		const template = transform_template(state, namespace, flags);
		state.hoisted.push(var_builder(template_name, template));

		state.init.unshift(var_builder(id, call(template_name)));
		close = stmt(call('$.append', id$2('$$anchor'), id));
	} else if (is_single_child_not_needing_template) {
		context.visit(trimmed[0], state);
	} else if (trimmed.length === 1 && trimmed[0].type === 'Text') {
		const id = id$2(context.state.scope.generate('text'));
		state.init.unshift(var_builder(id, call('$.text', literal(trimmed[0].data))));
		close = stmt(call('$.append', id$2('$$anchor'), id));
	} else if (trimmed.length > 0) {
		const id = id$2(context.state.scope.generate('fragment'));

		const use_space_template =
			trimmed.some((node) => node.type === 'ExpressionTag') &&
			trimmed.every((node) => node.type === 'Text' || node.type === 'ExpressionTag');

		if (use_space_template) {
			// special case — we can use `$.text` instead of creating a unique template
			const id = id$2(context.state.scope.generate('text'));

			process_children(trimmed, () => id, false, {
				...context,
				state
			});

			state.init.unshift(var_builder(id, call('$.text')));
			close = stmt(call('$.append', id$2('$$anchor'), id));
		} else {
			if (is_standalone) {
				// no need to create a template, we can just use the existing block's anchor
				process_children(trimmed, () => id$2('$$anchor'), false, { ...context, state });
			} else {
				/** @type {(is_text: boolean) => Expression} */
				const expression = (is_text) => call('$.first_child', id, is_text && true_instance);

				process_children(trimmed, expression, false, { ...context, state });

				let flags = TEMPLATE_FRAGMENT;

				if (state.template.needs_import_node) {
					flags |= TEMPLATE_USE_IMPORT_NODE;
				}

				if (state.template.nodes.length === 1 && state.template.nodes[0].type === 'comment') {
					// special case — we can use `$.comment` instead of creating a unique template
					state.init.unshift(var_builder(id, call('$.comment')));
				} else {
					const template = transform_template(state, namespace, flags);
					state.hoisted.push(var_builder(template_name, template));

					state.init.unshift(var_builder(id, call(template_name)));
				}

				close = stmt(call('$.append', id$2('$$anchor'), id));
			}
		}
	}

	body.push(...state.let_directives, ...state.consts);

	if (state.async_consts && state.async_consts.thunks.length > 0) {
		body.push(var_builder(state.async_consts.id, call('$.run', array(state.async_consts.thunks))));
	}

	if (is_text_first) {
		// skip over inserted comment
		body.push(stmt(call('$.next')));
	}

	body.push(...state.init);

	if (state.update.length > 0) {
		body.push(build_render_statement(state));
	}

	body.push(...state.after_update);

	if (close !== undefined) {
		// It's important that close is the last statement in the block, as any previous statements
		// could contain element insertions into the template, which the close statement needs to
		// know of when constructing the list of current inner elements.
		body.push(close);
	}

	return block(body);
}

/** @import { FunctionDeclaration } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {FunctionDeclaration} node
 * @param {ComponentContext} context
 */
function FunctionDeclaration(node, context) {
	const state = { ...context.state, in_constructor: false, in_derived: false };

	context.next(state);
}

/** @import { FunctionExpression } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {FunctionExpression} node
 * @param {ComponentContext} context
 */
function FunctionExpression(node, context) {
	return visit_function(node, context);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.HtmlTag} node
 * @param {ComponentContext} context
 */
function HtmlTag(node, context) {
	context.state.template.push_comment();

	const is_async = node.metadata.expression.is_async();

	const expression = build_expression(context, node.expression, node.metadata.expression);
	const html = is_async ? call('$.get', id$2('$$html')) : expression;

	const is_svg = context.state.metadata.namespace === 'svg';
	const is_mathml = context.state.metadata.namespace === 'mathml';

	const statement = stmt(
		call(
			'$.html',
			context.state.node,
			thunk(html),
			is_svg && true_instance,
			is_mathml && true_instance,
			is_ignored(node, 'hydration_html_changed') && true_instance
		)
	);

	// push into init, so that bindings run afterwards, which might trigger another run and override hydration
	if (is_async) {
		context.state.init.push(
			stmt(
				call(
					'$.async',
					context.state.node,
					node.metadata.expression.blockers(),
					array([thunk(expression, node.metadata.expression.has_await)]),
					arrow([context.state.node, id$2('$$html')], block([statement]))
				)
			)
		);
	} else {
		context.state.init.push(statement);
	}
}

/** @import { Identifier, Node } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {Identifier} node
 * @param {Context} context
 */
function Identifier(node, context) {
	const parent = /** @type {Node} */ (context.path.at(-1));

	if (is_reference(node, parent)) {
		if (node.name === '$$props') {
			return id$2('$$sanitized_props');
		}

		// Optimize prop access: If it's a member read access, we can use the $$props object directly
		const binding = context.state.scope.get(node.name);
		if (
			context.state.analysis.runes && // can't do this in legacy mode because the proxy does more than just read/write
			binding !== null &&
			node !== binding.node &&
			binding.kind === 'rest_prop'
		) {
			const grand_parent = context.path.at(-2);

			if (
				parent?.type === 'MemberExpression' &&
				!parent.computed &&
				grand_parent?.type !== 'AssignmentExpression' &&
				grand_parent?.type !== 'UpdateExpression'
			) {
				const key = /** @type {Identifier} */ (parent.property);

				if (!binding.metadata?.exclude_props?.includes(key.name)) {
					return id$2('$$props');
				}
			}
		}

		return build_getter$1(node, context.state);
	}
}

/** @import { BlockStatement, Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.IfBlock} node
 * @param {ComponentContext} context
 */
function IfBlock(node, context) {
	context.state.template.push_comment();
	const statements = [];

	const consequent = /** @type {BlockStatement} */ (context.visit(node.consequent));
	const consequent_id = id$2(context.state.scope.generate('consequent'));

	statements.push(var_builder(consequent_id, arrow([id$2('$$anchor')], consequent)));

	let alternate_id;

	if (node.alternate) {
		const alternate = /** @type {BlockStatement} */ (context.visit(node.alternate));
		alternate_id = id$2(context.state.scope.generate('alternate'));
		statements.push(var_builder(alternate_id, arrow([id$2('$$anchor')], alternate)));
	}

	const is_async = node.metadata.expression.is_async();

	const expression = build_expression(context, node.test, node.metadata.expression);
	const test = is_async ? call('$.get', id$2('$$condition')) : expression;

	/** @type {Expression[]} */
	const args = [
		context.state.node,
		arrow(
			[id$2('$$render')],
			block([
				if_builder(
					test,
					stmt(call('$$render', consequent_id)),
					alternate_id && stmt(call('$$render', alternate_id, literal(false)))
				)
			])
		)
	];

	if (node.elseif) {
		// We treat this...
		//
		//   {#if x}
		//     ...
		//   {:else}
		//     {#if y}
		//       <div transition:foo>...</div>
		//     {/if}
		//   {/if}
		//
		// ...slightly differently to this...
		//
		//   {#if x}
		//     ...
		//   {:else if y}
		//     <div transition:foo>...</div>
		//   {/if}
		//
		// ...even though they're logically equivalent. In the first case, the
		// transition will only play when `y` changes, but in the second it
		// should play when `x` or `y` change — both are considered 'local'
		args.push(true_instance);
	}

	statements.push(add_svelte_meta(call('$.if', ...args), node, 'if'));

	if (is_async) {
		context.state.init.push(
			stmt(
				call(
					'$.async',
					context.state.node,
					node.metadata.expression.blockers(),
					array([thunk(expression, node.metadata.expression.has_await)]),
					arrow([context.state.node, id$2('$$condition')], block(statements))
				)
			)
		);
	} else {
		context.state.init.push(block(statements));
	}
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.KeyBlock} node
 * @param {ComponentContext} context
 */
function KeyBlock(node, context) {
	context.state.template.push_comment();

	const is_async = node.metadata.expression.is_async();

	const expression = build_expression(context, node.expression, node.metadata.expression);
	const key = thunk(is_async ? call('$.get', id$2('$$key')) : expression);
	const body = /** @type {Expression} */ (context.visit(node.fragment));

	let statement = add_svelte_meta(
		call('$.key', context.state.node, key, arrow([id$2('$$anchor')], body)),
		node,
		'key'
	);

	if (is_async) {
		statement = stmt(
			call(
				'$.async',
				context.state.node,
				node.metadata.expression.blockers(),
				array([thunk(expression, node.metadata.expression.has_await)]),
				arrow([context.state.node, id$2('$$key')], block([statement]))
			)
		);
	}

	context.state.init.push(statement);
}

/** @import { Expression, LabeledStatement, Statement } from 'estree' */
/** @import { ReactiveStatement } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {LabeledStatement} node
 * @param {ComponentContext} context
 */
function LabeledStatement(node, context) {
	if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== '$') {
		context.next();
		return;
	}

	// To recreate Svelte 4 behaviour, we track the dependencies
	// the compiler can 'see', but we untrack the effect itself
	const reactive_statement = /** @type {ReactiveStatement} */ (
		context.state.analysis.reactive_statements.get(node)
	);

	if (!reactive_statement) return; // not the instance context

	let serialized_body = /** @type {Statement} */ (context.visit(node.body));

	if (serialized_body.type !== 'BlockStatement') {
		serialized_body = block([serialized_body]);
	}

	const body = serialized_body.body;

	/** @type {Expression[]} */
	const sequence$1 = [];

	for (const binding of reactive_statement.dependencies) {
		if (binding.kind === 'normal' && binding.declaration_kind !== 'import') continue;

		const name = binding.node.name;
		let serialized = build_getter$1(id$2(name), context.state);

		// If the binding is a prop, we need to deep read it because it could be fine-grained $state
		// from a runes-component, where mutations don't trigger an update on the prop as a whole.
		if (name === '$$props' || name === '$$restProps' || binding.kind === 'bindable_prop') {
			serialized = call('$.deep_read_state', serialized);
		}

		sequence$1.push(serialized);
	}

	// these statements will be topologically ordered later
	context.state.legacy_reactive_statements.set(
		node,
		stmt(
			call(
				'$.legacy_pre_effect',
				sequence$1.length > 0 ? thunk(sequence(sequence$1)) : thunk(block([])),
				thunk(block(body))
			)
		)
	);

	return empty;
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.LetDirective} node
 * @param {ComponentContext} context
 */
function LetDirective(node, context) {
	// let:x        -->  const x = $.derived(() => $$slotProps.x);
	// let:x={{y, z}}  -->  const derived_x = $.derived(() => { const { y, z } = $$slotProps.x; return { y, z }));
	if (node.expression && node.expression.type !== 'Identifier') {
		const name = context.state.scope.generate(node.name);
		const bindings = context.state.scope.get_bindings(node);

		for (const binding of bindings) {
			context.state.transform[binding.node.name] = {
				read: (node) => member(call('$.get', id$2(name)), node)
			};
		}

		context.state.let_directives.push(
			const_builder(
				name,
				call(
					'$.derived',
					thunk(
						block([
							let_builder(
								/** @type {Expression} */ (node.expression).type === 'ObjectExpression'
									? // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
										object_pattern(node.expression.properties)
									: // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
										array_pattern(node.expression.elements),
								member(id$2('$$slotProps'), node.name)
							),
							return_builder(object$2(bindings.map((binding) => init(binding.node.name, binding.node))))
						])
					)
				)
			)
		);
	} else {
		const name = node.expression === null ? node.name : node.expression.name;
		context.state.transform[name] = {
			read: (node) => call('$.get', node)
		};

		context.state.let_directives.push(
			const_builder(name, create_derived(context.state, member(id$2('$$slotProps'), node.name)))
		);
	}
}

/** @import { MemberExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {MemberExpression} node
 * @param {Context} context
 */
function MemberExpression(node, context) {
	// rewrite `this.#foo` as `this.#foo.v` inside a constructor
	if (node.property.type === 'PrivateIdentifier') {
		const field = context.state.state_fields.get('#' + node.property.name);

		if (field) {
			return context.state.in_constructor &&
				(field.type === '$state.raw' || field.type === '$state')
				? member(node, 'v')
				: call('$.get', node);
		}
	}

	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

const modifiers = /** @type {const} */ ([
	'stopPropagation',
	'stopImmediatePropagation',
	'preventDefault',
	'self',
	'trusted',
	'once'
]);

/**
 * @param {AST.OnDirective} node
 * @param {ComponentContext} context
 */
function OnDirective(node, context) {
	if (!node.expression) {
		context.state.analysis.needs_props = true;
	}

	let handler = build_event_handler(node.expression, node.metadata.expression, context);

	for (const modifier of modifiers) {
		if (node.modifiers.includes(modifier)) {
			handler = call('$.' + modifier, handler);
		}
	}

	const capture = node.modifiers.includes('capture');
	const passive =
		node.modifiers.includes('passive') ||
		(node.modifiers.includes('nonpassive') ? false : undefined);

	return build_event(node.name, context.state.node, handler, capture, passive);
}

/** @import { Expression, ImportDeclaration, MemberExpression, Node, Program } from 'estree' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {Program} node
 * @param {ComponentContext} context
 */
function Program(node, context) {
	if (!context.state.analysis.runes) {
		context.state.transform['$$props'] = {
			read: (node) => ({ ...node, name: '$$sanitized_props' })
		};

		for (const [name, binding] of context.state.scope.declarations) {
			if (binding.declaration_kind === 'import' && binding.mutated) {
				// the declaration itself is hoisted to the module scope, so we need
				// to resort to cruder measures to differentiate instance/module imports
				const { start, end } = context.state.analysis.instance.ast;
				const node = /** @type {ImportDeclaration} */ (binding.initial);
				const is_instance_import =
					/** @type {number} */ (node.start) > /** @type {number} */ (start) &&
					/** @type {number} */ (node.end) < /** @type {number} */ (end);

				if (is_instance_import) {
					const id = id$2('$$_import_' + name);

					context.state.transform[name] = {
						read: (_) => call(id),
						mutate: (_, mutation) => call(id, mutation)
					};

					context.state.legacy_reactive_imports.push(
						var_builder(id, call('$.reactive_import', thunk(id$2(name))))
					);
				}
			}
		}
	}

	for (const [name, binding] of context.state.scope.declarations) {
		if (binding.kind === 'store_sub') {
			// read lazily, so that transforms added later are still applied
			/** @type {Expression} */
			let cached;

			const get_store = () => {
				return (cached ??= /** @type {Expression} */ (context.visit(id$2(name.slice(1)))));
			};

			context.state.transform[name] = {
				read: call,
				assign: (_, value) => call('$.store_set', get_store(), value),
				mutate: (node, mutation) => {
					// We need to untrack the store read, for consistency with Svelte 4
					const untracked = call('$.untrack', node);

					/**
					 *
					 * @param {Expression} n
					 * @returns {Expression}
					 */
					function replace(n) {
						if (n.type === 'MemberExpression') {
							return {
								...n,
								object: replace(/** @type {Expression} */ (n.object)),
								property: n.property
							};
						}

						return untracked;
					}

					return call(
						'$.store_mutate',
						get_store(),
						mutation.type === 'AssignmentExpression'
							? assignment(
									mutation.operator,
									/** @type {MemberExpression} */ (
										replace(/** @type {MemberExpression} */ (mutation.left))
									),
									mutation.right
								)
							: update(mutation.operator, replace(mutation.argument), mutation.prefix),
						untracked
					);
				},
				update: (node) => {
					return call(
						node.prefix ? '$.update_pre_store' : '$.update_store',
						build_getter$1(id$2(name.slice(1)), context.state),
						call(node.argument),
						node.operator === '--' && literal(-1)
					);
				}
			};
		}

		if (binding.kind === 'prop' || binding.kind === 'bindable_prop') {
			if (is_prop_source(binding, context.state)) {
				context.state.transform[name] = {
					read: call,
					assign: (node, value) => call(node, value),
					mutate: (node, value) => {
						if (binding.kind === 'bindable_prop') {
							// only necessary for interop with legacy parent bindings
							return call(node, value, true_instance);
						}

						return value;
					},
					update: (node) => {
						return call(
							node.prefix ? '$.update_pre_prop' : '$.update_prop',
							node.argument,
							node.operator === '--' && literal(-1)
						);
					}
				};
			} else if (binding.prop_alias) {
				const key$1 = key(binding.prop_alias);

				context.state.transform[name] = {
					read: (_) => member(id$2('$$props'), key$1, key$1.type === 'Literal')
				};
			} else {
				context.state.transform[name] = {
					read: (node) => member(id$2('$$props'), node)
				};
			}
		}
	}

	add_state_transformers(context);

	if (context.state.is_instance) {
		return {
			...node,
			body: transform_body(
				context.state.analysis.instance_body,
				id$2('$.run'),
				(node) => /** @type {Node} */ (context.visit(node))
			)
		};
	}

	context.next();
}

/** @import { Expression, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.RenderTag} node
 * @param {ComponentContext} context
 */
function RenderTag(node, context) {
	context.state.template.push_comment();

	const call$1 = unwrap_optional(node.expression);

	/** @type {Expression[]} */
	let args = [];

	const memoizer = new Memoizer();

	for (let i = 0; i < call$1.arguments.length; i++) {
		const arg = /** @type {Expression} */ (call$1.arguments[i]);
		const metadata = node.metadata.arguments[i];
		let expression = build_expression(context, arg, metadata);
		const memoized = memoizer.add(expression, metadata);

		if (expression !== memoized) {
			expression = call('$.get', memoized);
		}

		args.push(thunk(expression));
	}

	memoizer.apply();

	/** @type {Statement[]} */
	const statements = memoizer.deriveds(context.state.analysis.runes);

	let snippet_function = build_expression(
		context,
		/** @type {Expression} */ (call$1.callee),
		node.metadata.expression
	);

	if (node.metadata.dynamic) {
		// If we have a chain expression then ensure a nullish snippet function gets turned into an empty one
		if (node.expression.type === 'ChainExpression') {
			snippet_function = logical$1('??', snippet_function, id$2('$.noop'));
		}

		statements.push(
			add_svelte_meta(
				call('$.snippet', context.state.node, thunk(snippet_function), ...args),
				node,
				'render'
			)
		);
	} else {
		statements.push(
			add_svelte_meta(
				(node.expression.type === 'CallExpression' ? call : maybe_call)(
					snippet_function,
					context.state.node,
					...args
				),
				node,
				'render'
			)
		);
	}

	const async_values = memoizer.async_values();
	const blockers = memoizer.blockers();

	if (async_values || blockers) {
		context.state.init.push(
			stmt(
				call(
					'$.async',
					context.state.node,
					blockers,
					memoizer.async_values(),
					arrow([context.state.node, ...memoizer.async_ids()], block(statements))
				)
			)
		);
	} else {
		context.state.init.push(statements.length === 1 ? statements[0] : block(statements));
	}
}

/** @import { BlockStatement, Expression, ExpressionStatement, Literal, Property, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SlotElement} node
 * @param {ComponentContext} context
 */
function SlotElement(node, context) {
	// <slot {a}>fallback</slot>  -->   $.slot($$slots.default, { get a() { .. } }, () => ...fallback);
	context.state.template.push_comment();

	/** @type {Property[]} */
	const props = [];

	/** @type {Expression[]} */
	const spreads = [];

	/** @type {ExpressionStatement[]} */
	const lets = [];

	const memoizer = new Memoizer();

	let name = literal('default');

	for (const attribute of node.attributes) {
		if (attribute.type === 'SpreadAttribute') {
			spreads.push(thunk(/** @type {Expression} */ (context.visit(attribute))));
		} else if (attribute.type === 'Attribute') {
			const { value, has_state } = build_attribute_value(
				attribute.value,
				context,
				(value, metadata) =>
					metadata.has_call || metadata.has_await
						? call('$.get', memoizer.add(value, metadata))
						: value
			);

			if (attribute.name === 'name') {
				name = /** @type {Literal} */ (value);
			} else if (attribute.name !== 'slot') {
				if (has_state) {
					props.push(get$1(attribute.name, [return_builder(value)]));
				} else {
					props.push(init(attribute.name, value));
				}
			}
		} else if (attribute.type === 'LetDirective') {
			context.visit(attribute, { ...context.state, let_directives: lets });
		}
	}

	memoizer.apply();

	// Let bindings first, they can be used on attributes
	context.state.init.push(...lets);

	/** @type {Statement[]} */
	const statements = memoizer.deriveds(context.state.analysis.runes);

	const props_expression =
		spreads.length === 0 ? object$2(props) : call('$.spread_props', object$2(props), ...spreads);

	const fallback =
		node.fragment.nodes.length === 0
			? null_instance
			: arrow([id$2('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.fragment)));

	statements.push(
		stmt(call('$.slot', context.state.node, id$2('$$props'), name, props_expression, fallback))
	);

	const async_values = memoizer.async_values();
	const blockers = memoizer.blockers();

	if (async_values || blockers) {
		context.state.init.push(
			stmt(
				call(
					'$.async',
					context.state.node,
					blockers,
					async_values,
					arrow([context.state.node, ...memoizer.async_ids()], block(statements))
				)
			)
		);
	} else {
		context.state.init.push(statements.length === 1 ? statements[0] : block(statements));
	}
}

/** @import { AssignmentPattern, BlockStatement, Expression, Identifier, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SnippetBlock} node
 * @param {ComponentContext} context
 */
function SnippetBlock(node, context) {
	// TODO hoist where possible
	/** @type {(Identifier | AssignmentPattern)[]} */
	const args = [id$2('$$anchor')];
	/** @type {BlockStatement} */
	let body;

	/** @type {Statement[]} */
	const declarations = [];

	const transform = { ...context.state.transform };
	const child_state = { ...context.state, transform };

	for (let i = 0; i < node.parameters.length; i++) {
		const argument = node.parameters[i];

		if (!argument) continue;

		if (argument.type === 'Identifier') {
			args.push(assignment_pattern(argument, id$2('$.noop')));
			transform[argument.name] = { read: call };

			continue;
		}

		let arg_alias = `$$arg${i}`;
		args.push(id$2(arg_alias));

		const { inserts, paths } = extract_paths(argument, maybe_call(id$2(arg_alias)));

		for (const { id, value } of inserts) {
			id.name = context.state.scope.generate('$$array');
			transform[id.name] = { read: get_value };

			declarations.push(
				var_builder(id, call('$.derived', /** @type {Expression} */ (context.visit(thunk(value)))))
			);
		}

		for (const path of paths) {
			const name = /** @type {Identifier} */ (path.node).name;
			const needs_derived = path.has_default_value; // to ensure that default value is only called once
			const fn = thunk(/** @type {Expression} */ (context.visit(path.expression, child_state)));

			declarations.push(let_builder(path.node, needs_derived ? call('$.derived_safe_equal', fn) : fn));

			transform[name] = {
				read: needs_derived ? get_value : call
			};

			// we need to eagerly evaluate the expression in order to hit any
			// 'Cannot access x before initialization' errors
			if (dev) {
				declarations.push(stmt(transform[name].read(id$2(name))));
			}
		}
	}
	const block$1 = /** @type {BlockStatement} */ (context.visit(node.body, child_state)).body;
	body = block([
		dev ? stmt(call('$.validate_snippet_args', spread(id$2('arguments')))) : empty,
		...declarations,
		...block$1
	]);

	// in dev we use a FunctionExpression (not arrow function) so we can use `arguments`
	let snippet = dev
		? call('$.wrap_snippet', id$2(context.state.analysis.name), function_builder(null, args, body))
		: arrow(args, body);

	const declaration = const_builder(node.expression, snippet);

	// Top-level snippets are hoisted so they can be referenced in the `<script>`
	if (context.path.length === 1 && context.path[0].type === 'Fragment') {
		if (node.metadata.can_hoist) {
			context.state.module_level_snippets.push(declaration);
		} else {
			context.state.instance_level_snippets.push(declaration);
		}
	} else {
		context.state.init.push(declaration);
	}
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SpreadAttribute} node
 * @param {ComponentContext} context
 */
function SpreadAttribute(node, context) {
	return context.visit(node.expression);
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../../types' */

/**
 *
 * @param {AST.SvelteBody | AST.SvelteDocument | AST.SvelteWindow} node
 * @param {string} id
 * @param {ComponentContext} context
 */
function visit_special_element(node, id, context) {
	const state = { ...context.state, node: id$2(id) };

	for (const attribute of node.attributes) {
		if (attribute.type === 'OnDirective') {
			context.state.init.push(stmt(/** @type {Expression} */ (context.visit(attribute, state))));
		} else {
			context.visit(attribute, state);
		}
	}
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteBody} node
 * @param {ComponentContext} context
 */
function SvelteBody(node, context) {
	visit_special_element(node, '$.document.body', context);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteComponent} node
 * @param {ComponentContext} context
 */
function SvelteComponent(node, context) {
	const component = build_component(node, '$$component', null, context);
	context.state.init.push(component);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteDocument} node
 * @param {ComponentContext} context
 */
function SvelteDocument(node, context) {
	visit_special_element(node, '$.document', context);
}

/** @import { BlockStatement, Expression, ExpressionStatement, Statement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteElement} node
 * @param {ComponentContext} context
 */
function SvelteElement(node, context) {
	context.state.template.push_comment();

	/** @type {Array<AST.Attribute | AST.SpreadAttribute>} */
	const attributes = [];

	/** @type {AST.Attribute['value'] | undefined} */
	let dynamic_namespace = undefined;

	/** @type {AST.ClassDirective[]} */
	const class_directives = [];

	/** @type {AST.StyleDirective[]} */
	const style_directives = [];

	/** @type {ExpressionStatement[]} */
	const statements = [];

	// Create a temporary context which picks up the init/update statements.
	// They'll then be added to the function parameter of $.element
	const element_id = id$2(context.state.scope.generate('$$element'));

	/** @type {ComponentContext} */
	const inner_context = {
		...context,
		state: {
			...context.state,
			node: element_id,
			init: [],
			update: [],
			after_update: [],
			memoizer: new Memoizer()
		}
	};

	for (const attribute of node.attributes) {
		if (attribute.type === 'Attribute') {
			if (attribute.name === 'xmlns' && !is_text_attribute(attribute)) {
				dynamic_namespace = attribute.value;
			}
			attributes.push(attribute);
		} else if (attribute.type === 'SpreadAttribute') {
			attributes.push(attribute);
		} else if (attribute.type === 'ClassDirective') {
			class_directives.push(attribute);
		} else if (attribute.type === 'StyleDirective') {
			style_directives.push(attribute);
		} else if (attribute.type === 'LetDirective') {
			statements.push(/** @type {ExpressionStatement} */ (context.visit(attribute)));
		} else if (attribute.type === 'OnDirective') {
			const handler = /** @type {Expression} */ (context.visit(attribute, inner_context.state));
			inner_context.state.after_update.push(stmt(handler));
		} else {
			context.visit(attribute, inner_context.state);
		}
	}

	if (
		attributes.length === 1 &&
		attributes[0].type === 'Attribute' &&
		attributes[0].name.toLowerCase() === 'class' &&
		is_text_attribute(attributes[0])
	) {
		build_set_class(node, element_id, attributes[0], class_directives, inner_context, false);
	} else if (attributes.length) {
		// Always use spread because we don't know whether the element is a custom element or not,
		// therefore we need to do the "how to set an attribute" logic at runtime.
		build_attribute_effect(
			attributes,
			class_directives,
			style_directives,
			inner_context,
			node,
			element_id
		);
	}

	const is_async = node.metadata.expression.is_async();

	const expression = /** @type {Expression} */ (context.visit(node.tag));
	const get_tag = thunk(is_async ? call('$.get', id$2('$$tag')) : expression);

	/** @type {Statement[]} */
	const inner = inner_context.state.init;
	if (inner_context.state.update.length > 0) {
		inner.push(build_render_statement(inner_context.state));
	}
	inner.push(...inner_context.state.after_update);
	inner.push(
		.../** @type {BlockStatement} */ (
			context.visit(node.fragment, {
				...context.state,
				metadata: {
					...context.state.metadata,
					namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
				}
			})
		).body
	);

	if (dev) {
		if (node.fragment.nodes.length > 0) {
			statements.push(stmt(call('$.validate_void_dynamic_element', get_tag)));
		}
		statements.push(stmt(call('$.validate_dynamic_element_tag', get_tag)));
	}

	const location = dev && locator(node.start);

	statements.push(
		stmt(
			call(
				'$.element',
				context.state.node,
				get_tag,
				node.metadata.svg || node.metadata.mathml ? true_instance : false_instance,
				inner.length > 0 && arrow([element_id, id$2('$$anchor')], block(inner)),
				dynamic_namespace && thunk(build_attribute_value(dynamic_namespace, context).value),
				location && array([literal(location.line), literal(location.column)])
			)
		)
	);

	if (is_async) {
		context.state.init.push(
			stmt(
				call(
					'$.async',
					context.state.node,
					node.metadata.expression.blockers(),
					array([thunk(expression, node.metadata.expression.has_await)]),
					arrow([context.state.node, id$2('$$tag')], block(statements))
				)
			)
		);
	} else {
		context.state.init.push(statements.length === 1 ? statements[0] : block(statements));
	}
}

/** @import { BlockStatement, ExpressionStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteFragment} node
 * @param {ComponentContext} context
 */
function SvelteFragment(node, context) {
	for (const attribute of node.attributes) {
		if (attribute.type === 'LetDirective') {
			context.visit(attribute);
		}
	}

	context.state.init.push(.../** @type {BlockStatement} */ (context.visit(node.fragment)).body);
}

/** @import { BlockStatement, Statement, Expression, VariableDeclaration } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteBoundary} node
 * @param {ComponentContext} context
 */
function SvelteBoundary(node, context) {
	const props = object$2([]);

	for (const attribute of node.attributes) {
		if (attribute.type !== 'Attribute' || attribute.value === true) {
			// these can't exist, because they would have caused validation
			// to fail, but typescript doesn't know that
			continue;
		}

		const chunk = Array.isArray(attribute.value)
			? /** @type {AST.ExpressionTag} */ (attribute.value[0])
			: attribute.value;

		const expression = /** @type {Expression} */ (context.visit(chunk.expression, context.state));

		if (chunk.metadata.expression.has_state) {
			props.properties.push(get$1(attribute.name, [return_builder(expression)]));
		} else {
			props.properties.push(init(attribute.name, expression));
		}
	}

	const nodes = [];

	/** @type {Statement[]} */
	const const_tags = [];

	/** @type {Statement[]} */
	const hoisted = [];

	let has_const = false;

	// const tags need to live inside the boundary, but might also be referenced in hoisted snippets.
	// to resolve this we cheat: we duplicate const tags inside snippets
	// We'll revert this behavior in the future, it was a mistake to allow this (Component snippets also don't do this).
	for (const child of node.fragment.nodes) {
		if (child.type === 'ConstTag') {
			has_const = true;
			if (!context.state.options.experimental.async) {
				context.visit(child, {
					...context.state,
					consts: const_tags,
					scope: context.state.scopes.get(node.fragment) ?? context.state.scope
				});
			}
		}
	}

	for (const child of node.fragment.nodes) {
		if (child.type === 'ConstTag') {
			if (context.state.options.experimental.async) {
				nodes.push(child);
			}
			continue;
		}

		if (child.type === 'SnippetBlock') {
			if (
				context.state.options.experimental.async &&
				has_const &&
				!['failed', 'pending'].includes(child.expression.name)
			) {
				// we can't hoist snippets as they may reference const tags, so we just keep them in the fragment
				nodes.push(child);
			} else {
				/** @type {Statement[]} */
				const statements = [];

				context.visit(child, { ...context.state, init: statements });

				const snippet = /** @type {VariableDeclaration} */ (statements[0]);

				const snippet_fn = dev
					? // @ts-expect-error we know this shape is correct
						snippet.declarations[0].init.arguments[1]
					: snippet.declarations[0].init;

				if (!context.state.options.experimental.async) {
					snippet_fn.body.body.unshift(
						...const_tags.filter((node) => node.type === 'VariableDeclaration')
					);
				}

				if (['failed', 'pending'].includes(child.expression.name)) {
					props.properties.push(prop('init', child.expression, child.expression));
				}

				hoisted.push(snippet);
			}

			continue;
		}

		nodes.push(child);
	}

	const block$1 = /** @type {BlockStatement} */ (
		context.visit(
			{ ...node.fragment, nodes },
			// Since we're creating a new fragment the reference in scopes can't match, so we gotta attach the right scope manually
			{ ...context.state, scope: context.state.scopes.get(node.fragment) ?? context.state.scope }
		)
	);

	if (!context.state.options.experimental.async) {
		block$1.body.unshift(...const_tags);
	}

	const boundary = stmt(
		call('$.boundary', context.state.node, props, arrow([id$2('$$anchor')], block$1))
	);

	context.state.template.push_comment();
	context.state.init.push(hoisted.length > 0 ? block([...hoisted, boundary]) : boundary);
}

/** @import { BlockStatement } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteHead} node
 * @param {ComponentContext} context
 */
function SvelteHead(node, context) {
	// TODO attributes?
	context.state.init.push(
		stmt(
			call(
				id$2('$.head', node.name_loc),
				literal(hash(filename)),
				arrow([id$2('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.fragment)))
			)
		)
	);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteSelf} node
 * @param {ComponentContext} context
 */
function SvelteSelf(node, context) {
	const component = build_component(node, component_name, node.name_loc, context);
	context.state.init.push(component);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.SvelteWindow} node
 * @param {ComponentContext} context
 */
function SvelteWindow(node, context) {
	visit_special_element(node, '$.window', context);
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.TitleElement} node
 * @param {ComponentContext} context
 */
function TitleElement(node, context) {
	const memoizer = new Memoizer();
	const { has_state, value } = build_template_chunk(
		/** @type {any} */ (node.fragment.nodes),
		context,
		context.state,
		(value, metadata) => memoizer.add(value, metadata)
	);
	const evaluated = context.state.scope.evaluate(value);

	const statement = stmt(
		assignment(
			'=',
			member(id$2('$.document'), id$2('title', node.name_loc)),
			evaluated.is_known
				? literal(evaluated.value)
				: evaluated.is_defined
					? value
					: logical$1('??', value, literal(''))
		)
	);

	// Make sure it only changes the title once async work is done
	if (has_state) {
		context.state.after_update.push(
			stmt(
				call(
					'$.deferred_template_effect',
					arrow(memoizer.apply(), block([statement])),
					memoizer.sync_values(),
					memoizer.async_values(),
					memoizer.blockers()
				)
			)
		);
	} else {
		context.state.after_update.push(stmt(call('$.effect', thunk(block([statement])))));
	}
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.TransitionDirective} node
 * @param {ComponentContext} context
 */
function TransitionDirective(node, context) {
	let flags = node.modifiers.includes('global') ? TRANSITION_GLOBAL : 0;
	if (node.intro) flags |= TRANSITION_IN;
	if (node.outro) flags |= TRANSITION_OUT;

	const args = [
		literal(flags),
		context.state.node,
		thunk(/** @type {Expression} */ (context.visit(parse_directive_name(node.name))))
	];

	if (node.expression) {
		args.push(thunk(/** @type {Expression} */ (context.visit(node.expression))));
	}

	// in after_update to ensure it always happens after bind:this
	let statement = stmt(call('$.transition', ...args));

	if (node.metadata.expression.is_async()) {
		statement = stmt(
			call(
				'$.run_after_blockers',
				node.metadata.expression.blockers(),
				thunk(block([statement]))
			)
		);
	}

	context.state.after_update.push(statement);
}

/** @import { AssignmentExpression, Expression, UpdateExpression } from 'estree' */
/** @import { Context } from '../types' */

/**
 * @param {UpdateExpression} node
 * @param {Context} context
 */
function UpdateExpression(node, context) {
	const argument = node.argument;

	if (
		argument.type === 'MemberExpression' &&
		argument.object.type === 'ThisExpression' &&
		argument.property.type === 'PrivateIdentifier' &&
		context.state.state_fields.has('#' + argument.property.name)
	) {
		let fn = '$.update';
		if (node.prefix) fn += '_pre';

		/** @type {Expression[]} */
		const args = [argument];
		if (node.operator === '--') {
			args.push(literal(-1));
		}

		return call(fn, ...args);
	}

	if (argument.type !== 'Identifier' && argument.type !== 'MemberExpression') {
		throw new Error('An impossible state was reached');
	}

	const left = object$1(argument);
	const transformers = left && context.state.transform[left.name];

	if (left === argument && transformers?.update) {
		// we don't need to worry about ownership_invalid_mutation here, because
		// we're not mutating but reassigning
		return transformers.update(node);
	}

	let update = /** @type {Expression} */ (context.next());

	if (left && transformers?.mutate) {
		update = transformers.mutate(
			left,
			/** @type {AssignmentExpression | UpdateExpression} */ (update)
		);
	}

	return validate_mutation(node, context, update);
}

/** @import { Expression } from 'estree' */
/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.UseDirective} node
 * @param {ComponentContext} context
 */
function UseDirective(node, context) {
	const params = [id$2('$$node')];

	if (node.expression) {
		params.push(id$2('$$action_arg'));
	}

	/** @type {Expression[]} */
	const args = [
		context.state.node,
		arrow(
			params,
			maybe_call(
				/** @type {Expression} */ (context.visit(parse_directive_name(node.name))),
				...params
			)
		)
	];

	if (node.expression) {
		args.push(thunk(/** @type {Expression} */ (context.visit(node.expression))));
	}

	// actions need to run after attribute updates in order with bindings/events
	let statement = stmt(call('$.action', ...args));

	if (node.metadata.expression.is_async()) {
		statement = stmt(
			call(
				'$.run_after_blockers',
				node.metadata.expression.blockers(),
				thunk(block([statement]))
			)
		);
	}

	context.state.init.push(statement);
	context.next();
}

/** @import { AST } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {AST.AttachTag} node
 * @param {ComponentContext} context
 */
function AttachTag(node, context) {
	const expression = build_expression(context, node.expression, node.metadata.expression);
	let statement = stmt(call('$.attach', context.state.node, thunk(expression)));

	if (node.metadata.expression.is_async()) {
		statement = stmt(
			call(
				'$.run_after_blockers',
				node.metadata.expression.blockers(),
				thunk(block([statement]))
			)
		);
	}

	context.state.init.push(statement);
	context.next();
}

/** @import { CallExpression, Expression, Identifier, Literal, VariableDeclaration, VariableDeclarator } from 'estree' */
/** @import { Binding } from '#compiler' */
/** @import { ComponentContext } from '../types' */

/**
 * @param {VariableDeclaration} node
 * @param {ComponentContext} context
 */
function VariableDeclaration(node, context) {
	/** @type {VariableDeclarator[]} */
	const declarations = [];

	if (context.state.analysis.runes) {
		for (const declarator$1 of node.declarations) {
			const init = /** @type {Expression} */ (declarator$1.init);
			const rune = get_rune(init, context.state.scope);

			if (
				!rune ||
				rune === '$effect.tracking' ||
				rune === '$effect.root' ||
				rune === '$inspect' ||
				rune === '$inspect.trace' ||
				rune === '$state.snapshot' ||
				rune === '$host'
			) {
				declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator$1)));
				continue;
			}

			if (rune === '$props.id') {
				// skip
				continue;
			}

			if (rune === '$props') {
				/** @type {string[]} */
				const seen = ['$$slots', '$$events', '$$legacy'];

				if (context.state.analysis.custom_element) {
					seen.push('$$host');
				}

				if (declarator$1.id.type === 'Identifier') {
					/** @type {Expression[]} */
					const args = [id$2('$$props'), array(seen.map((name) => literal(name)))];

					if (dev) {
						// include rest name, so we can provide informative error messages
						args.push(literal(declarator$1.id.name));
					}

					declarations.push(declarator(declarator$1.id, call('$.rest_props', ...args)));
				} else {
					equal(declarator$1.id.type, 'ObjectPattern');

					for (const property of declarator$1.id.properties) {
						if (property.type === 'Property') {
							const key = /** @type {Identifier | Literal} */ (property.key);
							const name = key.type === 'Identifier' ? key.name : /** @type {string} */ (key.value);

							seen.push(name);

							let id =
								property.value.type === 'AssignmentPattern' ? property.value.left : property.value;
							equal(id.type, 'Identifier');
							const binding = /** @type {Binding} */ (context.state.scope.get(id.name));
							let initial =
								binding.initial && /** @type {Expression} */ (context.visit(binding.initial));
							// We're adding proxy here on demand and not within the prop runtime function so that
							// people not using proxied state anywhere in their code don't have to pay the additional bundle size cost
							if (
								initial &&
								binding.kind === 'bindable_prop' &&
								should_proxy(initial, context.state.scope)
							) {
								initial = call('$.proxy', initial);

								if (dev) {
									initial = call('$.tag_proxy', initial, literal(id.name));
								}
							}

							if (is_prop_source(binding, context.state)) {
								declarations.push(
									declarator(id, get_prop_source(binding, context.state, name, initial))
								);
							}
						} else {
							// RestElement
							/** @type {Expression[]} */
							const args = [id$2('$$props'), array(seen.map((name) => literal(name)))];

							if (dev) {
								// include rest name, so we can provide informative error messages
								args.push(literal(/** @type {Identifier} */ (property.argument).name));
							}

							declarations.push(declarator(property.argument, call('$.rest_props', ...args)));
						}
					}
				}

				// TODO
				continue;
			}

			const args = /** @type {CallExpression} */ (init).arguments;
			const value = /** @type {Expression} */ (args[0]) ?? void0; // TODO do we need the void 0? can we just omit it altogether?

			if (rune === '$state' || rune === '$state.raw') {
				/**
				 * @param {Identifier} id
				 * @param {Expression} value
				 */
				const create_state_declarator = (id, value) => {
					const binding = /** @type {import('#compiler').Binding} */ (
						context.state.scope.get(id.name)
					);
					const is_state = is_state_source(binding, context.state.analysis);
					const is_proxy = should_proxy(value, context.state.scope);

					if (rune === '$state' && is_proxy) {
						value = call('$.proxy', value);

						if (dev && !is_state) {
							value = call('$.tag_proxy', value, literal(id.name));
						}
					}

					if (is_state) {
						const callee = id$2('$.state', /** @type {CallExpression} */ (init).callee.loc);
						value = call(callee, value);

						if (dev) {
							value = call('$.tag', value, literal(id.name));
						}
					}

					return value;
				};

				if (declarator$1.id.type === 'Identifier') {
					const expression = /** @type {Expression} */ (context.visit(value));

					declarations.push(
						declarator(declarator$1.id, create_state_declarator(declarator$1.id, expression))
					);
				} else {
					const tmp = id$2(context.state.scope.generate('tmp'));
					const { inserts, paths } = extract_paths(declarator$1.id, tmp);

					declarations.push(
						declarator(tmp, /** @type {Expression} */ (context.visit(value))),
						...inserts.map(({ id, value }) => {
							id.name = context.state.scope.generate('$$array');
							context.state.transform[id.name] = { read: get_value };

							const expression = /** @type {Expression} */ (context.visit(thunk(value)));
							let call$1 = call('$.derived', expression);

							if (dev) {
								const label = `[$state ${declarator$1.id.type === 'ArrayPattern' ? 'iterable' : 'object'}]`;
								call$1 = call('$.tag', call$1, literal(label));
							}

							return declarator(id, call$1);
						}),
						...paths.map((path) => {
							const value = /** @type {Expression} */ (context.visit(path.expression));
							const binding = context.state.scope.get(/** @type {Identifier} */ (path.node).name);
							return declarator(
								path.node,
								binding?.kind === 'state' || binding?.kind === 'raw_state'
									? create_state_declarator(binding.node, value)
									: value
							);
						})
					);
				}

				continue;
			}

			if (rune === '$derived' || rune === '$derived.by') {
				const is_async = context.state.analysis.async_deriveds.has(
					/** @type {CallExpression} */ (init)
				);

				// for now, only wrap async derived in $.save if it's not
				// a top-level instance derived. TODO in future maybe we
				// can dewaterfall all of them?
				const should_save = context.state.is_instance && context.state.scope.function_depth > 1;

				if (declarator$1.id.type === 'Identifier') {
					let expression = /** @type {Expression} */ (context.visit(value));

					if (is_async) {
						const location = dev && !is_ignored(init, 'await_waterfall') && locate_node(init);

						/** @type {Expression} */
						let call$1 = call(
							'$.async_derived',
							thunk(expression, true),
							location ? literal(location) : undefined
						);

						call$1 = should_save ? save(call$1) : await_builder(call$1);
						if (dev) call$1 = call('$.tag', call$1, literal(declarator$1.id.name));

						declarations.push(declarator(declarator$1.id, call$1));
					} else {
						if (rune === '$derived') expression = thunk(expression);

						let call$1 = call('$.derived', expression);
						if (dev) call$1 = call('$.tag', call$1, literal(declarator$1.id.name));

						declarations.push(declarator(declarator$1.id, call$1));
					}
				} else {
					const init = /** @type {CallExpression} */ (declarator$1.init);
					let expression = /** @type {Expression} */ (context.visit(value));

					let rhs = value;

					if (rune !== '$derived' || init.arguments[0].type !== 'Identifier') {
						const id = id$2(context.state.scope.generate('$$d'));

						/** @type {Expression} */
						let call$1 = call('$.derived', rune === '$derived' ? thunk(expression) : expression);

						rhs = call('$.get', id);

						if (is_async) {
							const location = dev && !is_ignored(init, 'await_waterfall') && locate_node(init);

							call$1 = call(
								'$.async_derived',
								thunk(expression, true),
								location ? literal(location) : undefined
							);

							call$1 = should_save ? save(call$1) : await_builder(call$1);
						}

						if (dev) {
							const label = `[$derived ${declarator$1.id.type === 'ArrayPattern' ? 'iterable' : 'object'}]`;
							call$1 = call('$.tag', call$1, literal(label));
						}

						declarations.push(declarator(id, call$1));
					}

					const { inserts, paths } = extract_paths(declarator$1.id, rhs);

					for (const { id, value } of inserts) {
						id.name = context.state.scope.generate('$$array');
						context.state.transform[id.name] = { read: get_value };

						const expression = /** @type {Expression} */ (context.visit(thunk(value)));
						let call$1 = call('$.derived', expression);

						if (dev) {
							const label = `[$derived ${declarator$1.id.type === 'ArrayPattern' ? 'iterable' : 'object'}]`;
							call$1 = call('$.tag', call$1, literal(label));
						}

						declarations.push(declarator(id, call$1));
					}

					for (const path of paths) {
						const expression = /** @type {Expression} */ (context.visit(path.expression));
						const call$1 = call('$.derived', thunk(expression));
						declarations.push(
							declarator(
								path.node,
								dev
									? call('$.tag', call$1, literal(/** @type {Identifier} */ (path.node).name))
									: call$1
							)
						);
					}
				}

				continue;
			}
		}
	} else {
		for (const declarator$1 of node.declarations) {
			const bindings = /** @type {Binding[]} */ (context.state.scope.get_bindings(declarator$1));
			const has_state = bindings.some((binding) => binding.kind === 'state');
			const has_props = bindings.some((binding) => binding.kind === 'bindable_prop');

			if (!has_state && !has_props) {
				declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator$1)));
				continue;
			}

			if (has_props) {
				if (declarator$1.id.type !== 'Identifier') {
					// Turn export let into props. It's really really weird because export let { x: foo, z: [bar]} = ..
					// means that foo and bar are the props (i.e. the leaves are the prop names), not x and z.
					const tmp = id$2(context.state.scope.generate('tmp'));
					const { inserts, paths } = extract_paths(declarator$1.id, tmp);

					declarations.push(
						declarator(
							tmp,
							/** @type {Expression} */ (context.visit(/** @type {Expression} */ (declarator$1.init)))
						)
					);

					for (const { id, value } of inserts) {
						id.name = context.state.scope.generate('$$array');
						context.state.transform[id.name] = { read: get_value };

						const expression = /** @type {Expression} */ (context.visit(thunk(value)));
						declarations.push(declarator(id, call('$.derived', expression)));
					}

					for (const path of paths) {
						const name = /** @type {Identifier} */ (path.node).name;
						const binding = /** @type {Binding} */ (context.state.scope.get(name));
						const value = /** @type {Expression} */ (context.visit(path.expression));

						declarations.push(
							declarator(
								path.node,
								binding.kind === 'bindable_prop'
									? get_prop_source(binding, context.state, binding.prop_alias ?? name, value)
									: value
							)
						);
					}

					continue;
				}

				const binding = /** @type {Binding} */ (context.state.scope.get(declarator$1.id.name));

				declarations.push(
					declarator(
						declarator$1.id,
						get_prop_source(
							binding,
							context.state,
							binding.prop_alias ?? declarator$1.id.name,
							declarator$1.init && /** @type {Expression} */ (context.visit(declarator$1.init))
						)
					)
				);

				continue;
			}

			declarations.push(
				...create_state_declarators(
					declarator$1,
					context,
					/** @type {Expression} */ (declarator$1.init && context.visit(declarator$1.init))
				)
			);
		}
	}

	if (declarations.length === 0) {
		return empty;
	}

	return {
		...node,
		declarations
	};
}

/**
 * Creates the output for a state declaration in legacy mode.
 * @param {VariableDeclarator} declarator
 * @param {ComponentContext} context
 * @param {Expression} value
 */
function create_state_declarators(declarator$1, context, value) {
	if (declarator$1.id.type === 'Identifier') {
		return [
			declarator(
				declarator$1.id,
				call('$.mutable_source', value, context.state.analysis.immutable ? true_instance : undefined)
			)
		];
	}

	const tmp = id$2(context.state.scope.generate('tmp'));
	const { inserts, paths } = extract_paths(declarator$1.id, tmp);

	return [
		declarator(tmp, value),
		...inserts.map(({ id, value }) => {
			id.name = context.state.scope.generate('$$array');
			context.state.transform[id.name] = { read: get_value };

			const expression = /** @type {Expression} */ (context.visit(thunk(value)));
			return declarator(id, call('$.derived', expression));
		}),
		...paths.map((path) => {
			const value = /** @type {Expression} */ (context.visit(path.expression));
			const binding = context.state.scope.get(/** @type {Identifier} */ (path.node).name);

			return declarator(
				path.node,
				binding?.kind === 'state'
					? call('$.mutable_source', value, context.state.analysis.immutable ? true_instance : undefined)
					: value
			);
		})
	];
}

const visitors = {
  _: function set_scope(node, { next, state }) {
    const scope = state.scopes.get(node);
    if (scope && scope !== state.scope) {
      const transform = { ...state.transform };
      for (const [name, binding] of scope.declarations) {
        if (binding.kind === "normal" || // Reads of `$state(...)` declarations are not
        // transformed if they are never reassigned
        binding.kind === "state" && !is_state_source(binding, state.analysis)) {
          delete transform[name];
        }
      }
      next({ ...state, transform, scope });
    } else {
      next();
    }
  },
  AnimateDirective,
  ArrowFunctionExpression,
  AssignmentExpression,
  Attribute,
  AwaitBlock,
  AwaitExpression,
  BinaryExpression,
  BindDirective,
  BlockStatement,
  BreakStatement,
  CallExpression,
  ClassBody,
  Comment,
  Component,
  ConstTag,
  DebugTag,
  EachBlock,
  ExportNamedDeclaration,
  ExpressionStatement,
  ForOfStatement,
  Fragment,
  FunctionDeclaration,
  FunctionExpression,
  HtmlTag,
  Identifier,
  IfBlock,
  KeyBlock,
  LabeledStatement,
  LetDirective,
  MemberExpression,
  OnDirective,
  Program,
  RegularElement,
  RenderTag,
  SlotElement,
  SnippetBlock,
  SpreadAttribute,
  SvelteBody,
  SvelteComponent,
  SvelteDocument,
  SvelteElement,
  SvelteFragment,
  SvelteBoundary,
  SvelteHead,
  SvelteSelf,
  SvelteWindow,
  TitleElement,
  TransitionDirective,
  UpdateExpression,
  UseDirective,
  AttachTag,
  VariableDeclaration
};
function client_component(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    is_instance: false,
    hoisted: [import_all("$", "svelte/internal/client"), ...analysis.instance_body.hoisted],
    node: (
      /** @type {any} */
      null
    ),
    // populated by the root node
    legacy_reactive_imports: [],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      namespace: options.namespace,
      bound_contenteditable: false
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: options.preserveWhitespace,
    state_fields: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false,
    instance_level_snippets: [],
    module_level_snippets: [],
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    consts: (
      /** @type {any} */
      null
    ),
    let_directives: (
      /** @type {any} */
      null
    ),
    update: (
      /** @type {any} */
      null
    ),
    after_update: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    memoizer: (
      /** @type {any} */
      null
    )
  };
  const module = (
    /** @type {ESTree.Program} */
    walk$1(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      visitors
    )
  );
  const instance_state = {
    ...state,
    transform: { ...state.transform },
    scope: analysis.instance.scope,
    scopes: analysis.instance.scopes,
    is_instance: true
  };
  const instance = (
    /** @type {ESTree.Program} */
    walk$1(
      /** @type {AST.SvelteNode} */
      analysis.instance.ast,
      instance_state,
      visitors
    )
  );
  const template = (
    /** @type {ESTree.Program} */
    walk$1(
      /** @type {AST.SvelteNode} */
      analysis.template.ast,
      {
        ...state,
        transform: instance_state.transform,
        scope: analysis.instance.scope,
        scopes: analysis.template.scopes
      },
      visitors
    )
  );
  module.body.unshift(...state.legacy_reactive_imports);
  const store_setup = [];
  let store_init = empty;
  const legacy_reactive_declarations = [];
  let needs_store_cleanup = false;
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "legacy_reactive") {
      legacy_reactive_declarations.push(
        const_builder(
          name,
          call("$.mutable_source", void 0, analysis.immutable ? true_instance : void 0)
        )
      );
    }
    if (binding.kind === "store_sub") {
      if (store_setup.length === 0) {
        needs_store_cleanup = true;
        store_init = const_builder(
          array_pattern([id$2("$$stores"), id$2("$$cleanup")]),
          call("$.setup_stores")
        );
      }
      const store_reference = build_getter$1(id$2(name.slice(1)), instance_state);
      const store_get = call("$.store_get", store_reference, literal(name), id$2("$$stores"));
      store_setup.push(
        const_builder(
          binding.node,
          dev ? thunk(
            sequence([
              call("$.validate_store", store_reference, literal(name.slice(1))),
              store_get
            ])
          ) : thunk(store_get)
        )
      );
    }
  }
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n]) => n === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  if (analysis.reactive_statements.size > 0) {
    instance.body.push(stmt(call("$.legacy_pre_effect_reset")));
  }
  const group_binding_declarations = [];
  for (const group of analysis.binding_groups.values()) {
    group_binding_declarations.push(const_builder(group.name, array([])));
  }
  const component_returned_object = analysis.exports.flatMap(({ name, alias }) => {
    const binding = instance_state.scope.get(name);
    const expression = build_getter$1(id$2(name), instance_state);
    const getter = get$1(alias ?? name, [return_builder(expression)]);
    if (expression.type === "Identifier") {
      if (binding?.declaration_kind === "let" || binding?.declaration_kind === "var") {
        return [
          getter,
          set(alias ?? name, [stmt(assignment("=", expression, id$2("$$value")))])
        ];
      } else if (!dev) {
        return init(alias ?? name, expression);
      }
    }
    if (binding?.kind === "prop" || binding?.kind === "bindable_prop") {
      return [getter, set(alias ?? name, [stmt(call(name, id$2("$$value")))])];
    }
    if (binding?.kind === "state" || binding?.kind === "raw_state") {
      const value = binding.kind === "state" ? call("$.proxy", id$2("$$value")) : id$2("$$value");
      return [getter, set(alias ?? name, [stmt(call("$.set", id$2(name), value))])];
    }
    return getter;
  });
  const properties = [...analysis.instance.scope.declarations].filter(
    ([name, binding]) => (binding.kind === "prop" || binding.kind === "bindable_prop") && !name.startsWith("$$")
  );
  if (analysis.accessors) {
    for (const [name, binding] of properties) {
      const key = binding.prop_alias ?? name;
      const getter = get$1(key, [return_builder(call(id$2(name)))]);
      const setter = set(key, [
        stmt(call(id$2(name), id$2("$$value"))),
        stmt(call("$.flush"))
      ]);
      if (analysis.runes && binding.initial) {
        setter.value.params[0] = {
          type: "AssignmentPattern",
          left: id$2("$$value"),
          right: (
            /** @type {ESTree.Expression} */
            binding.initial
          )
        };
      }
      component_returned_object.push(getter, setter);
    }
  }
  if (options.compatibility.componentApi === 4) {
    component_returned_object.push(
      init("$set", id$2("$.update_legacy_props")),
      init(
        "$on",
        arrow(
          [id$2("$$event_name"), id$2("$$event_cb")],
          call(
            "$.add_legacy_event_listener",
            id$2("$$props"),
            id$2("$$event_name"),
            id$2("$$event_cb")
          )
        )
      )
    );
  } else if (dev) {
    component_returned_object.push(spread(call(id$2("$.legacy_api"))));
  }
  const push_args = [id$2("$$props"), literal(analysis.runes)];
  if (dev) push_args.push(id$2(analysis.name));
  let component_block = block([
    store_init,
    ...legacy_reactive_declarations,
    ...group_binding_declarations
  ]);
  const should_inject_context = dev || analysis.needs_context || analysis.reactive_statements.size > 0 || component_returned_object.length > 0;
  component_block.body.push(
    ...state.instance_level_snippets,
    .../** @type {ESTree.Statement[]} */
    instance.body
  );
  if (should_inject_context && component_returned_object.length > 0) {
    component_block.body.push(var_builder("$$exports", object$2(component_returned_object)));
  }
  component_block.body.unshift(...store_setup);
  if (!analysis.runes && analysis.needs_context) {
    component_block.body.push(stmt(call("$.init", analysis.immutable ? true_instance : void 0)));
  }
  component_block.body.push(.../** @type {ESTree.Statement[]} */
  template.body);
  if (analysis.needs_mutation_validation) {
    component_block.body.unshift(
      var_builder("$$ownership_validator", call("$.create_ownership_validator", id$2("$$props")))
    );
  }
  let should_inject_props = should_inject_context || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  component_block.loc = instance.loc;
  if (!analysis.runes) {
    for (const { name, alias } of analysis.exports) {
      component_block.body.push(
        stmt(
          call(
            "$.bind_prop",
            id$2("$$props"),
            literal(alias ?? name),
            build_getter$1(id$2(name), instance_state)
          )
        )
      );
    }
  }
  if (analysis.css.ast !== null && analysis.inject_styles) {
    const hash = literal(analysis.css.hash);
    const code = literal(render_stylesheet(analysis.source, analysis, options).code);
    state.hoisted.push(const_builder("$$css", object$2([init("hash", hash), init("code", code)])));
    component_block.body.unshift(
      stmt(call("$.append_styles", id$2("$$anchor"), id$2("$$css")))
    );
  }
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", ...push_args)));
    let to_push;
    if (component_returned_object.length > 0) {
      let pop_call = call("$.pop", id$2("$$exports"));
      to_push = needs_store_cleanup ? var_builder("$$pop", pop_call) : return_builder(pop_call);
    } else {
      to_push = stmt(call("$.pop"));
    }
    component_block.body.push(to_push);
  }
  if (needs_store_cleanup) {
    component_block.body.push(stmt(call("$$cleanup")));
    if (component_returned_object.length > 0) {
      component_block.body.push(return_builder(id$2("$$pop")));
    }
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.legacy_rest_props",
          id$2("$$sanitized_props"),
          array(named_props.map((name) => literal(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    const to_remove = [
      literal("children"),
      literal("$$slots"),
      literal("$$events"),
      literal("$$legacy")
    ];
    if (analysis.custom_element) {
      to_remove.push(literal("$$host"));
    }
    component_block.body.unshift(
      const_builder(
        "$$sanitized_props",
        call("$.legacy_rest_props", id$2("$$props"), array(to_remove))
      )
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id$2("$$props"))));
  }
  const imports$1 = [];
  let body = [];
  for (const entry of [...module.body, ...state.hoisted]) {
    if (entry.type === "ImportDeclaration") {
      imports$1.push(entry);
    } else {
      body.push(entry);
    }
  }
  body = [...imports$1, ...state.module_level_snippets, ...body];
  const component = function_declaration(
    id$2(analysis.name),
    should_inject_props ? [id$2("$$anchor"), id$2("$$props")] : [id$2("$$anchor")],
    component_block
  );
  if (options.hmr) {
    const id = id$2(analysis.name);
    const HMR = id$2("$.HMR");
    const existing = member(id, HMR, true);
    const incoming = member(id$2("module.default"), HMR, true);
    const accept_fn_body = [
      stmt(assignment("=", member(incoming, "source"), member(existing, "source"))),
      stmt(call("$.set", member(existing, "source"), member(incoming, "original")))
    ];
    if (analysis.css.hash) {
      accept_fn_body.unshift(stmt(call("$.cleanup_styles", literal(analysis.css.hash))));
    }
    const hmr = block([
      stmt(assignment("=", id, call("$.hmr", id, thunk(member(existing, "source"))))),
      stmt(call("import.meta.hot.accept", arrow([id$2("module")], block(accept_fn_body))))
    ]);
    body.push(component, if_builder(id$2("import.meta.hot"), hmr), export_default(id$2(analysis.name)));
  } else {
    body.push(export_default(component));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id$2(analysis.name), "$.FILENAME", true), literal(filename))
      )
    );
  }
  if (options.experimental.async) {
    body.unshift(imports([], "svelte/internal/flags/async"));
  }
  if (!analysis.runes) {
    body.unshift(imports([], "svelte/internal/flags/legacy"));
  }
  if (analysis.tracing) {
    body.unshift(imports([], "svelte/internal/flags/tracing"));
  }
  if (options.discloseVersion) {
    body.unshift(imports([], "svelte/internal/disclose-version"));
  }
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports([["createClassComponent", "$$_createClassComponent"]], "svelte/legacy"));
    component_block.body.unshift(
      if_builder(
        id$2("new.target"),
        return_builder(
          call(
            "$$_createClassComponent",
            // When called with new, the first argument is the constructor options
            object$2([init("component", id$2(analysis.name)), spread(id$2("$$anchor"))])
          )
        )
      )
    );
  } else if (dev) {
    component_block.body.unshift(stmt(call("$.check_target", id$2("new.target"))));
  }
  if (analysis.props_id) {
    component_block.body.unshift(const_builder(analysis.props_id, call("$.props_id")));
  }
  if (state.events.size > 0) {
    body.push(
      stmt(call("$.delegate", array(Array.from(state.events).map((name) => literal(name)))))
    );
  }
  const ce = options.customElementOptions ?? options.customElement;
  if (ce) {
    const ce_props = typeof ce === "boolean" ? {} : ce.props || {};
    const props_str = [];
    for (const [name, prop_def] of Object.entries(ce_props)) {
      const binding = analysis.instance.scope.get(name);
      const key = binding?.prop_alias ?? name;
      if (!prop_def.type && binding?.initial?.type === "Literal" && typeof binding?.initial.value === "boolean") {
        prop_def.type = "Boolean";
      }
      const value = object$2(
        /** @type {ESTree.Property[]} */
        [
          prop_def.attribute ? init("attribute", literal(prop_def.attribute)) : void 0,
          prop_def.reflect ? init("reflect", true_instance) : void 0,
          prop_def.type ? init("type", literal(prop_def.type)) : void 0
        ].filter(Boolean)
      );
      props_str.push(init(key, value));
    }
    for (const [name, binding] of properties) {
      const key = binding.prop_alias ?? name;
      if (ce_props[key]) continue;
      props_str.push(init(key, object$2([])));
    }
    const slots_str = array([...analysis.slot_names.keys()].map((name) => literal(name)));
    const accessors_str = array(
      analysis.exports.map(({ name, alias }) => literal(alias ?? name))
    );
    const use_shadow_dom = typeof ce === "boolean" || ce.shadow !== "none" ? true : false;
    const create_ce = call(
      "$.create_custom_element",
      id$2(analysis.name),
      object$2(props_str),
      slots_str,
      accessors_str,
      literal(use_shadow_dom),
      /** @type {any} */
      typeof ce !== "boolean" ? ce.extend : void 0
    );
    if (typeof ce !== "boolean" && typeof ce.tag === "string") {
      const define = stmt(call("customElements.define", literal(ce.tag), create_ce));
      if (options.hmr) {
        body.push(
          if_builder(binary$1("==", call("customElements.get", literal(ce.tag)), null_instance), define)
        );
      } else {
        body.push(define);
      }
    } else {
      body.push(stmt(create_ce));
    }
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function client_module(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    state_fields: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false,
    is_instance: false
  };
  const module = (
    /** @type {ESTree.Program} */
    walk$1(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      visitors
    )
  );
  const body = [import_all("$", "svelte/internal/client")];
  if (analysis.tracing) {
    body.push(imports([], "svelte/internal/flags/tracing"));
  }
  return {
    type: "Program",
    sourceType: "module",
    body: [...body, ...module.body]
  };
}

/** @import { Node } from 'esrap/languages/ts' */
/** @import { ValidatedCompileOptions, CompileResult, ValidatedModuleCompileOptions } from '#compiler' */
/** @import { ComponentAnalysis, Analysis } from '../types' */

/**
 * @param {ComponentAnalysis} analysis
 * @param {string} source
 * @param {ValidatedCompileOptions} options
 * @returns {CompileResult}
 */
function transform_component(analysis, source, options) {
	if (options.generate === false) {
		return {
			js: /** @type {any} */ (null),
			css: null,
			warnings: warnings, // set afterwards
			metadata: {
				runes: analysis.runes
			},
			ast: /** @type {any} */ (null) // set afterwards
		};
	}

	const program =
		options.generate === 'server'
			? server_component(analysis, options)
			: client_component(analysis, options);

	const js_source_name = get_source_name(options.filename, options.outputFilename);

	const js = print(/** @type {Node} */ (program), ts({ comments: analysis.comments }), {
		// include source content; makes it easier/more robust looking up the source map code
		// (else esrap does return null for source and sourceMapContent which may trip up tooling)
		sourceMapContent: source,
		sourceMapSource: js_source_name
	});

	merge_with_preprocessor_map(js, options, js_source_name);

	const css =
		analysis.css.ast && !analysis.inject_styles
			? render_stylesheet(source, analysis, options)
			: null;

	return {
		js,
		css,
		warnings: warnings, // set afterwards. TODO apply preprocessor sourcemap
		metadata: {
			runes: analysis.runes
		},
		ast: /** @type {any} */ (null) // set afterwards
	};
}

/**
 * @param {Analysis} analysis
 * @param {string} source
 * @param {ValidatedModuleCompileOptions} options
 * @returns {CompileResult}
 */
function transform_module(analysis, source, options) {
	if (options.generate === false) {
		return {
			js: /** @type {any} */ (null),
			css: null,
			warnings: warnings, // set afterwards
			metadata: {
				runes: true
			},
			ast: /** @type {any} */ (null) // set afterwards
		};
	}

	const program =
		options.generate === 'server'
			? server_module(analysis, options)
			: client_module(analysis, options);

	const basename = options.filename.split(/[/\\]/).at(-1);
	if (program.body.length > 0) {
		program.body[0].leadingComments = [
			{
				type: 'Block',
				value: ` ${basename} generated by Svelte v${VERSION} `
			}
		];
	}

	const js = print(/** @type {Node} */ (program), ts({ comments: analysis.comments }), {
		// include source content; makes it easier/more robust looking up the source map code
		// (else esrap does return null for source and sourceMapContent which may trip up tooling)
		sourceMapContent: source,
		sourceMapSource: get_source_name(options.filename, undefined)
	});

	// prepend comment
	js.code = `/* ${basename} generated by Svelte v${VERSION} */\n${js.code}`;
	js.map.mappings = ';' + js.map.mappings;

	return {
		js,
		css: null,
		metadata: {
			runes: true
		},
		warnings: warnings, // set afterwards
		ast: /** @type {any} */ (null) // set afterwards
	};
}

/** @import { ModuleCompileOptions, ValidatedModuleCompileOptions, CompileOptions, ValidatedCompileOptions } from '#compiler' */

/**
 * @template [Input=any]
 * @template [Output=Input]
 * @typedef {(input: Input, keypath: string) => Required<Output>} Validator
 */

const common_options = {
	filename: string('(unknown)'),

	// default to process.cwd() where it exists to replicate svelte4 behavior (and make Deno work with this as well)
	// see https://github.com/sveltejs/svelte/blob/b62fc8c8fd2640c9b99168f01b9d958cb2f7574f/packages/svelte/src/compiler/compile/Component.js#L211
	/* eslint-disable */
	rootDir: string(
		typeof process !== 'undefined'
			? process.cwd?.()
			: // @ts-expect-error
				typeof Deno !== 'undefined'
				? // @ts-expect-error
					Deno.cwd()
				: undefined
	),
	/* eslint-enable */

	dev: boolean(false),

	generate: validator('client', (input, keypath) => {
		if (input === 'dom' || input === 'ssr') {
			warn_once(options_renamed_ssr_dom);
			return input === 'dom' ? 'client' : 'server';
		}

		// TODO deprecate `false` in favour of `analyze`/`analyzeModule` https://github.com/sveltejs/svelte-octane/issues/655
		if (input !== 'client' && input !== 'server' && input !== false) {
			throw_error(`${keypath} must be "client", "server" or false`);
		}

		return input;
	}),

	warningFilter: fun(() => true),

	experimental: object({
		async: boolean(false)
	})
};

const component_options = {
	accessors: deprecate(options_deprecated_accessors, boolean(false)),

	css: validator('external', (input) => {
		if (input === true || input === false) {
			throw_error(
				'The boolean options have been removed from the css option. Use "external" instead of false and "injected" instead of true'
			);
		}
		if (input === 'none') {
			throw_error(
				'css: "none" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case.'
			);
		}

		if (input !== 'external' && input !== 'injected') {
			throw_error(`css should be either "external" (default, recommended) or "injected"`);
		}

		return input;
	}),

	cssHash: fun(({ css, filename, hash }) => {
		return `svelte-${hash(filename === '(unknown)' ? css : filename ?? css)}`;
	}),

	// TODO this is a sourcemap option, would be good to put under a sourcemap namespace
	cssOutputFilename: string(undefined),

	customElement: boolean(false),

	discloseVersion: boolean(true),

	immutable: deprecate(options_deprecated_immutable, boolean(false)),

	legacy: removed(
		'The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead'
	),

	compatibility: object({
		componentApi: list([4, 5], 5)
	}),

	loopGuardTimeout: warn_removed(options_removed_loop_guard_timeout),

	name: string(undefined),

	namespace: list(['html', 'mathml', 'svg']),

	modernAst: boolean(false),

	outputFilename: string(undefined),

	preserveComments: boolean(false),

	fragments: list(['html', 'tree']),

	preserveWhitespace: boolean(false),

	runes: boolean(undefined),

	hmr: boolean(false),

	sourcemap: validator(undefined, (input) => {
		// Source maps can take on a variety of values, including string, JSON, map objects from magic-string and source-map,
		// so there's no good way to check type validity here
		return input;
	}),

	enableSourcemap: warn_removed(options_removed_enable_sourcemap),

	hydratable: warn_removed(options_removed_hydratable),

	format: removed(
		'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. ' +
			'If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
	),

	tag: removed(
		'The tag option has been removed in Svelte 5. Use `<svelte:options customElement="tag-name" />` inside the component instead. ' +
			'If that does not solve your use case, please open an issue on GitHub with details.'
	),

	sveltePath: removed(
		'The sveltePath option has been removed in Svelte 5. ' +
			'If this option was crucial for you, please open an issue on GitHub with your use case.'
	),

	// These two were primarily created for svelte-preprocess (https://github.com/sveltejs/svelte/pull/6194),
	// but with new TypeScript compilation modes strictly separating types it's not necessary anymore
	errorMode: removed(
		'The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, ' +
			'use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead'
	),

	varsReport: removed(
		'The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, ' +
			'use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead'
	)
};

const validate_module_options =
	/** @type {Validator<ModuleCompileOptions, ValidatedModuleCompileOptions>} */ (
		object({
			...common_options,
			...Object.fromEntries(Object.keys(component_options).map((key) => [key, () => {}]))
		})
	);

const validate_component_options =
	/** @type {Validator<CompileOptions, ValidatedCompileOptions>} */ (
		object({
			...common_options,
			...component_options
		})
	);

/**
 * @param {string} msg
 * @returns {Validator}
 */
function removed(msg) {
	return (input) => {
		if (input !== undefined) {
			options_removed(null, msg);
		}
		return /** @type {any} */ (undefined);
	};
}

const warned = new Set();

/** @param {(node: null) => void} fn */
function warn_once(fn) {
	if (!warned.has(fn)) {
		warned.add(fn);
		fn(null);
	}
}

/**
 * @param {(node: null) => void} fn
 * @returns {Validator}
 */
function warn_removed(fn) {
	return (input) => {
		if (input !== undefined) warn_once(fn);
		return /** @type {any} */ (undefined);
	};
}

/**
 * @param {(node: null) => void} fn
 * @param {Validator} validator
 * @returns {Validator}
 */
function deprecate(fn, validator) {
	return (input, keypath) => {
		if (input !== undefined) warn_once(fn);
		return validator(input, keypath);
	};
}

/**
 * @param {Record<string, Validator>} children
 * @param {boolean} [allow_unknown]
 * @returns {Validator}
 */
function object(children, allow_unknown = false) {
	return (input, keypath) => {
		/** @type {Record<string, any>} */
		const output = {};

		if ((input && typeof input !== 'object') || Array.isArray(input)) {
			throw_error(`${keypath} should be an object`);
		}

		for (const key in input) {
			if (!(key in children)) {
				if (allow_unknown) {
					output[key] = input[key];
				} else {
					options_unrecognised(null, `${keypath ? `${keypath}.${key}` : key}`);
				}
			}
		}

		for (const key in children) {
			const validator = children[key];
			output[key] = validator(input && input[key], keypath ? `${keypath}.${key}` : key);
		}

		return output;
	};
}

/**
 * @param {any} fallback
 * @param {(value: any, keypath: string) => any} fn
 * @returns {Validator}
 */
function validator(fallback, fn) {
	return (input, keypath) => {
		return input === undefined ? fallback : fn(input, keypath);
	};
}

/**
 * @param {string | undefined} fallback
 * @param {boolean} allow_empty
 * @returns {Validator}
 */
function string(fallback, allow_empty = true) {
	return validator(fallback, (input, keypath) => {
		if (typeof input !== 'string') {
			throw_error(`${keypath} should be a string, if specified`);
		}

		if (!allow_empty && input === '') {
			throw_error(`${keypath} cannot be empty`);
		}

		return input;
	});
}

/**
 * @param {boolean | undefined} fallback
 * @returns {Validator}
 */
function boolean(fallback) {
	return validator(fallback, (input, keypath) => {
		if (typeof input !== 'boolean') {
			throw_error(`${keypath} should be true or false, if specified`);
		}
		return input;
	});
}

/**
 * @param {Array<boolean | string | number>} options
 * @returns {Validator}
 */
function list(options, fallback = options[0]) {
	return validator(fallback, (input, keypath) => {
		if (!options.includes(input)) {
			// prettier-ignore
			const msg = options.length > 2
				? `${keypath} should be one of ${options.slice(0, -1).map(input => `"${input}"`).join(', ')} or "${options[options.length - 1]}"`
				: `${keypath} should be either "${options[0]}" or "${options[1]}"`;

			throw_error(msg);
		}
		return input;
	});
}

/**
 * @param {(...args: any) => any} fallback
 * @returns {Validator}
 */
function fun(fallback) {
	return validator(fallback, (input, keypath) => {
		if (typeof input !== 'function') {
			throw_error(`${keypath} should be a function, if specified`);
		}
		return input;
	});
}

/** @param {string} msg */
function throw_error(msg) {
	options_invalid_value(null, msg);
}

/** @import { Processed } from './public.js' */

/**
 * Import decoded sourcemap from mozilla/source-map/SourceMapGenerator
 * Forked from source-map/lib/source-map-generator.js
 * from methods _serializeMappings and toJSON.
 * We cannot use source-map.d.ts types, because we access hidden properties.
 * @param {any} generator
 */
function decoded_sourcemap_from_generator(generator) {
	let previous_generated_line = 1;
	/** @type {number[][][]} */
	const converted_mappings = [[]];
	let result_line = converted_mappings[0];
	let result_segment;
	let mapping;
	const source_idx = generator._sources
		.toArray()
		// @ts-ignore
		.reduce((acc, val, idx) => ((acc[val] = idx), acc), {});
	const name_idx = generator._names
		.toArray()
		// @ts-ignore
		.reduce((acc, val, idx) => ((acc[val] = idx), acc), {});
	const mappings = generator._mappings.toArray();
	for (let i = 0, len = mappings.length; i < len; i++) {
		mapping = mappings[i];
		if (mapping.generatedLine > previous_generated_line) {
			while (mapping.generatedLine > previous_generated_line) {
				converted_mappings.push([]);
				previous_generated_line++;
			}
			result_line = converted_mappings[mapping.generatedLine - 1]; // line is one-based
		} else if (i > 0) {
			const previous_mapping = mappings[i - 1];
			if (
				// sorted by selectivity
				mapping.generatedColumn === previous_mapping.generatedColumn &&
				mapping.originalColumn === previous_mapping.originalColumn &&
				mapping.name === previous_mapping.name &&
				mapping.generatedLine === previous_mapping.generatedLine &&
				mapping.originalLine === previous_mapping.originalLine &&
				mapping.source === previous_mapping.source
			) {
				continue;
			}
		}
		result_line.push([mapping.generatedColumn]);
		result_segment = result_line[result_line.length - 1];
		if (mapping.source != null) {
			result_segment.push(
				...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
			);
			if (mapping.name != null) {
				result_segment.push(name_idx[mapping.name]);
			}
		}
	}

	/**
	 * @type {{
	 *  version: number;
	 * sources: string[];
	 * names: string[];
	 * mappings: number[][][];
	 * file?: string;
	 * }}
	 */
	const map = {
		version: generator._version,
		sources: generator._sources.toArray(),
		names: generator._names.toArray(),
		mappings: converted_mappings
	};
	if (generator._file != null) {
		map.file = generator._file;
	}
	// not needed: map.sourcesContent and map.sourceRoot
	return map;
}

/**
 * @param {Processed} processed
 */
function decode_map(processed) {
	let decoded_map = typeof processed.map === 'string' ? JSON.parse(processed.map) : processed.map;
	if (typeof decoded_map.mappings === 'string') {
		decoded_map.mappings = decode(decoded_map.mappings);
	}
	if (decoded_map._mappings && decoded_map.constructor.name === 'SourceMapGenerator') {
		// import decoded sourcemap from mozilla/source-map/SourceMapGenerator
		decoded_map = decoded_sourcemap_from_generator(decoded_map);
	}
	return decoded_map;
}

/** @import { Source, Replacement } from './private.js' */

/**
 * @param {string} code_slice
 * @param {number} offset
 * @param {Source} opts
 * @returns {Source}
 */
function slice_source(code_slice, offset, { file_basename, filename, get_location }) {
	return {
		source: code_slice,
		get_location: (index) => get_location(index + offset),
		file_basename,
		filename
	};
}

/**
 * @param {RegExp} re
 * @param {(...match: any[]) => Promise<MappedCode>} get_replacement
 * @param {string} source
 */
function calculate_replacements(re, get_replacement, source) {
	/**
	 * @type {Array<Promise<Replacement>>}
	 */
	const replacements = [];
	source.replace(re, (...match) => {
		replacements.push(
			get_replacement(...match).then((replacement) => {
				const matched_string = match[0];
				const offset = match[match.length - 2];
				return { offset, length: matched_string.length, replacement };
			})
		);
		return '';
	});
	return Promise.all(replacements);
}

/**
 * @param {Replacement[]} replacements
 * @param {Source} source
 * @returns {MappedCode}
 */
function perform_replacements(replacements, source) {
	const out = new MappedCode();
	let last_end = 0;
	for (const { offset, length, replacement } of replacements) {
		const unchanged_prefix = MappedCode.from_source(
			slice_source(source.source.slice(last_end, offset), last_end, source)
		);
		out.concat(unchanged_prefix).concat(replacement);
		last_end = offset + length;
	}
	const unchanged_suffix = MappedCode.from_source(
		slice_source(source.source.slice(last_end), last_end, source)
	);
	return out.concat(unchanged_suffix);
}

/**
 * @param {RegExp} regex
 * @param {(...match: any[]) => Promise<MappedCode>} get_replacement
 * @param {Source} location
 * @returns {Promise<MappedCode>}
 */
async function replace_in_code(regex, get_replacement, location) {
	const replacements = await calculate_replacements(regex, get_replacement, location.source);
	return perform_replacements(replacements, location);
}

/** @import { Processed, Preprocessor, MarkupPreprocessor, PreprocessorGroup } from './public.js' */
/** @import { SourceUpdate, Source } from './private.js' */
/** @import { DecodedSourceMap, RawSourceMap } from '@jridgewell/remapping' */

/**
 * Represents intermediate states of the preprocessing.
 * Implements the Source interface.
 */
class PreprocessResult {
	/** @type {string} */
	source;

	/** @type {string | undefined} The filename passed as-is to preprocess */
	filename;

	// sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
	// so we use sourcemap_list.unshift() to add new maps
	// https://github.com/jridgewell/sourcemaps/tree/main/packages/remapping#multiple-transformations-of-a-file

	/**
	 * @default []
	 * @type {Array<DecodedSourceMap | RawSourceMap>}
	 */
	sourcemap_list = [];

	/**
	 * @default []
	 * @type {string[]}
	 */
	dependencies = [];

	/**
	 * @type {string | null} last part of the filename, as used for `sources` in sourcemaps
	 */
	file_basename = /** @type {any} */ (undefined);

	/**
	 * @type {ReturnType<typeof getLocator>}
	 */
	get_location = /** @type {any} */ (undefined);

	/**
	 * @param {string} source
	 * @param {string} [filename]
	 */
	constructor(source, filename) {
		this.source = source;
		this.filename = filename;
		this.update_source({ string: source });
		// preprocess source must be relative to itself or equal null
		this.file_basename = filename == null ? null : get_basename(filename);
	}

	/**
	 * @param {SourceUpdate} opts
	 */
	update_source({ string: source, map, dependencies }) {
		if (source != null) {
			this.source = source;
			this.get_location = getLocator$1(source);
		}
		if (map) {
			this.sourcemap_list.unshift(map);
		}
		if (dependencies) {
			this.dependencies.push(...dependencies);
		}
	}

	/**
	 * @returns {Processed}
	 */
	to_processed() {
		// Combine all the source maps for each preprocessor function into one
		// @ts-expect-error TODO there might be a bug in hiding here
		const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
		return {
			// TODO return separated output, in future version where svelte.compile supports it:
			// style: { code: styleCode, map: styleMap },
			// script { code: scriptCode, map: scriptMap },
			// markup { code: markupCode, map: markupMap },
			code: this.source,
			dependencies: [...new Set(this.dependencies)],
			// @ts-expect-error TODO there might be a bug in hiding here
			map,
			toString: () => this.source
		};
	}
}
/**
 * Convert preprocessor output for the tag content into MappedCode
 * @param {Processed} processed
 * @param {{ line: number; column: number; }} location
 * @param {string} file_basename
 * @returns {MappedCode}
 */
function processed_content_to_code(processed, location, file_basename) {
	// Convert the preprocessed code and its sourcemap to a MappedCode

	/**
	 * @type {DecodedSourceMap | undefined}
	 */
	let decoded_map = undefined;
	if (processed.map) {
		decoded_map = decode_map(processed);
		// decoded map may not have sources for empty maps like `{ mappings: '' }`
		if (decoded_map?.sources) {
			// offset only segments pointing at original component source
			const source_index = decoded_map.sources.indexOf(file_basename);
			if (source_index !== -1) {
				sourcemap_add_offset(decoded_map, location, source_index);
			}
		}
	}
	return MappedCode.from_processed(processed.code, decoded_map);
}
/**
 * Given the whole tag including content, return a `MappedCode`
 * representing the tag content replaced with `processed`.
 * @param {Processed} processed
 * @param {'style' | 'script'} tag_name
 * @param {string} original_attributes
 * @param {string} generated_attributes
 * @param {Source} source
 * @returns {MappedCode}
 */
function processed_tag_to_code(
	processed,
	tag_name,
	original_attributes,
	generated_attributes,
	source
) {
	const { file_basename, get_location } = source;

	/**
	 * @param {string} code
	 * @param {number} offset
	 */
	const build_mapped_code = (code, offset) =>
		MappedCode.from_source(slice_source(code, offset, source));

	// To map the open/close tag and content starts positions correctly, we need to
	// differentiate between the original attributes and the generated attributes:
	// `source` contains the original attributes and its get_location maps accordingly.
	const original_tag_open = `<${tag_name}${original_attributes}>`;
	const tag_open = `<${tag_name}${generated_attributes}>`;
	/** @type {MappedCode} */
	let tag_open_code;

	if (original_tag_open.length !== tag_open.length) {
		// Generate a source map for the open tag
		/** @type {DecodedSourceMap['mappings']} */
		const mappings = [
			[
				// start of tag
				[0, 0, 0, 0],
				// end of tag start
				[`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
			]
		];

		const line = tag_open.split('\n').length - 1;
		const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf('\n')) - 1;

		while (mappings.length <= line) {
			// end of tag start again, if this is a multi line mapping
			mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
		}

		// end of tag
		mappings[line].push([
			column,
			0,
			original_tag_open.split('\n').length - 1,
			original_tag_open.length - original_tag_open.lastIndexOf('\n') - 1
		]);

		/** @type {DecodedSourceMap} */
		const map = {
			version: 3,
			names: [],
			sources: [file_basename],
			mappings
		};
		sourcemap_add_offset(map, get_location(0), 0);
		tag_open_code = MappedCode.from_processed(tag_open, map);
	} else {
		tag_open_code = build_mapped_code(tag_open, 0);
	}

	const tag_close = `</${tag_name}>`;
	const tag_close_code = build_mapped_code(
		tag_close,
		original_tag_open.length + source.source.length
	);

	parse_attached_sourcemap(processed, tag_name);
	const content_code = processed_content_to_code(
		processed,
		get_location(original_tag_open.length),
		file_basename
	);

	return tag_open_code.concat(content_code).concat(tag_close_code);
}

const attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;

/**
 * @param {string} str
 */
function parse_tag_attributes(str) {
	/** @type {Record<string, string | boolean>} */
	const attrs = {};

	/** @type {RegExpMatchArray | null} */
	let match;
	while ((match = attribute_pattern.exec(str)) !== null) {
		const name = match[1];
		const value = match[2] || match[3] || match[4];
		attrs[name] = !value || value;
	}

	return attrs;
}

/**
 * @param {Record<string, string | boolean> | undefined} attributes
 */
function stringify_tag_attributes(attributes) {
	if (!attributes) return;

	let value = Object.entries(attributes)
		.map(([key, value]) => (value === true ? key : `${key}="${value}"`))
		.join(' ');
	if (value) {
		value = ' ' + value;
	}
	return value;
}

const regex_style_tags =
	/<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
const regex_script_tags =
	/<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;

/**
 * Calculate the updates required to process all instances of the specified tag.
 * @param {'style' | 'script'} tag_name
 * @param {Preprocessor} preprocessor
 * @param {Source} source
 * @returns {Promise<SourceUpdate>}
 */
async function process_tag(tag_name, preprocessor, source) {
	const { filename, source: markup } = source;
	const tag_regex = tag_name === 'style' ? regex_style_tags : regex_script_tags;

	/**
	 * @type {string[]}
	 */
	const dependencies = [];

	/**
	 * @param {string} tag_with_content
	 * @param {number} tag_offset
	 * @returns {Promise<MappedCode>}
	 */
	async function process_single_tag(tag_with_content, attributes = '', content = '', tag_offset) {
		const no_change = () =>
			MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
		if (!attributes && !content) return no_change();
		const processed = await preprocessor({
			content: content || '',
			attributes: parse_tag_attributes(attributes || ''),
			markup,
			filename
		});
		if (!processed) return no_change();
		if (processed.dependencies) dependencies.push(...processed.dependencies);
		if (!processed.map && processed.code === content) return no_change();
		return processed_tag_to_code(
			processed,
			tag_name,
			attributes,
			stringify_tag_attributes(processed.attributes) ?? attributes,
			slice_source(content, tag_offset, source)
		);
	}
	const { string, map } = await replace_in_code(tag_regex, process_single_tag, source);
	return { string, map, dependencies };
}

/**
 * @param {MarkupPreprocessor} process
 * @param {Source} source
 */
async function process_markup(process, source) {
	const processed = await process({
		content: source.source,
		filename: source.filename
	});
	if (processed) {
		return {
			string: processed.code,
			map: processed.map
				? // TODO: can we use decode_sourcemap?
					typeof processed.map === 'string'
					? JSON.parse(processed.map)
					: processed.map
				: undefined,
			dependencies: processed.dependencies
		};
	} else {
		return {};
	}
}

/**
 * The preprocess function provides convenient hooks for arbitrarily transforming component source code.
 * For example, it can be used to convert a `<style lang="sass">` block into vanilla CSS.
 *
 * @param {string} source
 * @param {PreprocessorGroup | PreprocessorGroup[]} preprocessor
 * @param {{ filename?: string }} [options]
 * @returns {Promise<Processed>}
 */
async function preprocess(source, preprocessor, options) {
	/**
	 * @type {string | undefined}
	 */
	const filename = (options && options.filename) || /** @type {any} */ (preprocessor).filename; // legacy
	const preprocessors = preprocessor
		? Array.isArray(preprocessor)
			? preprocessor
			: [preprocessor]
		: [];
	const result = new PreprocessResult(source, filename);

	// TODO keep track: what preprocessor generated what sourcemap?
	// to make debugging easier = detect low-resolution sourcemaps in fn combine_mappings
	for (const preprocessor of preprocessors) {
		if (preprocessor.markup) {
			// @ts-expect-error TODO there might be a bug in hiding here
			result.update_source(await process_markup(preprocessor.markup, result));
		}
		if (preprocessor.script) {
			// @ts-expect-error TODO there might be a bug in hiding here
			result.update_source(await process_tag('script', preprocessor.script, result));
		}
		if (preprocessor.style) {
			// @ts-expect-error TODO there might be a bug in hiding here
			result.update_source(await process_tag('style', preprocessor.style, result));
		}
	}

	return result.to_processed();
}

/** @import { LegacyRoot } from './types/legacy-nodes.js' */
/** @import { CompileOptions, CompileResult, ValidatedCompileOptions, ModuleCompileOptions } from '#compiler' */
/** @import { AST } from './public.js' */

/**
 * `compile` converts your `.svelte` source code into a JavaScript module that exports a component
 *
 * @param {string} source The component source code
 * @param {CompileOptions} options The compiler options
 * @returns {CompileResult}
 */
function compile(source, options) {
	source = remove_bom(source);
	reset({ warning: options.warningFilter, filename: options.filename });
	const validated = validate_component_options(options, '');

	let parsed = parse$3(source);

	const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};

	/** @type {ValidatedCompileOptions} */
	const combined_options = {
		...validated,
		...parsed_options,
		customElementOptions
	};

	if (parsed.metadata.ts) {
		parsed = {
			...parsed,
			fragment: parsed.fragment && remove_typescript_nodes(parsed.fragment),
			instance: parsed.instance && remove_typescript_nodes(parsed.instance),
			module: parsed.module && remove_typescript_nodes(parsed.module)
		};
		if (combined_options.customElementOptions?.extend) {
			combined_options.customElementOptions.extend = remove_typescript_nodes(
				combined_options.customElementOptions?.extend
			);
		}
	}

	const analysis = analyze_component(parsed, source, combined_options);
	const result = transform_component(analysis, source, combined_options);
	result.ast = to_public_ast(source, parsed, options.modernAst);
	return result;
}

/**
 * `compileModule` takes your JavaScript source code containing runes, and turns it into a JavaScript module.
 *
 * @param {string} source The component source code
 * @param {ModuleCompileOptions} options
 * @returns {CompileResult}
 */
function compileModule(source, options) {
	source = remove_bom(source);
	reset({ warning: options.warningFilter, filename: options.filename });
	const validated = validate_module_options(options, '');

	const analysis = analyze_module(source, validated);
	return transform_module(analysis, source, validated);
}

/**
 * @param {string} source
 * @param {AST.Root} ast
 * @param {boolean | undefined} modern
 */
function to_public_ast(source, ast, modern) {
	if (modern) {
		const clean = (/** @type {any} */ node) => {
			delete node.metadata;
		};

		ast.options?.attributes.forEach((attribute) => {
			clean(attribute);
			clean(attribute.value);
			if (Array.isArray(attribute.value)) {
				attribute.value.forEach(clean);
			}
		});

		// remove things that we don't want to treat as public API
		return walk$1(ast, null, {
			_(node, { next }) {
				clean(node);
				next();
			}
		});
	}

	return convert(source, ast);
}

/**
 * Remove the byte order mark from a string if it's present since it would mess with our template generation logic
 * @param {string} source
 */
function remove_bom(source) {
	if (source.charCodeAt(0) === 0xfeff) {
		return source.slice(1);
	}
	return source;
}

const hashes = Object.create(null);

//TODO shorter?
const hash_length = 12;

/**
 * replaces +/= in base64 output so they don't interfere
 *
 * @param {string} input
 * @returns {string} base64 hash safe to use in any context
 */
function safeBase64Hash(input) {
	if (hashes[input]) {
		return hashes[input];
	}
	//TODO if performance really matters, use a faster one like xx-hash etc.
	// should be evenly distributed because short input length and similarities in paths could cause collisions otherwise
	// OR DON'T USE A HASH AT ALL, what about a simple counter?
	const md5 = crypto$2.createHash('md5');
	md5.update(input);
	const hash = toSafe(md5.digest('base64')).slice(0, hash_length);
	hashes[input] = hash;
	return hash;
}

/** @type {Record<string, string>} */
const replacements = {
	'+': '-',
	'/': '_',
	'=': ''
};

const replaceRE = new RegExp(`[${Object.keys(replacements).join('')}]`, 'g');

/**
 * @param {string} base64
 * @returns {string}
 */
function toSafe(base64) {
	return base64.replace(replaceRE, (x) => replacements[x]);
}

/**
 * this appends a *{} rule to component styles to force the svelte compiler to add style classes to all nodes
 * That means adding/removing class rules from <style> node won't trigger js updates as the scope classes are not changed
 *
 * only used during dev with enabled css hmr
 *
 * @returns {import('svelte/compiler').PreprocessorGroup}
 */
function createInjectScopeEverythingRulePreprocessorGroup() {
	return {
		name: 'inject-scope-everything-rule',
		style({ content, filename }) {
			const s = new MagicString(content);
			s.append(' *{}');
			return {
				code: s.toString(),
				map: s.generateDecodedMap({
					source: filename ? path$b.basename(filename) : undefined,
					hires: true
				})
			};
		}
	};
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @param {import('vite').ResolvedConfig} config
 * @returns {{
 * 	prependPreprocessors: import('svelte/compiler').PreprocessorGroup[],
 * 	appendPreprocessors: import('svelte/compiler').PreprocessorGroup[]
 * }}
 */
function buildExtraPreprocessors(options, config) {
	/** @type {import('svelte/compiler').PreprocessorGroup[]} */
	const prependPreprocessors = [];
	/** @type {import('svelte/compiler').PreprocessorGroup[]} */
	const appendPreprocessors = [];

	// @ts-expect-error not typed
	const pluginsWithPreprocessorsDeprecated = config.plugins.filter((p) => p?.sveltePreprocess);
	if (pluginsWithPreprocessorsDeprecated.length > 0) {
		log.warn(
			`The following plugins use the deprecated 'plugin.sveltePreprocess' field. Please contact their maintainers and ask them to move it to 'plugin.api.sveltePreprocess': ${pluginsWithPreprocessorsDeprecated
				.map((p) => p.name)
				.join(', ')}`
		);
		// patch plugin to avoid breaking
		pluginsWithPreprocessorsDeprecated.forEach((p) => {
			if (!p.api) {
				p.api = {};
			}
			if (p.api.sveltePreprocess === undefined) {
				// @ts-expect-error not typed
				p.api.sveltePreprocess = p.sveltePreprocess;
			} else {
				log.error(
					`ignoring plugin.sveltePreprocess of ${p.name} because it already defined plugin.api.sveltePreprocess.`
				);
			}
		});
	}
	/** @type {import('vite').Plugin[]} */
	const pluginsWithPreprocessors = config.plugins.filter((p) => p?.api?.sveltePreprocess);
	/** @type {import('vite').Plugin[]} */
	const ignored = [];
	/** @type {import('vite').Plugin[]} */
	const included = [];
	for (const p of pluginsWithPreprocessors) {
		if (
			options.ignorePluginPreprocessors === true ||
			(Array.isArray(options.ignorePluginPreprocessors) &&
				options.ignorePluginPreprocessors?.includes(p.name))
		) {
			ignored.push(p);
		} else {
			included.push(p);
		}
	}
	if (ignored.length > 0) {
		log.debug(
			`Ignoring svelte preprocessors defined by these vite plugins: ${ignored
				.map((p) => p.name)
				.join(', ')}`,
			undefined,
			'preprocess'
		);
	}
	if (included.length > 0) {
		log.debug(
			`Adding svelte preprocessors defined by these vite plugins: ${included
				.map((p) => p.name)
				.join(', ')}`,
			undefined,
			'preprocess'
		);
		appendPreprocessors.push(...pluginsWithPreprocessors.map((p) => p.api.sveltePreprocess));
	}

	return { prependPreprocessors, appendPreprocessors };
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @param {import('vite').ResolvedConfig} config
 */
function addExtraPreprocessors(options, config) {
	const { prependPreprocessors, appendPreprocessors } = buildExtraPreprocessors(options, config);
	if (prependPreprocessors.length > 0 || appendPreprocessors.length > 0) {
		if (!options.preprocess) {
			options.preprocess = [...prependPreprocessors, ...appendPreprocessors];
		} else if (Array.isArray(options.preprocess)) {
			options.preprocess.unshift(...prependPreprocessors);
			options.preprocess.push(...appendPreprocessors);
		} else {
			options.preprocess = [...prependPreprocessors, options.preprocess, ...appendPreprocessors];
		}
	}
}

/**
 *
 * @param filename {string}
 * @param dependencies  {string[]}
 * @returns {({dependencies: string[], warnings:import('svelte/compiler').Warning[] })}
 */
function checkPreprocessDependencies(filename, dependencies) {
	/** @type {import('svelte/compiler').Warning[]} */
	const warnings = [];

	// to find self, we have to compare normalized filenames, but must keep the original values in `dependencies`
	// because otherwise file watching on windows doesn't work
	// so we track idx and filter by that in the end
	/** @type {number[]} */
	const selfIdx = [];
	const normalizedFullFilename = normalizePath$3(filename);
	const normalizedDeps = dependencies.map(normalizePath$3);
	for (let i = 0; i < normalizedDeps.length; i++) {
		if (normalizedDeps[i] === normalizedFullFilename) {
			selfIdx.push(i);
		}
	}
	const hasSelfDependency = selfIdx.length > 0;
	if (hasSelfDependency) {
		warnings.push({
			code: 'vite-plugin-svelte-preprocess-depends-on-self',
			message:
				'svelte.preprocess returned this file as a dependency of itself. This can be caused by an invalid configuration or importing generated code that depends on .svelte files (eg. tailwind base css)',
			filename
		});
	}

	if (dependencies.length > 10) {
		warnings.push({
			code: 'vite-plugin-svelte-preprocess-many-dependencies',
			message: `svelte.preprocess depends on more than 10 external files which can cause slow builds and poor DX, try to reduce them. Found: ${dependencies.join(
				', '
			)}`,
			filename
		});
	}
	return {
		dependencies: hasSelfDependency
			? dependencies.filter((_, i) => !selfIdx.includes(i)) // remove self dependency
			: dependencies,
		warnings
	};
}

const IS_WINDOWS$1 = process$1.platform === 'win32';

/**
 * @typedef {{
 *  file?: string;
 *  sources?: string[];
 *  sourceRoot?: string;
 * }} SourceMapFileRefs
 */

/**
 * convert absolute paths in sourcemap file refs to their relative equivalents to avoid leaking fs info
 *
 * map is modified in place.
 *
 * @param {SourceMapFileRefs | undefined} map sourcemap
 * @param {string} filename absolute path to file the sourcemap is for
 */
function mapToRelative(map, filename) {
	if (!map) {
		return;
	}
	const sourceRoot = map.sourceRoot;
	const dirname = path$b.dirname(filename);

	/** @type {(s: string) => string} */
	const toRelative = (s) => {
		if (!s) {
			return s;
		}
		/** @type {string} */
		let sourcePath;
		if (s.startsWith('file:///')) {
			// windows has file:///C:/foo and posix has file:///foo, so we have to remove one extra on windows
			sourcePath = s.slice(IS_WINDOWS$1 ? 8 : 7);
		} else if (sourceRoot) {
			const sep = sourceRoot[sourceRoot.length - 1] === '/' || s[0] === '/' ? '' : '/';
			sourcePath = `${sourceRoot}${sep}${s}`;
		} else {
			sourcePath = s;
		}
		return path$b.isAbsolute(sourcePath) ? path$b.relative(dirname, sourcePath) : sourcePath;
	};

	if (map.file) {
		map.file = path$b.basename(filename);
	}
	if (map.sources) {
		map.sources = map.sources.map(toRelative);
	}
	if (map.sourceRoot) {
		// we have prepended sourceRoot and computed relative paths from it
		// remove it here to avoid downstream processing prepending it again
		delete map.sourceRoot;
	}
}

const scriptLangRE = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
function createCompileSvelte() {
  let stats;
  const devStylePreprocessor = createInjectScopeEverythingRulePreprocessorGroup();
  return async function compileSvelte(svelteRequest, code, options) {
    const { filename, normalizedFilename, cssId, ssr, raw } = svelteRequest;
    const { emitCss = true } = options;
    const dependencies = [];
    const warnings = [];
    if (options.stats) {
      if (options.isBuild) {
        if (!stats) {
          stats = options.stats.startCollection(`${ssr ? "ssr" : "dom"} compile`, {
            logInProgress: () => false
          });
        }
      } else {
        if (ssr && !stats) {
          stats = options.stats.startCollection("ssr compile");
        }
        if (!ssr && stats) {
          stats.finish();
          stats = void 0;
        }
      }
    }
    const compileOptions = {
      ...options.compilerOptions,
      filename,
      generate: ssr ? "server" : "client"
    };
    if (compileOptions.hmr && options.emitCss) {
      const hash = `s-${safeBase64Hash(normalizedFilename)}`;
      compileOptions.cssHash = () => hash;
    }
    let preprocessed;
    let preprocessors = options.preprocess;
    if (!options.isBuild && options.emitCss && compileOptions.hmr) {
      if (!Array.isArray(preprocessors)) {
        preprocessors = preprocessors ? [preprocessors, devStylePreprocessor] : [devStylePreprocessor];
      } else {
        preprocessors = preprocessors.concat(devStylePreprocessor);
      }
    }
    if (preprocessors) {
      try {
        preprocessed = await preprocess(code, preprocessors, { filename });
      } catch (e) {
        e.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ""}`;
        throw e;
      }
      if (preprocessed.dependencies?.length) {
        const checked = checkPreprocessDependencies(filename, preprocessed.dependencies);
        if (checked.warnings.length) {
          warnings.push(...checked.warnings);
        }
        if (checked.dependencies.length) {
          dependencies.push(...checked.dependencies);
        }
      }
      if (preprocessed.map) compileOptions.sourcemap = preprocessed.map;
    }
    if (typeof preprocessed?.map === "object") {
      mapToRelative(preprocessed?.map, filename);
    }
    if (raw && svelteRequest.query.type === "preprocessed") {
      return (
        /** @type {import('../types/compile.d.ts').CompileData} */
        {
          preprocessed: preprocessed ?? { code }
        }
      );
    }
    const finalCode = preprocessed ? preprocessed.code : code;
    const dynamicCompileOptions = await options?.dynamicCompileOptions?.({
      filename,
      code: finalCode,
      compileOptions
    });
    if (dynamicCompileOptions && log.debug.enabled) {
      log.debug(
        `dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`,
        void 0,
        "compile"
      );
    }
    const finalCompileOptions = dynamicCompileOptions ? {
      ...compileOptions,
      ...dynamicCompileOptions
    } : compileOptions;
    const endStat = stats?.start(filename);
    let compiled;
    try {
      compiled = compile(finalCode, { ...finalCompileOptions, filename });
      if (options.server?.config.experimental.hmrPartialAccept && compiled.js.code.includes("import.meta.hot.accept(")) {
        compiled.js.code = compiled.js.code.replaceAll(
          "import.meta.hot.accept(",
          'import.meta.hot.acceptExports(["default"],'
        );
      }
    } catch (e) {
      enhanceCompileError(e, code, preprocessors);
      throw e;
    }
    if (endStat) {
      endStat();
    }
    mapToRelative(compiled.js?.map, filename);
    mapToRelative(compiled.css?.map, filename);
    if (warnings.length) {
      if (!compiled.warnings) {
        compiled.warnings = [];
      }
      compiled.warnings.push(...warnings);
    }
    if (!raw) {
      const hasCss = compiled.css?.code?.trim()?.length ?? 0 > 0;
      if (emitCss && hasCss) {
        compiled.js.code += `
import ${JSON.stringify(cssId)};
`;
      }
    }
    let lang = "js";
    for (const match of code.matchAll(scriptLangRE)) {
      if (match[2]) {
        lang = match[2];
        break;
      }
    }
    return {
      filename,
      normalizedFilename,
      lang,
      compiled,
      ssr,
      dependencies,
      preprocessed: preprocessed ?? { code }
    };
  };
}

const sveltePkg = createRequire$2(import.meta.url)('svelte/package.json');

// list of svelte runtime dependencies to optimize together with svelte itself
const SVELTE_RUNTIME_DEPENDENCIES = [
	'clsx' // avoids dev server restart after page load with npm + vite6 (see #1067)
].filter((dep) => !!sveltePkg.dependencies?.[dep]);

const SVELTE_IMPORTS = Object.entries(sveltePkg.exports)
	.map(([name, config]) => {
		// ignore type only
		if (typeof config === 'object' && Object.keys(config).length === 1 && config.types) {
			return '';
		}
		// ignore names
		if (name === './package.json' || name === './compiler') {
			return '';
		}
		return name.replace(/^\./, 'svelte');
	})
	.filter((s) => s.length > 0);

const SVELTE_EXPORT_CONDITIONS = ['svelte'];

const FAQ_LINK_MISSING_EXPORTS_CONDITION =
	'https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#missing-exports-condition';

const DEFAULT_SVELTE_EXT = ['.svelte'];
const DEFAULT_SVELTE_MODULE_INFIX = ['.svelte.'];
const DEFAULT_SVELTE_MODULE_EXT = ['.js', '.ts'];

const VITE_FS_PREFIX = '/@fs/';
const IS_WINDOWS = process$1.platform === 'win32';

const SUPPORTED_COMPILER_OPTIONS = ['generate', 'dev', 'css', 'customElement', 'immutable'];
const TYPES_WITH_COMPILER_OPTIONS = ['style', 'script', 'all'];

/**
 * @param {string} id
 * @returns {{ filename: string, rawQuery: string }}
 */
function splitId(id) {
	const parts = id.split('?', 2);
	const filename = parts[0];
	const rawQuery = parts[1];
	return { filename, rawQuery };
}

/**
 * @param {string} id
 * @param {string} filename
 * @param {string} rawQuery
 * @param {string} root
 * @param {number} timestamp
 * @param {boolean} ssr
 * @returns {import('../types/id.d.ts').SvelteRequest | undefined}
 */
function parseToSvelteRequest(id, filename, rawQuery, root, timestamp, ssr) {
	const query = parseRequestQuery(rawQuery);
	const rawOrDirect = !!(query.raw || query.direct);
	if (query.url || (!query.svelte && rawOrDirect)) {
		// skip requests with special vite tags
		return;
	}
	const raw = rawOrDirect;
	const normalizedFilename = normalize(filename, root);
	const cssId = createVirtualImportId(filename, root, 'style');

	return {
		id,
		filename,
		normalizedFilename,
		cssId,
		query,
		timestamp,
		ssr,
		raw
	};
}

/**
 * @param {string} filename
 * @param {string} root
 * @param {import('../types/id.d.ts').SvelteQueryTypes} type
 * @returns {string}
 */
function createVirtualImportId(filename, root, type) {
	const parts = ['svelte', `type=${type}`];
	{
		parts.push('lang.css');
	}
	if (existsInRoot(filename, root)) {
		filename = root + filename;
	} else if (filename.startsWith(VITE_FS_PREFIX)) {
		filename = IS_WINDOWS
			? filename.slice(VITE_FS_PREFIX.length) // remove /@fs/ from /@fs/C:/...
			: filename.slice(VITE_FS_PREFIX.length - 1); // remove /@fs from /@fs/home/user
	}
	// return same virtual id format as vite-plugin-vue eg ...App.svelte?svelte&type=style&lang.css
	return `${filename}?${parts.join('&')}`;
}

/**
 * @param {string} rawQuery
 * @returns {import('../types/id.d.ts').RequestQuery}
 */
function parseRequestQuery(rawQuery) {
	const query = Object.fromEntries(new URLSearchParams(rawQuery));
	for (const key in query) {
		if (query[key] === '') {
			// @ts-expect-error not boolean
			query[key] = true;
		}
	}
	const compilerOptions = query.compilerOptions;
	if (compilerOptions) {
		if (!((query.raw || query.direct) && TYPES_WITH_COMPILER_OPTIONS.includes(query.type))) {
			throw new Error(
				`Invalid compilerOptions in query ${rawQuery}. CompilerOptions are only supported for raw or direct queries with type in "${TYPES_WITH_COMPILER_OPTIONS.join(
					', '
				)}" e.g. '?svelte&raw&type=script&compilerOptions={"generate":"server","dev":false}`
			);
		}
		try {
			const parsed = JSON.parse(compilerOptions);
			const invalid = Object.keys(parsed).filter(
				(key) => !SUPPORTED_COMPILER_OPTIONS.includes(key)
			);
			if (invalid.length) {
				throw new Error(
					`Invalid compilerOptions in query ${rawQuery}: ${invalid.join(
						', '
					)}. Supported: ${SUPPORTED_COMPILER_OPTIONS.join(', ')}`
				);
			}
			query.compilerOptions = parsed;
		} catch (e) {
			log.error('failed to parse request query compilerOptions', e);
			throw e;
		}
	}

	return /** @type {import('../types/id.d.ts').RequestQuery}*/ query;
}

/**
 * posixify and remove root at start
 *
 * @param {string} filename
 * @param {string} normalizedRoot
 * @returns {string}
 */
function normalize(filename, normalizedRoot) {
	return stripRoot(normalizePath$3(filename), normalizedRoot);
}

/**
 * @param {string} filename
 * @param {string} root
 * @returns {boolean}
 */
function existsInRoot(filename, root) {
	if (filename.startsWith(VITE_FS_PREFIX)) {
		return false; // vite already tagged it as out of root
	}
	return fs__default.existsSync(root + filename);
}

/**
 * @param {string} normalizedFilename
 * @param {string} normalizedRoot
 * @returns {string}
 */
function stripRoot(normalizedFilename, normalizedRoot) {
	return normalizedFilename.startsWith(normalizedRoot + '/')
		? normalizedFilename.slice(normalizedRoot.length)
		: normalizedFilename;
}

/**
 * @param {import('../public.d.ts').Options['include'] | undefined} include
 * @param {import('../public.d.ts').Options['exclude'] | undefined} exclude
 * @param {string[]} extensions
 * @returns {(filename: string) => boolean}
 */
function buildFilter(include, exclude, extensions) {
	const rollupFilter = createFilter$1(include, exclude);
	return (filename) => rollupFilter(filename) && extensions.some((ext) => filename.endsWith(ext));
}

/**
 * @param {import('../public.d.ts').Options['include'] | undefined} include
 * @param {import('../public.d.ts').Options['exclude'] | undefined} exclude
 * @param {string[]} infixes
 * @param {string[]} extensions
 * @returns {(filename: string) => boolean}
 */
function buildModuleFilter(include, exclude, infixes, extensions) {
	const rollupFilter = createFilter$1(include, exclude);
	return (filename) => {
		const basename = path$b.basename(filename);

		return (
			rollupFilter(filename) &&
			infixes.some((infix) => basename.includes(infix)) &&
			extensions.some((ext) => basename.endsWith(ext))
		);
	};
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {import('../types/id.d.ts').IdParser}
 */
function buildIdParser(options) {
	const { include, exclude, extensions, root } = options;
	const normalizedRoot = normalizePath$3(root);
	const filter = buildFilter(include, exclude, extensions ?? []);
	return (id, ssr, timestamp = Date.now()) => {
		const { filename, rawQuery } = splitId(id);
		if (filter(filename)) {
			return parseToSvelteRequest(id, filename, rawQuery, normalizedRoot, timestamp, ssr);
		}
	};
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {import('../types/id.d.ts').ModuleIdParser}
 */
function buildModuleIdParser(options) {
	const {
		include,
		exclude,
		infixes = DEFAULT_SVELTE_MODULE_INFIX,
		extensions = DEFAULT_SVELTE_MODULE_EXT
	} = options?.experimental?.compileModule ?? {};
	const root = options.root;
	const normalizedRoot = normalizePath$3(root);
	const filter = buildModuleFilter(include, exclude, infixes, extensions);
	return (id, ssr, timestamp = Date.now()) => {
		const { filename, rawQuery } = splitId(id);
		if (filter(filename)) {
			return parseToSvelteModuleRequest(id, filename, rawQuery, normalizedRoot, timestamp, ssr);
		}
	};
}

/**
 * @param {string} id
 * @param {string} filename
 * @param {string} rawQuery
 * @param {string} root
 * @param {number} timestamp
 * @param {boolean} ssr
 * @returns {import('../types/id.d.ts').SvelteModuleRequest | undefined}
 */
function parseToSvelteModuleRequest(id, filename, rawQuery, root, timestamp, ssr) {
	const query = parseRequestQuery(rawQuery);

	if (query.url || query.raw || query.direct) {
		// skip requests with special vite tags
		return;
	}

	const normalizedFilename = normalize(filename, root);

	return {
		id,
		filename,
		normalizedFilename,
		query,
		timestamp,
		ssr
	};
}

// used to require cjs config in esm.
// NOTE dynamic import() cjs technically works, but timestamp query cache bust
// have no effect, likely because it has another internal cache?
/** @type {NodeRequire}*/
let esmRequire;

const knownSvelteConfigNames = [
	'svelte.config.js',
	'svelte.config.cjs',
	'svelte.config.mjs'
];

/**
 * @param {string} filePath
 * @param {number} timestamp
 */
async function dynamicImportDefault(filePath, timestamp) {
	return await import(filePath + '?t=' + timestamp).then((m) => m.default);
}

/**
 * @param {import('vite').UserConfig} [viteConfig]
 * @param {Partial<import('../public.d.ts').Options>} [inlineOptions]
 * @returns {Promise<Partial<import('../public.d.ts').SvelteConfig> | undefined>}
 */
async function loadSvelteConfig(viteConfig, inlineOptions) {
	if (inlineOptions?.configFile === false) {
		return;
	}
	const configFile = findConfigToLoad(viteConfig, inlineOptions);
	if (configFile) {
		let err;
		// try to use dynamic import for svelte.config.js first
		if (configFile.endsWith('.js') || configFile.endsWith('.mjs')) {
			try {
				const result = await dynamicImportDefault(
					pathToFileURL$1(configFile).href,
					fs__default.statSync(configFile).mtimeMs
				);
				if (result != null) {
					return {
						...result,
						configFile
					};
				} else {
					throw new Error(`invalid export in ${configFile}`);
				}
			} catch (e) {
				log.error(`failed to import config ${configFile}`, e);
				err = e;
			}
		}
		// cjs or error with dynamic import
		if (!configFile.endsWith('.mjs')) {
			try {
				// identify which require function to use (esm and cjs mode)
				const _require = import.meta.url
					? (esmRequire ?? (esmRequire = createRequire$2(import.meta.url)))
					: // eslint-disable-next-line no-undef
						require;

				// avoid loading cached version on reload
				delete _require.cache[_require.resolve(configFile)];
				const result = _require(configFile);
				if (result != null) {
					return {
						...result,
						configFile
					};
				} else {
					throw new Error(`invalid export in ${configFile}`);
				}
			} catch (e) {
				log.error(`failed to require config ${configFile}`, e);
				if (!err) {
					err = e;
				}
			}
		}
		// failed to load existing config file
		throw err;
	}
}

/**
 * @param {import('vite').UserConfig | undefined} viteConfig
 * @param {Partial<import('../public.d.ts').Options> | undefined} inlineOptions
 * @returns {string | undefined}
 */
function findConfigToLoad(viteConfig, inlineOptions) {
	const root = viteConfig?.root || process$1.cwd();
	if (inlineOptions?.configFile) {
		const abolutePath = path$b.isAbsolute(inlineOptions.configFile)
			? inlineOptions.configFile
			: path$b.resolve(root, inlineOptions.configFile);
		if (!fs__default.existsSync(abolutePath)) {
			throw new Error(`failed to find svelte config file ${abolutePath}.`);
		}
		return abolutePath;
	} else {
		const existingKnownConfigFiles = knownSvelteConfigNames
			.map((candidate) => path$b.resolve(root, candidate))
			.filter((file) => fs__default.existsSync(file));
		if (existingKnownConfigFiles.length === 0) {
			log.debug(`no svelte config found at ${root}`, undefined, 'config');
			return;
		} else if (existingKnownConfigFiles.length > 1) {
			log.warn(
				`found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`,
				existingKnownConfigFiles
			);
		}
		return existingKnownConfigFiles[0];
	}
}

/**
 * @typedef {NonNullable<import('vite').DepOptimizationOptions['esbuildOptions']>} EsbuildOptions
 * @typedef {NonNullable<EsbuildOptions['plugins']>[number]} EsbuildPlugin
 */

const facadeEsbuildSveltePluginName = 'vite-plugin-svelte:facade';
const facadeEsbuildSvelteModulePluginName = 'vite-plugin-svelte-module:facade';

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {EsbuildPlugin}
 */
function esbuildSveltePlugin(options) {
	return {
		name: 'vite-plugin-svelte:optimize-svelte',
		setup(build) {
			// Skip in scanning phase as Vite already handles scanning Svelte files.
			// Otherwise this would heavily slow down the scanning phase.
			if (build.initialOptions.plugins?.some((v) => v.name === 'vite:dep-scan')) return;

			const filter = /\.svelte(?:\?.*)?$/;
			/** @type {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection | undefined} */
			let statsCollection;
			build.onStart(() => {
				statsCollection = options.stats?.startCollection('prebundle library components', {
					logResult: (c) => c.stats.length > 1
				});
			});
			build.onLoad({ filter }, async ({ path: filename }) => {
				const code = readFileSync(filename, 'utf8');
				try {
					const contents = await compileSvelte(options, { filename, code }, statsCollection);
					return { contents };
				} catch (e) {
					return { errors: [toESBuildError(e, options)] };
				}
			});
			build.onEnd(() => {
				statsCollection?.finish();
			});
		}
	};
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @param {{ filename: string, code: string }} input
 * @param {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection} [statsCollection]
 * @returns {Promise<string>}
 */
async function compileSvelte(options, { filename, code }, statsCollection) {
	let css = options.compilerOptions.css;
	if (css !== 'injected') {
		// TODO ideally we'd be able to externalize prebundled styles too, but for now always put them in the js
		css = 'injected';
	}
	/** @type {import('svelte/compiler').CompileOptions} */
	const compileOptions = {
		dev: true, // default to dev: true because prebundling is only used in dev
		...options.compilerOptions,
		css,
		filename,
		generate: 'client'
	};

	if (compileOptions.hmr && options.emitCss) {
		const hash = `s-${safeBase64Hash(normalize(filename, options.root))}`;
		compileOptions.cssHash = () => hash;
	}

	let preprocessed;

	if (options.preprocess) {
		try {
			preprocessed = await preprocess(code, options.preprocess, { filename });
		} catch (e) {
			e.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ''}`;
			throw e;
		}
		if (preprocessed.map) compileOptions.sourcemap = preprocessed.map;
	}

	const finalCode = preprocessed ? preprocessed.code : code;

	const dynamicCompileOptions = await options?.dynamicCompileOptions?.({
		filename,
		code: finalCode,
		compileOptions
	});

	if (dynamicCompileOptions && log.debug.enabled) {
		log.debug(
			`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`,
			undefined,
			'compile'
		);
	}

	const finalCompileOptions = dynamicCompileOptions
		? {
				...compileOptions,
				...dynamicCompileOptions
			}
		: compileOptions;
	const endStat = statsCollection?.start(filename);
	const compiled = compile(finalCode, finalCompileOptions);
	if (endStat) {
		endStat();
	}
	return compiled.js.map
		? compiled.js.code + '//# sourceMappingURL=' + compiled.js.map.toUrl()
		: compiled.js.code;
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {EsbuildPlugin}
 */
function esbuildSvelteModulePlugin(options) {
	return {
		name: 'vite-plugin-svelte-module:optimize-svelte',
		setup(build) {
			// Skip in scanning phase as Vite already handles scanning Svelte files.
			// Otherwise this would heavily slow down the scanning phase.
			if (build.initialOptions.plugins?.some((v) => v.name === 'vite:dep-scan')) return;

			const filter = /\.svelte\.[jt]s(?:\?.*)?$/;
			/** @type {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection | undefined} */
			let statsCollection;
			build.onStart(() => {
				statsCollection = options.stats?.startCollection('prebundle library modules', {
					logResult: (c) => c.stats.length > 1
				});
			});
			build.onLoad({ filter }, async ({ path: filename }) => {
				const code = readFileSync(filename, 'utf8');
				try {
					const contents = await compileSvelteModule(options, { filename, code }, statsCollection);
					return { contents };
				} catch (e) {
					return { errors: [toESBuildError(e, options)] };
				}
			});
			build.onEnd(() => {
				statsCollection?.finish();
			});
		}
	};
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @param {{ filename: string; code: string }} input
 * @param {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection} [statsCollection]
 * @returns {Promise<string>}
 */
async function compileSvelteModule(options, { filename, code }, statsCollection) {
	const endStat = statsCollection?.start(filename);
	const compiled = compileModule(code, {
		dev: options.compilerOptions?.dev ?? true, // default to dev: true because prebundling is only used in dev
		filename,
		generate: 'client'
	});
	if (endStat) {
		endStat();
	}
	return compiled.js.map
		? compiled.js.code + '//# sourceMappingURL=' + compiled.js.map.toUrl()
		: compiled.js.code;
}

var cjs;
var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;

	var isMergeableObject = function isMergeableObject(value) {
		return isNonNullObject(value)
			&& !isSpecial(value)
	};

	function isNonNullObject(value) {
		return !!value && typeof value === 'object'
	}

	function isSpecial(value) {
		var stringValue = Object.prototype.toString.call(value);

		return stringValue === '[object RegExp]'
			|| stringValue === '[object Date]'
			|| isReactElement(value)
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

	function isReactElement(value) {
		return value.$$typeof === REACT_ELEMENT_TYPE
	}

	function emptyTarget(val) {
		return Array.isArray(val) ? [] : {}
	}

	function cloneUnlessOtherwiseSpecified(value, options) {
		return (options.clone !== false && options.isMergeableObject(value))
			? deepmerge(emptyTarget(value), value, options)
			: value
	}

	function defaultArrayMerge(target, source, options) {
		return target.concat(source).map(function(element) {
			return cloneUnlessOtherwiseSpecified(element, options)
		})
	}

	function getMergeFunction(key, options) {
		if (!options.customMerge) {
			return deepmerge
		}
		var customMerge = options.customMerge(key);
		return typeof customMerge === 'function' ? customMerge : deepmerge
	}

	function getEnumerableOwnPropertySymbols(target) {
		return Object.getOwnPropertySymbols
			? Object.getOwnPropertySymbols(target).filter(function(symbol) {
				return Object.propertyIsEnumerable.call(target, symbol)
			})
			: []
	}

	function getKeys(target) {
		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
	}

	function propertyIsOnObject(object, property) {
		try {
			return property in object
		} catch(_) {
			return false
		}
	}

	// Protects from prototype poisoning and unexpected merging up the prototype chain.
	function propertyIsUnsafe(target, key) {
		return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
			&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
				&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
	}

	function mergeObject(target, source, options) {
		var destination = {};
		if (options.isMergeableObject(target)) {
			getKeys(target).forEach(function(key) {
				destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
			});
		}
		getKeys(source).forEach(function(key) {
			if (propertyIsUnsafe(target, key)) {
				return
			}

			if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
				destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
			} else {
				destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
			}
		});
		return destination
	}

	function deepmerge(target, source, options) {
		options = options || {};
		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
		options.isMergeableObject = options.isMergeableObject || isMergeableObject;
		// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
		// implementations can use it. The caller may not replace it.
		options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

		var sourceIsArray = Array.isArray(source);
		var targetIsArray = Array.isArray(target);
		var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

		if (!sourceAndTargetTypesMatch) {
			return cloneUnlessOtherwiseSpecified(source, options)
		} else if (sourceIsArray) {
			return options.arrayMerge(target, source, options)
		} else {
			return mergeObject(target, source, options)
		}
	}

	deepmerge.all = function deepmergeAll(array, options) {
		if (!Array.isArray(array)) {
			throw new Error('first argument should be an array')
		}

		return array.reduce(function(prev, next) {
			return deepmerge(prev, next, options)
		}, {})
	};

	var deepmerge_1 = deepmerge;

	cjs = deepmerge_1;
	return cjs;
}

var cjsExports = requireCjs();
const deepmerge = /*@__PURE__*/getDefaultExportFromCjs$1(cjsExports);

var sync;
var hasRequiredSync;

function requireSync () {
	if (hasRequiredSync) return sync;
	hasRequiredSync = 1;
	// contains synchronous API only so it can be exported as CJS and ESM

	/** @type {import('./index.d.ts').isDepIncluded} */
	function isDepIncluded(dep, optimizeDepsInclude) {
	  return optimizeDepsInclude.some((id) => parseIncludeStr(id) === dep)
	}

	/** @type {import('./index.d.ts').isDepExcluded} */
	function isDepExcluded(dep, optimizeDepsExclude) {
	  dep = parseIncludeStr(dep);
	  return optimizeDepsExclude.some(
	    (id) => id === dep || dep.startsWith(`${id}/`)
	  )
	}

	/** @type {import('./index.d.ts').isDepNoExternaled} */
	function isDepNoExternaled(dep, ssrNoExternal) {
	  if (ssrNoExternal === true) {
	    return true
	  } else {
	    return isMatch(dep, ssrNoExternal)
	  }
	}

	/** @type {import('./index.d.ts').isDepExternaled} */
	function isDepExternaled(dep, ssrExternal) {
	  // If `ssrExternal` is `true`, it just means that all linked
	  // dependencies should also be externalized by default. It doesn't
	  // mean that a dependency is being explicitly externalized. So we
	  // return `false` in this case.
	  // @ts-expect-error can be true in Vite 6
	  if (ssrExternal === true) {
	    return false
	  } else {
	    return ssrExternal.includes(dep)
	  }
	}

	/**
	 * @param {string} raw could be "foo" or "foo > bar" etc
	 */
	function parseIncludeStr(raw) {
	  const lastArrow = raw.lastIndexOf('>');
	  return lastArrow === -1 ? raw : raw.slice(lastArrow + 1).trim()
	}

	/**
	 * @param {string} target
	 * @param {string | RegExp | (string | RegExp)[]} pattern
	 */
	function isMatch(target, pattern) {
	  if (Array.isArray(pattern)) {
	    return pattern.some((p) => isMatch(target, p))
	  } else if (typeof pattern === 'string') {
	    return target === pattern
	  } else if (pattern instanceof RegExp) {
	    return pattern.test(target)
	  }
	}

	sync = {
	  isDepIncluded,
	  isDepExcluded,
	  isDepNoExternaled,
	  isDepExternaled
	};
	return sync;
}

var syncExports = requireSync();

/** @type {import('pnpapi')} */
let pnp;


/** @type {Array<{ name: string; reference: string; }>} */
let pnpWorkspaceLocators;

if (process.versions.pnp) {
  try {
    pnp = createRequire$2(import.meta.url)('pnpapi');
    // returns a set of physical locators https://yarnpkg.com/advanced/pnpapi#getdependencytreeroots
    // @ts-expect-error unfortunately doesn't exist in the `@types` package
    pnpWorkspaceLocators = pnp.getDependencyTreeRoots();
  } catch {}
}

/** @type {import('./index.d.ts').crawlFrameworkPkgs} */
async function crawlFrameworkPkgs(options) {
  const pkgJsonPath = await findClosestPkgJsonPath(options.root);
  if (!pkgJsonPath) {
    // don't throw as package.json is not required
    return {
      optimizeDeps: { include: [], exclude: [] },
      ssr: { noExternal: [], external: [] }
    }
  }
  const pkgJson = await readJson(pkgJsonPath).catch((e) => {
    throw new Error(`Unable to read ${pkgJsonPath}`, { cause: e })
  });

  /** @type {string[]} */
  let optimizeDepsInclude = [];
  /** @type {string[]} */
  let optimizeDepsExclude = [];
  /** @type {string[]} */
  let ssrNoExternal = [];
  /** @type {string[]} */
  let ssrExternal = [];

  await crawl(pkgJsonPath, pkgJson);

  // respect vite user config
  if (options.viteUserConfig) {
    // remove includes that are explicitly excluded in optimizeDeps
    const _optimizeDepsExclude = options.viteUserConfig?.optimizeDeps?.exclude;
    if (_optimizeDepsExclude) {
      optimizeDepsInclude = optimizeDepsInclude.filter(
        (dep) => !syncExports.isDepExcluded(dep, _optimizeDepsExclude)
      );
    }
    // remove excludes that are explicitly included in optimizeDeps
    const _optimizeDepsInclude = options.viteUserConfig?.optimizeDeps?.include;
    if (_optimizeDepsInclude) {
      optimizeDepsExclude = optimizeDepsExclude.filter(
        (dep) => !syncExports.isDepIncluded(dep, _optimizeDepsInclude)
      );
    }
    // remove noExternals that are explicitly externalized
    const _ssrExternal = options.viteUserConfig?.ssr?.external;
    if (_ssrExternal) {
      ssrNoExternal = ssrNoExternal.filter(
        (dep) => !syncExports.isDepExternaled(dep, _ssrExternal)
      );
    }
    // remove externals that are explicitly noExternal
    const _ssrNoExternal = options.viteUserConfig?.ssr?.noExternal;
    if (_ssrNoExternal) {
      ssrExternal = ssrExternal.filter(
        (dep) => !syncExports.isDepNoExternaled(dep, _ssrNoExternal)
      );
    }
  }

  return {
    optimizeDeps: {
      include: optimizeDepsInclude,
      exclude: optimizeDepsExclude
    },
    ssr: {
      noExternal: ssrNoExternal,
      external: ssrExternal
    }
  }

  /**
   * crawl the package.json dependencies for framework packages. rules:
   * 1. a framework package should be `optimizeDeps.exclude` and `ssr.noExternal`.
   * 2. the deps of the framework package should be `optimizeDeps.include` and `ssr.external`
   *    unless the dep is also a framework package, in which case do no1 & no2 recursively.
   * 3. any non-framework packages that aren't imported by a framework package can be skipped entirely.
   * 4. a semi-framework package is like a framework package, except it isn't `optimizeDeps.exclude`,
   *    but only applies `ssr.noExternal`.
   * @param {string} pkgJsonPath
   * @param {Record<string, any>} pkgJson
   * @param {string[]} [parentDepNames]
   */
  async function crawl(pkgJsonPath, pkgJson, parentDepNames = []) {
    const isRoot = parentDepNames.length === 0;
    const crawlDevDependencies = isRoot || isPrivateWorkspacePackage(pkgJsonPath,pkgJson,options.workspaceRoot);
    /** @type {string[]} */
    let deps = [
      ...Object.keys(pkgJson.dependencies || {}),
      ...((crawlDevDependencies) ? Object.keys(pkgJson.devDependencies || {}) : [])
    ];

    deps = deps.filter((dep) => {
      // skip circular deps
      if (parentDepNames.includes(dep)) {
        return false
      }

      const isFrameworkPkg = options.isFrameworkPkgByName?.(dep);
      const isSemiFrameworkPkg = options.isSemiFrameworkPkgByName?.(dep);
      if (isFrameworkPkg) {
        // framework packages should be excluded from optimization as esbuild can't handle them.
        // otherwise it'll cause https://github.com/vitejs/vite/issues/3910
        optimizeDepsExclude.push(dep);
        // framework packages should be noExternal so that they go through vite's transformation
        // pipeline, since nodejs can't support them.
        ssrNoExternal.push(dep);
      } else if (isSemiFrameworkPkg) {
        // semi-framework packages should do the same except for optimization exclude as they
        // aren't needed to work (they don't contain raw framework components)
        ssrNoExternal.push(dep);
      }

      // only those that are explictly false can skip crawling since we don't need to do anything
      // special for them
      if (isFrameworkPkg === false || isSemiFrameworkPkg === false) {
        return false
      }
      // if `true`, we need to crawl the nested deps to deep include and ssr externalize them in dev.
      // if `undefined`, it's the same as "i don't know". we need to crawl and find the package.json
      // to find out.
      else {
        return true
      }
    });

    const promises = deps.map(async (dep) => {
      const depPkgJsonPath = await _findDepPkgJsonPath(dep, pkgJsonPath, !!options.workspaceRoot);
      if (!depPkgJsonPath) return
      const depPkgJson = await readJson(depPkgJsonPath).catch(() => {});
      if (!depPkgJson) return

      // fast path if this dep is already a framework dep based on the filter condition above
      const cachedIsFrameworkPkg = ssrNoExternal.includes(dep);
      if (cachedIsFrameworkPkg) {
        return crawl(depPkgJsonPath, depPkgJson, parentDepNames.concat(dep))
      }

      // check if this dep is a framework dep, if so, track and crawl it
      const isFrameworkPkg = options.isFrameworkPkgByJson?.(depPkgJson);
      const isSemiFrameworkPkg = options.isSemiFrameworkPkgByJson?.(depPkgJson);
      if (isFrameworkPkg || isSemiFrameworkPkg) {
        // see explanation in filter condition above
        if (isFrameworkPkg) {
          optimizeDepsExclude.push(dep);
          ssrNoExternal.push(dep);
        } else if (isSemiFrameworkPkg) {
          ssrNoExternal.push(dep);
        }
        return crawl(depPkgJsonPath, depPkgJson, parentDepNames.concat(dep))
      }

      // if we're crawling in a non-root state, the parent is 100% a framework package
      // because of the above if block. in this case, if it's dep of a non-framework
      // package, handle special cases for them.
      if (!isRoot) {
        // deep include it if it's a CJS package, so it becomes ESM and vite is happy.
        if (await pkgNeedsOptimization(depPkgJson, depPkgJsonPath)) {
          optimizeDepsInclude.push(parentDepNames.concat(dep).join(' > '));
        }
        // also externalize it in dev so it doesn't trip vite's SSR transformation.
        // we do in dev only as build cannot access deep external packages in strict
        // dependency installations, such as pnpm.
        if (!options.isBuild && !ssrExternal.includes(dep)) {
          ssrExternal.push(dep);
        }
      }
    });

    await Promise.all(promises);
  }
}

/**
 * internal implementation to avoid exposing the usePnpWorkspaceLocators flag
 *
 * @param {string} dep
 * @param {string} parent
 * @param {boolean} usePnpWorkspaceLocators
 * @returns {Promise<undefined|string>}
 * @private
 */
async function _findDepPkgJsonPath(dep, parent, usePnpWorkspaceLocators) {
  if (pnp) {
    if(usePnpWorkspaceLocators) {
      try {
        // if we're in a workspace and the dep is a workspace dep,
        // then we'll try to resolve to it's real location
        const locator = pnpWorkspaceLocators.find((root) => root.name === dep);
        if (locator) {
          const pkgPath = pnp.getPackageInformation(locator).packageLocation;
          return path$b.resolve(pkgPath, 'package.json')
        }
      } catch {}
    }
    try {
      const depRoot = pnp.resolveToUnqualified(dep, parent);
      if (!depRoot) return undefined
      return path$b.join(depRoot, 'package.json')
    } catch {
      return undefined
    }
  }

  let root = parent;
  while (root) {
    const pkg = path$b.join(root, 'node_modules', dep, 'package.json');
    try {
      await fsp.access(pkg);
      // use 'node:fs' version to match 'vite:resolve' and avoid realpath.native quirk
      // https://github.com/sveltejs/vite-plugin-svelte/issues/525#issuecomment-1355551264
      return fs__default.realpathSync(pkg)
    } catch {}
    const nextRoot = path$b.dirname(root);
    if (nextRoot === root) break
    root = nextRoot;
  }
  return undefined
}

/** @type {import('./index.d.ts').findClosestPkgJsonPath} */
async function findClosestPkgJsonPath(dir, predicate = undefined) {
  if (dir.endsWith('package.json')) {
    dir = path$b.dirname(dir);
  }
  while (dir) {
    const pkg = path$b.join(dir, 'package.json');
    try {
      const stat = await fsp.stat(pkg);
      if (stat.isFile() && (!predicate || (await predicate(pkg)))) {
        return pkg
      }
    } catch {}
    const nextDir = path$b.dirname(dir);
    if (nextDir === dir) break
    dir = nextDir;
  }
  return undefined
}

/** @type {import('./index.d.ts').pkgNeedsOptimization} */
async function pkgNeedsOptimization(pkgJson, pkgJsonPath) {
  // only optimize if is cjs, using the below as heuristic
  // see https://github.com/sveltejs/vite-plugin-svelte/issues/162
  if (pkgJson.module || pkgJson.exports) return false
  // if have main, ensure entry is js so vite can prebundle it
  // see https://github.com/sveltejs/vite-plugin-svelte/issues/233
  if (pkgJson.main) {
    const entryExt = path$b.extname(pkgJson.main);
    return !entryExt || entryExt === '.js' || entryExt === '.cjs'
  }
  // check if has implicit index.js entrypoint to prebundle
  // see https://github.com/sveltejs/vite-plugin-svelte/issues/281
  // see https://github.com/solidjs/vite-plugin-solid/issues/70#issuecomment-1306488154
  try {
    await fsp.access(path$b.join(path$b.dirname(pkgJsonPath), 'index.js'));
    return true
  } catch {
    return false
  }
}

/**
 * @param {string} findDepPkgJsonPath
 * @returns {Promise<Record<string, any>>}
 */
async function readJson(findDepPkgJsonPath) {
  return JSON.parse(await fsp.readFile(findDepPkgJsonPath, 'utf8'))
}

/**
 *
 * @param {string} pkgJsonPath
 * @param {Record<string,any>} pkgJson
 * @param {string} [workspaceRoot]
 * @returns {boolean}
 */
function isPrivateWorkspacePackage(pkgJsonPath,pkgJson,workspaceRoot = undefined) {
  return !!(
    workspaceRoot &&
    pkgJson.private &&
    !pkgJsonPath.match(/[/\\]node_modules[/\\]/) &&
    !path$b.relative(workspaceRoot,pkgJsonPath).startsWith('..')
  )
}

const COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD = [
	'@lukeed/uuid',
	'@playwright/test',
	'@sveltejs/kit',
	'@sveltejs/package',
	'@sveltejs/vite-plugin-svelte',
	'autoprefixer',
	'cookie',
	'dotenv',
	'esbuild',
	'eslint',
	'jest',
	'mdsvex',
	'playwright',
	'postcss',
	'prettier',
	'svelte',
	'svelte2tsx',
	'svelte-check',
	'svelte-preprocess',
	'tslib',
	'typescript',
	'vite',
	'vitest',
	'__vite-browser-external' // see https://github.com/sveltejs/vite-plugin-svelte/issues/362
];
const COMMON_PREFIXES_WITHOUT_SVELTE_FIELD = [
	'@fontsource/',
	'@postcss-plugins/',
	'@rollup/',
	'@sveltejs/adapter-',
	'@types/',
	'@typescript-eslint/',
	'eslint-',
	'jest-',
	'postcss-plugin-',
	'prettier-plugin-',
	'rollup-plugin-',
	'vite-plugin-'
];

/**
 * Test for common dependency names that tell us it is not a package including a svelte field, eg. eslint + plugins.
 *
 * This speeds up the find process as we don't have to try and require the package.json for all of them
 *
 * @param {string} dependency
 * @returns {boolean} true if it is a dependency without a svelte field
 */
function isCommonDepWithoutSvelteField(dependency) {
	return (
		COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD.includes(dependency) ||
		COMMON_PREFIXES_WITHOUT_SVELTE_FIELD.some(
			(prefix) =>
				prefix.startsWith('@')
					? dependency.startsWith(prefix)
					: dependency.substring(dependency.lastIndexOf('/') + 1).startsWith(prefix) // check prefix omitting @scope/
		)
	);
}

/** @type {import('../types/vite-plugin-svelte-stats.d.ts').CollectionOptions} */
const defaultCollectionOptions = {
	// log after 500ms and more than one file processed
	logInProgress: (c, now) => now - c.collectionStart > 500 && c.stats.length > 1,
	// always log results
	logResult: () => true
};

/**
 * @param {number} n
 * @returns
 */
function humanDuration(n) {
	// 99.9ms  0.10s
	return n < 100 ? `${n.toFixed(1)}ms` : `${(n / 1000).toFixed(2)}s`;
}

/**
 * @param {import('../types/vite-plugin-svelte-stats.d.ts').PackageStats[]} pkgStats
 * @returns {string}
 */
function formatPackageStats(pkgStats) {
	const statLines = pkgStats.map((pkgStat) => {
		const duration = pkgStat.duration;
		const avg = duration / pkgStat.files;
		return [pkgStat.pkg, `${pkgStat.files}`, humanDuration(duration), humanDuration(avg)];
	});
	statLines.unshift(['package', 'files', 'time', 'avg']);
	const columnWidths = statLines.reduce(
		(widths, row) => {
			for (let i = 0; i < row.length; i++) {
				const cell = row[i];
				if (widths[i] < cell.length) {
					widths[i] = cell.length;
				}
			}
			return widths;
		},
		statLines[0].map(() => 0)
	);

	const table = statLines
		.map((row) =>
			row
				.map((cell, i) => {
					if (i === 0) {
						return cell.padEnd(columnWidths[i], ' ');
					} else {
						return cell.padStart(columnWidths[i], ' ');
					}
				})
				.join('\t')
		)
		.join('\n');
	return table;
}

/**
 * @class
 */
class VitePluginSvelteStats {
	// package directory -> package name
	/** @type {import('./vite-plugin-svelte-cache.js').VitePluginSvelteCache} */
	#cache;
	/** @type {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection[]} */
	#collections = [];

	/**
	 * @param {import('./vite-plugin-svelte-cache.js').VitePluginSvelteCache} cache
	 */
	constructor(cache) {
		this.#cache = cache;
	}

	/**
	 * @param {string} name
	 * @param {Partial<import('../types/vite-plugin-svelte-stats.d.ts').CollectionOptions>} [opts]
	 * @returns {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection}
	 */
	startCollection(name, opts) {
		const options = {
			...defaultCollectionOptions,
			...opts
		};
		/** @type {import('../types/vite-plugin-svelte-stats.d.ts').Stat[]} */
		const stats = [];
		const collectionStart = performance$1.now();

		const _this = this;
		let hasLoggedProgress = false;
		/** @type {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection} */
		const collection = {
			name,
			options,
			stats,
			collectionStart,
			finished: false,
			start(file) {
				if (collection.finished) {
					throw new Error('called after finish() has been used');
				}
				file = normalizePath$3(file);
				const start = performance$1.now();
				/** @type {import('../types/vite-plugin-svelte-stats.d.ts').Stat} */
				const stat = { file, start, end: start };
				return () => {
					const now = performance$1.now();
					stat.end = now;
					stats.push(stat);
					if (!hasLoggedProgress && options.logInProgress(collection, now)) {
						hasLoggedProgress = true;
						log.debug(`${name} in progress ...`, undefined, 'stats');
					}
				};
			},
			async finish() {
				await _this.#finish(collection);
			}
		};
		_this.#collections.push(collection);
		return collection;
	}

	async finishAll() {
		await Promise.all(this.#collections.map((c) => c.finish()));
	}

	/**
	 * @param {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection} collection
	 */
	async #finish(collection) {
		try {
			collection.finished = true;
			const now = performance$1.now();
			collection.duration = now - collection.collectionStart;
			const logResult = collection.options.logResult(collection);
			if (logResult) {
				await this.#aggregateStatsResult(collection);
				log.debug(
					`${collection.name} done.\n${formatPackageStats(
						/** @type {import('../types/vite-plugin-svelte-stats.d.ts').PackageStats[]}*/ (
							collection.packageStats
						)
					)}`,
					undefined,
					'stats'
				);
			}
			// cut some ties to free it for garbage collection
			const index = this.#collections.indexOf(collection);
			this.#collections.splice(index, 1);
			collection.stats.length = 0;
			collection.stats = [];
			if (collection.packageStats) {
				collection.packageStats.length = 0;
				collection.packageStats = [];
			}
			collection.start = () => () => {};
			collection.finish = () => {};
		} catch (e) {
			// this should not happen, but stats taking also should not break the process
			log.debug.once(`failed to finish stats for ${collection.name}\n`, e, 'stats');
		}
	}

	/**
	 * @param {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection} collection
	 */
	async #aggregateStatsResult(collection) {
		const stats = collection.stats;
		for (const stat of stats) {
			stat.pkg = (await this.#cache.getPackageInfo(stat.file)).name;
		}

		// group stats
		/** @type {Record<string, import('../types/vite-plugin-svelte-stats.d.ts').PackageStats>} */
		const grouped = {};
		stats.forEach((stat) => {
			const pkg = /** @type {string} */ (stat.pkg);
			let group = grouped[pkg];
			if (!group) {
				group = grouped[pkg] = {
					files: 0,
					duration: 0,
					pkg
				};
			}
			group.files += 1;
			group.duration += stat.end - stat.start;
		});

		const groups = Object.values(grouped);
		groups.sort((a, b) => b.duration - a.duration);
		collection.packageStats = groups;
	}
}

const allowedPluginOptions = new Set([
	'include',
	'exclude',
	'emitCss',
	'hot',
	'ignorePluginPreprocessors',
	'disableDependencyReinclusion',
	'prebundleSvelteLibraries',
	'inspector',
	'dynamicCompileOptions',
	'experimental'
]);

const knownRootOptions = new Set(['extensions', 'compilerOptions', 'preprocess', 'onwarn']);

const allowedInlineOptions = new Set(['configFile', ...allowedPluginOptions, ...knownRootOptions]);

/**
 * @param {Partial<import('../public.d.ts').Options>} [inlineOptions]
 */
function validateInlineOptions(inlineOptions) {
	const invalidKeys = Object.keys({}).filter(
		(key) => !allowedInlineOptions.has(key)
	);
	if (invalidKeys.length) {
		log.warn(`invalid plugin options "${invalidKeys.join(', ')}" in inline config`, inlineOptions);
	}
}

/**
 * @param {Partial<import('../public.d.ts').SvelteConfig>} [config]
 * @returns {Partial<import('../public.d.ts').Options> | undefined}
 */
function convertPluginOptions(config) {
	if (!config) {
		return;
	}
	const invalidRootOptions = Object.keys(config).filter((key) => allowedPluginOptions.has(key));
	if (invalidRootOptions.length > 0) {
		throw new Error(
			`Invalid options in svelte config. Move the following options into 'vitePlugin:{...}': ${invalidRootOptions.join(
				', '
			)}`
		);
	}
	if (!config.vitePlugin) {
		return config;
	}
	const pluginOptions = config.vitePlugin;
	const pluginOptionKeys = Object.keys(pluginOptions);

	const rootOptionsInPluginOptions = pluginOptionKeys.filter((key) => knownRootOptions.has(key));
	if (rootOptionsInPluginOptions.length > 0) {
		throw new Error(
			`Invalid options in svelte config under vitePlugin:{...}', move them to the config root : ${rootOptionsInPluginOptions.join(
				', '
			)}`
		);
	}
	const duplicateOptions = pluginOptionKeys.filter((key) =>
		Object.prototype.hasOwnProperty.call(config, key)
	);
	if (duplicateOptions.length > 0) {
		throw new Error(
			`Invalid duplicate options in svelte config under vitePlugin:{...}', they are defined in root too and must only exist once: ${duplicateOptions.join(
				', '
			)}`
		);
	}
	const unknownPluginOptions = pluginOptionKeys.filter((key) => !allowedPluginOptions.has(key));
	if (unknownPluginOptions.length > 0) {
		log.warn(
			`ignoring unknown plugin options in svelte config under vitePlugin:{...}: ${unknownPluginOptions.join(
				', '
			)}`
		);
		unknownPluginOptions.forEach((unkownOption) => {
			// @ts-expect-error not typed
			delete pluginOptions[unkownOption];
		});
	}
	/** @type {import('../public.d.ts').Options} */
	const result = {
		...config,
		...pluginOptions
	};
	// @ts-expect-error it exists
	delete result.vitePlugin;

	return result;
}

/**
 * used in config phase, merges the default options, svelte config, and inline options
 * @param {Partial<import('../public.d.ts').Options> | undefined} inlineOptions
 * @param {import('vite').UserConfig} viteUserConfig
 * @param {import('vite').ConfigEnv} viteEnv
 * @returns {Promise<import('../types/options.d.ts').PreResolvedOptions>}
 */
async function preResolveOptions(inlineOptions, viteUserConfig, viteEnv) {
	if (!inlineOptions) {
		inlineOptions = {};
	}
	/** @type {import('vite').UserConfig} */
	const viteConfigWithResolvedRoot = {
		...viteUserConfig,
		root: resolveViteRoot(viteUserConfig)
	};
	const isBuild = viteEnv.command === 'build';
	/** @type {Partial<import('../types/options.d.ts').PreResolvedOptions>} */
	const defaultOptions = {
		extensions: DEFAULT_SVELTE_EXT,
		emitCss: true,
		prebundleSvelteLibraries: !isBuild
	};
	const svelteConfig = convertPluginOptions(
		await loadSvelteConfig(viteConfigWithResolvedRoot, inlineOptions)
	);
	/** @type {Partial<import('../types/options.d.ts').PreResolvedOptions>} */
	const extraOptions = {
		root: viteConfigWithResolvedRoot.root,
		isBuild,
		isServe: viteEnv.command === 'serve',
		isDebug: process$1.env.DEBUG != null
	};

	const merged = /** @type {import('../types/options.d.ts').PreResolvedOptions} */ (
		mergeConfigs(defaultOptions, svelteConfig, inlineOptions, extraOptions)
	);
	// configFile of svelteConfig contains the absolute path it was loaded from,
	// prefer it over the possibly relative inline path
	if (svelteConfig?.configFile) {
		merged.configFile = svelteConfig.configFile;
	}
	return merged;
}

/**
 * @template T
 * @param  {(Partial<T> | undefined)[]} configs
 * @returns T
 */
function mergeConfigs(...configs) {
	/** @type {Partial<T>} */
	let result = {};
	for (const config of configs.filter((x) => x != null)) {
		result = deepmerge(result, /** @type {Partial<T>} */ (config), {
			// replace arrays
			arrayMerge: (target, source) => source ?? target
		});
	}
	return /** @type {T} */ result;
}

/**
 * used in configResolved phase, merges a contextual default config, pre-resolved options, and some preprocessors. also validates the final config.
 *
 * @param {import('../types/options.d.ts').PreResolvedOptions} preResolveOptions
 * @param {import('vite').ResolvedConfig} viteConfig
 * @param {import('./vite-plugin-svelte-cache.js').VitePluginSvelteCache} cache
 * @returns {import('../types/options.d.ts').ResolvedOptions}
 */
function resolveOptions(preResolveOptions, viteConfig, cache) {
	const css = preResolveOptions.emitCss ? 'external' : 'injected';
	/** @type {Partial<import('../public.d.ts').Options>} */
	const defaultOptions = {
		compilerOptions: {
			css,
			dev: !viteConfig.isProduction,
			hmr:
				!viteConfig.isProduction &&
				!preResolveOptions.isBuild &&
				viteConfig.server &&
				viteConfig.server.hmr !== false
		}
	};

	/** @type {Partial<import('../types/options.d.ts').ResolvedOptions>} */
	const extraOptions = {
		root: viteConfig.root,
		isProduction: viteConfig.isProduction
	};
	const merged = /** @type {import('../types/options.d.ts').ResolvedOptions}*/ (
		mergeConfigs(defaultOptions, preResolveOptions, extraOptions)
	);

	removeIgnoredOptions(merged);
	handleDeprecatedOptions(merged);
	addExtraPreprocessors(merged, viteConfig);
	enforceOptionsForHmr(merged, viteConfig);
	enforceOptionsForProduction(merged);
	// mergeConfigs would mangle functions on the stats class, so do this afterwards
	if (log.debug.enabled && isDebugNamespaceEnabled('stats')) {
		merged.stats = new VitePluginSvelteStats(cache);
	}
	return merged;
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @param {import('vite').ResolvedConfig} viteConfig
 */
function enforceOptionsForHmr(options, viteConfig) {
	if (options.hot) {
		log.warn(
			'svelte 5 has hmr integrated in core. Please remove the vitePlugin.hot option and use compilerOptions.hmr instead'
		);
		delete options.hot;
		options.compilerOptions.hmr = true;
	}
	if (options.compilerOptions.hmr && viteConfig.server?.hmr === false) {
		log.warn(
			'vite config server.hmr is false but compilerOptions.hmr is true. Forcing compilerOptions.hmr to false as it would not work.'
		);
		options.compilerOptions.hmr = false;
	}
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 */
function enforceOptionsForProduction(options) {
	if (options.isProduction) {
		if (options.compilerOptions.hmr) {
			log.warn(
				'you are building for production but compilerOptions.hmr is true, forcing it to false'
			);
			options.compilerOptions.hmr = false;
		}
		if (options.compilerOptions.dev) {
			log.warn(
				'you are building for production but compilerOptions.dev is true, forcing it to false'
			);
			options.compilerOptions.dev = false;
		}
	}
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 */
function removeIgnoredOptions(options) {
	const ignoredCompilerOptions = ['generate', 'format', 'filename'];
	if (options.compilerOptions.hmr && options.emitCss) {
		ignoredCompilerOptions.push('cssHash');
	}
	const passedCompilerOptions = Object.keys(options.compilerOptions || {});
	const passedIgnored = passedCompilerOptions.filter((o) => ignoredCompilerOptions.includes(o));
	if (passedIgnored.length) {
		log.warn(
			`The following Svelte compilerOptions are controlled by vite-plugin-svelte and essential to its functionality. User-specified values are ignored. Please remove them from your configuration: ${passedIgnored.join(
				', '
			)}`
		);
		passedIgnored.forEach((ignored) => {
			// @ts-expect-error string access
			delete options.compilerOptions[ignored];
		});
	}
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 */
function handleDeprecatedOptions(options) {
	const experimental = /** @type {Record<string, any>} */ (options.experimental);
	if (experimental) {
		for (const promoted of ['prebundleSvelteLibraries', 'inspector', 'dynamicCompileOptions']) {
			if (experimental[promoted]) {
				//@ts-expect-error untyped assign
				options[promoted] = experimental[promoted];
				delete experimental[promoted];
				log.warn(
					`Option "experimental.${promoted}" is no longer experimental and has moved to "${promoted}". Please update your Svelte or Vite config.`
				);
			}
		}
		if (experimental.generateMissingPreprocessorSourcemaps) {
			log.warn('experimental.generateMissingPreprocessorSourcemaps has been removed.');
		}
	}
}

/**
 * vite passes unresolved `root`option to config hook but we need the resolved value, so do it here
 *
 * @see https://github.com/sveltejs/vite-plugin-svelte/issues/113
 * @see https://github.com/vitejs/vite/blob/43c957de8a99bb326afd732c962f42127b0a4d1e/packages/vite/src/node/config.ts#L293
 *
 * @param {import('vite').UserConfig} viteConfig
 * @returns {string | undefined}
 */
function resolveViteRoot(viteConfig) {
	return normalizePath$3(viteConfig.root ? path$b.resolve(viteConfig.root) : process$1.cwd());
}

/**
 * @param {import('../types/options.d.ts').PreResolvedOptions} options
 * @param {import('vite').UserConfig} config
 * @returns {Promise<Partial<import('vite').UserConfig>>}
 */
async function buildExtraViteConfig(options, config) {
	/** @type {Partial<import('vite').UserConfig>} */
	const extraViteConfig = {
		resolve: {
			dedupe: [...SVELTE_IMPORTS]
		}
		// this option is still awaiting a PR in vite to be supported
		// see https://github.com/sveltejs/vite-plugin-svelte/issues/60
		// knownJsSrcExtensions: options.extensions
	};

	const extraSvelteConfig = buildExtraConfigForSvelte(config);
	const extraDepsConfig = await buildExtraConfigForDependencies(options, config);
	// merge extra svelte and deps config, but make sure dep values are not contradicting svelte
	extraViteConfig.optimizeDeps = {
		include: [
			...extraSvelteConfig.optimizeDeps.include,
			...extraDepsConfig.optimizeDeps.include.filter(
				(dep) => !syncExports.isDepExcluded(dep, extraSvelteConfig.optimizeDeps.exclude)
			)
		],
		exclude: [
			...extraSvelteConfig.optimizeDeps.exclude,
			...extraDepsConfig.optimizeDeps.exclude.filter(
				(dep) => !syncExports.isDepIncluded(dep, extraSvelteConfig.optimizeDeps.include)
			)
		]
	};

	extraViteConfig.ssr = {
		external: [
			...extraSvelteConfig.ssr.external,
			...extraDepsConfig.ssr.external.filter(
				(dep) => !syncExports.isDepNoExternaled(dep, extraSvelteConfig.ssr.noExternal)
			)
		],
		noExternal: [
			...extraSvelteConfig.ssr.noExternal,
			...extraDepsConfig.ssr.noExternal.filter(
				(dep) => !syncExports.isDepExternaled(dep, extraSvelteConfig.ssr.external)
			)
		]
	};

	// handle prebundling for svelte files
	if (options.prebundleSvelteLibraries) {
		extraViteConfig.optimizeDeps = {
			...extraViteConfig.optimizeDeps,
			// Experimental Vite API to allow these extensions to be scanned and prebundled
			extensions: options.extensions ? [...options.extensions] : ['.svelte'],
			// Add esbuild plugin to prebundle Svelte files.
			// Currently a placeholder as more information is needed after Vite config is resolved,
			// the real Svelte plugin is added in `patchResolvedViteConfig()`
			esbuildOptions: {
				plugins: [
					{ name: facadeEsbuildSveltePluginName, setup: () => {} },
					{ name: facadeEsbuildSvelteModulePluginName, setup: () => {} }
				]
			}
		};
	}

	// enable hmrPartialAccept if not explicitly disabled
	if (config.experimental?.hmrPartialAccept !== false) {
		log.debug('enabling "experimental.hmrPartialAccept" in vite config', undefined, 'config');
		extraViteConfig.experimental = { hmrPartialAccept: true };
	}
	validateViteConfig(extraViteConfig, config, options);
	return extraViteConfig;
}

/**
 * @param {Partial<import('vite').UserConfig>} extraViteConfig
 * @param {import('vite').UserConfig} config
 * @param {import('../types/options.d.ts').PreResolvedOptions} options
 */
function validateViteConfig(extraViteConfig, config, options) {
	const { prebundleSvelteLibraries, isBuild } = options;
	if (prebundleSvelteLibraries) {
		/** @type {(option: 'dev' | 'build' | boolean)=> boolean} */
		const isEnabled = (option) => option !== true && option !== (isBuild ? 'build' : 'dev');
		/** @type {(name: string, value: 'dev' | 'build' | boolean, recommendation: string)=> void} */
		const logWarning = (name, value, recommendation) =>
			log.warn.once(
				`Incompatible options: \`prebundleSvelteLibraries: true\` and vite \`${name}: ${JSON.stringify(
					value
				)}\` ${isBuild ? 'during build.' : '.'} ${recommendation}`
			);
		const viteOptimizeDepsDisabled = config.optimizeDeps?.disabled ?? 'build'; // fall back to vite default
		const isOptimizeDepsEnabled = isEnabled(viteOptimizeDepsDisabled);
		if (!isBuild && !isOptimizeDepsEnabled) {
			logWarning(
				'optimizeDeps.disabled',
				viteOptimizeDepsDisabled,
				'Forcing `optimizeDeps.disabled: "build"`. Disable prebundleSvelteLibraries or update your vite config to enable optimizeDeps during dev.'
			);
			if (!extraViteConfig.optimizeDeps) {
				extraViteConfig.optimizeDeps = {};
			}
			extraViteConfig.optimizeDeps.disabled = 'build';
		} else if (isBuild && isOptimizeDepsEnabled) {
			logWarning(
				'optimizeDeps.disabled',
				viteOptimizeDepsDisabled,
				'Disable optimizeDeps or prebundleSvelteLibraries for build if you experience errors.'
			);
		}
	}
}

/**
 * @param {import('../types/options.d.ts').PreResolvedOptions} options
 * @param {import('vite').UserConfig} config
 * @returns {Promise<import('vitefu').CrawlFrameworkPkgsResult>}
 */
async function buildExtraConfigForDependencies(options, config) {
	// extra handling for svelte dependencies in the project
	const packagesWithoutSvelteExportsCondition = new Set();
	const depsConfig = await crawlFrameworkPkgs({
		root: options.root,
		isBuild: options.isBuild,
		viteUserConfig: config,
		isFrameworkPkgByJson(pkgJson) {
			let hasSvelteCondition = false;
			if (typeof pkgJson.exports === 'object') {
				// use replacer as a simple way to iterate over nested keys
				JSON.stringify(pkgJson.exports, (key, value) => {
					if (SVELTE_EXPORT_CONDITIONS.includes(key)) {
						hasSvelteCondition = true;
					}
					return value;
				});
			}
			const hasSvelteField = !!pkgJson.svelte;
			if (hasSvelteField && !hasSvelteCondition) {
				packagesWithoutSvelteExportsCondition.add(`${pkgJson.name}@${pkgJson.version}`);
			}
			return hasSvelteCondition || hasSvelteField;
		},
		isSemiFrameworkPkgByJson(pkgJson) {
			return !!pkgJson.dependencies?.svelte || !!pkgJson.peerDependencies?.svelte;
		},
		isFrameworkPkgByName(pkgName) {
			const isNotSveltePackage = isCommonDepWithoutSvelteField(pkgName);
			if (isNotSveltePackage) {
				return false;
			} else {
				return undefined;
			}
		}
	});
	if (
		!options.experimental?.disableSvelteResolveWarnings &&
		packagesWithoutSvelteExportsCondition?.size > 0
	) {
		log.warn(
			`WARNING: The following packages have a svelte field in their package.json but no exports condition for svelte.\n\n${[
				...packagesWithoutSvelteExportsCondition
			].join('\n')}\n\nPlease see ${FAQ_LINK_MISSING_EXPORTS_CONDITION} for details.`
		);
	}
	log.debug('extra config for dependencies generated by vitefu', depsConfig, 'config');

	if (options.prebundleSvelteLibraries) {
		// prebundling enabled, so we don't need extra dependency excludes
		depsConfig.optimizeDeps.exclude = [];
		// but keep dependency reinclusions of explicit user excludes
		const userExclude = config.optimizeDeps?.exclude;
		depsConfig.optimizeDeps.include = !userExclude
			? []
			: depsConfig.optimizeDeps.include.filter((dep) => {
					// reincludes look like this: foo > bar > baz
					// in case foo or bar are excluded, we have to retain the reinclude even with prebundling
					return (
						dep.includes('>') &&
						dep
							.split('>')
							.slice(0, -1)
							.some((d) => syncExports.isDepExcluded(d.trim(), userExclude))
					);
				});
	}
	if (options.disableDependencyReinclusion === true) {
		depsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter(
			(dep) => !dep.includes('>')
		);
	} else if (Array.isArray(options.disableDependencyReinclusion)) {
		const disabledDeps = options.disableDependencyReinclusion;
		depsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter((dep) => {
			if (!dep.includes('>')) return true;
			const trimDep = dep.replace(/\s+/g, '');
			return disabledDeps.some((disabled) => trimDep.includes(`${disabled}>`));
		});
	}

	log.debug('post-processed extra config for dependencies', depsConfig, 'config');

	return depsConfig;
}

/**
 * @param {import('vite').UserConfig} config
 * @returns {import('vite').UserConfig & { optimizeDeps: { include: string[], exclude:string[] }, ssr: { noExternal:(string|RegExp)[], external: string[] } } }
 */
function buildExtraConfigForSvelte(config) {
	// include svelte imports for optimization unless explicitly excluded
	/** @type {string[]} */
	const include = [];
	/** @type {string[]} */
	const exclude = [];
	if (!syncExports.isDepExcluded('svelte', config.optimizeDeps?.exclude ?? [])) {
		const svelteImportsToInclude = SVELTE_IMPORTS.filter(
			(si) => !(si.endsWith('/server') || si.includes('/server/'))
		);
		svelteImportsToInclude.push(...SVELTE_RUNTIME_DEPENDENCIES.map((dep) => `svelte > ${dep}`));
		log.debug(
			`adding bare svelte packages and runtime dependencies to optimizeDeps.include: ${svelteImportsToInclude.join(', ')} `,
			undefined,
			'config'
		);
		include.push(...svelteImportsToInclude);
	} else {
		log.debug(
			'"svelte" is excluded in optimizeDeps.exclude, skipped adding it to include.',
			undefined,
			'config'
		);
	}
	/** @type {(string | RegExp)[]} */
	const noExternal = [];
	/** @type {string[]} */
	const external = [];
	// add svelte to ssr.noExternal unless it is present in ssr.external
	// so it is correctly resolving according to the conditions in sveltes exports map
	if (!syncExports.isDepExternaled('svelte', config.ssr?.external ?? [])) {
		noExternal.push('svelte', /^svelte\//);
	}
	// esm-env needs to be bundled by default for the development/production condition
	// be properly used by svelte
	if (!syncExports.isDepExternaled('esm-env', config.ssr?.external ?? [])) {
		noExternal.push('esm-env');
	}
	return { optimizeDeps: { include, exclude }, ssr: { noExternal, external } };
}

/**
 * @param {import('vite').ResolvedConfig} viteConfig
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 */
function patchResolvedViteConfig(viteConfig, options) {
	if (options.preprocess) {
		for (const preprocessor of arraify(options.preprocess)) {
			if (preprocessor.style && '__resolvedConfig' in preprocessor.style) {
				preprocessor.style.__resolvedConfig = viteConfig;
			}
		}
	}

	// replace facade esbuild plugin with a real one
	const facadeEsbuildSveltePlugin = viteConfig.optimizeDeps.esbuildOptions?.plugins?.find(
		(plugin) => plugin.name === facadeEsbuildSveltePluginName
	);
	if (facadeEsbuildSveltePlugin) {
		Object.assign(facadeEsbuildSveltePlugin, esbuildSveltePlugin(options));
	}
	const facadeEsbuildSvelteModulePlugin = viteConfig.optimizeDeps.esbuildOptions?.plugins?.find(
		(plugin) => plugin.name === facadeEsbuildSvelteModulePluginName
	);
	if (facadeEsbuildSvelteModulePlugin) {
		Object.assign(facadeEsbuildSvelteModulePlugin, esbuildSvelteModulePlugin(options));
	}
}

/**
 * Mutates `config` to ensure `resolve.mainFields` is set. If unset, it emulates Vite's default fallback.
 * @param {string} name
 * @param {import('vite').EnvironmentOptions} config
 * @param {{ isSsrTargetWebworker?: boolean }} opts
 */
function ensureConfigEnvironmentMainFields(name, config, opts) {
	config.resolve ??= {};
	if (config.resolve.mainFields == null) {
		if (config.consumer === 'client' || name === 'client' || opts.isSsrTargetWebworker) {
			config.resolve.mainFields = [...DEFAULT_CLIENT_MAIN_FIELDS];
		} else {
			config.resolve.mainFields = [...DEFAULT_SERVER_MAIN_FIELDS];
		}
	}
	return true;
}

/**
 * Mutates `config` to ensure `resolve.conditions` is set. If unset, it emulates Vite's default fallback.
 * @param {string} name
 * @param {import('vite').EnvironmentOptions} config
 * @param {{ isSsrTargetWebworker?: boolean }} opts
 */
function ensureConfigEnvironmentConditions(name, config, opts) {
	config.resolve ??= {};
	if (config.resolve.conditions == null) {
		if (config.consumer === 'client' || name === 'client' || opts.isSsrTargetWebworker) {
			config.resolve.conditions = [...DEFAULT_CLIENT_CONDITIONS];
		} else {
			config.resolve.conditions = [...DEFAULT_SERVER_CONDITIONS];
		}
	}
}

/**
 * @template T
 * @param {T | T[]} value
 * @returns {T[]}
 */
function arraify(value) {
	return Array.isArray(value) ? value : [value];
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @param {import('./vite-plugin-svelte-cache.js').VitePluginSvelteCache} cache
 * @param {import('../types/id.d.ts').IdParser} requestParser
 * @returns {void}
 */
function setupWatchers(options, cache, requestParser) {
	const { server, configFile: svelteConfigFile } = options;
	if (!server) {
		return;
	}
	const { watcher, ws } = server;
	const { root, server: serverConfig } = server.config;
	/** @type {(filename: string) => void} */
	const emitChangeEventOnDependants = (filename) => {
		const dependants = cache.getDependants(filename);
		dependants.forEach((dependant) => {
			if (fs__default.existsSync(dependant)) {
				log.debug(
					`emitting virtual change event for "${dependant}" because dependency "${filename}" changed`,
					undefined,
					'hmr'
				);
				watcher.emit('change', dependant);
			}
		});
	};
	/** @type {(filename: string) => void} */
	const removeUnlinkedFromCache = (filename) => {
		const svelteRequest = requestParser(filename, false);
		if (svelteRequest) {
			const removedFromCache = cache.remove(svelteRequest);
			if (removedFromCache) {
				log.debug(`cleared VitePluginSvelteCache for deleted file ${filename}`, undefined, 'hmr');
			}
		}
	};
	/** @type {(filename: string) => void} */
	const triggerViteRestart = (filename) => {
		if (serverConfig.middlewareMode) {
			// in middlewareMode we can't restart the server automatically
			// show the user an overlay instead
			const message =
				'Svelte config change detected, restart your dev process to apply the changes.';
			log.info(message, filename);
			ws.send({
				type: 'error',
				err: { message, stack: '', plugin: 'vite-plugin-svelte', id: filename }
			});
		} else {
			log.info(`svelte config changed: restarting vite server. - file: ${filename}`);
			server.restart();
		}
	};

	// collection of watcher listeners by event
	/** @type {Record<string, Function[]>} */
	const listenerCollection = {
		add: [],
		change: [emitChangeEventOnDependants],
		unlink: [removeUnlinkedFromCache, emitChangeEventOnDependants]
	};

	if (svelteConfigFile !== false) {
		// configFile false means we ignore the file and external process is responsible
		const possibleSvelteConfigs = knownSvelteConfigNames.map((cfg) => path$b.join(root, cfg));
		/** @type {(filename: string) => void} */
		const restartOnConfigAdd = (filename) => {
			if (possibleSvelteConfigs.includes(filename)) {
				triggerViteRestart(filename);
			}
		};

		/** @type {(filename: string) => void} */
		const restartOnConfigChange = (filename) => {
			if (filename === svelteConfigFile) {
				triggerViteRestart(filename);
			}
		};

		if (svelteConfigFile) {
			listenerCollection.change.push(restartOnConfigChange);
			listenerCollection.unlink.push(restartOnConfigChange);
		} else {
			listenerCollection.add.push(restartOnConfigAdd);
		}
	}

	Object.entries(listenerCollection).forEach(([evt, listeners]) => {
		if (listeners.length > 0) {
			watcher.on(evt, (filename) => listeners.forEach((listener) => listener(filename)));
		}
	});
}

/**
 * taken from vite utils
 * @param {import('vite').FSWatcher} watcher
 * @param {string | null} file
 * @param {string} root
 * @returns {void}
 */
function ensureWatchedFile(watcher, file, root) {
	if (
		file &&
		// only need to watch if out of root
		!file.startsWith(root + '/') &&
		// some rollup plugins use null bytes for private resolved Ids
		!file.includes('\0') &&
		fs__default.existsSync(file)
	) {
		// resolve file to normalized system path
		watcher.add(path$b.resolve(file));
	}
}

// List of options that changes the prebundling result
/** @type {(keyof import('../types/options.d.ts').ResolvedOptions)[]} */
const PREBUNDLE_SENSITIVE_OPTIONS = [
	'compilerOptions',
	'configFile',
	'experimental',
	'extensions',
	'ignorePluginPreprocessors',
	'preprocess'
];

/**
 * @param {string} cacheDir
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {Promise<boolean>} Whether the Svelte metadata has changed
 */
async function saveSvelteMetadata(cacheDir, options) {
	const svelteMetadata = generateSvelteMetadata(options);
	const svelteMetadataPath = path$b.resolve(cacheDir, '_svelte_metadata.json');

	const currentSvelteMetadata = JSON.stringify(svelteMetadata, (_, value) => {
		// Handle preprocessors
		return typeof value === 'function' ? value.toString() : value;
	});

	/** @type {string | undefined} */
	let existingSvelteMetadata;
	try {
		existingSvelteMetadata = await promises.readFile(svelteMetadataPath, 'utf8');
	} catch {
		// ignore
	}

	await promises.mkdir(cacheDir, { recursive: true });
	await promises.writeFile(svelteMetadataPath, currentSvelteMetadata);
	return currentSvelteMetadata !== existingSvelteMetadata;
}

/**
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {Partial<import('../types/options.d.ts').ResolvedOptions>}
 */
function generateSvelteMetadata(options) {
	/** @type {Record<string, any>} */
	const metadata = {};
	for (const key of PREBUNDLE_SENSITIVE_OPTIONS) {
		metadata[key] = options[key];
	}
	return metadata;
}

/**
 * @typedef {{
 * 	name: string;
 * 	version: string;
 * 	svelte?: string;
 * 	path: string;
 * }} PackageInfo
 */

/**
 * @class
 */
class VitePluginSvelteCache {
	/** @type {Map<string, import('../types/compile.d.ts').Code | null>} */
	#css = new Map();
	/** @type {Map<string, import('../types/compile.d.ts').Code | null>} */
	#js = new Map();
	/** @type {Map<string, string[]>} */
	#dependencies = new Map();
	/** @type {Map<string, Set<string>>} */
	#dependants = new Map();
	/** @type {Map<string, any>} */
	#errors = new Map();
	/** @type {PackageInfo[]} */
	#packageInfos = [];

	/**
	 * @param {import('../types/compile.d.ts').CompileData} compileData
	 */
	update(compileData) {
		this.#errors.delete(compileData.normalizedFilename);
		this.#updateCSS(compileData);
		this.#updateJS(compileData);
		this.#updateDependencies(compileData);
	}

	/**
	 * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
	 * @returns {boolean}
	 */
	has(svelteRequest) {
		const id = svelteRequest.normalizedFilename;
		return this.#errors.has(id) || this.#js.has(id) || this.#css.has(id);
	}

	/**
	 * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
	 * @param {any} error
	 */
	setError(svelteRequest, error) {
		// keep dependency info, otherwise errors in dependants would not trigger an update after fixing
		// because they are no longer watched
		this.remove(svelteRequest, true);
		this.#errors.set(svelteRequest.normalizedFilename, error);
	}

	/**
	 * @param {import('../types/compile.d.ts').CompileData} compileData
	 */
	#updateCSS(compileData) {
		this.#css.set(compileData.normalizedFilename, compileData.compiled.css);
	}

	/**
	 * @param {import('../types/compile.d.ts').CompileData} compileData
	 */
	#updateJS(compileData) {
		if (!compileData.ssr) {
			// do not cache SSR js
			this.#js.set(compileData.normalizedFilename, compileData.compiled.js);
		}
	}

	/**
	 * @param {import('../types/compile.d.ts').CompileData} compileData
	 */
	#updateDependencies(compileData) {
		const id = compileData.normalizedFilename;
		const prevDependencies = this.#dependencies.get(id) || [];
		const dependencies = compileData.dependencies;
		this.#dependencies.set(id, dependencies);
		const removed = prevDependencies.filter((d) => !dependencies.includes(d));
		const added = dependencies.filter((d) => !prevDependencies.includes(d));
		added.forEach((d) => {
			if (!this.#dependants.has(d)) {
				this.#dependants.set(d, new Set());
			}
			/** @type {Set<string>} */ (this.#dependants.get(d)).add(compileData.filename);
		});
		removed.forEach((d) => {
			/** @type {Set<string>} */ (this.#dependants.get(d)).delete(compileData.filename);
		});
	}

	/**
	 * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
	 * @param {boolean} [keepDependencies]
	 * @returns {boolean}
	 */
	remove(svelteRequest, keepDependencies = false) {
		const id = svelteRequest.normalizedFilename;
		let removed = false;
		if (this.#errors.delete(id)) {
			removed = true;
		}
		if (this.#js.delete(id)) {
			removed = true;
		}
		if (this.#css.delete(id)) {
			removed = true;
		}
		if (!keepDependencies) {
			const dependencies = this.#dependencies.get(id);
			if (dependencies) {
				removed = true;
				dependencies.forEach((d) => {
					const dependants = this.#dependants.get(d);
					if (dependants && dependants.has(svelteRequest.filename)) {
						dependants.delete(svelteRequest.filename);
					}
				});
				this.#dependencies.delete(id);
			}
		}

		return removed;
	}

	/**
	 * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
	 * @returns {import('../types/compile.d.ts').Code | undefined | null}
	 */
	getCSS(svelteRequest) {
		return this.#css.get(svelteRequest.normalizedFilename);
	}

	/**
	 * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
	 * @returns {import('../types/compile.d.ts').Code | undefined | null}
	 */
	getJS(svelteRequest) {
		if (!svelteRequest.ssr) {
			// SSR js isn't cached
			return this.#js.get(svelteRequest.normalizedFilename);
		}
	}
	/**
	 * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
	 * @returns {any}
	 */
	getError(svelteRequest) {
		return this.#errors.get(svelteRequest.normalizedFilename);
	}

	/**
	 * @param {string} path
	 * @returns {string[]}
	 */
	getDependants(path) {
		const dependants = this.#dependants.get(path);
		return dependants ? [...dependants] : [];
	}

	/**
	 * @param {string} file
	 * @returns {Promise<PackageInfo>}
	 */
	async getPackageInfo(file) {
		let info = this.#packageInfos.find((pi) => file.startsWith(pi.path));
		if (!info) {
			info = await findPackageInfo(file);
			this.#packageInfos.push(info);
		}
		return info;
	}
}

/**
 * utility to get some info from the closest package.json with a "name" set
 *
 * @param {string} file to find info for
 * @returns {Promise<PackageInfo>}
 */
async function findPackageInfo(file) {
	/** @type {PackageInfo} */
	const info = {
		name: '$unknown',
		version: '0.0.0-unknown',
		path: '$unknown'
	};
	let path = await findClosestPkgJsonPath(file, (pkgPath) => {
		const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
		if (pkg.name != null) {
			info.name = pkg.name;
			if (pkg.version != null) {
				info.version = pkg.version;
			}
			info.svelte = pkg.svelte;
			return true;
		}
		return false;
	});
	// return normalized path with appended '/' so .startsWith works for future file checks
	path = normalizePath$3(dirname$1(path ?? file)) + '/';
	info.path = path;
	return info;
}

/**
 * utility function to compile ?raw and ?direct requests in load hook
 *
 * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
 * @param {import('../types/compile.d.ts').CompileSvelte} compileSvelte
 * @param {import('../types/options.d.ts').ResolvedOptions} options
 * @returns {Promise<string>}
 */
async function loadRaw(svelteRequest, compileSvelte, options) {
	const { id, filename, query } = svelteRequest;

	// raw svelte subrequest, compile on the fly and return requested subpart
	let compileData;
	const source = fs__default.readFileSync(filename, 'utf-8');
	try {
		//avoid compileSvelte doing extra ssr stuff unless requested
		svelteRequest.ssr = query.compilerOptions?.generate === 'server';
		compileData = await compileSvelte(svelteRequest, source, {
			...options,
			// don't use dynamic vite-plugin-svelte defaults here to ensure stable result between ssr,dev and build
			compilerOptions: {
				dev: false,
				css: 'external',
				hmr: false,
				...svelteRequest.query.compilerOptions
			},
			emitCss: true
		});
	} catch (e) {
		throw toRollupError(e, options);
	}
	let result;
	if (query.type === 'style') {
		result = compileData.compiled.css ?? { code: '', map: null };
	} else if (query.type === 'script') {
		result = compileData.compiled.js;
	} else if (query.type === 'preprocessed') {
		result = compileData.preprocessed;
	} else if (query.type === 'all' && query.raw) {
		return allToRawExports(compileData, source);
	} else {
		throw new Error(
			`invalid "type=${query.type}" in ${id}. supported are script, style, preprocessed, all`
		);
	}
	if (query.direct) {
		const supportedDirectTypes = ['script', 'style'];
		if (!supportedDirectTypes.includes(query.type)) {
			throw new Error(
				`invalid "type=${
					query.type
				}" combined with direct in ${id}. supported are: ${supportedDirectTypes.join(', ')}`
			);
		}
		log.debug(`load returns direct result for ${id}`, undefined, 'load');
		let directOutput = result.code;
		// @ts-expect-error might not be SourceMap but toUrl check should suffice
		if (query.sourcemap && result.map?.toUrl) {
			// @ts-expect-error toUrl might not exist
			const map = `sourceMappingURL=${result.map.toUrl()}`;
			if (query.type === 'style') {
				directOutput += `\n\n/*# ${map} */\n`;
			} else if (query.type === 'script') {
				directOutput += `\n\n//# ${map}\n`;
			}
		}
		return directOutput;
	} else if (query.raw) {
		log.debug(`load returns raw result for ${id}`, undefined, 'load');
		return toRawExports(result);
	} else {
		throw new Error(`invalid raw mode in ${id}, supported are raw, direct`);
	}
}

/**
 * turn compileData and source into a flat list of raw exports
 *
 * @param {import('../types/compile.d.ts').CompileData} compileData
 * @param {string} source
 */
function allToRawExports(compileData, source) {
	// flatten CompileData
	/** @type {Partial<import('../types/compile.d.ts').CompileData & { source: string }>} */
	const exports$1 = {
		...compileData,
		...compileData.compiled,
		source
	};
	delete exports$1.compiled;
	delete exports$1.filename; // absolute path, remove to avoid it in output
	return toRawExports(exports$1);
}

/**
 * turn object into raw exports.
 *
 * every prop is returned as a const export, and if prop 'code' exists it is additionally added as default export
 *
 * eg {'foo':'bar','code':'baz'} results in
 *
 *  ```js
 *  export const code='baz'
 *  export const foo='bar'
 *  export default code
 *  ```
 * @param {object} object
 * @returns {string}
 */
function toRawExports(object) {
	let exports$1 =
		Object.entries(object)
			.filter(([_key, value]) => typeof value !== 'function') // preprocess output has a toString function that's enumerable
			.sort(([a], [b]) => (a < b ? -1 : a === b ? 0 : 1))
			.map(([key, value]) => `export const ${key}=${JSON.stringify(value)}`)
			.join('\n') + '\n';
	if (Object.prototype.hasOwnProperty.call(object, 'code')) {
		exports$1 += 'export default code\n';
	}
	return exports$1;
}

/**
 * @param {Partial<import('./public.d.ts').Options>} [inlineOptions]
 * @returns {import('vite').Plugin[]}
 */
function svelte(inlineOptions) {
	if (process$1.env.DEBUG != null) {
		log.setLevel('debug');
	}
	validateInlineOptions(inlineOptions);
	const cache = new VitePluginSvelteCache();
	// updated in configResolved hook
	/** @type {import('./types/id.d.ts').IdParser} */
	let requestParser;
	/** @type {import('./types/id.d.ts').ModuleIdParser} */
	let moduleRequestParser;
	/** @type {import('./types/options.d.ts').ResolvedOptions} */
	let options;
	/** @type {import('vite').ResolvedConfig} */
	let viteConfig;
	/** @type {import('./types/compile.d.ts').CompileSvelte} */
	let compileSvelte;
	/** @type {import('./types/plugin-api.d.ts').PluginAPI} */
	const api = {};
	/** @type {import('vite').Plugin[]} */
	const plugins = [
		{
			name: 'vite-plugin-svelte',
			// make sure our resolver runs before vite internal resolver to resolve svelte field correctly
			enforce: 'pre',
			api,
			async config(config, configEnv) {
				// setup logger
				if (process$1.env.DEBUG) {
					log.setLevel('debug');
				} else if (config.logLevel) {
					log.setLevel(config.logLevel);
				}
				// @ts-expect-error temporarily lend the options variable until fixed in configResolved
				options = await preResolveOptions(inlineOptions, config, configEnv);
				// extra vite config
				const extraViteConfig = await buildExtraViteConfig(options, config);
				log.debug('additional vite config', extraViteConfig, 'config');
				return extraViteConfig;
			},

			configEnvironment(name, config, opts) {
				ensureConfigEnvironmentMainFields(name, config, opts);
				// @ts-expect-error the function above should make `resolve.mainFields` non-nullable
				config.resolve.mainFields.unshift('svelte');

				ensureConfigEnvironmentConditions(name, config, opts);
				// @ts-expect-error the function above should make `resolve.conditions` non-nullable
				config.resolve.conditions.push('svelte');
			},

			async configResolved(config) {
				options = resolveOptions(options, config, cache);
				patchResolvedViteConfig(config, options);
				requestParser = buildIdParser(options);
				compileSvelte = createCompileSvelte();
				viteConfig = config;
				// TODO deep clone to avoid mutability from outside?
				api.options = options;
				log.debug('resolved options', options, 'config');
			},

			async buildStart() {
				if (!options.prebundleSvelteLibraries) return;
				const isSvelteMetadataChanged = await saveSvelteMetadata(viteConfig.cacheDir, options);
				if (isSvelteMetadataChanged) {
					// Force Vite to optimize again. Although we mutate the config here, it works because
					// Vite's optimizer runs after `buildStart()`.
					viteConfig.optimizeDeps.force = true;
				}
			},

			configureServer(server) {
				options.server = server;
				setupWatchers(options, cache, requestParser);
			},

			async load(id, opts) {
				const ssr = !!opts?.ssr;
				const svelteRequest = requestParser(id, !!ssr);
				if (svelteRequest) {
					const { filename, query, raw } = svelteRequest;
					if (raw) {
						const code = await loadRaw(svelteRequest, compileSvelte, options);
						// prevent vite from injecting sourcemaps in the results.
						return {
							code,
							map: {
								mappings: ''
							}
						};
					} else {
						if (query.svelte && query.type === 'style') {
							const cachedCss = cache.getCSS(svelteRequest);
							if (cachedCss) {
								const { hasGlobal, ...css } = cachedCss;
								if (hasGlobal === false) {
									// hasGlobal was added in svelte 5.26.0, so make sure it is boolean false
									css.meta ??= {};
									css.meta.vite ??= {};
									css.meta.vite.cssScopeTo = [svelteRequest.filename, 'default'];
								}
								return css;
							}
						}
						// prevent vite asset plugin from loading files as url that should be compiled in transform
						if (viteConfig.assetsInclude(filename)) {
							log.debug(`load returns raw content for ${filename}`, undefined, 'load');
							return fs__default.readFileSync(filename, 'utf-8');
						}
					}
				}
			},

			async resolveId(importee, importer, opts) {
				const ssr = !!opts?.ssr;
				const svelteRequest = requestParser(importee, ssr);
				if (svelteRequest?.query.svelte) {
					if (
						svelteRequest.query.type === 'style' &&
						!svelteRequest.raw &&
						!svelteRequest.query.inline
					) {
						// return cssId with root prefix so postcss pipeline of vite finds the directory correctly
						// see https://github.com/sveltejs/vite-plugin-svelte/issues/14
						log.debug(
							`resolveId resolved virtual css module ${svelteRequest.cssId}`,
							undefined,
							'resolve'
						);
						return svelteRequest.cssId;
					}
				}
			},

			async transform(code, id, opts) {
				const ssr = !!opts?.ssr;
				const svelteRequest = requestParser(id, ssr);
				if (!svelteRequest || svelteRequest.query.type === 'style' || svelteRequest.raw) {
					return;
				}
				let compileData;
				try {
					compileData = await compileSvelte(svelteRequest, code, options);
				} catch (e) {
					cache.setError(svelteRequest, e);
					throw toRollupError(e, options);
				}
				logCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);
				cache.update(compileData);
				if (compileData.dependencies?.length) {
					if (options.server) {
						for (const dep of compileData.dependencies) {
							ensureWatchedFile(options.server.watcher, dep, options.root);
						}
					} else if (options.isBuild && viteConfig.build.watch) {
						for (const dep of compileData.dependencies) {
							this.addWatchFile(dep);
						}
					}
				}
				return {
					...compileData.compiled.js,
					meta: {
						vite: {
							lang: compileData.lang
						}
					}
				};
			},

			handleHotUpdate(ctx) {
				if (!options.compilerOptions.hmr || !options.emitCss) {
					return;
				}
				const svelteRequest = requestParser(ctx.file, false, ctx.timestamp);
				if (svelteRequest) {
					return handleHotUpdate(compileSvelte, ctx, svelteRequest, cache, options);
				}
			},
			async buildEnd() {
				await options.stats?.finishAll();
			}
		},
		{
			name: 'vite-plugin-svelte-module',
			enforce: 'post',
			async configResolved() {
				moduleRequestParser = buildModuleIdParser(options);
			},
			async transform(code, id, opts) {
				const ssr = !!opts?.ssr;
				const moduleRequest = moduleRequestParser(id, ssr);
				if (!moduleRequest) {
					return;
				}
				try {
					const compileResult = compileModule(code, {
						dev: !viteConfig.isProduction,
						generate: ssr ? 'server' : 'client',
						filename: moduleRequest.filename
					});
					logCompilerWarnings(moduleRequest, compileResult.warnings, options);
					return compileResult.js;
				} catch (e) {
					throw toRollupError(e, options);
				}
			}
		},
		svelteInspector()
	];
	return plugins;
}

function getRenderer() {
  return {
    name: "@astrojs/svelte",
    clientEntrypoint: "@astrojs/svelte/client.js",
    serverEntrypoint: "@astrojs/svelte/server.js"
  };
}
function svelteIntegration(options) {
  return {
    name: "@astrojs/svelte",
    hooks: {
      "astro:config:setup": async ({ updateConfig, addRenderer }) => {
        addRenderer(getRenderer());
        updateConfig({
          vite: {
            optimizeDeps: {
              include: ["@astrojs/svelte/client.js"],
              exclude: ["@astrojs/svelte/server.js"]
            },
            plugins: [svelte(options)]
          }
        });
      }
    }
  };
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
const s={chrome:{releases:[["1","2008-12-11","r","w","528"],["2","2009-05-21","r","w","530"],["3","2009-09-15","r","w","532"],["4","2010-01-25","r","w","532.5"],["5","2010-05-25","r","w","533"],["6","2010-09-02","r","w","534.3"],["7","2010-10-19","r","w","534.7"],["8","2010-12-02","r","w","534.10"],["9","2011-02-03","r","w","534.13"],["10","2011-03-08","r","w","534.16"],["11","2011-04-27","r","w","534.24"],["12","2011-06-07","r","w","534.30"],["13","2011-08-02","r","w","535.1"],["14","2011-09-16","r","w","535.1"],["15","2011-10-25","r","w","535.2"],["16","2011-12-13","r","w","535.7"],["17","2012-02-08","r","w","535.11"],["18","2012-03-28","r","w","535.19"],["19","2012-05-15","r","w","536.5"],["20","2012-06-26","r","w","536.10"],["21","2012-07-31","r","w","537.1"],["22","2012-09-25","r","w","537.4"],["23","2012-11-06","r","w","537.11"],["24","2013-01-10","r","w","537.17"],["25","2013-02-21","r","w","537.22"],["26","2013-03-26","r","w","537.31"],["27","2013-05-21","r","w","537.36"],["28","2013-07-09","r","b","28"],["29","2013-08-20","r","b","29"],["30","2013-10-01","r","b","30"],["31","2013-11-12","r","b","31"],["32","2014-01-14","r","b","32"],["33","2014-02-20","r","b","33"],["34","2014-04-08","r","b","34"],["35","2014-05-20","r","b","35"],["36","2014-07-16","r","b","36"],["37","2014-08-26","r","b","37"],["38","2014-10-07","r","b","38"],["39","2014-11-18","r","b","39"],["40","2015-01-21","r","b","40"],["41","2015-03-03","r","b","41"],["42","2015-04-14","r","b","42"],["43","2015-05-19","r","b","43"],["44","2015-07-21","r","b","44"],["45","2015-09-01","r","b","45"],["46","2015-10-13","r","b","46"],["47","2015-12-01","r","b","47"],["48","2016-01-20","r","b","48"],["49","2016-03-02","r","b","49"],["50","2016-04-13","r","b","50"],["51","2016-05-25","r","b","51"],["52","2016-07-20","r","b","52"],["53","2016-08-31","r","b","53"],["54","2016-10-12","r","b","54"],["55","2016-12-01","r","b","55"],["56","2017-01-25","r","b","56"],["57","2017-03-09","r","b","57"],["58","2017-04-19","r","b","58"],["59","2017-06-05","r","b","59"],["60","2017-07-25","r","b","60"],["61","2017-09-05","r","b","61"],["62","2017-10-17","r","b","62"],["63","2017-12-06","r","b","63"],["64","2018-01-23","r","b","64"],["65","2018-03-06","r","b","65"],["66","2018-04-17","r","b","66"],["67","2018-05-29","r","b","67"],["68","2018-07-24","r","b","68"],["69","2018-09-04","r","b","69"],["70","2018-10-16","r","b","70"],["71","2018-12-04","r","b","71"],["72","2019-01-29","r","b","72"],["73","2019-03-12","r","b","73"],["74","2019-04-23","r","b","74"],["75","2019-06-04","r","b","75"],["76","2019-07-30","r","b","76"],["77","2019-09-10","r","b","77"],["78","2019-10-22","r","b","78"],["79","2019-12-10","r","b","79"],["80","2020-02-04","r","b","80"],["81","2020-04-07","r","b","81"],["83","2020-05-19","r","b","83"],["84","2020-07-27","r","b","84"],["85","2020-08-25","r","b","85"],["86","2020-10-20","r","b","86"],["87","2020-11-17","r","b","87"],["88","2021-01-19","r","b","88"],["89","2021-03-02","r","b","89"],["90","2021-04-13","r","b","90"],["91","2021-05-25","r","b","91"],["92","2021-07-20","r","b","92"],["93","2021-08-31","r","b","93"],["94","2021-09-21","r","b","94"],["95","2021-10-19","r","b","95"],["96","2021-11-15","r","b","96"],["97","2022-01-04","r","b","97"],["98","2022-02-01","r","b","98"],["99","2022-03-01","r","b","99"],["100","2022-03-29","r","b","100"],["101","2022-04-26","r","b","101"],["102","2022-05-24","r","b","102"],["103","2022-06-21","r","b","103"],["104","2022-08-02","r","b","104"],["105","2022-09-02","r","b","105"],["106","2022-09-27","r","b","106"],["107","2022-10-25","r","b","107"],["108","2022-11-29","r","b","108"],["109","2023-01-10","r","b","109"],["110","2023-02-07","r","b","110"],["111","2023-03-07","r","b","111"],["112","2023-04-04","r","b","112"],["113","2023-05-02","r","b","113"],["114","2023-05-30","r","b","114"],["115","2023-07-18","r","b","115"],["116","2023-08-15","r","b","116"],["117","2023-09-12","r","b","117"],["118","2023-10-10","r","b","118"],["119","2023-10-31","r","b","119"],["120","2023-12-05","r","b","120"],["121","2024-01-23","r","b","121"],["122","2024-02-20","r","b","122"],["123","2024-03-19","r","b","123"],["124","2024-04-16","r","b","124"],["125","2024-05-14","r","b","125"],["126","2024-06-11","r","b","126"],["127","2024-07-23","r","b","127"],["128","2024-08-20","r","b","128"],["129","2024-09-17","r","b","129"],["130","2024-10-15","r","b","130"],["131","2024-11-12","r","b","131"],["132","2025-01-14","r","b","132"],["133","2025-02-04","r","b","133"],["134","2025-03-04","r","b","134"],["135","2025-04-01","r","b","135"],["136","2025-04-29","r","b","136"],["137","2025-05-27","r","b","137"],["138","2025-06-24","r","b","138"],["139","2025-08-05","r","b","139"],["140","2025-09-02","r","b","140"],["141","2025-09-30","r","b","141"],["142","2025-10-28","r","b","142"],["143","2025-12-02","c","b","143"],["144","2026-01-13","b","b","144"],["145","2026-02-10","n","b","145"],["146",null,"p","b","146"]]},chrome_android:{releases:[["18","2012-06-27","r","w","535.19"],["25","2013-02-27","r","w","537.22"],["26","2013-04-03","r","w","537.31"],["27","2013-05-22","r","w","537.36"],["28","2013-07-10","r","b","28"],["29","2013-08-21","r","b","29"],["30","2013-10-02","r","b","30"],["31","2013-11-14","r","b","31"],["32","2014-01-15","r","b","32"],["33","2014-02-26","r","b","33"],["34","2014-04-02","r","b","34"],["35","2014-05-20","r","b","35"],["36","2014-07-16","r","b","36"],["37","2014-09-03","r","b","37"],["38","2014-10-08","r","b","38"],["39","2014-11-12","r","b","39"],["40","2015-01-21","r","b","40"],["41","2015-03-11","r","b","41"],["42","2015-04-15","r","b","42"],["43","2015-05-27","r","b","43"],["44","2015-07-29","r","b","44"],["45","2015-09-01","r","b","45"],["46","2015-10-14","r","b","46"],["47","2015-12-02","r","b","47"],["48","2016-01-26","r","b","48"],["49","2016-03-09","r","b","49"],["50","2016-04-13","r","b","50"],["51","2016-06-08","r","b","51"],["52","2016-07-27","r","b","52"],["53","2016-09-07","r","b","53"],["54","2016-10-19","r","b","54"],["55","2016-12-06","r","b","55"],["56","2017-02-01","r","b","56"],["57","2017-03-16","r","b","57"],["58","2017-04-25","r","b","58"],["59","2017-06-06","r","b","59"],["60","2017-08-01","r","b","60"],["61","2017-09-05","r","b","61"],["62","2017-10-24","r","b","62"],["63","2017-12-05","r","b","63"],["64","2018-01-23","r","b","64"],["65","2018-03-06","r","b","65"],["66","2018-04-17","r","b","66"],["67","2018-05-31","r","b","67"],["68","2018-07-24","r","b","68"],["69","2018-09-04","r","b","69"],["70","2018-10-17","r","b","70"],["71","2018-12-04","r","b","71"],["72","2019-01-29","r","b","72"],["73","2019-03-12","r","b","73"],["74","2019-04-24","r","b","74"],["75","2019-06-04","r","b","75"],["76","2019-07-30","r","b","76"],["77","2019-09-10","r","b","77"],["78","2019-10-22","r","b","78"],["79","2019-12-17","r","b","79"],["80","2020-02-04","r","b","80"],["81","2020-04-07","r","b","81"],["83","2020-05-19","r","b","83"],["84","2020-07-27","r","b","84"],["85","2020-08-25","r","b","85"],["86","2020-10-20","r","b","86"],["87","2020-11-17","r","b","87"],["88","2021-01-19","r","b","88"],["89","2021-03-02","r","b","89"],["90","2021-04-13","r","b","90"],["91","2021-05-25","r","b","91"],["92","2021-07-20","r","b","92"],["93","2021-08-31","r","b","93"],["94","2021-09-21","r","b","94"],["95","2021-10-19","r","b","95"],["96","2021-11-15","r","b","96"],["97","2022-01-04","r","b","97"],["98","2022-02-01","r","b","98"],["99","2022-03-01","r","b","99"],["100","2022-03-29","r","b","100"],["101","2022-04-26","r","b","101"],["102","2022-05-24","r","b","102"],["103","2022-06-21","r","b","103"],["104","2022-08-02","r","b","104"],["105","2022-09-02","r","b","105"],["106","2022-09-27","r","b","106"],["107","2022-10-25","r","b","107"],["108","2022-11-29","r","b","108"],["109","2023-01-10","r","b","109"],["110","2023-02-07","r","b","110"],["111","2023-03-07","r","b","111"],["112","2023-04-04","r","b","112"],["113","2023-05-02","r","b","113"],["114","2023-05-30","r","b","114"],["115","2023-07-21","r","b","115"],["116","2023-08-15","r","b","116"],["117","2023-09-12","r","b","117"],["118","2023-10-10","r","b","118"],["119","2023-10-31","r","b","119"],["120","2023-12-05","r","b","120"],["121","2024-01-23","r","b","121"],["122","2024-02-20","r","b","122"],["123","2024-03-19","r","b","123"],["124","2024-04-16","r","b","124"],["125","2024-05-14","r","b","125"],["126","2024-06-11","r","b","126"],["127","2024-07-23","r","b","127"],["128","2024-08-20","r","b","128"],["129","2024-09-17","r","b","129"],["130","2024-10-15","r","b","130"],["131","2024-11-12","r","b","131"],["132","2025-01-14","r","b","132"],["133","2025-02-04","r","b","133"],["134","2025-03-04","r","b","134"],["135","2025-04-01","r","b","135"],["136","2025-04-29","r","b","136"],["137","2025-05-27","r","b","137"],["138","2025-06-24","r","b","138"],["139","2025-08-05","r","b","139"],["140","2025-09-02","r","b","140"],["141","2025-09-30","r","b","141"],["142","2025-10-28","r","b","142"],["143","2025-12-02","c","b","143"],["144","2026-01-13","b","b","144"],["145","2026-02-10","n","b","145"],["146",null,"p","b","146"]]},edge:{releases:[["12","2015-07-29","r",null,"12"],["13","2015-11-12","r",null,"13"],["14","2016-08-02","r",null,"14"],["15","2017-04-05","r",null,"15"],["16","2017-10-17","r",null,"16"],["17","2018-04-30","r",null,"17"],["18","2018-10-02","r",null,"18"],["79","2020-01-15","r","b","79"],["80","2020-02-07","r","b","80"],["81","2020-04-13","r","b","81"],["83","2020-05-21","r","b","83"],["84","2020-07-16","r","b","84"],["85","2020-08-27","r","b","85"],["86","2020-10-09","r","b","86"],["87","2020-11-19","r","b","87"],["88","2021-01-21","r","b","88"],["89","2021-03-04","r","b","89"],["90","2021-04-15","r","b","90"],["91","2021-05-27","r","b","91"],["92","2021-07-22","r","b","92"],["93","2021-09-02","r","b","93"],["94","2021-09-24","r","b","94"],["95","2021-10-21","r","b","95"],["96","2021-11-19","r","b","96"],["97","2022-01-06","r","b","97"],["98","2022-02-03","r","b","98"],["99","2022-03-03","r","b","99"],["100","2022-04-01","r","b","100"],["101","2022-04-28","r","b","101"],["102","2022-05-31","r","b","102"],["103","2022-06-23","r","b","103"],["104","2022-08-05","r","b","104"],["105","2022-09-01","r","b","105"],["106","2022-10-03","r","b","106"],["107","2022-10-27","r","b","107"],["108","2022-12-05","r","b","108"],["109","2023-01-12","r","b","109"],["110","2023-02-09","r","b","110"],["111","2023-03-13","r","b","111"],["112","2023-04-06","r","b","112"],["113","2023-05-05","r","b","113"],["114","2023-06-02","r","b","114"],["115","2023-07-21","r","b","115"],["116","2023-08-21","r","b","116"],["117","2023-09-15","r","b","117"],["118","2023-10-13","r","b","118"],["119","2023-11-02","r","b","119"],["120","2023-12-07","r","b","120"],["121","2024-01-25","r","b","121"],["122","2024-02-23","r","b","122"],["123","2024-03-22","r","b","123"],["124","2024-04-18","r","b","124"],["125","2024-05-17","r","b","125"],["126","2024-06-13","r","b","126"],["127","2024-07-25","r","b","127"],["128","2024-08-22","r","b","128"],["129","2024-09-19","r","b","129"],["130","2024-10-17","r","b","130"],["131","2024-11-14","r","b","131"],["132","2025-01-17","r","b","132"],["133","2025-02-06","r","b","133"],["134","2025-03-06","r","b","134"],["135","2025-04-04","r","b","135"],["136","2025-05-01","r","b","136"],["137","2025-05-29","r","b","137"],["138","2025-06-26","r","b","138"],["139","2025-08-07","r","b","139"],["140","2025-09-05","r","b","140"],["141","2025-10-03","r","b","141"],["142","2025-10-31","r","b","142"],["143","2025-12-05","c","b","143"],["144","2026-01-15","b","b","144"],["145","2026-02-12","n","b","145"],["146","2026-03-12","p","b","146"]]},firefox:{releases:[["1","2004-11-09","r","g","1.7"],["2","2006-10-24","r","g","1.8.1"],["3","2008-06-17","r","g","1.9"],["4","2011-03-22","r","g","2"],["5","2011-06-21","r","g","5"],["6","2011-08-16","r","g","6"],["7","2011-09-27","r","g","7"],["8","2011-11-08","r","g","8"],["9","2011-12-20","r","g","9"],["10","2012-01-31","r","g","10"],["11","2012-03-13","r","g","11"],["12","2012-04-24","r","g","12"],["13","2012-06-05","r","g","13"],["14","2012-07-17","r","g","14"],["15","2012-08-28","r","g","15"],["16","2012-10-09","r","g","16"],["17","2012-11-20","r","g","17"],["18","2013-01-08","r","g","18"],["19","2013-02-19","r","g","19"],["20","2013-04-02","r","g","20"],["21","2013-05-14","r","g","21"],["22","2013-06-25","r","g","22"],["23","2013-08-06","r","g","23"],["24","2013-09-17","r","g","24"],["25","2013-10-29","r","g","25"],["26","2013-12-10","r","g","26"],["27","2014-02-04","r","g","27"],["28","2014-03-18","r","g","28"],["29","2014-04-29","r","g","29"],["30","2014-06-10","r","g","30"],["31","2014-07-22","r","g","31"],["32","2014-09-02","r","g","32"],["33","2014-10-14","r","g","33"],["34","2014-12-01","r","g","34"],["35","2015-01-13","r","g","35"],["36","2015-02-24","r","g","36"],["37","2015-03-31","r","g","37"],["38","2015-05-12","r","g","38"],["39","2015-07-02","r","g","39"],["40","2015-08-11","r","g","40"],["41","2015-09-22","r","g","41"],["42","2015-11-03","r","g","42"],["43","2015-12-15","r","g","43"],["44","2016-01-26","r","g","44"],["45","2016-03-08","r","g","45"],["46","2016-04-26","r","g","46"],["47","2016-06-07","r","g","47"],["48","2016-08-02","r","g","48"],["49","2016-09-20","r","g","49"],["50","2016-11-15","r","g","50"],["51","2017-01-24","r","g","51"],["52","2017-03-07","r","g","52"],["53","2017-04-19","r","g","53"],["54","2017-06-13","r","g","54"],["55","2017-08-08","r","g","55"],["56","2017-09-28","r","g","56"],["57","2017-11-14","r","g","57"],["58","2018-01-23","r","g","58"],["59","2018-03-13","r","g","59"],["60","2018-05-09","r","g","60"],["61","2018-06-26","r","g","61"],["62","2018-09-05","r","g","62"],["63","2018-10-23","r","g","63"],["64","2018-12-11","r","g","64"],["65","2019-01-29","r","g","65"],["66","2019-03-19","r","g","66"],["67","2019-05-21","r","g","67"],["68","2019-07-09","r","g","68"],["69","2019-09-03","r","g","69"],["70","2019-10-22","r","g","70"],["71","2019-12-10","r","g","71"],["72","2020-01-07","r","g","72"],["73","2020-02-11","r","g","73"],["74","2020-03-10","r","g","74"],["75","2020-04-07","r","g","75"],["76","2020-05-05","r","g","76"],["77","2020-06-02","r","g","77"],["78","2020-06-30","r","g","78"],["79","2020-07-28","r","g","79"],["80","2020-08-25","r","g","80"],["81","2020-09-22","r","g","81"],["82","2020-10-20","r","g","82"],["83","2020-11-17","r","g","83"],["84","2020-12-15","r","g","84"],["85","2021-01-26","r","g","85"],["86","2021-02-23","r","g","86"],["87","2021-03-23","r","g","87"],["88","2021-04-19","r","g","88"],["89","2021-06-01","r","g","89"],["90","2021-07-13","r","g","90"],["91","2021-08-10","r","g","91"],["92","2021-09-07","r","g","92"],["93","2021-10-05","r","g","93"],["94","2021-11-02","r","g","94"],["95","2021-12-07","r","g","95"],["96","2022-01-11","r","g","96"],["97","2022-02-08","r","g","97"],["98","2022-03-08","r","g","98"],["99","2022-04-05","r","g","99"],["100","2022-05-03","r","g","100"],["101","2022-05-31","r","g","101"],["102","2022-06-28","r","g","102"],["103","2022-07-26","r","g","103"],["104","2022-08-23","r","g","104"],["105","2022-09-20","r","g","105"],["106","2022-10-18","r","g","106"],["107","2022-11-15","r","g","107"],["108","2022-12-13","r","g","108"],["109","2023-01-17","r","g","109"],["110","2023-02-14","r","g","110"],["111","2023-03-14","r","g","111"],["112","2023-04-11","r","g","112"],["113","2023-05-09","r","g","113"],["114","2023-06-06","r","g","114"],["115","2023-07-04","r","g","115"],["116","2023-08-01","r","g","116"],["117","2023-08-29","r","g","117"],["118","2023-09-26","r","g","118"],["119","2023-10-24","r","g","119"],["120","2023-11-21","r","g","120"],["121","2023-12-19","r","g","121"],["122","2024-01-23","r","g","122"],["123","2024-02-20","r","g","123"],["124","2024-03-19","r","g","124"],["125","2024-04-16","r","g","125"],["126","2024-05-14","r","g","126"],["127","2024-06-11","r","g","127"],["128","2024-07-09","r","g","128"],["129","2024-08-06","r","g","129"],["130","2024-09-03","r","g","130"],["131","2024-10-01","r","g","131"],["132","2024-10-29","r","g","132"],["133","2024-11-26","r","g","133"],["134","2025-01-07","r","g","134"],["135","2025-02-04","r","g","135"],["136","2025-03-04","r","g","136"],["137","2025-04-01","r","g","137"],["138","2025-04-29","r","g","138"],["139","2025-05-27","r","g","139"],["140","2025-06-24","e","g","140"],["141","2025-07-22","r","g","141"],["142","2025-08-19","r","g","142"],["143","2025-09-16","r","g","143"],["144","2025-10-14","r","g","144"],["145","2025-11-11","r","g","145"],["146","2025-12-09","c","g","146"],["147","2026-01-13","b","g","147"],["148","2026-02-24","n","g","148"],["149","2026-03-24","p","g","149"],["1.5","2005-11-29","r","g","1.8"],["3.5","2009-06-30","r","g","1.9.1"],["3.6","2010-01-21","r","g","1.9.2"]]},firefox_android:{releases:[["4","2011-03-29","r","g","2"],["5","2011-06-21","r","g","5"],["6","2011-08-16","r","g","6"],["7","2011-09-27","r","g","7"],["8","2011-11-08","r","g","8"],["9","2011-12-21","r","g","9"],["10","2012-01-31","r","g","10"],["14","2012-06-26","r","g","14"],["15","2012-08-28","r","g","15"],["16","2012-10-09","r","g","16"],["17","2012-11-20","r","g","17"],["18","2013-01-08","r","g","18"],["19","2013-02-19","r","g","19"],["20","2013-04-02","r","g","20"],["21","2013-05-14","r","g","21"],["22","2013-06-25","r","g","22"],["23","2013-08-06","r","g","23"],["24","2013-09-17","r","g","24"],["25","2013-10-29","r","g","25"],["26","2013-12-10","r","g","26"],["27","2014-02-04","r","g","27"],["28","2014-03-18","r","g","28"],["29","2014-04-29","r","g","29"],["30","2014-06-10","r","g","30"],["31","2014-07-22","r","g","31"],["32","2014-09-02","r","g","32"],["33","2014-10-14","r","g","33"],["34","2014-12-01","r","g","34"],["35","2015-01-13","r","g","35"],["36","2015-02-27","r","g","36"],["37","2015-03-31","r","g","37"],["38","2015-05-12","r","g","38"],["39","2015-07-02","r","g","39"],["40","2015-08-11","r","g","40"],["41","2015-09-22","r","g","41"],["42","2015-11-03","r","g","42"],["43","2015-12-15","r","g","43"],["44","2016-01-26","r","g","44"],["45","2016-03-08","r","g","45"],["46","2016-04-26","r","g","46"],["47","2016-06-07","r","g","47"],["48","2016-08-02","r","g","48"],["49","2016-09-20","r","g","49"],["50","2016-11-15","r","g","50"],["51","2017-01-24","r","g","51"],["52","2017-03-07","r","g","52"],["53","2017-04-19","r","g","53"],["54","2017-06-13","r","g","54"],["55","2017-08-08","r","g","55"],["56","2017-09-28","r","g","56"],["57","2017-11-28","r","g","57"],["58","2018-01-22","r","g","58"],["59","2018-03-13","r","g","59"],["60","2018-05-09","r","g","60"],["61","2018-06-26","r","g","61"],["62","2018-09-05","r","g","62"],["63","2018-10-23","r","g","63"],["64","2018-12-11","r","g","64"],["65","2019-01-29","r","g","65"],["66","2019-03-19","r","g","66"],["67","2019-05-21","r","g","67"],["68","2019-07-09","r","g","68"],["79","2020-07-28","r","g","79"],["80","2020-08-31","r","g","80"],["81","2020-09-22","r","g","81"],["82","2020-10-20","r","g","82"],["83","2020-11-17","r","g","83"],["84","2020-12-15","r","g","84"],["85","2021-01-26","r","g","85"],["86","2021-02-23","r","g","86"],["87","2021-03-23","r","g","87"],["88","2021-04-19","r","g","88"],["89","2021-06-01","r","g","89"],["90","2021-07-13","r","g","90"],["91","2021-08-10","r","g","91"],["92","2021-09-07","r","g","92"],["93","2021-10-05","r","g","93"],["94","2021-11-02","r","g","94"],["95","2021-12-07","r","g","95"],["96","2022-01-11","r","g","96"],["97","2022-02-08","r","g","97"],["98","2022-03-08","r","g","98"],["99","2022-04-05","r","g","99"],["100","2022-05-03","r","g","100"],["101","2022-05-31","r","g","101"],["102","2022-06-28","r","g","102"],["103","2022-07-26","r","g","103"],["104","2022-08-23","r","g","104"],["105","2022-09-20","r","g","105"],["106","2022-10-18","r","g","106"],["107","2022-11-15","r","g","107"],["108","2022-12-13","r","g","108"],["109","2023-01-17","r","g","109"],["110","2023-02-14","r","g","110"],["111","2023-03-14","r","g","111"],["112","2023-04-11","r","g","112"],["113","2023-05-09","r","g","113"],["114","2023-06-06","r","g","114"],["115","2023-07-04","r","g","115"],["116","2023-08-01","r","g","116"],["117","2023-08-29","r","g","117"],["118","2023-09-26","r","g","118"],["119","2023-10-24","r","g","119"],["120","2023-11-21","r","g","120"],["121","2023-12-19","r","g","121"],["122","2024-01-23","r","g","122"],["123","2024-02-20","r","g","123"],["124","2024-03-19","r","g","124"],["125","2024-04-16","r","g","125"],["126","2024-05-14","r","g","126"],["127","2024-06-11","r","g","127"],["128","2024-07-09","r","g","128"],["129","2024-08-06","r","g","129"],["130","2024-09-03","r","g","130"],["131","2024-10-01","r","g","131"],["132","2024-10-29","r","g","132"],["133","2024-11-26","r","g","133"],["134","2025-01-07","r","g","134"],["135","2025-02-04","r","g","135"],["136","2025-03-04","r","g","136"],["137","2025-04-01","r","g","137"],["138","2025-04-29","r","g","138"],["139","2025-05-27","r","g","139"],["140","2025-06-24","e","g","140"],["141","2025-07-22","r","g","141"],["142","2025-08-19","r","g","142"],["143","2025-09-16","r","g","143"],["144","2025-10-14","r","g","144"],["145","2025-11-11","r","g","145"],["146","2025-12-09","c","g","146"],["147","2026-01-13","b","g","147"],["148","2026-02-24","n","g","148"],["149","2026-03-24","p","g","149"]]},opera:{releases:[["2","1996-07-14","r",null,null],["3","1997-12-01","r",null,null],["4","2000-06-28","r",null,null],["5","2000-12-06","r",null,null],["6","2001-12-18","r",null,null],["7","2003-01-28","r","p","1"],["8","2005-04-19","r","p","1"],["9","2006-06-20","r","p","2"],["10","2009-09-01","r","p","2.2"],["11","2010-12-16","r","p","2.7"],["12","2012-06-14","r","p","2.10"],["15","2013-07-02","r","b","28"],["16","2013-08-27","r","b","29"],["17","2013-10-08","r","b","30"],["18","2013-11-19","r","b","31"],["19","2014-01-28","r","b","32"],["20","2014-03-04","r","b","33"],["21","2014-05-06","r","b","34"],["22","2014-06-03","r","b","35"],["23","2014-07-22","r","b","36"],["24","2014-09-02","r","b","37"],["25","2014-10-15","r","b","38"],["26","2014-12-03","r","b","39"],["27","2015-01-27","r","b","40"],["28","2015-03-10","r","b","41"],["29","2015-04-28","r","b","42"],["30","2015-06-09","r","b","43"],["31","2015-08-04","r","b","44"],["32","2015-09-15","r","b","45"],["33","2015-10-27","r","b","46"],["34","2015-12-08","r","b","47"],["35","2016-02-02","r","b","48"],["36","2016-03-15","r","b","49"],["37","2016-05-04","r","b","50"],["38","2016-06-08","r","b","51"],["39","2016-08-02","r","b","52"],["40","2016-09-20","r","b","53"],["41","2016-10-25","r","b","54"],["42","2016-12-13","r","b","55"],["43","2017-02-07","r","b","56"],["44","2017-03-21","r","b","57"],["45","2017-05-10","r","b","58"],["46","2017-06-22","r","b","59"],["47","2017-08-09","r","b","60"],["48","2017-09-27","r","b","61"],["49","2017-11-08","r","b","62"],["50","2018-01-04","r","b","63"],["51","2018-02-07","r","b","64"],["52","2018-03-22","r","b","65"],["53","2018-05-10","r","b","66"],["54","2018-06-28","r","b","67"],["55","2018-08-16","r","b","68"],["56","2018-09-25","r","b","69"],["57","2018-11-28","r","b","70"],["58","2019-01-23","r","b","71"],["60","2019-04-09","r","b","73"],["62","2019-06-27","r","b","75"],["63","2019-08-20","r","b","76"],["64","2019-10-07","r","b","77"],["65","2019-11-13","r","b","78"],["66","2020-01-07","r","b","79"],["67","2020-03-03","r","b","80"],["68","2020-04-22","r","b","81"],["69","2020-06-24","r","b","83"],["70","2020-07-27","r","b","84"],["71","2020-09-15","r","b","85"],["72","2020-10-21","r","b","86"],["73","2020-12-09","r","b","87"],["74","2021-02-02","r","b","88"],["75","2021-03-24","r","b","89"],["76","2021-04-28","r","b","90"],["77","2021-06-09","r","b","91"],["78","2021-08-03","r","b","92"],["79","2021-09-14","r","b","93"],["80","2021-10-05","r","b","94"],["81","2021-11-04","r","b","95"],["82","2021-12-02","r","b","96"],["83","2022-01-19","r","b","97"],["84","2022-02-16","r","b","98"],["85","2022-03-23","r","b","99"],["86","2022-04-20","r","b","100"],["87","2022-05-17","r","b","101"],["88","2022-06-08","r","b","102"],["89","2022-07-07","r","b","103"],["90","2022-08-18","r","b","104"],["91","2022-09-14","r","b","105"],["92","2022-10-19","r","b","106"],["93","2022-11-17","r","b","107"],["94","2022-12-15","r","b","108"],["95","2023-02-01","r","b","109"],["96","2023-02-22","r","b","110"],["97","2023-03-22","r","b","111"],["98","2023-04-20","r","b","112"],["99","2023-05-16","r","b","113"],["100","2023-06-29","r","b","114"],["101","2023-07-26","r","b","115"],["102","2023-08-23","r","b","116"],["103","2023-10-03","r","b","117"],["104","2023-10-23","r","b","118"],["105","2023-11-14","r","b","119"],["106","2023-12-19","r","b","120"],["107","2024-02-07","r","b","121"],["108","2024-03-05","r","b","122"],["109","2024-03-27","r","b","123"],["110","2024-05-14","r","b","124"],["111","2024-06-12","r","b","125"],["112","2024-07-11","r","b","126"],["113","2024-08-22","r","b","127"],["114","2024-09-25","r","b","128"],["115","2024-11-27","r","b","130"],["116","2025-01-08","r","b","131"],["117","2025-02-13","r","b","132"],["118","2025-04-15","r","b","133"],["119","2025-05-13","r","b","134"],["120","2025-07-02","r","b","135"],["121","2025-08-27","r","b","137"],["122","2025-09-11","r","b","138"],["123","2025-10-28","c","b","139"],["124",null,"b","b","140"],["125",null,"n","b","141"],["10.1","2009-11-23","r","p","2.2"],["10.5","2010-03-02","r","p","2.5"],["10.6","2010-07-01","r","p","2.6"],["11.1","2011-04-12","r","p","2.8"],["11.5","2011-06-28","r","p","2.9"],["11.6","2011-12-06","r","p","2.10"],["12.1","2012-11-20","r","p","2.12"],["3.5","1998-11-18","r",null,null],["3.6","1999-05-06","r",null,null],["5.1","2001-04-10","r",null,null],["7.1","2003-04-11","r","p","1"],["7.2","2003-09-23","r","p","1"],["7.5","2004-05-12","r","p","1"],["8.5","2005-09-20","r","p","1"],["9.1","2006-12-18","r","p","2"],["9.2","2007-04-11","r","p","2"],["9.5","2008-06-12","r","p","2.1"],["9.6","2008-10-08","r","p","2.1"]]},opera_android:{releases:[["11","2011-03-22","r","p","2.7"],["12","2012-02-25","r","p","2.10"],["14","2013-05-21","r","w","537.31"],["15","2013-07-08","r","b","28"],["16","2013-09-18","r","b","29"],["18","2013-11-20","r","b","31"],["19","2014-01-28","r","b","32"],["20","2014-03-06","r","b","33"],["21","2014-04-22","r","b","34"],["22","2014-06-17","r","b","35"],["24","2014-09-10","r","b","37"],["25","2014-10-16","r","b","38"],["26","2014-12-02","r","b","39"],["27","2015-01-29","r","b","40"],["28","2015-03-10","r","b","41"],["29","2015-04-28","r","b","42"],["30","2015-06-10","r","b","43"],["32","2015-09-23","r","b","45"],["33","2015-11-03","r","b","46"],["34","2015-12-16","r","b","47"],["35","2016-02-04","r","b","48"],["36","2016-03-31","r","b","49"],["37","2016-06-16","r","b","50"],["41","2016-10-25","r","b","54"],["42","2017-01-21","r","b","55"],["43","2017-09-27","r","b","59"],["44","2017-12-11","r","b","60"],["45","2018-02-15","r","b","61"],["46","2018-05-14","r","b","63"],["47","2018-07-23","r","b","66"],["48","2018-11-08","r","b","69"],["49","2018-12-07","r","b","70"],["50","2019-02-18","r","b","71"],["51","2019-03-21","r","b","72"],["52","2019-05-17","r","b","73"],["53","2019-07-11","r","b","74"],["54","2019-10-18","r","b","76"],["55","2019-12-03","r","b","77"],["56","2020-02-06","r","b","78"],["57","2020-03-30","r","b","80"],["58","2020-05-13","r","b","81"],["59","2020-06-30","r","b","83"],["60","2020-09-23","r","b","85"],["61","2020-12-07","r","b","86"],["62","2021-02-16","r","b","87"],["63","2021-04-16","r","b","89"],["64","2021-05-25","r","b","91"],["65","2021-10-20","r","b","92"],["66","2021-12-15","r","b","94"],["67","2022-01-31","r","b","96"],["68","2022-03-30","r","b","99"],["69","2022-05-09","r","b","100"],["70","2022-06-29","r","b","102"],["71","2022-09-16","r","b","104"],["72","2022-10-21","r","b","106"],["73","2023-01-17","r","b","108"],["74","2023-03-13","r","b","110"],["75","2023-05-17","r","b","112"],["76","2023-06-26","r","b","114"],["77","2023-08-31","r","b","115"],["78","2023-10-23","r","b","117"],["79","2023-12-06","r","b","119"],["80","2024-01-25","r","b","120"],["81","2024-03-14","r","b","122"],["82","2024-05-02","r","b","124"],["83","2024-06-25","r","b","126"],["84","2024-08-26","r","b","127"],["85","2024-10-29","r","b","128"],["86","2024-12-02","r","b","130"],["87","2025-01-22","r","b","132"],["88","2025-03-19","r","b","134"],["89","2025-04-29","r","b","135"],["90","2025-06-18","r","b","137"],["91","2025-08-19","r","b","139"],["92","2025-10-08","r","b","140"],["93","2025-11-25","c","b","142"],["10.1","2010-11-09","r","p","2.5"],["11.1","2011-06-30","r","p","2.8"],["11.5","2011-10-12","r","p","2.9"],["12.1","2012-10-09","r","p","2.11"]]},safari:{releases:[["1","2003-06-23","r","w","85"],["2","2005-04-29","r","w","412"],["3","2007-10-26","r","w","523.10"],["4","2009-06-08","r","w","530.17"],["5","2010-06-07","r","w","533.16"],["6","2012-07-25","r","w","536.25"],["7","2013-10-22","r","w","537.71"],["8","2014-10-16","r","w","538.35"],["9","2015-09-30","r","w","601.1.56"],["10","2016-09-20","r","w","602.1.50"],["11","2017-09-19","r","w","604.2.4"],["12","2018-09-17","r","w","606.1.36"],["13","2019-09-19","r","w","608.2.11"],["14","2020-09-16","r","w","610.1.28"],["15","2021-09-20","r","w","612.1.27"],["16","2022-09-12","r","w","614.1.25"],["17","2023-09-18","r","w","616.1.27"],["18","2024-09-16","r","w","619.1.26"],["26","2025-09-15","r","w","622.1.22"],["1.1","2003-10-24","r","w","100"],["1.2","2004-02-02","r","w","125"],["1.3","2005-04-15","r","w","312"],["10.1","2017-03-27","r","w","603.2.1"],["11.1","2018-04-12","r","w","605.1.33"],["12.1","2019-03-25","r","w","607.1.40"],["13.1","2020-03-24","r","w","609.1.20"],["14.1","2021-04-26","r","w","611.1.21"],["15.1","2021-10-25","r","w","612.2.9"],["15.2","2021-12-13","r","w","612.3.6"],["15.3","2022-01-26","r","w","612.4.9"],["15.4","2022-03-14","r","w","613.1.17"],["15.5","2022-05-16","r","w","613.2.7"],["15.6","2022-07-20","r","w","613.3.9"],["16.1","2022-10-24","r","w","614.2.9"],["16.2","2022-12-13","r","w","614.3.7"],["16.3","2023-01-23","r","w","614.4.6"],["16.4","2023-03-27","r","w","615.1.26"],["16.5","2023-05-18","r","w","615.2.9"],["16.6","2023-07-24","r","w","615.3.12"],["17.1","2023-10-25","r","w","616.2.9"],["17.2","2023-12-11","r","w","617.1.17"],["17.3","2024-01-22","r","w","617.2.4"],["17.4","2024-03-05","r","w","618.1.15"],["17.5","2024-05-13","r","w","618.2.12"],["17.6","2024-07-29","r","w","618.3.11"],["18.1","2024-10-28","r","w","619.2.8"],["18.2","2024-12-11","r","w","620.1.16"],["18.3","2025-01-27","r","w","620.2.4"],["18.4","2025-03-31","r","w","621.1.15"],["18.5","2025-05-12","r","w","621.2.5"],["18.6","2025-07-29","r","w","621.3.11"],["26.1","2025-11-03","c","w","622.2.11"],["26.2",null,"b","w","623.1.12"],["3.1","2008-03-18","r","w","525.13"],["5.1","2011-07-20","r","w","534.48"],["9.1","2016-03-21","r","w","601.5.17"]]},safari_ios:{releases:[["1","2007-06-29","r","w","522.11"],["2","2008-07-11","r","w","525.18"],["3","2009-06-17","r","w","528.18"],["4","2010-06-21","r","w","532.9"],["5","2011-10-12","r","w","534.46"],["6","2012-09-10","r","w","536.26"],["7","2013-09-18","r","w","537.51"],["8","2014-09-17","r","w","600.1.4"],["9","2015-09-16","r","w","601.1.56"],["10","2016-09-13","r","w","602.1.50"],["11","2017-09-19","r","w","604.2.4"],["12","2018-09-17","r","w","606.1.36"],["13","2019-09-19","r","w","608.2.11"],["14","2020-09-16","r","w","610.1.28"],["15","2021-09-20","r","w","612.1.27"],["16","2022-09-12","r","w","614.1.25"],["17","2023-09-18","r","w","616.1.27"],["18","2024-09-16","r","w","619.1.26"],["26","2025-09-15","r","w","622.1.22"],["10.3","2017-03-27","r","w","603.2.1"],["11.3","2018-03-29","r","w","605.1.33"],["12.2","2019-03-25","r","w","607.1.40"],["13.4","2020-03-24","r","w","609.1.20"],["14.5","2021-04-26","r","w","611.1.21"],["15.1","2021-10-25","r","w","612.2.9"],["15.2","2021-12-13","r","w","612.3.6"],["15.3","2022-01-26","r","w","612.4.9"],["15.4","2022-03-14","r","w","613.1.17"],["15.5","2022-05-16","r","w","613.2.7"],["15.6","2022-07-20","r","w","613.3.9"],["16.1","2022-10-24","r","w","614.2.9"],["16.2","2022-12-13","r","w","614.3.7"],["16.3","2023-01-23","r","w","614.4.6"],["16.4","2023-03-27","r","w","615.1.26"],["16.5","2023-05-18","r","w","615.2.9"],["16.6","2023-07-24","r","w","615.3.12"],["17.1","2023-10-25","r","w","616.2.9"],["17.2","2023-12-11","r","w","617.1.17"],["17.3","2024-01-22","r","w","617.2.4"],["17.4","2024-03-05","r","w","618.1.15"],["17.5","2024-05-13","r","w","618.2.12"],["17.6","2024-07-29","r","w","618.3.11"],["18.1","2024-10-28","r","w","619.2.8"],["18.2","2024-12-11","r","w","620.1.16"],["18.3","2025-01-27","r","w","620.2.4"],["18.4","2025-03-31","r","w","621.1.15"],["18.5","2025-05-12","r","w","621.2.5"],["18.6","2025-07-29","r","w","621.3.11"],["26.1","2025-11-03","c","w","622.2.11"],["26.2",null,"b","w","623.1.12"],["3.2","2010-04-03","r","w","531.21"],["4.2","2010-11-22","r","w","533.17"],["9.3","2016-03-21","r","w","601.5.17"]]},samsunginternet_android:{releases:[["1.0","2013-04-27","r","w","535.19"],["1.5","2013-09-25","r","b","28"],["1.6","2014-04-11","r","b","28"],["10.0","2019-08-22","r","b","71"],["10.2","2019-10-09","r","b","71"],["11.0","2019-12-05","r","b","75"],["11.2","2020-03-22","r","b","75"],["12.0","2020-06-19","r","b","79"],["12.1","2020-07-07","r","b","79"],["13.0","2020-12-02","r","b","83"],["13.2","2021-01-20","r","b","83"],["14.0","2021-04-17","r","b","87"],["14.2","2021-06-25","r","b","87"],["15.0","2021-08-13","r","b","90"],["16.0","2021-11-25","r","b","92"],["16.2","2022-03-06","r","b","92"],["17.0","2022-05-04","r","b","96"],["18.0","2022-08-08","r","b","99"],["18.1","2022-09-09","r","b","99"],["19.0","2022-11-01","r","b","102"],["19.1","2022-11-08","r","b","102"],["2.0","2014-10-17","r","b","34"],["2.1","2015-01-07","r","b","34"],["20.0","2023-02-10","r","b","106"],["21.0","2023-05-19","r","b","110"],["22.0","2023-07-14","r","b","111"],["23.0","2023-10-18","r","b","115"],["24.0","2024-01-25","r","b","117"],["25.0","2024-04-24","r","b","121"],["26.0","2024-06-07","r","b","122"],["27.0","2024-11-06","r","b","125"],["28.0","2025-04-02","r","b","130"],["29.0","2025-10-25","c","b","136"],["3.0","2015-04-10","r","b","38"],["3.2","2015-08-24","r","b","38"],["4.0","2016-03-11","r","b","44"],["4.2","2016-08-02","r","b","44"],["5.0","2016-12-15","r","b","51"],["5.2","2017-04-21","r","b","51"],["5.4","2017-05-17","r","b","51"],["6.0","2017-08-23","r","b","56"],["6.2","2017-10-26","r","b","56"],["6.4","2018-02-19","r","b","56"],["7.0","2018-03-16","r","b","59"],["7.2","2018-06-20","r","b","59"],["7.4","2018-09-12","r","b","59"],["8.0","2018-07-18","r","b","63"],["8.2","2018-12-21","r","b","63"],["9.0","2018-09-15","r","b","67"],["9.2","2019-04-02","r","b","67"],["9.4","2019-07-25","r","b","67"]]},webview_android:{releases:[["1","2008-09-23","r","w","523.12"],["2","2009-10-26","r","w","530.17"],["3","2011-02-22","r","w","534.13"],["4","2011-10-18","r","w","534.30"],["37","2014-09-03","r","b","37"],["38","2014-10-08","r","b","38"],["39","2014-11-12","r","b","39"],["40","2015-01-21","r","b","40"],["41","2015-03-11","r","b","41"],["42","2015-04-15","r","b","42"],["43","2015-05-27","r","b","43"],["44","2015-07-29","r","b","44"],["45","2015-09-01","r","b","45"],["46","2015-10-14","r","b","46"],["47","2015-12-02","r","b","47"],["48","2016-01-26","r","b","48"],["49","2016-03-09","r","b","49"],["50","2016-04-13","r","b","50"],["51","2016-06-08","r","b","51"],["52","2016-07-27","r","b","52"],["53","2016-09-07","r","b","53"],["54","2016-10-19","r","b","54"],["55","2016-12-06","r","b","55"],["56","2017-02-01","r","b","56"],["57","2017-03-16","r","b","57"],["58","2017-04-25","r","b","58"],["59","2017-06-06","r","b","59"],["60","2017-08-01","r","b","60"],["61","2017-09-05","r","b","61"],["62","2017-10-24","r","b","62"],["63","2017-12-05","r","b","63"],["64","2018-01-23","r","b","64"],["65","2018-03-06","r","b","65"],["66","2018-04-17","r","b","66"],["67","2018-05-31","r","b","67"],["68","2018-07-24","r","b","68"],["69","2018-09-04","r","b","69"],["70","2018-10-17","r","b","70"],["71","2018-12-04","r","b","71"],["72","2019-01-29","r","b","72"],["73","2019-03-12","r","b","73"],["74","2019-04-24","r","b","74"],["75","2019-06-04","r","b","75"],["76","2019-07-30","r","b","76"],["77","2019-09-10","r","b","77"],["78","2019-10-22","r","b","78"],["79","2019-12-17","r","b","79"],["80","2020-02-04","r","b","80"],["81","2020-04-07","r","b","81"],["83","2020-05-19","r","b","83"],["84","2020-07-27","r","b","84"],["85","2020-08-25","r","b","85"],["86","2020-10-20","r","b","86"],["87","2020-11-17","r","b","87"],["88","2021-01-19","r","b","88"],["89","2021-03-02","r","b","89"],["90","2021-04-13","r","b","90"],["91","2021-05-25","r","b","91"],["92","2021-07-20","r","b","92"],["93","2021-08-31","r","b","93"],["94","2021-09-21","r","b","94"],["95","2021-10-19","r","b","95"],["96","2021-11-15","r","b","96"],["97","2022-01-04","r","b","97"],["98","2022-02-01","r","b","98"],["99","2022-03-01","r","b","99"],["100","2022-03-29","r","b","100"],["101","2022-04-26","r","b","101"],["102","2022-05-24","r","b","102"],["103","2022-06-21","r","b","103"],["104","2022-08-02","r","b","104"],["105","2022-09-02","r","b","105"],["106","2022-09-27","r","b","106"],["107","2022-10-25","r","b","107"],["108","2022-11-29","r","b","108"],["109","2023-01-10","r","b","109"],["110","2023-02-07","r","b","110"],["111","2023-03-01","r","b","111"],["112","2023-04-04","r","b","112"],["113","2023-05-02","r","b","113"],["114","2023-05-30","r","b","114"],["115","2023-07-21","r","b","115"],["116","2023-08-15","r","b","116"],["117","2023-09-12","r","b","117"],["118","2023-10-10","r","b","118"],["119","2023-10-31","r","b","119"],["120","2023-12-05","r","b","120"],["121","2024-01-23","r","b","121"],["122","2024-02-20","r","b","122"],["123","2024-03-19","r","b","123"],["124","2024-04-16","r","b","124"],["125","2024-05-14","r","b","125"],["126","2024-06-11","r","b","126"],["127","2024-07-23","r","b","127"],["128","2024-08-20","r","b","128"],["129","2024-09-17","r","b","129"],["130","2024-10-15","r","b","130"],["131","2024-11-12","r","b","131"],["132","2025-01-14","r","b","132"],["133","2025-02-04","r","b","133"],["134","2025-03-04","r","b","134"],["135","2025-04-01","r","b","135"],["136","2025-04-29","r","b","136"],["137","2025-05-27","r","b","137"],["138","2025-06-24","r","b","138"],["139","2025-08-05","r","b","139"],["140","2025-09-02","r","b","140"],["141","2025-09-30","r","b","141"],["142","2025-10-28","r","b","142"],["143","2025-12-02","c","b","143"],["144","2026-01-13","b","b","144"],["145","2026-02-10","n","b","145"],["146",null,"p","b","146"],["1.5","2009-04-27","r","w","525.20"],["2.2","2010-05-20","r","w","533.1"],["4.4","2013-12-09","r","b","30"],["4.4.3","2014-06-02","r","b","33"]]}},a={ya_android:{releases:[["1.0","u","u","b","25"],["1.5","u","u","b","22"],["1.6","u","u","b","25"],["1.7","u","u","b","25"],["1.20","u","u","b","25"],["2.5","u","u","b","25"],["3.2","u","u","b","25"],["4.6","u","u","b","25"],["5.3","u","u","b","25"],["5.4","u","u","b","25"],["7.4","u","u","b","25"],["9.6","u","u","b","25"],["10.5","u","u","b","25"],["11.4","u","u","b","25"],["11.5","u","u","b","25"],["12.7","u","u","b","25"],["13.9","u","u","b","28"],["13.10","u","u","b","28"],["13.11","u","u","b","28"],["13.12","u","u","b","30"],["14.2","u","u","b","32"],["14.4","u","u","b","33"],["14.5","u","u","b","34"],["14.7","u","u","b","35"],["14.8","u","u","b","36"],["14.10","u","u","b","37"],["14.12","u","u","b","38"],["15.2","u","u","b","40"],["15.4","u","u","b","41"],["15.6","u","u","b","42"],["15.7","u","u","b","43"],["15.9","u","u","b","44"],["15.10","u","u","b","45"],["15.12","u","u","b","46"],["16.2","u","u","b","47"],["16.3","u","u","b","47"],["16.4","u","u","b","49"],["16.6","u","u","b","50"],["16.7","u","u","b","51"],["16.9","u","u","b","52"],["16.10","u","u","b","53"],["16.11","u","u","b","54"],["17.1","u","u","b","55"],["17.3","u","u","b","56"],["17.4","u","u","b","57"],["17.6","u","u","b","58"],["17.7","u","u","b","59"],["17.9","u","u","b","60"],["17.10","u","u","b","61"],["17.11","u","u","b","62"],["18.1","u","u","b","63"],["18.2","u","u","b","63"],["18.3","u","u","b","64"],["18.4","u","u","b","65"],["18.6","u","u","b","66"],["18.7","u","u","b","67"],["18.9","u","u","b","68"],["18.10","u","u","b","69"],["18.11","u","u","b","70"],["19.1","u","u","b","71"],["19.3","u","u","b","72"],["19.4","u","u","b","73"],["19.5","u","u","b","75"],["19.6","u","u","b","75"],["19.7","u","u","b","75"],["19.9","u","u","b","76"],["19.10","u","u","b","77"],["19.11","u","u","b","78"],["19.12","u","u","b","78"],["20.2","u","u","b","79"],["20.3","u","u","b","80"],["20.4","u","u","b","81"],["20.6","u","u","b","81"],["20.7","u","u","b","83"],["20.8","2020-09-02","u","b","84"],["20.9","2020-09-27","u","b","85"],["20.11","2020-11-11","u","b","86"],["20.12","2020-12-20","u","b","87"],["21.1","2021-12-31","u","b","88"],["21.2","u","u","b","88"],["21.3","2021-04-04","u","b","89"],["21.5","u","u","b","90"],["21.6","2021-09-28","u","b","91"],["21.8","2021-09-28","u","b","92"],["21.9","2021-09-29","u","b","93"],["21.11","2021-10-29","u","b","94"],["22.1","2021-12-31","u","b","96"],["22.3","2022-03-25","u","b","98"],["22.4","u","u","b","92"],["22.5","2022-05-20","u","b","100"],["22.7","2022-07-07","u","b","102"],["22.8","u","u","b","104"],["22.9","2022-08-27","u","b","104"],["22.11","2022-11-11","u","b","106"],["23.1","2023-01-10","u","b","108"],["23.3","2023-03-26","u","b","110"],["23.5","2023-05-19","u","b","112"],["23.7","2023-07-06","u","b","114"],["23.9","2023-09-13","u","b","116"],["23.11","2023-11-15","u","b","118"],["24.1","2024-01-18","u","b","120"],["24.2","2024-03-25","u","b","120"],["24.4","2024-03-27","u","b","122"],["24.6","2024-06-04","u","b","124"],["24.7","2024-07-18","u","b","126"],["24.9","2024-10-01","u","b","126"],["24.10","2024-10-11","u","b","128"],["24.12","2024-11-30","u","b","130"],["25.2","2025-04-24","u","b","132"],["25.3","2025-04-23","u","b","132"],["25.4","2025-04-23","u","b","134"],["25.6","2025-09-04","u","b","136"],["25.8","2025-08-30","u","b","138"],["25.10","2025-10-09","u","b","140"],["25.12","2025-12-07","u","b","142"]]},uc_android:{releases:[["10.5","u","u","b","31"],["10.7","u","u","b","31"],["10.8","u","u","b","31"],["10.10","u","u","b","31"],["11.0","u","u","b","31"],["11.1","u","u","b","40"],["11.2","u","u","b","40"],["11.3","u","u","b","40"],["11.4","u","u","b","40"],["11.5","u","u","b","40"],["11.6","u","u","b","57"],["11.8","u","u","b","57"],["11.9","u","u","b","57"],["12.0","u","u","b","57"],["12.1","u","u","b","57"],["12.2","u","u","b","57"],["12.3","u","u","b","57"],["12.4","u","u","b","57"],["12.5","u","u","b","57"],["12.6","u","u","b","57"],["12.7","u","u","b","57"],["12.8","u","u","b","57"],["12.9","u","u","b","57"],["12.10","u","u","b","57"],["12.11","u","u","b","57"],["12.12","u","u","b","57"],["12.13","u","u","b","57"],["12.14","u","u","b","57"],["13.0","u","u","b","57"],["13.1","u","u","b","57"],["13.2","u","u","b","57"],["13.3","2020-09-09","u","b","78"],["13.4","2021-09-28","u","b","78"],["13.5","2023-08-25","u","b","78"],["13.6","2023-12-17","u","b","78"],["13.7","2023-06-24","u","b","78"],["13.8","2022-04-30","u","b","78"],["13.9","2022-05-18","u","b","78"],["15.0","2022-08-24","u","b","78"],["15.1","2022-11-11","u","b","78"],["15.2","2023-04-23","u","b","78"],["15.3","2023-03-17","u","b","100"],["15.4","2023-10-25","u","b","100"],["15.5","2023-08-22","u","b","100"],["16.0","2023-08-24","u","b","100"],["16.1","2023-10-15","u","b","100"],["16.2","2023-12-09","u","b","100"],["16.3","2024-03-08","u","b","100"],["16.4","2024-10-03","u","b","100"],["16.5","2024-05-30","u","b","100"],["16.6","2024-07-23","u","b","100"],["17.0","2024-08-24","u","b","100"],["17.1","2024-09-26","u","b","100"],["17.2","2024-11-29","u","b","100"],["17.3","2025-01-07","u","b","100"],["17.4","2025-02-26","u","b","100"],["17.5","2025-04-08","u","b","100"],["17.6","2025-05-15","u","b","123"],["17.7","2025-06-11","u","b","123"],["17.8","2025-07-30","u","b","123"],["18.0","2025-08-17","u","b","123"],["18.1","2025-10-04","u","b","123"],["18.2","2025-11-04","u","b","123"],["18.3","2025-12-12","u","b","123"]]},qq_android:{releases:[["6.0","u","u","b","37"],["6.1","u","u","b","37"],["6.2","u","u","b","37"],["6.3","u","u","b","37"],["6.4","u","u","b","37"],["6.6","u","u","b","37"],["6.7","u","u","b","37"],["6.8","u","u","b","37"],["6.9","u","u","b","37"],["7.0","u","u","b","37"],["7.1","u","u","b","37"],["7.2","u","u","b","37"],["7.3","u","u","b","37"],["7.4","u","u","b","37"],["7.5","u","u","b","37"],["7.6","u","u","b","37"],["7.7","u","u","b","37"],["7.8","u","u","b","37"],["7.9","u","u","b","37"],["8.0","u","u","b","37"],["8.1","u","u","b","57"],["8.2","u","u","b","57"],["8.3","u","u","b","57"],["8.4","u","u","b","57"],["8.5","u","u","b","57"],["8.6","u","u","b","57"],["8.7","u","u","b","57"],["8.8","u","u","b","57"],["8.9","u","u","b","57"],["9.1","u","u","b","57"],["9.6","u","u","b","66"],["9.7","u","u","b","66"],["9.8","u","u","b","66"],["10.0","u","u","b","66"],["10.1","u","u","b","66"],["10.2","u","u","b","66"],["10.3","u","u","b","66"],["10.4","u","u","b","66"],["10.5","u","u","b","66"],["10.7","2020-09-09","u","b","66"],["10.9","2020-11-22","u","b","77"],["11.0","u","u","b","77"],["11.2","2021-01-30","u","b","77"],["11.3","2021-03-31","u","b","77"],["11.7","2021-11-02","u","b","89"],["11.9","u","u","b","89"],["12.0","2021-11-04","u","b","89"],["12.1","2021-11-05","u","b","89"],["12.2","2021-12-07","u","b","89"],["12.5","2022-04-07","u","b","89"],["12.7","2022-05-21","u","b","89"],["12.8","2022-06-30","u","b","89"],["12.9","2022-07-26","u","b","89"],["13.0","2022-08-15","u","b","89"],["13.1","2022-09-10","u","b","89"],["13.2","2022-10-26","u","b","89"],["13.3","2022-11-09","u","b","89"],["13.4","2023-04-26","u","b","98"],["13.5","2023-02-06","u","b","98"],["13.6","2023-02-09","u","b","98"],["13.7","2023-04-21","u","b","98"],["13.8","2023-04-21","u","b","98"],["14.0","2023-12-12","u","b","98"],["14.1","2023-07-16","u","b","98"],["14.2","2023-10-14","u","b","109"],["14.3","2023-09-13","u","b","109"],["14.4","2023-10-31","u","b","109"],["14.5","2023-11-12","u","b","109"],["14.6","2023-12-24","u","b","109"],["14.7","2024-01-18","u","b","109"],["14.8","2024-03-04","u","b","109"],["14.9","2024-04-09","u","b","109"],["15.0","2024-04-17","u","b","109"],["15.1","2024-05-18","u","b","109"],["15.2","2024-10-24","u","b","109"],["15.3","2024-07-28","u","b","109"],["15.4","2024-09-07","u","b","109"],["15.5","2024-09-24","u","b","109"],["15.6","2024-10-24","u","b","109"],["15.7","2024-12-03","u","b","109"],["15.8","2024-12-11","u","b","109"],["15.9","2025-02-01","u","b","109"],["19.1","2025-07-08","u","b","121"],["19.2","2025-07-15","u","b","121"],["19.3","2025-08-31","u","b","121"],["19.4","2025-09-20","u","b","121"],["19.5","2025-10-23","u","b","121"],["19.6","2025-11-17","u","b","121"]]},kai_os:{releases:[["1.0","2017-03-01","u","g","37"],["2.0","2017-07-01","u","g","48"],["2.5","2017-07-01","u","g","48"],["3.0","2021-09-01","u","g","84"],["3.1","2022-03-01","u","g","84"],["4.0","2025-05-01","u","g","123"]]},facebook_android:{releases:[["66","u","u","b","48"],["68","u","u","b","48"],["74","u","u","b","50"],["75","u","u","b","50"],["76","u","u","b","50"],["77","u","u","b","50"],["78","u","u","b","50"],["79","u","u","b","50"],["80","u","u","b","51"],["81","u","u","b","51"],["82","u","u","b","51"],["83","u","u","b","51"],["84","u","u","b","51"],["86","u","u","b","51"],["87","u","u","b","52"],["88","u","u","b","52"],["89","u","u","b","52"],["90","u","u","b","52"],["91","u","u","b","52"],["92","u","u","b","52"],["93","u","u","b","52"],["94","u","u","b","52"],["95","u","u","b","53"],["96","u","u","b","53"],["97","u","u","b","53"],["98","u","u","b","53"],["99","u","u","b","53"],["100","u","u","b","54"],["101","u","u","b","54"],["103","u","u","b","54"],["104","u","u","b","54"],["105","u","u","b","54"],["106","u","u","b","55"],["107","u","u","b","55"],["108","u","u","b","55"],["109","u","u","b","55"],["110","u","u","b","55"],["111","u","u","b","55"],["112","u","u","b","56"],["113","u","u","b","56"],["114","u","u","b","56"],["115","u","u","b","56"],["116","u","u","b","56"],["117","u","u","b","57"],["118","u","u","b","57"],["119","u","u","b","57"],["120","u","u","b","57"],["121","u","u","b","57"],["122","u","u","b","58"],["123","u","u","b","58"],["124","u","u","b","58"],["125","u","u","b","58"],["126","u","u","b","58"],["127","u","u","b","58"],["128","u","u","b","58"],["129","u","u","b","58"],["130","u","u","b","59"],["131","u","u","b","59"],["132","u","u","b","59"],["133","u","u","b","59"],["134","u","u","b","59"],["135","u","u","b","59"],["136","u","u","b","59"],["137","u","u","b","59"],["138","u","u","b","60"],["140","u","u","b","60"],["142","u","u","b","61"],["143","u","u","b","61"],["144","u","u","b","61"],["145","u","u","b","61"],["146","u","u","b","61"],["147","u","u","b","61"],["148","u","u","b","61"],["149","u","u","b","62"],["150","u","u","b","62"],["151","u","u","b","62"],["152","u","u","b","62"],["153","u","u","b","63"],["154","u","u","b","63"],["155","u","u","b","63"],["156","u","u","b","63"],["157","u","u","b","64"],["158","u","u","b","64"],["159","u","u","b","64"],["160","u","u","b","64"],["161","u","u","b","64"],["162","u","u","b","64"],["163","u","u","b","65"],["164","u","u","b","65"],["165","u","u","b","65"],["166","u","u","b","65"],["167","u","u","b","65"],["168","u","u","b","65"],["169","u","u","b","66"],["170","u","u","b","66"],["171","u","u","b","66"],["172","u","u","b","66"],["173","u","u","b","66"],["174","u","u","b","66"],["175","u","u","b","67"],["176","u","u","b","67"],["177","u","u","b","67"],["178","u","u","b","67"],["180","u","u","b","67"],["181","u","u","b","67"],["182","u","u","b","67"],["183","u","u","b","68"],["184","u","u","b","68"],["185","u","u","b","68"],["186","u","u","b","68"],["187","u","u","b","68"],["188","u","u","b","68"],["202","u","u","b","71"],["227","u","u","b","75"],["228","u","u","b","75"],["229","u","u","b","75"],["230","u","u","b","75"],["231","u","u","b","75"],["233","u","u","b","76"],["235","u","u","b","76"],["236","u","u","b","76"],["237","u","u","b","76"],["238","u","u","b","76"],["240","u","u","b","77"],["241","u","u","b","77"],["242","u","u","b","77"],["243","u","u","b","77"],["244","u","u","b","78"],["245","u","u","b","78"],["246","u","u","b","78"],["247","u","u","b","78"],["248","u","u","b","78"],["249","u","u","b","78"],["250","u","u","b","78"],["251","u","u","b","79"],["252","u","u","b","79"],["253","u","u","b","79"],["254","u","u","b","79"],["255","u","u","b","79"],["256","u","u","b","80"],["257","u","u","b","80"],["258","u","u","b","80"],["259","u","u","b","80"],["260","u","u","b","80"],["261","u","u","b","80"],["262","u","u","b","80"],["263","u","u","b","80"],["264","u","u","b","80"],["265","u","u","b","80"],["266","u","u","b","81"],["267","u","u","b","81"],["268","u","u","b","81"],["269","u","u","b","81"],["270","u","u","b","81"],["271","u","u","b","81"],["272","u","u","b","83"],["273","u","u","b","83"],["274","u","u","b","83"],["275","u","u","b","83"],["297","2020-12-02","u","b","86"],["348","2021-12-19","u","b","96"],["399","2023-02-04","u","b","109"],["400","2023-02-10","u","b","109"],["420","2023-06-28","u","b","114"],["430","2023-09-03","u","b","116"],["434","2023-10-05","u","b","117"],["436","2023-10-13","u","b","117"],["437","u","u","b","118"],["438","2023-10-28","u","b","118"],["439","2023-11-11","u","b","119"],["440","2023-11-12","u","b","119"],["441","2023-11-20","u","b","119"],["442","2023-11-29","u","b","119"],["443","2023-12-07","u","b","120"],["444","2023-12-13","u","b","120"],["445","2023-12-21","u","b","120"],["446","2024-01-06","u","b","120"],["447","2024-01-12","u","b","120"],["448","2024-01-29","u","b","121"],["449","2024-02-02","u","b","121"],["450","2024-02-05","u","b","121"],["451","2024-02-17","u","b","121"],["452","2024-02-25","u","b","122"],["453","2024-02-28","u","b","122"],["454","2024-03-04","u","b","122"],["465","2024-07-07","u","b","126"],["466","u","u","b","126"],["469","u","u","b","126"],["471","2024-07-10","u","b","126"],["472","2024-07-11","u","b","126"],["474","2024-07-30","u","b","127"],["475","2024-08-01","u","b","127"],["476","2024-08-09","u","b","127"],["477","2024-08-16","u","b","127"],["478","2024-08-21","u","b","128"],["479","2024-08-31","u","b","128"],["480","2024-09-07","u","b","128"],["481","2024-09-14","u","b","128"],["482","2024-09-20","u","b","129"],["483","2024-09-27","u","b","129"],["484","2024-10-04","u","b","129"],["485","2024-10-11","u","b","129"],["486","2024-10-18","u","b","130"],["487","2024-10-26","u","b","130"],["488","2024-11-02","u","b","130"],["489","2024-11-09","u","b","130"],["494","2024-12-26","u","b","131"],["497","2025-01-26","u","b","132"],["503","2025-03-12","u","b","134"],["514","2025-05-28","u","b","136"],["515","2025-05-31","u","b","137"]]},instagram_android:{releases:[["23","u","u","b","62"],["24","u","u","b","62"],["25","u","u","b","62"],["26","u","u","b","63"],["27","u","u","b","63"],["28","u","u","b","63"],["29","u","u","b","63"],["30","u","u","b","63"],["31","u","u","b","64"],["32","u","u","b","64"],["33","u","u","b","64"],["34","u","u","b","64"],["35","u","u","b","65"],["36","u","u","b","65"],["37","u","u","b","65"],["38","u","u","b","65"],["39","u","u","b","65"],["40","u","u","b","65"],["41","u","u","b","65"],["42","u","u","b","66"],["43","u","u","b","66"],["44","u","u","b","66"],["45","u","u","b","66"],["46","u","u","b","66"],["47","u","u","b","66"],["48","u","u","b","67"],["49","u","u","b","67"],["50","u","u","b","67"],["51","u","u","b","67"],["52","u","u","b","67"],["53","u","u","b","67"],["54","u","u","b","67"],["55","u","u","b","67"],["56","u","u","b","68"],["57","u","u","b","68"],["58","u","u","b","68"],["59","u","u","b","68"],["60","u","u","b","68"],["61","u","u","b","68"],["65","u","u","b","69"],["66","u","u","b","69"],["68","u","u","b","69"],["72","u","u","b","70"],["74","u","u","b","71"],["75","u","u","b","71"],["79","u","u","b","71"],["81","u","u","b","72"],["82","u","u","b","72"],["83","u","u","b","72"],["84","u","u","b","73"],["86","u","u","b","73"],["95","u","u","b","74"],["96","u","u","b","80"],["97","u","u","b","80"],["98","u","u","b","80"],["103","u","u","b","80"],["104","u","u","b","80"],["117","u","u","b","80"],["118","u","u","b","80"],["119","u","u","b","80"],["120","u","u","b","80"],["121","u","u","b","80"],["127","u","u","b","80"],["128","u","u","b","80"],["129","u","u","b","80"],["130","u","u","b","80"],["131","u","u","b","80"],["132","u","u","b","80"],["133","u","u","b","80"],["134","u","u","b","80"],["135","u","u","b","80"],["136","u","u","b","80"],["137","u","u","b","81"],["138","u","u","b","81"],["139","u","u","b","81"],["140","u","u","b","81"],["141","u","u","b","81"],["142","u","u","b","81"],["143","u","u","b","83"],["144","u","u","b","83"],["145","u","u","b","83"],["146","u","u","b","83"],["153","u","u","b","84"],["163","u","u","b","92"],["164","u","u","b","92"],["230","u","u","b","92"],["258","2022-11-04","u","b","106"],["259","2022-11-04","u","b","106"],["279","2023-12-31","u","b","109"],["281","u","u","b","109"],["288","u","u","b","114"],["289","2023-12-21","u","b","114"],["290","2023-12-30","u","b","114"],["292","u","u","b","115"],["295","u","u","b","115"],["296","u","u","b","115"],["297","u","u","b","115"],["298","2024-01-11","u","b","115"],["299","u","u","b","115"],["300","u","u","b","116"],["301","2024-01-12","u","b","116"],["302","u","u","b","117"],["303","u","u","b","117"],["304","u","u","b","117"],["305","u","u","b","117"],["306","2024-01-17","u","b","118"],["307","u","u","b","118"],["308","2024-01-19","u","b","118"],["309","u","u","b","119"],["310","u","u","b","119"],["311","u","u","b","120"],["312","u","u","b","120"],["313","u","u","b","120"],["314","u","u","b","120"],["315","2024-01-19","u","b","120"],["316","2024-01-25","u","b","120"],["317","2024-02-03","u","b","121"],["318","2024-02-16","u","b","121"],["320","2024-03-04","u","b","121"],["321","2024-03-07","u","b","122"],["338","2024-07-06","u","b","126"],["346","2024-09-01","u","b","127"],["347","2024-09-11","u","b","127"],["349","2024-09-20","u","b","128"],["355","2024-11-06","u","b","130"],["366","u","u","b","132"],["367","2025-02-15","u","b","132"],["378","2025-05-03","u","b","135"],["381","2025-06-19","u","b","137"],["382","2025-06-19","u","b","137"],["383","2025-06-18","u","b","137"],["384","2025-06-16","u","b","137"],["385","2025-06-27","u","b","137"],["387","2025-07-09","u","b","137"],["390","2025-07-26","u","b","138"],["392","2025-08-12","u","b","138"],["394","2025-08-26","u","b","139"],["395","2025-09-13","u","b","139"],["396","2025-09-20","u","b","139"],["397","2025-09-19","u","b","139"],["399","2025-09-28","u","b","140"],["400","2025-10-06","u","b","141"],["401","2025-10-08","u","b","141"],["404","2025-10-31","u","b","141"],["406","2025-11-16","u","b","141"],["407","2025-11-23","u","b","142"],["408","2025-11-28","u","b","142"]]}},r=[["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"1",fa:"4",s:"4",si:"3.2"}],["2019-03-25",{c:"66",ca:"66",e:"16",f:"57",fa:"57",s:"12.1",si:"12.2"}],["2019-03-25",{c:"66",ca:"66",e:"16",f:"57",fa:"57",s:"12.1",si:"12.2"}],["2024-03-19",{c:"116",ca:"116",e:"116",f:"124",fa:"124",s:"17.4",si:"17.4"}],["2025-06-26",{c:"138",ca:"138",e:"138",f:"118",fa:"118",s:"15.4",si:"15.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"17",ca:"18",e:"12",f:"5",fa:"5",s:"6",si:"6"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2024-04-16",{c:"123",ca:"123",e:"123",f:"125",fa:"125",s:"17.4",si:"17.4"}],["2020-01-15",{c:"37",ca:"37",e:"79",f:"27",fa:"27",s:"9.1",si:"9.3"}],["2024-07-09",{c:"77",ca:"77",e:"79",f:"128",fa:"128",s:"17.4",si:"17.4"}],["2016-06-07",{c:"32",ca:"30",e:"12",f:"47",fa:"47",s:"8",si:"8"}],["2023-07-04",{c:"112",ca:"112",e:"112",f:"115",fa:"115",s:"16",si:"16"}],["2015-09-30",{c:"43",ca:"43",e:"12",f:"16",fa:"16",s:"9",si:"9"}],["2022-03-14",{c:"84",ca:"84",e:"84",f:"80",fa:"80",s:"15.4",si:"15.4"}],["2023-10-24",{c:"103",ca:"103",e:"103",f:"119",fa:"119",s:"16.4",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2022-03-14",{c:"92",ca:"92",e:"92",f:"90",fa:"90",s:"15.4",si:"15.4"}],["2023-07-04",{c:"110",ca:"110",e:"110",f:"115",fa:"115",s:"16",si:"16"}],["2016-09-20",{c:"45",ca:"45",e:"12",f:"34",fa:"34",s:"10",si:"10"}],["2016-09-20",{c:"45",ca:"45",e:"12",f:"37",fa:"37",s:"10",si:"10"}],["2016-09-20",{c:"45",ca:"45",e:"12",f:"37",fa:"37",s:"10",si:"10"}],["2022-08-23",{c:"97",ca:"97",e:"97",f:"104",fa:"104",s:"15.4",si:"15.4"}],["2020-01-15",{c:"69",ca:"69",e:"79",f:"62",fa:"62",s:"12",si:"12"}],["2016-09-20",{c:"45",ca:"45",e:"12",f:"38",fa:"38",s:"10",si:"10"}],["2024-01-25",{c:"121",ca:"121",e:"121",f:"115",fa:"115",s:"16.4",si:"16.4"}],["2024-03-05",{c:"117",ca:"117",e:"117",f:"119",fa:"119",s:"17.4",si:"17.4"}],["2016-09-20",{c:"47",ca:"47",e:"14",f:"43",fa:"43",s:"10",si:"10"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"5"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3",fa:"4",s:"4",si:"3.2"}],["2018-05-09",{c:"66",ca:"66",e:"14",f:"60",fa:"60",s:"10",si:"10"}],["2016-09-20",{c:"45",ca:"45",e:"12",f:"38",fa:"38",s:"10",si:"10"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2021-09-20",{c:"88",ca:"88",e:"88",f:"89",fa:"89",s:"15",si:"15"}],["2017-04-05",{c:"55",ca:"55",e:"15",f:"52",fa:"52",s:"10.1",si:"10.3"}],["2024-06-11",{c:"76",ca:"76",e:"79",f:"127",fa:"127",s:"13.1",si:"13.4"}],["2020-01-15",{c:"63",ca:"63",e:"79",f:"57",fa:"57",s:"12",si:"12"}],["2020-01-15",{c:"63",ca:"63",e:"79",f:"57",fa:"57",s:"12",si:"12"}],["2025-04-01",{c:"133",ca:"133",e:"133",f:"137",fa:"137",s:"18.4",si:"18.4"}],["2025-11-11",{c:"90",ca:"90",e:"90",f:"145",fa:"145",s:"16.4",si:"16.4"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"1",fa:"4",s:"3.1",si:"2"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3.5",fa:"4",s:"3.1",si:"3"}],["2021-04-26",{c:"66",ca:"66",e:"79",f:"76",fa:"79",s:"14.1",si:"14.5"}],["2023-02-09",{c:"110",ca:"110",e:"110",f:"86",fa:"86",s:"15",si:"15"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"4",si:"3.2"}],["2020-01-15",{c:"54",ca:"54",e:"79",f:"63",fa:"63",s:"10.1",si:"10.3"}],["2024-01-26",{c:"85",ca:"85",e:"121",f:"93",fa:"93",s:"16",si:"16"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2022-03-14",{c:"37",ca:"37",e:"79",f:"47",fa:"47",s:"15.4",si:"15.4"}],["2024-09-16",{c:"76",ca:"76",e:"79",f:"103",fa:"103",s:"18",si:"18"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"3.6",fa:"4",s:"1.3",si:"1"}],["2022-03-14",{c:"1",ca:"18",e:"12",f:"25",fa:"25",s:"15.4",si:"15.4"}],["2020-01-15",{c:"35",ca:"59",e:"79",f:"30",fa:"54",s:"8",si:"8"}],["2015-07-29",{c:"21",ca:"25",e:"12",f:"22",fa:"22",s:"5.1",si:"5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"3.6",fa:"4",s:"1.3",si:"1"}],["2015-07-29",{c:"21",ca:"25",e:"12",f:"22",fa:"22",s:"5.1",si:"4"}],["2015-07-29",{c:"25",ca:"25",e:"12",f:"13",fa:"14",s:"7",si:"7"}],["2016-09-20",{c:"30",ca:"30",e:"12",f:"49",fa:"49",s:"8",si:"8"}],["2015-07-29",{c:"21",ca:"25",e:"12",f:"9",fa:"18",s:"5.1",si:"4.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"2"}],["2016-09-20",{c:"30",ca:"30",e:"12",f:"4",fa:"4",s:"10",si:"10"}],["2020-01-15",{c:"16",ca:"18",e:"79",f:"10",fa:"10",s:"6",si:"6"}],["2015-07-29",{c:"≤15",ca:"18",e:"12",f:"10",fa:"10",s:"≤4",si:"≤3.2"}],["2018-04-12",{c:"39",ca:"42",e:"14",f:"31",fa:"31",s:"11.1",si:"11.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1.5",fa:"4",s:"4",si:"3.2"}],["2020-09-16",{c:"67",ca:"67",e:"79",f:"68",fa:"68",s:"14",si:"14"}],["2021-09-20",{c:"67",ca:"67",e:"79",f:"68",fa:"68",s:"15",si:"15"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2017-02-01",{c:"56",ca:"56",e:"12",f:"50",fa:"50",s:"9.1",si:"9.3"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"14",s:"1",si:"3"}],["2015-07-29",{c:"10",ca:"18",e:"12",f:"4",fa:"4",s:"5.1",si:"5"}],["2015-07-29",{c:"10",ca:"18",e:"12",f:"29",fa:"29",s:"5.1",si:"6"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2022-03-14",{c:"54",ca:"54",e:"79",f:"38",fa:"38",s:"15.4",si:"15.4"}],["2017-09-19",{c:"50",ca:"51",e:"15",f:"44",fa:"44",s:"11",si:"11"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"26",ca:"28",e:"12",f:"16",fa:"16",s:"7",si:"7"}],["2023-06-06",{c:"110",ca:"110",e:"110",f:"114",fa:"114",s:"16",si:"16"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1.5",fa:"4",s:"2",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1.5",fa:"4",s:"2",si:"1"}],["2024-09-16",{c:"99",ca:"99",e:"99",f:"28",fa:"28",s:"18",si:"18"}],["2023-04-11",{c:"99",ca:"99",e:"99",f:"112",fa:"112",s:"16.4",si:"16.4"}],["2023-12-11",{c:"99",ca:"99",e:"99",f:"113",fa:"113",s:"17.2",si:"17.2"}],["2023-04-11",{c:"99",ca:"99",e:"99",f:"112",fa:"112",s:"16.4",si:"16.4"}],["2023-12-11",{c:"118",ca:"118",e:"118",f:"97",fa:"97",s:"17.2",si:"17.2"}],["2020-01-15",{c:"51",ca:"51",e:"79",f:"43",fa:"43",s:"11",si:"11"}],["2020-01-15",{c:"57",ca:"57",e:"79",f:"53",fa:"53",s:"11.1",si:"11.3"}],["2022-03-14",{c:"99",ca:"99",e:"99",f:"97",fa:"97",s:"15.4",si:"15.4"}],["2020-01-15",{c:"49",ca:"49",e:"79",f:"47",fa:"47",s:"9",si:"9"}],["2015-07-29",{c:"27",ca:"27",e:"12",f:"1",fa:"4",s:"7",si:"7"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"2"}],["2015-09-22",{c:"4",ca:"18",e:"12",f:"41",fa:"41",s:"5",si:"4.2"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"1.5",fa:"4",s:"4",si:"4"}],["2024-03-05",{c:"105",ca:"105",e:"105",f:"106",fa:"106",s:"17.4",si:"17.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2016-03-08",{c:"42",ca:"42",e:"13",f:"45",fa:"45",s:"9",si:"9"}],["2023-09-18",{c:"117",ca:"117",e:"117",f:"63",fa:"63",s:"17",si:"17"}],["2021-01-21",{c:"88",ca:"88",e:"88",f:"71",fa:"79",s:"13.1",si:"13"}],["2020-01-15",{c:"55",ca:"55",e:"79",f:"49",fa:"49",s:"12.1",si:"12.2"}],["2023-11-02",{c:"119",ca:"119",e:"119",f:"54",fa:"54",s:"13.1",si:"13.4"}],["2017-03-27",{c:"41",ca:"41",e:"12",f:"22",fa:"22",s:"10.1",si:"10.3"}],["2025-03-31",{c:"121",ca:"121",e:"121",f:"127",fa:"127",s:"18.4",si:"18.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-05-09",{c:"111",ca:"111",e:"111",f:"113",fa:"113",s:"15",si:"15"}],["2023-02-14",{c:"58",ca:"58",e:"79",f:"110",fa:"110",s:"10",si:"10"}],["2023-05-09",{c:"111",ca:"111",e:"111",f:"113",fa:"113",s:"16.2",si:"16.2"}],["2022-02-03",{c:"98",ca:"98",e:"98",f:"96",fa:"96",s:"13",si:"13"}],["2020-01-15",{c:"53",ca:"53",e:"79",f:"31",fa:"31",s:"11.1",si:"11.3"}],["2017-03-07",{c:"50",ca:"50",e:"12",f:"52",fa:"52",s:"9",si:"9"}],["2020-07-28",{c:"50",ca:"50",e:"12",f:"71",fa:"79",s:"9",si:"9"}],["2025-08-19",{c:"137",ca:"137",e:"137",f:"142",fa:"142",s:"17",si:"17"}],["2017-04-19",{c:"26",ca:"26",e:"12",f:"53",fa:"53",s:"7",si:"7"}],["2023-05-09",{c:"80",ca:"80",e:"80",f:"113",fa:"113",s:"16.4",si:"16.4"}],["2020-11-17",{c:"69",ca:"69",e:"79",f:"83",fa:"83",s:"12.1",si:"12.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"4",fa:"4",s:"3",si:"1"}],["2018-12-11",{c:"40",ca:"40",e:"18",f:"51",fa:"64",s:"10.1",si:"10.3"}],["2023-03-27",{c:"73",ca:"73",e:"79",f:"101",fa:"101",s:"16.4",si:"16.4"}],["2022-03-14",{c:"52",ca:"52",e:"79",f:"69",fa:"79",s:"15.4",si:"15.4"}],["2022-09-12",{c:"105",ca:"105",e:"105",f:"101",fa:"101",s:"16",si:"16"}],["2023-09-18",{c:"83",ca:"83",e:"83",f:"107",fa:"107",s:"17",si:"17"}],["2022-03-14",{c:"52",ca:"52",e:"79",f:"69",fa:"79",s:"15.4",si:"15.4"}],["2022-03-14",{c:"52",ca:"52",e:"79",f:"69",fa:"79",s:"15.4",si:"15.4"}],["2022-03-14",{c:"52",ca:"52",e:"79",f:"69",fa:"79",s:"15.4",si:"15.4"}],["2022-07-26",{c:"52",ca:"52",e:"79",f:"103",fa:"103",s:"15.4",si:"15.4"}],["2023-02-14",{c:"105",ca:"105",e:"105",f:"110",fa:"110",s:"16",si:"16"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2025-09-15",{c:"108",ca:"108",e:"108",f:"130",fa:"130",s:"26",si:"26"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"4",fa:"4",s:"≤4",si:"≤3.2"}],["2025-03-04",{c:"51",ca:"51",e:"12",f:"136",fa:"136",s:"5.1",si:"5"}],["2024-09-16",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"18",si:"18"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"3.5",fa:"4",s:"4",si:"3.2"}],["2023-12-11",{c:"85",ca:"85",e:"85",f:"68",fa:"68",s:"17.2",si:"17.2"}],["2023-09-18",{c:"91",ca:"91",e:"91",f:"33",fa:"33",s:"17",si:"17"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"1",fa:"25",s:"3",si:"1"}],["2023-12-11",{c:"59",ca:"59",e:"79",f:"98",fa:"98",s:"17.2",si:"17.2"}],["2020-01-15",{c:"60",ca:"60",e:"79",f:"60",fa:"60",s:"13",si:"13"}],["2016-08-02",{c:"25",ca:"25",e:"14",f:"23",fa:"23",s:"7",si:"7"}],["2020-01-15",{c:"46",ca:"46",e:"79",f:"31",fa:"31",s:"10.1",si:"10.3"}],["2015-09-30",{c:"28",ca:"28",e:"12",f:"22",fa:"22",s:"9",si:"9"}],["2020-01-15",{c:"61",ca:"61",e:"79",f:"55",fa:"55",s:"11",si:"11"}],["2015-07-29",{c:"16",ca:"18",e:"12",f:"4",fa:"4",s:"6",si:"6"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1.5",fa:"4",s:"4",si:"3.2"}],["2017-04-05",{c:"49",ca:"49",e:"15",f:"31",fa:"31",s:"9.1",si:"9.3"}],["2017-10-24",{c:"62",ca:"62",e:"14",f:"22",fa:"22",s:"10",si:"10"}],["2015-07-29",{c:"≤4",ca:"18",e:"12",f:"≤2",fa:"4",s:"≤3.1",si:"≤2"}],["2015-07-29",{c:"7",ca:"18",e:"12",f:"6",fa:"6",s:"5.1",si:"5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2024-02-20",{c:"111",ca:"111",e:"111",f:"123",fa:"123",s:"16.4",si:"16.4"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"4",fa:"4",s:"4",si:"5"}],["2020-01-15",{c:"10",ca:"18",e:"79",f:"4",fa:"4",s:"5",si:"5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2020-01-15",{c:"60",ca:"60",e:"79",f:"55",fa:"55",s:"11.1",si:"11.3"}],["2020-01-15",{c:"12",ca:"18",e:"79",f:"49",fa:"49",s:"6",si:"6"}],["2025-09-16",{c:"131",ca:"131",e:"131",f:"143",fa:"143",s:"18.4",si:"18.4"}],["2024-09-03",{c:"120",ca:"120",e:"120",f:"130",fa:"130",s:"17.2",si:"17.2"}],["2023-09-18",{c:"31",ca:"31",e:"12",f:"6",fa:"6",s:"17",si:"4.2"}],["2015-07-29",{c:"15",ca:"18",e:"12",f:"1",fa:"4",s:"6",si:"6"}],["2022-03-14",{c:"37",ca:"37",e:"79",f:"98",fa:"98",s:"15.4",si:"15.4"}],["2023-12-07",{c:"120",ca:"120",e:"120",f:"49",fa:"49",s:"16.4",si:"16.4"}],["2023-08-01",{c:"17",ca:"18",e:"79",f:"116",fa:"116",s:"6",si:"6"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-01-15",{c:"58",ca:"58",e:"79",f:"53",fa:"53",s:"13",si:"13"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["≤2017-04-05",{c:"1",ca:"18",e:"≤15",f:"3",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-01-15",{c:"61",ca:"61",e:"79",f:"33",fa:"33",s:"11",si:"11"}],["2020-01-15",{c:"1",ca:"18",e:"79",f:"1",fa:"4",s:"4",si:"3.2"}],["2016-03-21",{c:"31",ca:"31",e:"12",f:"12",fa:"14",s:"9.1",si:"9.3"}],["2019-09-19",{c:"14",ca:"18",e:"18",f:"20",fa:"20",s:"10.1",si:"13"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3.5",fa:"4",s:"4",si:"3.2"}],["2022-05-03",{c:"98",ca:"98",e:"98",f:"100",fa:"100",s:"13.1",si:"13.4"}],["2020-01-15",{c:"43",ca:"43",e:"79",f:"46",fa:"46",s:"11.1",si:"11.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-01-15",{c:"1",ca:"18",e:"79",f:"1.5",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3.1",si:"2"}],["2019-03-25",{c:"42",ca:"42",e:"13",f:"38",fa:"38",s:"12.1",si:"12.2"}],["2021-11-02",{c:"77",ca:"77",e:"79",f:"94",fa:"94",s:"13.1",si:"13.4"}],["2021-09-20",{c:"93",ca:"93",e:"93",f:"91",fa:"91",s:"15",si:"15"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-12-07",{c:"120",ca:"120",e:"120",f:"118",fa:"118",s:"15.4",si:"15.4"}],["2017-03-27",{c:"52",ca:"52",e:"14",f:"52",fa:"52",s:"10.1",si:"10.3"}],["2018-04-30",{c:"38",ca:"38",e:"17",f:"47",fa:"35",s:"9",si:"9"}],["2021-09-20",{c:"56",ca:"56",e:"79",f:"51",fa:"51",s:"15",si:"15"}],["2020-09-16",{c:"63",ca:"63",e:"17",f:"47",fa:"36",s:"14",si:"14"}],["2020-02-07",{c:"40",ca:"40",e:"80",f:"58",fa:"28",s:"9",si:"9"}],["2016-06-07",{c:"34",ca:"34",e:"12",f:"47",fa:"47",s:"9.1",si:"9.3"}],["2017-03-27",{c:"42",ca:"42",e:"14",f:"39",fa:"39",s:"10.1",si:"10.3"}],["2024-10-29",{c:"103",ca:"103",e:"103",f:"132",fa:"132",s:"17.2",si:"17.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"8",ca:"18",e:"12",f:"4",fa:"4",s:"5.1",si:"5"}],["2020-01-15",{c:"38",ca:"38",e:"79",f:"28",fa:"28",s:"10.1",si:"10.3"}],["2021-04-26",{c:"89",ca:"89",e:"89",f:"82",fa:"82",s:"14.1",si:"14.5"}],["2016-09-07",{c:"53",ca:"53",e:"12",f:"35",fa:"35",s:"9.1",si:"9.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2021-11-02",{c:"46",ca:"46",e:"79",f:"94",fa:"94",s:"11",si:"11"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-09-30",{c:"29",ca:"29",e:"12",f:"20",fa:"20",s:"9",si:"9"}],["2021-04-26",{c:"84",ca:"84",e:"84",f:"63",fa:"63",s:"14.1",si:"14.5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2025-04-04",{c:"135",ca:"135",e:"135",f:"129",fa:"129",s:"18.2",si:"18.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"24",fa:"24",s:"3.1",si:"2"}],["2022-03-14",{c:"86",ca:"86",e:"86",f:"85",fa:"85",s:"15.4",si:"15.4"}],["2020-01-15",{c:"60",ca:"60",e:"79",f:"52",fa:"52",s:"10.1",si:"10.3"}],["2020-01-15",{c:"60",ca:"60",e:"79",f:"58",fa:"58",s:"11.1",si:"11.3"}],["2016-09-20",{c:"36",ca:"36",e:"14",f:"39",fa:"39",s:"10",si:"10"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2021-09-07",{c:"56",ca:"56",e:"79",f:"92",fa:"92",s:"11",si:"11"}],["2017-04-05",{c:"48",ca:"48",e:"15",f:"34",fa:"34",s:"9.1",si:"9.3"}],["2020-01-15",{c:"33",ca:"33",e:"79",f:"32",fa:"32",s:"9",si:"9"}],["2020-01-15",{c:"35",ca:"35",e:"79",f:"41",fa:"41",s:"10",si:"10"}],["2020-03-24",{c:"79",ca:"79",e:"17",f:"62",fa:"62",s:"13.1",si:"13.4"}],["2022-11-15",{c:"101",ca:"101",e:"101",f:"107",fa:"107",s:"15.4",si:"15.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2024-07-25",{c:"127",ca:"127",e:"127",f:"118",fa:"118",s:"17",si:"17"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2022-01-06",{c:"97",ca:"97",e:"97",f:"34",fa:"34",s:"9",si:"9"}],["2023-03-27",{c:"97",ca:"97",e:"97",f:"111",fa:"111",s:"16.4",si:"16.4"}],["2023-03-27",{c:"97",ca:"97",e:"97",f:"111",fa:"111",s:"16.4",si:"16.4"}],["2023-03-27",{c:"97",ca:"97",e:"97",f:"111",fa:"111",s:"16.4",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-03-13",{c:"111",ca:"111",e:"111",f:"34",fa:"34",s:"9.1",si:"9.3"}],["2020-01-15",{c:"52",ca:"52",e:"79",f:"34",fa:"34",s:"9.1",si:"9.3"}],["2020-01-15",{c:"63",ca:"63",e:"79",f:"34",fa:"34",s:"9.1",si:"9.3"}],["2020-01-15",{c:"34",ca:"34",e:"79",f:"34",fa:"34",s:"9.1",si:"9.3"}],["2020-01-15",{c:"52",ca:"52",e:"79",f:"34",fa:"34",s:"9.1",si:"9.3"}],["2018-09-05",{c:"62",ca:"62",e:"17",f:"62",fa:"62",s:"11",si:"11"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2022-09-12",{c:"89",ca:"89",e:"79",f:"89",fa:"89",s:"16",si:"16"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"2"}],["2023-03-27",{c:"77",ca:"77",e:"79",f:"98",fa:"98",s:"16.4",si:"16.4"}],["2015-07-29",{c:"10",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2017-03-27",{c:"35",ca:"35",e:"12",f:"29",fa:"32",s:"10.1",si:"10.3"}],["2016-09-20",{c:"39",ca:"39",e:"13",f:"26",fa:"26",s:"10",si:"10"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"3.5",fa:"4",s:"5",si:"≤3"}],["2015-07-29",{c:"11",ca:"18",e:"12",f:"3.5",fa:"4",s:"5.1",si:"5"}],["2024-09-16",{c:"125",ca:"125",e:"125",f:"128",fa:"128",s:"18",si:"18"}],["2020-01-15",{c:"71",ca:"71",e:"79",f:"65",fa:"65",s:"12.1",si:"12.2"}],["2024-06-11",{c:"111",ca:"111",e:"111",f:"127",fa:"127",s:"16.2",si:"16.2"}],["2015-07-29",{c:"26",ca:"26",e:"12",f:"3.6",fa:"4",s:"7",si:"7"}],["2017-10-17",{c:"57",ca:"57",e:"16",f:"52",fa:"52",s:"10.1",si:"10.3"}],["2022-10-27",{c:"107",ca:"107",e:"107",f:"66",fa:"66",s:"16",si:"16"}],["2022-03-14",{c:"37",ca:"37",e:"15",f:"48",fa:"48",s:"15.4",si:"15.4"}],["2023-12-19",{c:"105",ca:"105",e:"105",f:"121",fa:"121",s:"15.4",si:"15.4"}],["2020-03-24",{c:"74",ca:"74",e:"79",f:"67",fa:"67",s:"13.1",si:"13.4"}],["2015-07-29",{c:"16",ca:"18",e:"12",f:"11",fa:"14",s:"6",si:"6"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4"}],["2020-01-15",{c:"54",ca:"54",e:"79",f:"63",fa:"63",s:"10",si:"10"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2020-01-15",{c:"65",ca:"65",e:"79",f:"52",fa:"52",s:"12.1",si:"12.2"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"4",fa:"4",s:"7",si:"7"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-09-30",{c:"41",ca:"41",e:"12",f:"36",fa:"36",s:"9",si:"9"}],["2024-09-16",{c:"87",ca:"87",e:"87",f:"88",fa:"88",s:"18",si:"18"}],["2022-04-28",{c:"101",ca:"101",e:"101",f:"96",fa:"96",s:"15",si:"15"}],["2023-09-18",{c:"106",ca:"106",e:"106",f:"98",fa:"98",s:"17",si:"17"}],["2023-09-18",{c:"88",ca:"55",e:"88",f:"43",fa:"43",s:"17",si:"17"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2022-10-03",{c:"106",ca:"106",e:"106",f:"97",fa:"97",s:"15.4",si:"15.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"17",fa:"17",s:"5",si:"4"}],["2020-01-15",{c:"20",ca:"25",e:"79",f:"25",fa:"25",s:"6",si:"6"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-04-13",{c:"81",ca:"81",e:"81",f:"26",fa:"26",s:"13.1",si:"13.4"}],["2021-10-05",{c:"41",ca:"41",e:"79",f:"93",fa:"93",s:"10",si:"10"}],["2023-09-18",{c:"113",ca:"113",e:"113",f:"89",fa:"89",s:"17",si:"17"}],["2020-01-15",{c:"66",ca:"66",e:"79",f:"50",fa:"50",s:"11.1",si:"11.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-03-27",{c:"89",ca:"89",e:"89",f:"108",fa:"108",s:"16.4",si:"16.4"}],["2020-01-15",{c:"39",ca:"39",e:"79",f:"51",fa:"51",s:"10",si:"10"}],["2021-09-20",{c:"58",ca:"58",e:"79",f:"51",fa:"51",s:"15",si:"15"}],["2022-08-05",{c:"104",ca:"104",e:"104",f:"72",fa:"79",s:"14.1",si:"14.5"}],["2023-04-11",{c:"102",ca:"102",e:"102",f:"112",fa:"112",s:"15.5",si:"15.5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-11-12",{c:"1",ca:"18",e:"13",f:"19",fa:"19",s:"1.2",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"3.6",fa:"4",s:"3",si:"1"}],["2021-04-26",{c:"20",ca:"25",e:"12",f:"57",fa:"57",s:"14.1",si:"5"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"3"}],["2020-01-15",{c:"1",ca:"18",e:"79",f:"6",fa:"6",s:"3.1",si:"2"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"3",fa:"4",s:"4",si:"3"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"3.6",fa:"4",s:"4",si:"3.2"}],["2025-08-19",{c:"13",ca:"132",e:"13",f:"50",fa:"142",s:"11.1",si:"18.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"7",ca:"18",e:"12",f:"29",fa:"29",s:"5.1",si:"5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2017-03-16",{c:"4",ca:"57",e:"12",f:"23",fa:"52",s:"3.1",si:"5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3.1",si:"2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2021-12-07",{c:"66",ca:"66",e:"79",f:"95",fa:"79",s:"12.1",si:"12.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2018-12-11",{c:"41",ca:"41",e:"12",f:"64",fa:"64",s:"9",si:"9"}],["2019-03-25",{c:"58",ca:"58",e:"16",f:"55",fa:"55",s:"12.1",si:"12.2"}],["2017-09-28",{c:"24",ca:"25",e:"12",f:"29",fa:"56",s:"10",si:"10"}],["2021-04-26",{c:"81",ca:"81",e:"81",f:"86",fa:"86",s:"14.1",si:"14.5"}],["2025-03-04",{c:"129",ca:"129",e:"129",f:"136",fa:"136",s:"16.4",si:"16.4"}],["2021-04-26",{c:"72",ca:"72",e:"79",f:"78",fa:"79",s:"14.1",si:"14.5"}],["2020-09-16",{c:"74",ca:"74",e:"79",f:"75",fa:"79",s:"14",si:"14"}],["2019-09-19",{c:"63",ca:"63",e:"18",f:"58",fa:"58",s:"13",si:"13"}],["2020-09-16",{c:"71",ca:"71",e:"79",f:"76",fa:"79",s:"14",si:"14"}],["2024-04-16",{c:"87",ca:"87",e:"87",f:"125",fa:"125",s:"14.1",si:"14.5"}],["2021-01-21",{c:"88",ca:"88",e:"88",f:"82",fa:"82",s:"14",si:"14"}],["2018-04-12",{c:"55",ca:"55",e:"15",f:"52",fa:"52",s:"11.1",si:"11.3"}],["2020-01-15",{c:"41",ca:"41",e:"79",f:"36",fa:"36",s:"8",si:"8"}],["2025-03-31",{c:"122",ca:"122",e:"122",f:"131",fa:"131",s:"18.4",si:"18.4"}],["2015-07-29",{c:"38",ca:"38",e:"12",f:"13",fa:"14",s:"7",si:"7"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"1",fa:"4",s:"5",si:"4.2"}],["2018-05-09",{c:"61",ca:"61",e:"16",f:"60",fa:"60",s:"11",si:"11"}],["2023-06-06",{c:"80",ca:"80",e:"80",f:"114",fa:"114",s:"15",si:"15"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3.5",fa:"4",s:"4",si:"4"}],["2025-04-29",{c:"123",ca:"123",e:"123",f:"138",fa:"138",s:"17.2",si:"17.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"6",fa:"6",s:"1.2",si:"1"}],["2023-05-09",{c:"111",ca:"111",e:"111",f:"113",fa:"113",s:"15",si:"15"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3.1",si:"2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-01-15",{c:"48",ca:"48",e:"79",f:"50",fa:"50",s:"11",si:"11"}],["2016-09-20",{c:"49",ca:"49",e:"14",f:"44",fa:"44",s:"10",si:"10"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-11-21",{c:"109",ca:"109",e:"109",f:"120",fa:"120",s:"16.4",si:"16.4"}],["2024-05-13",{c:"123",ca:"123",e:"123",f:"120",fa:"120",s:"17.5",si:"17.5"}],["2020-07-28",{c:"83",ca:"83",e:"83",f:"69",fa:"79",s:"13",si:"13"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-12-11",{c:"113",ca:"113",e:"113",f:"112",fa:"112",s:"17.2",si:"17.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2025-09-15",{c:"46",ca:"46",e:"79",f:"127",fa:"127",s:"5",si:"26"}],["2020-01-15",{c:"46",ca:"46",e:"79",f:"39",fa:"39",s:"11.1",si:"11.3"}],["2021-01-26",{c:"50",ca:"50",e:"79",f:"85",fa:"85",s:"11.1",si:"11.3"}],["2020-01-15",{c:"65",ca:"65",e:"79",f:"50",fa:"50",s:"9",si:"9"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-12-19",{c:"77",ca:"77",e:"79",f:"121",fa:"121",s:"16.4",si:"16.4"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"3.5",fa:"6",s:"4",si:"3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-09-16",{c:"85",ca:"85",e:"85",f:"79",fa:"79",s:"14",si:"14"}],["2021-09-20",{c:"89",ca:"89",e:"89",f:"66",fa:"66",s:"15",si:"15"}],["2015-07-29",{c:"26",ca:"26",e:"12",f:"21",fa:"21",s:"7",si:"7"}],["2015-07-29",{c:"38",ca:"38",e:"12",f:"13",fa:"14",s:"8",si:"8"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"7",ca:"18",e:"12",f:"4",fa:"4",s:"5.1",si:"5"}],["2020-01-15",{c:"24",ca:"25",e:"79",f:"35",fa:"35",s:"7",si:"7"}],["2023-12-07",{c:"120",ca:"120",e:"120",f:"53",fa:"53",s:"15.4",si:"15.4"}],["2015-07-29",{c:"9",ca:"18",e:"12",f:"6",fa:"6",s:"5.1",si:"5"}],["2023-01-12",{c:"109",ca:"109",e:"109",f:"4",fa:"4",s:"5.1",si:"5"}],["2022-04-28",{c:"101",ca:"101",e:"101",f:"63",fa:"63",s:"15.4",si:"15.4"}],["2017-09-19",{c:"53",ca:"53",e:"12",f:"36",fa:"36",s:"11",si:"11"}],["2020-02-04",{c:"80",ca:"80",e:"12",f:"42",fa:"42",s:"8",si:"12.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2023-03-27",{c:"104",ca:"104",e:"104",f:"102",fa:"102",s:"16.4",si:"16.4"}],["2021-04-26",{c:"49",ca:"49",e:"79",f:"25",fa:"25",s:"14.1",si:"14"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2023-03-27",{c:"60",ca:"60",e:"18",f:"57",fa:"57",s:"16.4",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2018-10-02",{c:"6",ca:"18",e:"18",f:"56",fa:"56",s:"6",si:"10.3"}],["2020-07-28",{c:"79",ca:"79",e:"79",f:"75",fa:"79",s:"13.1",si:"13.4"}],["2020-01-15",{c:"46",ca:"46",e:"79",f:"66",fa:"66",s:"11",si:"11"}],["2015-07-29",{c:"18",ca:"18",e:"12",f:"1",fa:"4",s:"1.3",si:"1"}],["2020-01-15",{c:"41",ca:"41",e:"79",f:"32",fa:"32",s:"8",si:"8"}],["2020-01-15",{c:"≤79",ca:"≤79",e:"79",f:"≤23",fa:"≤23",s:"≤9.1",si:"≤9.3"}],["2022-09-02",{c:"105",ca:"105",e:"105",f:"103",fa:"103",s:"15.6",si:"15.6"}],["2023-09-18",{c:"66",ca:"66",e:"79",f:"115",fa:"115",s:"17",si:"17"}],["2022-09-12",{c:"55",ca:"55",e:"79",f:"72",fa:"79",s:"16",si:"16"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2017-03-07",{c:"50",ca:"50",e:"12",f:"52",fa:"52",s:"9",si:"9"}],["2015-07-29",{c:"26",ca:"26",e:"12",f:"14",fa:"14",s:"7",si:"7"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2021-10-25",{c:"57",ca:"57",e:"12",f:"58",fa:"58",s:"15",si:"15.1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-12-11",{c:"120",ca:"120",e:"120",f:"117",fa:"117",s:"17.2",si:"17.2"}],["2021-01-21",{c:"88",ca:"88",e:"88",f:"84",fa:"84",s:"9",si:"9"}],["2023-03-27",{c:"20",ca:"42",e:"14",f:"22",fa:"22",s:"7",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"3.5",fa:"4",s:"3.1",si:"2"}],["2023-05-09",{c:"111",ca:"111",e:"111",f:"113",fa:"113",s:"9",si:"9"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"3.5",fa:"4",s:"3.1",si:"2"}],["2020-09-16",{c:"85",ca:"85",e:"85",f:"79",fa:"79",s:"14",si:"14"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-07-28",{c:"75",ca:"75",e:"79",f:"70",fa:"79",s:"13",si:"13"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"2"}],["2020-01-15",{c:"32",ca:"32",e:"79",f:"36",fa:"36",s:"10",si:"10"}],["2022-03-14",{c:"93",ca:"93",e:"93",f:"92",fa:"92",s:"15.4",si:"15.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-01-15",{c:"32",ca:"32",e:"79",f:"36",fa:"36",s:"10",si:"10"}],["2015-07-29",{c:"24",ca:"25",e:"12",f:"24",fa:"24",s:"8",si:"8"}],["2021-04-26",{c:"80",ca:"80",e:"80",f:"71",fa:"79",s:"14.1",si:"14.5"}],["2015-07-29",{c:"10",ca:"18",e:"12",f:"10",fa:"10",s:"8",si:"8"}],["2015-07-29",{c:"10",ca:"18",e:"12",f:"6",fa:"6",s:"8",si:"8"}],["2015-07-29",{c:"29",ca:"29",e:"12",f:"24",fa:"24",s:"8",si:"8"}],["2016-08-02",{c:"27",ca:"27",e:"14",f:"29",fa:"29",s:"8",si:"8"}],["2018-04-30",{c:"24",ca:"25",e:"17",f:"25",fa:"25",s:"8",si:"9"}],["2021-04-26",{c:"35",ca:"35",e:"12",f:"25",fa:"25",s:"14.1",si:"14.5"}],["2023-03-27",{c:"69",ca:"69",e:"79",f:"105",fa:"105",s:"16.4",si:"16.4"}],["2023-05-09",{c:"111",ca:"111",e:"111",f:"113",fa:"113",s:"15.4",si:"15.4"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"1.5",fa:"4",s:"4",si:"3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"2",si:"1"}],["≤2020-03-24",{c:"≤80",ca:"≤80",e:"≤80",f:"1.5",fa:"4",s:"≤13.1",si:"≤13.4"}],["2020-01-15",{c:"66",ca:"66",e:"79",f:"58",fa:"58",s:"11.1",si:"11.3"}],["2023-03-27",{c:"108",ca:"109",e:"108",f:"111",fa:"111",s:"16.4",si:"16.4"}],["2023-03-27",{c:"94",ca:"94",e:"94",f:"88",fa:"88",s:"16.4",si:"16.4"}],["2017-04-05",{c:"1",ca:"18",e:"15",f:"1.5",fa:"4",s:"1.2",si:"1"}],["≤2018-10-02",{c:"10",ca:"18",e:"≤18",f:"4",fa:"4",s:"7",si:"7"}],["2023-09-18",{c:"113",ca:"113",e:"113",f:"66",fa:"66",s:"17",si:"17"}],["2022-09-12",{c:"90",ca:"90",e:"90",f:"81",fa:"81",s:"16",si:"16"}],["2020-03-24",{c:"68",ca:"68",e:"79",f:"61",fa:"61",s:"13.1",si:"13.4"}],["2018-10-02",{c:"23",ca:"25",e:"18",f:"49",fa:"49",s:"7",si:"7"}],["2022-09-12",{c:"63",ca:"63",e:"18",f:"59",fa:"59",s:"16",si:"16"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2019-01-29",{c:"50",ca:"50",e:"12",f:"65",fa:"65",s:"10",si:"10"}],["2024-12-11",{c:"15",ca:"18",e:"79",f:"95",fa:"95",s:"18.2",si:"18.2"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"1.5",fa:"4",s:"5",si:"4"}],["2015-07-29",{c:"33",ca:"33",e:"12",f:"18",fa:"18",s:"7",si:"7"}],["2021-04-26",{c:"60",ca:"60",e:"79",f:"84",fa:"84",s:"14.1",si:"14.5"}],["2025-09-15",{c:"124",ca:"124",e:"124",f:"128",fa:"128",s:"26",si:"26"}],["2023-03-27",{c:"94",ca:"94",e:"94",f:"99",fa:"99",s:"16.4",si:"16.4"}],["2015-09-16",{c:"6",ca:"18",e:"12",f:"7",fa:"7",s:"8",si:"9"}],["2022-09-12",{c:"44",ca:"44",e:"79",f:"46",fa:"46",s:"16",si:"16"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2016-03-21",{c:"38",ca:"38",e:"13",f:"38",fa:"38",s:"9.1",si:"9.3"}],["2020-01-15",{c:"57",ca:"57",e:"79",f:"51",fa:"51",s:"10.1",si:"10.3"}],["2020-01-15",{c:"47",ca:"47",e:"79",f:"51",fa:"51",s:"9",si:"9"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"3.6",fa:"4",s:"4",si:"3.2"}],["2020-07-28",{c:"55",ca:"55",e:"12",f:"59",fa:"79",s:"13",si:"13"}],["2025-01-27",{c:"116",ca:"116",e:"116",f:"125",fa:"125",s:"17",si:"18.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"3",fa:"4",s:"4",si:"3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2020-01-15",{c:"76",ca:"76",e:"79",f:"67",fa:"67",s:"12.1",si:"13"}],["2022-05-31",{c:"96",ca:"96",e:"96",f:"101",fa:"101",s:"14.1",si:"14.5"}],["2020-01-15",{c:"74",ca:"74",e:"79",f:"63",fa:"64",s:"10.1",si:"10.3"}],["2023-12-11",{c:"73",ca:"73",e:"79",f:"78",fa:"79",s:"17.2",si:"17.2"}],["2023-12-11",{c:"86",ca:"86",e:"86",f:"101",fa:"101",s:"17.2",si:"17.2"}],["2023-06-06",{c:"1",ca:"18",e:"12",f:"1",fa:"114",s:"1.1",si:"1"}],["2025-05-01",{c:"136",ca:"136",e:"136",f:"97",fa:"97",s:"15.4",si:"15.4"}],["2019-09-19",{c:"63",ca:"63",e:"12",f:"6",fa:"6",s:"13",si:"13"}],["2015-07-29",{c:"6",ca:"18",e:"12",f:"6",fa:"6",s:"6",si:"7"}],["2015-07-29",{c:"32",ca:"32",e:"12",f:"29",fa:"29",s:"8",si:"8"}],["2020-07-28",{c:"76",ca:"76",e:"79",f:"71",fa:"79",s:"13",si:"13"}],["2020-09-16",{c:"85",ca:"85",e:"85",f:"79",fa:"79",s:"14",si:"14"}],["2018-10-02",{c:"63",ca:"63",e:"18",f:"58",fa:"58",s:"11.1",si:"11.3"}],["2025-01-07",{c:"128",ca:"128",e:"128",f:"134",fa:"134",s:"18.2",si:"18.2"}],["2024-03-05",{c:"119",ca:"119",e:"119",f:"121",fa:"121",s:"17.4",si:"17.4"}],["2016-09-20",{c:"49",ca:"49",e:"12",f:"18",fa:"18",s:"10",si:"10"}],["2023-03-27",{c:"50",ca:"50",e:"17",f:"44",fa:"48",s:"16",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"2"}],["2020-03-24",{c:"63",ca:"63",e:"79",f:"49",fa:"49",s:"13.1",si:"13.4"}],["2020-07-28",{c:"71",ca:"71",e:"79",f:"69",fa:"79",s:"12.1",si:"12.2"}],["2021-04-26",{c:"87",ca:"87",e:"87",f:"70",fa:"79",s:"14.1",si:"14.5"}],["2020-07-28",{c:"1",ca:"18",e:"13",f:"78",fa:"79",s:"4",si:"3.2"}],["2024-01-23",{c:"119",ca:"119",e:"119",f:"122",fa:"122",s:"17.2",si:"17.2"}],["2021-09-20",{c:"85",ca:"85",e:"85",f:"87",fa:"87",s:"15",si:"15"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2025-05-01",{c:"136",ca:"136",e:"136",f:"134",fa:"134",s:"18.2",si:"18.2"}],["2024-07-09",{c:"85",ca:"85",e:"85",f:"128",fa:"128",s:"16.4",si:"16.4"}],["2024-09-16",{c:"125",ca:"125",e:"125",f:"128",fa:"128",s:"18",si:"18"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"3.6",fa:"4",s:"5",si:"4"}],["2015-07-29",{c:"24",ca:"25",e:"12",f:"23",fa:"23",s:"7",si:"7"}],["2023-03-27",{c:"69",ca:"69",e:"79",f:"99",fa:"99",s:"16.4",si:"16.4"}],["2024-10-29",{c:"83",ca:"83",e:"83",f:"132",fa:"132",s:"15.4",si:"15.4"}],["2025-05-27",{c:"134",ca:"134",e:"134",f:"139",fa:"139",s:"18.4",si:"18.4"}],["2024-07-09",{c:"111",ca:"111",e:"111",f:"128",fa:"128",s:"16.4",si:"16.4"}],["2020-07-28",{c:"64",ca:"64",e:"79",f:"69",fa:"79",s:"13.1",si:"13.4"}],["2022-09-12",{c:"68",ca:"68",e:"79",f:"62",fa:"62",s:"16",si:"16"}],["2018-10-23",{c:"1",ca:"18",e:"12",f:"63",fa:"63",s:"3",si:"1"}],["2023-03-27",{c:"54",ca:"54",e:"17",f:"45",fa:"45",s:"16.4",si:"16.4"}],["2017-09-19",{c:"29",ca:"29",e:"12",f:"35",fa:"35",s:"11",si:"11"}],["2020-07-27",{c:"84",ca:"84",e:"84",f:"67",fa:"67",s:"9.1",si:"9.3"}],["2020-01-15",{c:"65",ca:"65",e:"79",f:"52",fa:"52",s:"12.1",si:"12.2"}],["2023-11-21",{c:"111",ca:"111",e:"111",f:"120",fa:"120",s:"16.4",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2024-05-17",{c:"125",ca:"125",e:"125",f:"118",fa:"118",s:"17.2",si:"17.2"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"38",fa:"38",s:"5",si:"4.2"}],["2024-12-11",{c:"128",ca:"128",e:"128",f:"38",fa:"38",s:"18.2",si:"18.2"}],["2024-12-11",{c:"84",ca:"84",e:"84",f:"38",fa:"38",s:"18.2",si:"18.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2020-01-15",{c:"69",ca:"69",e:"79",f:"65",fa:"65",s:"11.1",si:"11.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2025-12-09",{c:"118",ca:"118",e:"118",f:"146",fa:"146",s:"17.4",si:"17.4"}],["2020-01-15",{c:"27",ca:"27",e:"79",f:"32",fa:"32",s:"7",si:"7"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2023-03-27",{c:"38",ca:"39",e:"79",f:"43",fa:"43",s:"16.4",si:"16.4"}],["2025-03-31",{c:"84",ca:"84",e:"84",f:"126",fa:"126",s:"16.4",si:"18.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"2"}],["2023-12-07",{c:"120",ca:"120",e:"120",f:"113",fa:"113",s:"17",si:"17"}],["2022-03-14",{c:"61",ca:"61",e:"79",f:"36",fa:"36",s:"15.4",si:"15.4"}],["2020-09-16",{c:"61",ca:"61",e:"79",f:"36",fa:"36",s:"14",si:"14"}],["2020-01-15",{c:"1",ca:"18",e:"79",f:"1",fa:"4",s:"3",si:"1"}],["2020-01-15",{c:"69",ca:"69",e:"79",f:"68",fa:"68",s:"11",si:"11"}],["2024-10-01",{c:"80",ca:"80",e:"80",f:"131",fa:"131",s:"16.1",si:"16.1"}],["2024-12-11",{c:"94",ca:"94",e:"94",f:"97",fa:"97",s:"18.2",si:"18.2"}],["2024-12-11",{c:"121",ca:"121",e:"121",f:"64",fa:"64",s:"18.2",si:"18.2"}],["2023-10-13",{c:"118",ca:"118",e:"118",f:"118",fa:"118",s:"17",si:"17"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"4",fa:"4",s:"5",si:"4.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2017-03-07",{c:"11",ca:"18",e:"12",f:"52",fa:"52",s:"5.1",si:"5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2020-01-15",{c:"6",ca:"18",e:"79",f:"6",fa:"45",s:"5",si:"5"}],["2023-03-27",{c:"65",ca:"65",e:"79",f:"61",fa:"61",s:"16.4",si:"16.4"}],["2018-04-30",{c:"45",ca:"45",e:"17",f:"44",fa:"44",s:"11.1",si:"11.3"}],["2015-07-29",{c:"38",ca:"38",e:"12",f:"13",fa:"14",s:"8",si:"8"}],["2024-06-11",{c:"122",ca:"122",e:"122",f:"127",fa:"127",s:"17",si:"17"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3.5",fa:"4",s:"4",si:"5"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3.5",fa:"4",s:"4",si:"5"}],["2020-01-15",{c:"53",ca:"53",e:"79",f:"63",fa:"63",s:"10",si:"10"}],["2020-07-28",{c:"73",ca:"73",e:"79",f:"72",fa:"79",s:"13.1",si:"13.4"}],["2020-01-15",{c:"37",ca:"37",e:"79",f:"62",fa:"62",s:"10.1",si:"10.3"}],["2020-01-15",{c:"37",ca:"37",e:"79",f:"54",fa:"54",s:"10.1",si:"10.3"}],["2021-12-13",{c:"68",ca:"89",e:"79",f:"79",fa:"79",s:"15.2",si:"15.2"}],["2020-01-15",{c:"53",ca:"53",e:"79",f:"63",fa:"63",s:"10",si:"10"}],["2023-03-27",{c:"92",ca:"92",e:"92",f:"92",fa:"92",s:"16.4",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2020-01-15",{c:"19",ca:"25",e:"79",f:"4",fa:"4",s:"6",si:"6"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3.5",fa:"4",s:"3.1",si:"2"}],["2020-01-15",{c:"18",ca:"18",e:"79",f:"55",fa:"55",s:"7",si:"7"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2018-09-05",{c:"33",ca:"33",e:"14",f:"49",fa:"62",s:"7",si:"7"}],["2017-11-28",{c:"9",ca:"47",e:"12",f:"2",fa:"57",s:"5.1",si:"5"}],["2020-01-15",{c:"60",ca:"60",e:"79",f:"55",fa:"55",s:"11.1",si:"11.3"}],["2017-03-27",{c:"38",ca:"38",e:"13",f:"38",fa:"38",s:"10.1",si:"10.3"}],["2020-01-15",{c:"70",ca:"70",e:"79",f:"3",fa:"4",s:"10.1",si:"10.3"}],["2024-08-06",{c:"117",ca:"117",e:"117",f:"129",fa:"129",s:"17.5",si:"17.5"}],["2024-05-17",{c:"125",ca:"125",e:"125",f:"126",fa:"126",s:"17.4",si:"17.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-09-16",{c:"77",ca:"77",e:"79",f:"65",fa:"65",s:"14",si:"14"}],["2019-09-19",{c:"56",ca:"56",e:"16",f:"59",fa:"59",s:"13",si:"13"}],["2023-12-05",{c:"119",ca:"120",e:"85",f:"65",fa:"65",s:"11.1",si:"11.3"}],["2023-09-18",{c:"61",ca:"61",e:"79",f:"57",fa:"57",s:"17",si:"17"}],["2022-06-28",{c:"67",ca:"67",e:"79",f:"102",fa:"102",s:"14.1",si:"14.5"}],["2022-03-14",{c:"92",ca:"92",e:"92",f:"90",fa:"90",s:"15.4",si:"15.4"}],["2015-09-30",{c:"41",ca:"41",e:"12",f:"29",fa:"29",s:"9",si:"9"}],["2015-09-30",{c:"41",ca:"41",e:"12",f:"40",fa:"40",s:"9",si:"9"}],["2020-01-15",{c:"73",ca:"73",e:"79",f:"67",fa:"67",s:"13",si:"13"}],["2016-09-20",{c:"34",ca:"34",e:"12",f:"31",fa:"31",s:"10",si:"10"}],["2017-04-05",{c:"57",ca:"57",e:"15",f:"48",fa:"48",s:"10",si:"10"}],["2015-09-30",{c:"41",ca:"41",e:"12",f:"34",fa:"34",s:"9",si:"9"}],["2015-09-30",{c:"41",ca:"36",e:"12",f:"24",fa:"24",s:"9",si:"9"}],["2020-08-27",{c:"85",ca:"85",e:"85",f:"77",fa:"79",s:"13.1",si:"13.4"}],["2015-09-30",{c:"41",ca:"36",e:"12",f:"17",fa:"17",s:"9",si:"9"}],["2020-01-15",{c:"66",ca:"66",e:"79",f:"61",fa:"61",s:"12",si:"12"}],["2023-10-24",{c:"111",ca:"111",e:"111",f:"119",fa:"119",s:"16.4",si:"16.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2022-03-14",{c:"98",ca:"98",e:"98",f:"94",fa:"94",s:"15.4",si:"15.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2023-09-15",{c:"117",ca:"117",e:"117",f:"71",fa:"79",s:"16",si:"16"}],["2015-09-30",{c:"28",ca:"28",e:"12",f:"22",fa:"22",s:"9",si:"9"}],["2016-09-20",{c:"2",ca:"18",e:"12",f:"49",fa:"49",s:"4",si:"3.2"}],["2020-01-15",{c:"1",ca:"18",e:"79",f:"3",fa:"4",s:"3",si:"2"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"3",fa:"4",s:"6",si:"6"}],["2015-09-30",{c:"38",ca:"38",e:"12",f:"36",fa:"36",s:"9",si:"9"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2021-08-10",{c:"42",ca:"42",e:"79",f:"91",fa:"91",s:"13.1",si:"13.4"}],["2018-10-02",{c:"1",ca:"18",e:"18",f:"1.5",fa:"4",s:"3.1",si:"2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1.3",si:"2"}],["2024-12-11",{c:"89",ca:"89",e:"89",f:"131",fa:"131",s:"18.2",si:"18.2"}],["2015-11-12",{c:"26",ca:"26",e:"13",f:"22",fa:"22",s:"8",si:"8"}],["2020-01-15",{c:"62",ca:"62",e:"79",f:"53",fa:"53",s:"11",si:"11"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2022-09-12",{c:"47",ca:"47",e:"12",f:"49",fa:"49",s:"16",si:"16"}],["2022-03-14",{c:"48",ca:"48",e:"79",f:"48",fa:"48",s:"15.4",si:"15.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2022-03-03",{c:"99",ca:"99",e:"99",f:"46",fa:"46",s:"7",si:"7"}],["2020-01-15",{c:"38",ca:"38",e:"79",f:"19",fa:"19",s:"10.1",si:"10.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-09-16",{c:"48",ca:"48",e:"79",f:"41",fa:"41",s:"14",si:"14"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"7",fa:"7",s:"1.3",si:"1"}],["2015-07-29",{c:"2",ca:"18",e:"12",f:"3.5",fa:"4",s:"1.1",si:"1"}],["2017-04-05",{c:"4",ca:"18",e:"15",f:"49",fa:"49",s:"3",si:"2"}],["2015-07-29",{c:"23",ca:"25",e:"12",f:"31",fa:"31",s:"6",si:"6"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-11-19",{c:"87",ca:"87",e:"87",f:"70",fa:"79",s:"12.1",si:"12.2"}],["2020-07-28",{c:"33",ca:"33",e:"12",f:"74",fa:"79",s:"12.1",si:"12.2"}],["2024-03-19",{c:"114",ca:"114",e:"114",f:"124",fa:"124",s:"17.4",si:"17.4"}],["2024-05-13",{c:"114",ca:"114",e:"114",f:"121",fa:"121",s:"17.5",si:"17.5"}],["2024-10-17",{c:"130",ca:"130",e:"130",f:"124",fa:"124",s:"17.4",si:"17.4"}],["2024-03-19",{c:"114",ca:"114",e:"114",f:"124",fa:"124",s:"17.4",si:"17.4"}],["2024-10-17",{c:"130",ca:"130",e:"130",f:"121",fa:"121",s:"17.5",si:"17.5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3"}],["2017-10-24",{c:"62",ca:"62",e:"14",f:"22",fa:"22",s:"10",si:"10"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2019-09-19",{c:"36",ca:"36",e:"12",f:"52",fa:"52",s:"13",si:"9.3"}],["2024-03-05",{c:"114",ca:"114",e:"114",f:"122",fa:"122",s:"17.4",si:"17.4"}],["2024-04-16",{c:"118",ca:"118",e:"118",f:"125",fa:"125",s:"13.1",si:"13.4"}],["2015-09-30",{c:"36",ca:"36",e:"12",f:"16",fa:"16",s:"9",si:"9"}],["2022-03-14",{c:"36",ca:"36",e:"12",f:"16",fa:"16",s:"15.4",si:"15.4"}],["2024-08-06",{c:"117",ca:"117",e:"117",f:"129",fa:"129",s:"17.4",si:"17.4"}],["2015-09-30",{c:"26",ca:"26",e:"12",f:"16",fa:"16",s:"9",si:"9"}],["2023-03-14",{c:"19",ca:"25",e:"79",f:"111",fa:"111",s:"6",si:"6"}],["2023-03-13",{c:"111",ca:"111",e:"111",f:"108",fa:"108",s:"15.4",si:"15.4"}],["2023-07-21",{c:"115",ca:"115",e:"115",f:"70",fa:"79",s:"15",si:"15"}],["2016-09-20",{c:"45",ca:"45",e:"12",f:"38",fa:"38",s:"10",si:"10"}],["2016-09-20",{c:"45",ca:"45",e:"12",f:"37",fa:"37",s:"10",si:"10"}],["2015-07-29",{c:"7",ca:"18",e:"12",f:"4",fa:"4",s:"5.1",si:"4.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2025-09-05",{c:"140",ca:"140",e:"140",f:"133",fa:"133",s:"18.2",si:"18.2"}],["2015-09-30",{c:"44",ca:"44",e:"12",f:"40",fa:"40",s:"9",si:"9"}],["2016-03-21",{c:"41",ca:"41",e:"13",f:"27",fa:"27",s:"9.1",si:"9.3"}],["2023-09-18",{c:"113",ca:"113",e:"113",f:"102",fa:"102",s:"17",si:"17"}],["2018-04-30",{c:"44",ca:"44",e:"17",f:"48",fa:"48",s:"10.1",si:"10.3"}],["2015-07-29",{c:"32",ca:"32",e:"12",f:"19",fa:"19",s:"7",si:"7"}],["2023-12-07",{c:"120",ca:"120",e:"120",f:"115",fa:"115",s:"17",si:"17"}],["2025-09-15",{c:"95",ca:"95",e:"95",f:"142",fa:"142",s:"26",si:"26"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"2",si:"1"}],["2023-11-21",{c:"72",ca:"72",e:"79",f:"120",fa:"120",s:"16.4",si:"16.4"}],["2015-07-29",{c:"4",ca:"18",e:"12",f:"3.5",fa:"4",s:"4",si:"5"}],["2023-11-02",{c:"119",ca:"119",e:"119",f:"88",fa:"88",s:"16.5",si:"16.5"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"≤4",si:"≤3.2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2024-04-18",{c:"124",ca:"124",e:"124",f:"120",fa:"120",s:"17.4",si:"17.4"}],["2015-07-29",{c:"3",ca:"18",e:"12",f:"3.5",fa:"4",s:"3.1",si:"3"}],["2025-10-14",{c:"125",ca:"125",e:"125",f:"144",fa:"144",s:"18.2",si:"18.2"}],["2025-10-14",{c:"111",ca:"111",e:"111",f:"144",fa:"144",s:"18",si:"18"}],["2022-12-05",{c:"108",ca:"108",e:"108",f:"101",fa:"101",s:"15.4",si:"15.4"}],["2017-10-17",{c:"26",ca:"26",e:"16",f:"19",fa:"19",s:"7",si:"7"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1.3",si:"1"}],["2021-08-10",{c:"61",ca:"61",e:"79",f:"91",fa:"68",s:"13",si:"13"}],["2017-10-17",{c:"57",ca:"57",e:"16",f:"52",fa:"52",s:"11",si:"11"}],["2021-04-26",{c:"85",ca:"85",e:"85",f:"78",fa:"79",s:"14.1",si:"14.5"}],["2021-10-25",{c:"75",ca:"75",e:"79",f:"78",fa:"79",s:"15.1",si:"15.1"}],["2022-05-03",{c:"95",ca:"95",e:"95",f:"100",fa:"100",s:"15.2",si:"15.2"}],["2024-03-05",{c:"114",ca:"114",e:"114",f:"112",fa:"112",s:"17.4",si:"17.4"}],["2024-12-11",{c:"119",ca:"119",e:"119",f:"120",fa:"120",s:"18.2",si:"18.2"}],["2020-10-20",{c:"86",ca:"86",e:"86",f:"78",fa:"79",s:"13.1",si:"13.4"}],["2020-03-24",{c:"69",ca:"69",e:"79",f:"62",fa:"62",s:"13.1",si:"13.4"}],["2021-10-25",{c:"75",ca:"75",e:"18",f:"64",fa:"64",s:"15.1",si:"15.1"}],["2021-11-19",{c:"96",ca:"96",e:"96",f:"79",fa:"79",s:"15.1",si:"15.1"}],["2021-04-26",{c:"69",ca:"69",e:"18",f:"62",fa:"62",s:"14.1",si:"14.5"}],["2023-03-27",{c:"91",ca:"91",e:"91",f:"89",fa:"89",s:"16.4",si:"16.4"}],["2024-12-11",{c:"112",ca:"112",e:"112",f:"121",fa:"121",s:"18.2",si:"18.2"}],["2021-12-13",{c:"74",ca:"88",e:"79",f:"79",fa:"79",s:"15.2",si:"15.2"}],["2024-09-16",{c:"119",ca:"119",e:"119",f:"120",fa:"120",s:"18",si:"18"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"4",si:"3.2"}],["2021-04-26",{c:"84",ca:"84",e:"84",f:"79",fa:"79",s:"14.1",si:"14.5"}],["2015-07-29",{c:"36",ca:"36",e:"12",f:"6",fa:"6",s:"8",si:"8"}],["2015-09-30",{c:"36",ca:"36",e:"12",f:"34",fa:"34",s:"9",si:"9"}],["2020-09-16",{c:"84",ca:"84",e:"84",f:"75",fa:"79",s:"14",si:"14"}],["2021-04-26",{c:"35",ca:"35",e:"12",f:"25",fa:"25",s:"14.1",si:"14.5"}],["2015-07-29",{c:"37",ca:"37",e:"12",f:"34",fa:"34",s:"11",si:"11"}],["2022-03-14",{c:"69",ca:"69",e:"79",f:"96",fa:"96",s:"15.4",si:"15.4"}],["2021-09-07",{c:"67",ca:"70",e:"18",f:"60",fa:"92",s:"13",si:"13"}],["2023-10-24",{c:"85",ca:"85",e:"85",f:"119",fa:"119",s:"16",si:"16"}],["2015-07-29",{c:"9",ca:"25",e:"12",f:"4",fa:"4",s:"5.1",si:"8"}],["2021-09-20",{c:"63",ca:"63",e:"17",f:"30",fa:"30",s:"14",si:"15"}],["2024-10-29",{c:"104",ca:"104",e:"104",f:"132",fa:"132",s:"16.4",si:"16.4"}],["2020-01-15",{c:"47",ca:"47",e:"79",f:"53",fa:"53",s:"12",si:"12"}],["2017-04-19",{c:"33",ca:"33",e:"12",f:"53",fa:"53",s:"9.1",si:"9.3"}],["2020-09-16",{c:"47",ca:"47",e:"79",f:"56",fa:"56",s:"14",si:"14"}],["2015-07-29",{c:"26",ca:"26",e:"12",f:"22",fa:"22",s:"8",si:"8"}],["2018-04-30",{c:"26",ca:"26",e:"17",f:"22",fa:"22",s:"8",si:"8"}],["2022-12-13",{c:"100",ca:"100",e:"100",f:"108",fa:"108",s:"16",si:"16"}],["2021-09-20",{c:"56",ca:"58",e:"79",f:"51",fa:"51",s:"15",si:"15"}],["2024-10-29",{c:"104",ca:"104",e:"104",f:"132",fa:"132",s:"16.4",si:"16.4"}],["2020-09-16",{c:"9",ca:"18",e:"18",f:"65",fa:"65",s:"14",si:"14"}],["2020-01-15",{c:"56",ca:"56",e:"79",f:"22",fa:"24",s:"11",si:"11"}],["2025-10-03",{c:"141",ca:"141",e:"141",f:"117",fa:"117",s:"15.4",si:"15.4"}],["2023-05-09",{c:"76",ca:"76",e:"79",f:"113",fa:"113",s:"15.4",si:"15.4"}],["2020-01-15",{c:"58",ca:"58",e:"79",f:"44",fa:"44",s:"11",si:"11"}],["2015-07-29",{c:"5",ca:"18",e:"12",f:"11",fa:"14",s:"5",si:"4.2"}],["2015-07-29",{c:"23",ca:"25",e:"12",f:"31",fa:"31",s:"6",si:"8"}],["2020-01-15",{c:"23",ca:"25",e:"79",f:"31",fa:"31",s:"6",si:"8"}],["2021-01-21",{c:"88",ca:"88",e:"88",f:"82",fa:"82",s:"14",si:"14"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2024-03-19",{c:"114",ca:"114",e:"114",f:"124",fa:"124",s:"17.4",si:"17.4"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2020-01-15",{c:"36",ca:"36",e:"79",f:"36",fa:"36",s:"9.1",si:"9.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2015-09-30",{c:"44",ca:"44",e:"12",f:"15",fa:"15",s:"9",si:"9"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"1",si:"1"}],["2017-03-27",{c:"48",ca:"48",e:"12",f:"41",fa:"41",s:"10.1",si:"10.3"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3",si:"1"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"1",fa:"4",s:"3.1",si:"2"}],["2015-07-29",{c:"1",ca:"18",e:"12",f:"3",fa:"4",s:"1",si:"1"}],["2024-05-14",{c:"1",ca:"18",e:"12",f:"126",fa:"126",s:"3.1",si:"3"}]],c={w:"WebKit",g:"Gecko",p:"Presto",b:"Blink"},e={r:"retired",c:"current",b:"beta",n:"nightly",p:"planned",u:"unknown",e:"esr"},f=s=>{const a={};return Object.entries(s).forEach(([s,r])=>{if(r.releases){a[s]||(a[s]={releases:{}});const f=a[s].releases;r.releases.forEach(s=>{f[s[0]]={version:s[0],release_date:"u"==s[1]?"unknown":s[1],status:e[s[2]],engine:s[3]?c[s[3]]:void 0,engine_version:s[4]};});}}),a},b=(()=>{const s=[];return r.forEach(a=>{var r;s.push({status:{baseline_low_date:a[0],support:(r=a[1],{chrome:r.c,chrome_android:r.ca,edge:r.e,firefox:r.f,firefox_android:r.fa,safari:r.s,safari_ios:r.si})}});}),s})(),u=f(s),i=f(a);let n=false;const o=["chrome","chrome_android","edge","firefox","firefox_android","safari","safari_ios"],g=Object.entries(u).filter(([s])=>o.includes(s)),t=["webview_android","samsunginternet_android","opera_android","opera"],l=[...Object.entries(u).filter(([s])=>t.includes(s)),...Object.entries(i)],w=["current","esr","retired","unknown","beta","nightly"];let p=false;const d=s=>{if(false===s.includeDownstreamBrowsers&&true===s.includeKaiOS){if(console.log(new Error("KaiOS is a downstream browser and can only be included if you include other downstream browsers. Please ensure you use `includeDownstreamBrowsers: true`.")),"undefined"==typeof process||!process.exit)throw new Error("KaiOS configuration error: process.exit is not available");process.exit(1);}},v=s=>s&&s.startsWith("≤")?s.slice(1):s,_=(s,a)=>{if(s===a)return 0;const[r=0,c=0]=s.split(".",2).map(Number),[e=0,f=0]=a.split(".",2).map(Number);if(isNaN(r)||isNaN(c))throw new Error(`Invalid version: ${s}`);if(isNaN(e)||isNaN(f))throw new Error(`Invalid version: ${a}`);return r!==e?r>e?1:-1:c!==f?c>f?1:-1:0},h=s=>{let a=[];return s.forEach(s=>{let r=g.find(a=>a[0]===s.browser);if(r){Object.entries(r[1].releases).filter(([,s])=>w.includes(s.status)).sort((s,a)=>_(s[0],a[0])).forEach(([r,c])=>!!w.includes(c.status)&&(1===_(r,s.version)&&(a.push({browser:s.browser,version:r,release_date:c.release_date?c.release_date:"unknown"}),true)));}}),a},m=(s,a=false)=>{if(s.getFullYear()<2015&&!p&&console.warn(new Error("There are no browser versions compatible with Baseline before 2015.  You may receive unexpected results.")),s.getFullYear()<2002)throw new Error("None of the browsers in the core set were released before 2002.  Please use a date after 2002.");if(s.getFullYear()>(new Date).getFullYear())throw new Error("There are no browser versions compatible with Baseline in the future");const r=(s=>b.filter(a=>a.status.baseline_low_date&&new Date(a.status.baseline_low_date)<=s).map(s=>({baseline_low_date:s.status.baseline_low_date,support:s.status.support})))(s),c=(s=>{let a={};return Object.entries(g).forEach(([,s])=>{a[s[0]]={browser:s[0],version:"0",release_date:""};}),s.forEach(s=>{Object.entries(s.support).forEach(r=>{const c=r[0],e=v(r[1]);a[c]&&1===_(e,v(a[c].version))&&(a[c]={browser:c,version:e,release_date:s.baseline_low_date});});}),Object.values(a)})(r);return a?[...c,...h(c)].sort((s,a)=>s.browser<a.browser?-1:s.browser>a.browser?1:_(s.version,a.version)):c},O=(s=[],a=true,r=false)=>{const c=a=>{var r;return s&&s.length>0?null===(r=s.filter(s=>s.browser===a).sort((s,a)=>_(s.version,a.version))[0])||void 0===r?void 0:r.version:void 0},e=c("chrome"),f=c("firefox");if(!e&&!f)throw new Error("There are no browser versions compatible with Baseline before Chrome and Firefox");let b=[];return l.filter(([s])=>!("kai_os"===s&&!r)).forEach(([s,r])=>{var c;if(!r.releases)return;let u=Object.entries(r.releases).filter(([,s])=>{const{engine:a,engine_version:r}=s;return !(!a||!r)&&("Blink"===a&&e?_(r,e)>=0:!("Gecko"!==a||!f)&&_(r,f)>=0)}).sort((s,a)=>_(s[0],a[0]));for(let r=0;r<u.length;r++){const e=u[r];if(e){const[r,f]=e;let u={browser:s,version:r,release_date:null!==(c=f.release_date)&&void 0!==c?c:"unknown"};if(f.engine&&f.engine_version&&(u.engine=f.engine,u.engine_version=f.engine_version),b.push(u),!a)break}}}),b};function y(s){var a,r,c,e,f,b,u;let i=null!=s?s:{},o={listAllCompatibleVersions:null!==(a=i.listAllCompatibleVersions)&&void 0!==a&&a,includeDownstreamBrowsers:null!==(r=i.includeDownstreamBrowsers)&&void 0!==r&&r,widelyAvailableOnDate:null!==(c=i.widelyAvailableOnDate)&&void 0!==c?c:void 0,targetYear:null!==(e=i.targetYear)&&void 0!==e?e:void 0,includeKaiOS:null!==(f=i.includeKaiOS)&&void 0!==f&&f,overrideLastUpdated:null!==(b=i.overrideLastUpdated)&&void 0!==b?b:void 0,suppressWarnings:null!==(u=i.suppressWarnings)&&void 0!==u&&u},g=new Date;if(d(o),o.widelyAvailableOnDate||o.targetYear)if(o.targetYear&&o.widelyAvailableOnDate){if(console.log(new Error("You cannot use targetYear and widelyAvailableOnDate at the same time.  Please remove one of these options and try again.")),"undefined"==typeof process||!process.exit)throw new Error("Configuration error: targetYear and widelyAvailableOnDate cannot be used together");process.exit(1);}else o.widelyAvailableOnDate?g=new Date(o.widelyAvailableOnDate):o.targetYear&&(g=new Date(`${o.targetYear}-12-31`));else g=new Date;(o.widelyAvailableOnDate||void 0===o.targetYear)&&g.setMonth(g.getMonth()-30);let t=m(g,o.listAllCompatibleVersions);return o.suppressWarnings||((s,a)=>{if(n||"undefined"!=typeof process&&process.env&&(process.env.BROWSERSLIST_IGNORE_OLD_DATA||process.env.BASELINE_BROWSER_MAPPING_IGNORE_OLD_DATA))return;const r=new Date;r.setMonth(r.getMonth()-2),s>r&&(null!=a?a:1765548679074)<r.getTime()&&(console.warn("[baseline-browser-mapping] The data in this module is over two months old and you are targetting a recent feature cut off date of "+s.toISOString().slice(0,10)+". To ensure accurate Baseline data, please update to the latest version of this module using your package manager of choice.\nYou can suppress these warnings using the environment variables `BROWSERSLIST_IGNORE_OLD_DATA=true` or `BASELINE_BROWSER_MAPPING_IGNORE_OLD_DATA=true`.\nSome modules including `next.js` pre-compile data from this module via `browserslist` or other packages.\nPlease contact the maintainers of those modules if you are receiving these warnings and can't suppress them.\n"),n=true);})(g,o.overrideLastUpdated),false===o.includeDownstreamBrowsers?t:[...t,...O(t,o.listAllCompatibleVersions,o.includeKaiOS)]}dist._resetHasWarned=function(){n=false;},dist.getAllVersions=function(s){var a,r,c,e,f;p=true;let b=null!=s?s:{},u={outputFormat:null!==(a=b.outputFormat)&&void 0!==a?a:"array",includeDownstreamBrowsers:null!==(r=b.includeDownstreamBrowsers)&&void 0!==r&&r,useSupports:null!==(c=b.useSupports)&&void 0!==c&&c,includeKaiOS:null!==(e=b.includeKaiOS)&&void 0!==e&&e,suppressWarnings:null!==(f=b.suppressWarnings)&&void 0!==f&&f};d(u);let i=(new Date).getFullYear()+1;const n=[...Array(i).keys()].slice(2002),g={};n.forEach(s=>{g[s]={},y({targetYear:s,suppressWarnings:u.suppressWarnings}).forEach(a=>{g[s]&&(g[s][a.browser]=a);});});const t=y({suppressWarnings:u.suppressWarnings}),l={};t.forEach(s=>{l[s.browser]=s;});const w=new Date;w.setMonth(w.getMonth()+30);const v=y({widelyAvailableOnDate:w.toISOString().slice(0,10),suppressWarnings:u.suppressWarnings}),h={};v.forEach(s=>{h[s.browser]=s;});const m=y({targetYear:2002,listAllCompatibleVersions:true,suppressWarnings:u.suppressWarnings}),E=[];if(o.forEach(s=>{var a,r,c,e;let f=m.filter(a=>a.browser==s).sort((s,a)=>_(s.version,a.version)),b=null!==(r=null===(a=l[s])||void 0===a?void 0:a.version)&&void 0!==r?r:"0",o=null!==(e=null===(c=h[s])||void 0===c?void 0:c.version)&&void 0!==e?e:"0";n.forEach(a=>{var r;if(g[a]){let c=(null!==(r=g[a][s])&&void 0!==r?r:{version:"0"}).version,e=f.findIndex(s=>0===_(s.version,c));(a===i-1?f:f.slice(0,e)).forEach(s=>{let r=_(s.version,b)>=0,c=_(s.version,o)>=0,e=Object.assign(Object.assign({},s),{year:a<=2015?"pre_baseline":a-1});u.useSupports?(r&&(e.supports="widely"),c&&(e.supports="newly")):e=Object.assign(Object.assign({},e),{wa_compatible:r}),E.push(e);}),f=f.slice(e,f.length);}});}),u.includeDownstreamBrowsers){O(E,true,u.includeKaiOS).forEach(s=>{let a=E.find(a=>"chrome"===a.browser&&a.version===s.engine_version);a&&(u.useSupports?E.push(Object.assign(Object.assign({},s),{year:a.year,supports:a.supports})):E.push(Object.assign(Object.assign({},s),{year:a.year,wa_compatible:a.wa_compatible})));});}if(E.sort((s,a)=>{if("pre_baseline"===s.year&&"pre_baseline"!==a.year)return  -1;if("pre_baseline"===a.year&&"pre_baseline"!==s.year)return 1;if("pre_baseline"!==s.year&&"pre_baseline"!==a.year){if(s.year<a.year)return  -1;if(s.year>a.year)return 1}return s.browser<a.browser?-1:s.browser>a.browser?1:_(s.version,a.version)}),"object"===u.outputFormat){const s={};return E.forEach(a=>{s[a.browser]||(s[a.browser]={});let r={year:a.year,release_date:a.release_date,engine:a.engine,engine_version:a.engine_version};s[a.browser][a.version]=u.useSupports?a.supports?Object.assign(Object.assign({},r),{supports:a.supports}):r:Object.assign(Object.assign({},r),{wa_compatible:a.wa_compatible});}),null!=s?s:{}}if("csv"===u.outputFormat){let s=`"browser","version","year","${u.useSupports?"supports":"wa_compatible"}","release_date","engine","engine_version"`;return E.forEach(a=>{var r,c,e,f;let b={browser:a.browser,version:a.version,year:a.year,release_date:null!==(r=a.release_date)&&void 0!==r?r:"NULL",engine:null!==(c=a.engine)&&void 0!==c?c:"NULL",engine_version:null!==(e=a.engine_version)&&void 0!==e?e:"NULL"};b=u.useSupports?Object.assign(Object.assign({},b),{supports:null!==(f=a.supports)&&void 0!==f?f:""}):Object.assign(Object.assign({},b),{wa_compatible:a.wa_compatible}),s+=`\n"${b.browser}","${b.version}","${b.year}","${u.useSupports?b.supports:b.wa_compatible}","${b.release_date}","${b.engine}","${b.engine_version}"`;}),s}return E},dist.getCompatibleVersions=y;
	return dist;
}

const require$$1 = /* #__PURE__ */ JSON.parse("[{\"name\":\"nodejs\",\"version\":\"0.2.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.3.8.0\"},{\"name\":\"nodejs\",\"version\":\"0.3.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.5.1.0\"},{\"name\":\"nodejs\",\"version\":\"0.4.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.2.0\"},{\"name\":\"nodejs\",\"version\":\"0.5.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.8.25\"},{\"name\":\"nodejs\",\"version\":\"0.6.0\",\"date\":\"2011-11-04\",\"lts\":false,\"security\":false,\"v8\":\"3.6.6.6\"},{\"name\":\"nodejs\",\"version\":\"0.7.0\",\"date\":\"2012-01-17\",\"lts\":false,\"security\":false,\"v8\":\"3.8.6.0\"},{\"name\":\"nodejs\",\"version\":\"0.8.0\",\"date\":\"2012-06-22\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.10\"},{\"name\":\"nodejs\",\"version\":\"0.9.0\",\"date\":\"2012-07-20\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.15\"},{\"name\":\"nodejs\",\"version\":\"0.10.0\",\"date\":\"2013-03-11\",\"lts\":false,\"security\":false,\"v8\":\"3.14.5.8\"},{\"name\":\"nodejs\",\"version\":\"0.11.0\",\"date\":\"2013-03-28\",\"lts\":false,\"security\":false,\"v8\":\"3.17.13.0\"},{\"name\":\"nodejs\",\"version\":\"0.12.0\",\"date\":\"2015-02-06\",\"lts\":false,\"security\":false,\"v8\":\"3.28.73.0\"},{\"name\":\"nodejs\",\"version\":\"4.0.0\",\"date\":\"2015-09-08\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.30\"},{\"name\":\"nodejs\",\"version\":\"4.1.0\",\"date\":\"2015-09-17\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.33\"},{\"name\":\"nodejs\",\"version\":\"4.2.0\",\"date\":\"2015-10-12\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.3.0\",\"date\":\"2016-02-09\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.4.0\",\"date\":\"2016-03-08\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.5.0\",\"date\":\"2016-08-16\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.6.0\",\"date\":\"2016-09-27\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.7.0\",\"date\":\"2016-12-06\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.43\"},{\"name\":\"nodejs\",\"version\":\"4.8.0\",\"date\":\"2017-02-21\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.45\"},{\"name\":\"nodejs\",\"version\":\"4.9.0\",\"date\":\"2018-03-28\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.53\"},{\"name\":\"nodejs\",\"version\":\"5.0.0\",\"date\":\"2015-10-29\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.28\"},{\"name\":\"nodejs\",\"version\":\"5.1.0\",\"date\":\"2015-11-17\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.2.0\",\"date\":\"2015-12-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.3.0\",\"date\":\"2015-12-15\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.4.0\",\"date\":\"2016-01-06\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.5.0\",\"date\":\"2016-01-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.6.0\",\"date\":\"2016-02-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.7.0\",\"date\":\"2016-02-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.8.0\",\"date\":\"2016-03-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.9.0\",\"date\":\"2016-03-16\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.10.0\",\"date\":\"2016-04-01\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.11.0\",\"date\":\"2016-04-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.12.0\",\"date\":\"2016-06-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.32\"},{\"name\":\"nodejs\",\"version\":\"6.0.0\",\"date\":\"2016-04-26\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.1.0\",\"date\":\"2016-05-05\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.2.0\",\"date\":\"2016-05-17\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.47\"},{\"name\":\"nodejs\",\"version\":\"6.3.0\",\"date\":\"2016-07-06\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.52\"},{\"name\":\"nodejs\",\"version\":\"6.4.0\",\"date\":\"2016-08-12\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.60\"},{\"name\":\"nodejs\",\"version\":\"6.5.0\",\"date\":\"2016-08-26\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.81\"},{\"name\":\"nodejs\",\"version\":\"6.6.0\",\"date\":\"2016-09-14\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.7.0\",\"date\":\"2016-09-27\",\"lts\":false,\"security\":true,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.8.0\",\"date\":\"2016-10-12\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.9.0\",\"date\":\"2016-10-18\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.10.0\",\"date\":\"2017-02-21\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.93\"},{\"name\":\"nodejs\",\"version\":\"6.11.0\",\"date\":\"2017-06-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.102\"},{\"name\":\"nodejs\",\"version\":\"6.12.0\",\"date\":\"2017-11-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.108\"},{\"name\":\"nodejs\",\"version\":\"6.13.0\",\"date\":\"2018-02-10\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.14.0\",\"date\":\"2018-03-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.15.0\",\"date\":\"2018-11-27\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.16.0\",\"date\":\"2018-12-26\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.17.0\",\"date\":\"2019-02-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"7.0.0\",\"date\":\"2016-10-25\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.1.0\",\"date\":\"2016-11-08\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.2.0\",\"date\":\"2016-11-22\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.43\"},{\"name\":\"nodejs\",\"version\":\"7.3.0\",\"date\":\"2016-12-20\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.4.0\",\"date\":\"2017-01-04\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.5.0\",\"date\":\"2017-01-31\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.48\"},{\"name\":\"nodejs\",\"version\":\"7.6.0\",\"date\":\"2017-02-21\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.40\"},{\"name\":\"nodejs\",\"version\":\"7.7.0\",\"date\":\"2017-02-28\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.41\"},{\"name\":\"nodejs\",\"version\":\"7.8.0\",\"date\":\"2017-03-29\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.9.0\",\"date\":\"2017-04-11\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.10.0\",\"date\":\"2017-05-02\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"8.0.0\",\"date\":\"2017-05-30\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.1.0\",\"date\":\"2017-06-08\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.2.0\",\"date\":\"2017-07-19\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.3.0\",\"date\":\"2017-08-08\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.4.0\",\"date\":\"2017-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.5.0\",\"date\":\"2017-09-12\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.6.0\",\"date\":\"2017-09-26\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.7.0\",\"date\":\"2017-10-11\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.8.0\",\"date\":\"2017-10-24\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.9.0\",\"date\":\"2017-10-31\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.1.534.46\"},{\"name\":\"nodejs\",\"version\":\"8.10.0\",\"date\":\"2018-03-06\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.11.0\",\"date\":\"2018-03-28\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.12.0\",\"date\":\"2018-09-10\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.66\"},{\"name\":\"nodejs\",\"version\":\"8.13.0\",\"date\":\"2018-11-20\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.75\"},{\"name\":\"nodejs\",\"version\":\"8.16.0\",\"date\":\"2019-04-16\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.77\"},{\"name\":\"nodejs\",\"version\":\"8.17.0\",\"date\":\"2019-12-17\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.78\"},{\"name\":\"nodejs\",\"version\":\"9.0.0\",\"date\":\"2017-10-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.1.0\",\"date\":\"2017-11-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.2.0\",\"date\":\"2017-11-14\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.44\"},{\"name\":\"nodejs\",\"version\":\"9.3.0\",\"date\":\"2017-12-12\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.4.0\",\"date\":\"2018-01-10\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.5.0\",\"date\":\"2018-01-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.6.0\",\"date\":\"2018-02-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.7.0\",\"date\":\"2018-03-01\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.8.0\",\"date\":\"2018-03-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.9.0\",\"date\":\"2018-03-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.10.0\",\"date\":\"2018-03-28\",\"lts\":false,\"security\":true,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.11.0\",\"date\":\"2018-04-04\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"10.0.0\",\"date\":\"2018-04-24\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.24\"},{\"name\":\"nodejs\",\"version\":\"10.1.0\",\"date\":\"2018-05-08\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.27\"},{\"name\":\"nodejs\",\"version\":\"10.2.0\",\"date\":\"2018-05-23\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.3.0\",\"date\":\"2018-05-29\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.4.0\",\"date\":\"2018-06-06\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.43\"},{\"name\":\"nodejs\",\"version\":\"10.5.0\",\"date\":\"2018-06-20\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.6.0\",\"date\":\"2018-07-04\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.7.0\",\"date\":\"2018-07-18\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.8.0\",\"date\":\"2018-08-01\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.9.0\",\"date\":\"2018-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.24\"},{\"name\":\"nodejs\",\"version\":\"10.10.0\",\"date\":\"2018-09-06\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.30\"},{\"name\":\"nodejs\",\"version\":\"10.11.0\",\"date\":\"2018-09-19\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.12.0\",\"date\":\"2018-10-10\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.13.0\",\"date\":\"2018-10-30\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.16.0\",\"date\":\"2019-05-28\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.17.0\",\"date\":\"2019-10-22\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.18.0\",\"date\":\"2019-12-17\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.19.0\",\"date\":\"2020-02-05\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.20.0\",\"date\":\"2020-03-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.21.0\",\"date\":\"2020-06-02\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.22.0\",\"date\":\"2020-07-21\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.23.0\",\"date\":\"2020-10-27\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.24.0\",\"date\":\"2021-02-23\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"11.0.0\",\"date\":\"2018-10-23\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.28\"},{\"name\":\"nodejs\",\"version\":\"11.1.0\",\"date\":\"2018-10-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.32\"},{\"name\":\"nodejs\",\"version\":\"11.2.0\",\"date\":\"2018-11-15\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.3.0\",\"date\":\"2018-11-27\",\"lts\":false,\"security\":true,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.4.0\",\"date\":\"2018-12-07\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.5.0\",\"date\":\"2018-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.6.0\",\"date\":\"2018-12-26\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.7.0\",\"date\":\"2019-01-17\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.8.0\",\"date\":\"2019-01-24\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.9.0\",\"date\":\"2019-01-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.10.0\",\"date\":\"2019-02-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.11.0\",\"date\":\"2019-03-05\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.12.0\",\"date\":\"2019-03-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.13.0\",\"date\":\"2019-03-28\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.14.0\",\"date\":\"2019-04-10\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.15.0\",\"date\":\"2019-04-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"12.0.0\",\"date\":\"2019-04-23\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.1.0\",\"date\":\"2019-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.2.0\",\"date\":\"2019-05-07\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.3.0\",\"date\":\"2019-05-21\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.4.0\",\"date\":\"2019-06-04\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.5.0\",\"date\":\"2019-06-26\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.6.0\",\"date\":\"2019-07-03\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.7.0\",\"date\":\"2019-07-23\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.8.0\",\"date\":\"2019-08-06\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.9.0\",\"date\":\"2019-08-20\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.10.0\",\"date\":\"2019-09-04\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.11.0\",\"date\":\"2019-09-25\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.11\"},{\"name\":\"nodejs\",\"version\":\"12.12.0\",\"date\":\"2019-10-11\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.13.0\",\"date\":\"2019-10-21\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.14.0\",\"date\":\"2019-12-17\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.15.0\",\"date\":\"2020-02-05\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.16.0\",\"date\":\"2020-02-11\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.17.0\",\"date\":\"2020-05-26\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.18.0\",\"date\":\"2020-06-02\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.19.0\",\"date\":\"2020-10-06\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.20.0\",\"date\":\"2020-11-24\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.21.0\",\"date\":\"2021-02-23\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.22.0\",\"date\":\"2021-03-30\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"13.0.0\",\"date\":\"2019-10-22\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.1.0\",\"date\":\"2019-11-05\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.2.0\",\"date\":\"2019-11-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.23\"},{\"name\":\"nodejs\",\"version\":\"13.3.0\",\"date\":\"2019-12-03\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.4.0\",\"date\":\"2019-12-17\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.5.0\",\"date\":\"2019-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.6.0\",\"date\":\"2020-01-07\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.7.0\",\"date\":\"2020-01-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.8.0\",\"date\":\"2020-02-05\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.9.0\",\"date\":\"2020-02-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.10.0\",\"date\":\"2020-03-04\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.11.0\",\"date\":\"2020-03-12\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.12.0\",\"date\":\"2020-03-26\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.13.0\",\"date\":\"2020-04-14\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.14.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"14.0.0\",\"date\":\"2020-04-21\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.30\"},{\"name\":\"nodejs\",\"version\":\"14.1.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.2.0\",\"date\":\"2020-05-05\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.3.0\",\"date\":\"2020-05-19\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.4.0\",\"date\":\"2020-06-02\",\"lts\":false,\"security\":true,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.5.0\",\"date\":\"2020-06-30\",\"lts\":false,\"security\":false,\"v8\":\"8.3.110.9\"},{\"name\":\"nodejs\",\"version\":\"14.6.0\",\"date\":\"2020-07-20\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.7.0\",\"date\":\"2020-07-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.8.0\",\"date\":\"2020-08-11\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.9.0\",\"date\":\"2020-08-27\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.10.0\",\"date\":\"2020-09-08\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.11.0\",\"date\":\"2020-09-15\",\"lts\":false,\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.12.0\",\"date\":\"2020-09-22\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.13.0\",\"date\":\"2020-09-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.14.0\",\"date\":\"2020-10-15\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.15.0\",\"date\":\"2020-10-27\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.16.0\",\"date\":\"2021-02-23\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.17.0\",\"date\":\"2021-05-11\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.18.0\",\"date\":\"2021-09-28\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.19.0\",\"date\":\"2022-02-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.20.0\",\"date\":\"2022-07-07\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.21.0\",\"date\":\"2022-11-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"15.0.0\",\"date\":\"2020-10-20\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.16\"},{\"name\":\"nodejs\",\"version\":\"15.1.0\",\"date\":\"2020-11-04\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.2.0\",\"date\":\"2020-11-10\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.3.0\",\"date\":\"2020-11-24\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.4.0\",\"date\":\"2020-12-09\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.5.0\",\"date\":\"2020-12-22\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.6.0\",\"date\":\"2021-01-14\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.7.0\",\"date\":\"2021-01-25\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.8.0\",\"date\":\"2021-02-02\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.9.0\",\"date\":\"2021-02-18\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.10.0\",\"date\":\"2021-02-23\",\"lts\":false,\"security\":true,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.11.0\",\"date\":\"2021-03-03\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.12.0\",\"date\":\"2021-03-17\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.13.0\",\"date\":\"2021-03-31\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.14.0\",\"date\":\"2021-04-06\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"16.0.0\",\"date\":\"2021-04-20\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.17\"},{\"name\":\"nodejs\",\"version\":\"16.1.0\",\"date\":\"2021-05-04\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.24\"},{\"name\":\"nodejs\",\"version\":\"16.2.0\",\"date\":\"2021-05-19\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.3.0\",\"date\":\"2021-06-03\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.4.0\",\"date\":\"2021-06-23\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.36\"},{\"name\":\"nodejs\",\"version\":\"16.5.0\",\"date\":\"2021-07-14\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.38\"},{\"name\":\"nodejs\",\"version\":\"16.6.0\",\"date\":\"2021-07-29\",\"lts\":false,\"security\":true,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.7.0\",\"date\":\"2021-08-18\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.8.0\",\"date\":\"2021-08-25\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.9.0\",\"date\":\"2021-09-07\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.16\"},{\"name\":\"nodejs\",\"version\":\"16.10.0\",\"date\":\"2021-09-22\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.19\"},{\"name\":\"nodejs\",\"version\":\"16.11.0\",\"date\":\"2021-10-08\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.12.0\",\"date\":\"2021-10-20\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.13.0\",\"date\":\"2021-10-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.14.0\",\"date\":\"2022-02-08\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.15.0\",\"date\":\"2022-04-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.16.0\",\"date\":\"2022-07-07\",\"lts\":\"Gallium\",\"security\":true,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.17.0\",\"date\":\"2022-08-16\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.18.0\",\"date\":\"2022-10-12\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.19.0\",\"date\":\"2022-12-13\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.20.0\",\"date\":\"2023-03-28\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"17.0.0\",\"date\":\"2021-10-19\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.21\"},{\"name\":\"nodejs\",\"version\":\"17.1.0\",\"date\":\"2021-11-09\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.25\"},{\"name\":\"nodejs\",\"version\":\"17.2.0\",\"date\":\"2021-11-30\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.14\"},{\"name\":\"nodejs\",\"version\":\"17.3.0\",\"date\":\"2021-12-17\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.4.0\",\"date\":\"2022-01-18\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.5.0\",\"date\":\"2022-02-10\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.6.0\",\"date\":\"2022-02-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.7.0\",\"date\":\"2022-03-09\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.8.0\",\"date\":\"2022-03-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.9.0\",\"date\":\"2022-04-07\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"18.0.0\",\"date\":\"2022-04-18\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.1.0\",\"date\":\"2022-05-03\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.2.0\",\"date\":\"2022-05-17\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.3.0\",\"date\":\"2022-06-02\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.4.0\",\"date\":\"2022-06-16\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.5.0\",\"date\":\"2022-07-06\",\"lts\":false,\"security\":true,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.6.0\",\"date\":\"2022-07-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.7.0\",\"date\":\"2022-07-26\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.8.0\",\"date\":\"2022-08-24\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.9.0\",\"date\":\"2022-09-07\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.10.0\",\"date\":\"2022-09-28\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.11.0\",\"date\":\"2022-10-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.12.0\",\"date\":\"2022-10-25\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.13.0\",\"date\":\"2023-01-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.14.0\",\"date\":\"2023-02-01\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.15.0\",\"date\":\"2023-03-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.16.0\",\"date\":\"2023-04-12\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.17.0\",\"date\":\"2023-07-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.18.0\",\"date\":\"2023-09-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.19.0\",\"date\":\"2023-11-29\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.20.0\",\"date\":\"2024-03-26\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"19.0.0\",\"date\":\"2022-10-17\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.13\"},{\"name\":\"nodejs\",\"version\":\"19.1.0\",\"date\":\"2022-11-14\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.20\"},{\"name\":\"nodejs\",\"version\":\"19.2.0\",\"date\":\"2022-11-29\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.20\"},{\"name\":\"nodejs\",\"version\":\"19.3.0\",\"date\":\"2022-12-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.21\"},{\"name\":\"nodejs\",\"version\":\"19.4.0\",\"date\":\"2023-01-05\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.5.0\",\"date\":\"2023-01-24\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.6.0\",\"date\":\"2023-02-01\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.7.0\",\"date\":\"2023-02-21\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.8.0\",\"date\":\"2023-03-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.9.0\",\"date\":\"2023-04-10\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"20.0.0\",\"date\":\"2023-04-17\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.4\"},{\"name\":\"nodejs\",\"version\":\"20.1.0\",\"date\":\"2023-05-03\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.2.0\",\"date\":\"2023-05-16\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.3.0\",\"date\":\"2023-06-08\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.4.0\",\"date\":\"2023-07-04\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.5.0\",\"date\":\"2023-07-19\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.6.0\",\"date\":\"2023-08-23\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.7.0\",\"date\":\"2023-09-18\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.8.0\",\"date\":\"2023-09-28\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.9.0\",\"date\":\"2023-10-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.10.0\",\"date\":\"2023-11-22\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.11.0\",\"date\":\"2024-01-09\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.12.0\",\"date\":\"2024-03-26\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.13.0\",\"date\":\"2024-05-07\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.14.0\",\"date\":\"2024-05-28\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.15.0\",\"date\":\"2024-06-20\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.16.0\",\"date\":\"2024-07-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.17.0\",\"date\":\"2024-08-21\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.18.0\",\"date\":\"2024-10-03\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.19.0\",\"date\":\"2025-03-13\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"21.0.0\",\"date\":\"2023-10-17\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.13\"},{\"name\":\"nodejs\",\"version\":\"21.1.0\",\"date\":\"2023-10-24\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.15\"},{\"name\":\"nodejs\",\"version\":\"21.2.0\",\"date\":\"2023-11-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.3.0\",\"date\":\"2023-11-30\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.4.0\",\"date\":\"2023-12-05\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.5.0\",\"date\":\"2023-12-19\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.6.0\",\"date\":\"2024-01-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.7.0\",\"date\":\"2024-03-06\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"22.0.0\",\"date\":\"2024-04-24\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.1.0\",\"date\":\"2024-05-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.2.0\",\"date\":\"2024-05-15\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.3.0\",\"date\":\"2024-06-11\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.20\"},{\"name\":\"nodejs\",\"version\":\"22.4.0\",\"date\":\"2024-07-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.5.0\",\"date\":\"2024-07-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.6.0\",\"date\":\"2024-08-06\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.7.0\",\"date\":\"2024-08-21\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.8.0\",\"date\":\"2024-09-03\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.9.0\",\"date\":\"2024-09-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.10.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.11.0\",\"date\":\"2024-10-29\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.12.0\",\"date\":\"2024-12-02\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.13.0\",\"date\":\"2025-01-06\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.14.0\",\"date\":\"2025-02-11\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.15.0\",\"date\":\"2025-04-22\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.16.0\",\"date\":\"2025-05-20\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.17.0\",\"date\":\"2025-06-24\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.18.0\",\"date\":\"2025-07-31\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.19.0\",\"date\":\"2025-08-28\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.20.0\",\"date\":\"2025-09-24\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.21.0\",\"date\":\"2025-10-20\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"23.0.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.26\"},{\"name\":\"nodejs\",\"version\":\"23.1.0\",\"date\":\"2024-10-24\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.2.0\",\"date\":\"2024-11-11\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.3.0\",\"date\":\"2024-11-20\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.4.0\",\"date\":\"2024-12-10\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.5.0\",\"date\":\"2024-12-19\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.6.0\",\"date\":\"2025-01-07\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.7.0\",\"date\":\"2025-01-30\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.8.0\",\"date\":\"2025-02-13\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.9.0\",\"date\":\"2025-02-26\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.10.0\",\"date\":\"2025-03-13\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.11.0\",\"date\":\"2025-04-01\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"24.0.0\",\"date\":\"2025-05-06\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.8\"},{\"name\":\"nodejs\",\"version\":\"24.1.0\",\"date\":\"2025-05-20\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.2.0\",\"date\":\"2025-06-09\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.3.0\",\"date\":\"2025-06-24\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.4.0\",\"date\":\"2025-07-09\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.5.0\",\"date\":\"2025-07-31\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.6.0\",\"date\":\"2025-08-14\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.7.0\",\"date\":\"2025-08-27\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.8.0\",\"date\":\"2025-09-10\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.9.0\",\"date\":\"2025-09-25\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.10.0\",\"date\":\"2025-10-08\",\"lts\":false,\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"24.11.0\",\"date\":\"2025-10-28\",\"lts\":\"Krypton\",\"security\":false,\"v8\":\"13.6.233.10\"},{\"name\":\"nodejs\",\"version\":\"25.0.0\",\"date\":\"2025-10-15\",\"lts\":false,\"security\":false,\"v8\":\"14.1.146.11\"},{\"name\":\"nodejs\",\"version\":\"25.1.0\",\"date\":\"2025-10-28\",\"lts\":false,\"security\":false,\"v8\":\"14.1.146.11\"}]");

var agents$1 = {};

var browsers$2 = {};

var browsers$1;
var hasRequiredBrowsers$2;

function requireBrowsers$2 () {
	if (hasRequiredBrowsers$2) return browsers$1;
	hasRequiredBrowsers$2 = 1;
	browsers$1={A:"ie",B:"edge",C:"firefox",D:"chrome",E:"safari",F:"opera",G:"ios_saf",H:"op_mini",I:"android",J:"bb",K:"op_mob",L:"and_chr",M:"and_ff",N:"ie_mob",O:"and_uc",P:"samsung",Q:"and_qq",R:"baidu",S:"kaios"};
	return browsers$1;
}

var hasRequiredBrowsers$1;

function requireBrowsers$1 () {
	if (hasRequiredBrowsers$1) return browsers$2;
	hasRequiredBrowsers$1 = 1;
	browsers$2.browsers = requireBrowsers$2();
	return browsers$2;
}

var browserVersions$1 = {};

var browserVersions;
var hasRequiredBrowserVersions$1;

function requireBrowserVersions$1 () {
	if (hasRequiredBrowserVersions$1) return browserVersions;
	hasRequiredBrowserVersions$1 = 1;
	browserVersions={"0":"117","1":"118","2":"119","3":"120","4":"121","5":"122","6":"20","7":"21","8":"22","9":"23",A:"10",B:"11",C:"12",D:"7",E:"8",F:"9",G:"15",H:"80",I:"142",J:"4",K:"6",L:"13",M:"14",N:"16",O:"17",P:"18",Q:"79",R:"81",S:"83",T:"84",U:"85",V:"86",W:"87",X:"88",Y:"89",Z:"90",a:"91",b:"92",c:"93",d:"94",e:"95",f:"96",g:"97",h:"98",i:"99",j:"100",k:"101",l:"102",m:"103",n:"104",o:"105",p:"106",q:"107",r:"108",s:"109",t:"110",u:"111",v:"112",w:"113",x:"114",y:"115",z:"116",AB:"24",BB:"25",CB:"26",DB:"27",EB:"28",FB:"29",GB:"123",HB:"124",IB:"125",JB:"126",KB:"127",LB:"128",MB:"129",NB:"130",OB:"131",PB:"132",QB:"133",RB:"134",SB:"135",TB:"136",UB:"137",VB:"138",WB:"139",XB:"140",YB:"141",ZB:"143",aB:"5",bB:"19",cB:"30",dB:"31",eB:"32",fB:"33",gB:"34",hB:"35",iB:"36",jB:"37",kB:"38",lB:"39",mB:"40",nB:"41",oB:"42",pB:"43",qB:"44",rB:"45",sB:"46",tB:"47",uB:"48",vB:"49",wB:"50",xB:"51",yB:"52",zB:"53","0B":"54","1B":"55","2B":"56","3B":"57","4B":"58","5B":"60","6B":"62","7B":"63","8B":"64","9B":"65",AC:"66",BC:"67",CC:"68",DC:"69",EC:"70",FC:"71",GC:"72",HC:"73",IC:"74",JC:"75",KC:"76",LC:"77",MC:"78",NC:"144",OC:"11.1",PC:"12.1",QC:"15.5",RC:"16.0",SC:"17.0",TC:"18.0",UC:"3",VC:"59",WC:"61",XC:"82",YC:"145",ZC:"146",aC:"3.2",bC:"10.1",cC:"15.2-15.3",dC:"15.4",eC:"16.1",fC:"16.2",gC:"16.3",hC:"16.4",iC:"16.5",jC:"17.1",kC:"17.2",lC:"17.3",mC:"17.4",nC:"17.5",oC:"18.1",pC:"18.2",qC:"18.3",rC:"18.4",sC:"26.0",tC:"26.1",uC:"11.5",vC:"4.2-4.3",wC:"5.5",xC:"2",yC:"147",zC:"148","0C":"3.5","1C":"3.6","2C":"3.1","3C":"5.1","4C":"6.1","5C":"7.1","6C":"9.1","7C":"13.1","8C":"14.1","9C":"15.1",AD:"15.6",BD:"16.6",CD:"17.6",DD:"18.5-18.6",ED:"26.2",FD:"TP",GD:"9.5-9.6",HD:"10.0-10.1",ID:"10.5",JD:"10.6",KD:"11.6",LD:"4.0-4.1",MD:"5.0-5.1",ND:"6.0-6.1",OD:"7.0-7.1",PD:"8.1-8.4",QD:"9.0-9.2",RD:"9.3",SD:"10.0-10.2",TD:"10.3",UD:"11.0-11.2",VD:"11.3-11.4",WD:"12.0-12.1",XD:"12.2-12.5",YD:"13.0-13.1",ZD:"13.2",aD:"13.3",bD:"13.4-13.7",cD:"14.0-14.4",dD:"14.5-14.8",eD:"15.0-15.1",fD:"15.6-15.8",gD:"16.6-16.7",hD:"17.6-17.7",iD:"18.5-18.7",jD:"all",kD:"2.1",lD:"2.2",mD:"2.3",nD:"4.1",oD:"4.4",pD:"4.4.3-4.4.4",qD:"5.0-5.4",rD:"6.2-6.4",sD:"7.2-7.4",tD:"8.2",uD:"9.2",vD:"11.1-11.2",wD:"12.0",xD:"13.0",yD:"14.0",zD:"15.0","0D":"19.0","1D":"14.9","2D":"13.52","3D":"2.5","4D":"3.0-3.1"};
	return browserVersions;
}

var hasRequiredBrowserVersions;

function requireBrowserVersions () {
	if (hasRequiredBrowserVersions) return browserVersions$1;
	hasRequiredBrowserVersions = 1;
	browserVersions$1.browserVersions = requireBrowserVersions$1();
	return browserVersions$1;
}

var agents;
var hasRequiredAgents$1;

function requireAgents$1 () {
	if (hasRequiredAgents$1) return agents;
	hasRequiredAgents$1 = 1;
	agents={A:{A:{K:0,D:0,E:0.0347693,F:0.052154,A:0,B:0.330309,wC:0},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","wC","K","D","E","F","A","B","","",""],E:"IE",F:{wC:962323200,K:998870400,D:1161129600,E:1237420800,F:1300060800,A:1346716800,B:1381968000}},B:{A:{"0":0,"1":0,"2":0,"3":0.028128,"4":0.032816,"5":0.009376,C:0,L:0,M:0,G:0,N:0,O:0,P:0,Q:0,H:0,R:0,S:0,T:0,U:0,V:0,W:0,X:0,Y:0,Z:0,a:0,b:0.009376,c:0,d:0,e:0,f:0,g:0,h:0,i:0,j:0,k:0,l:0,m:0,n:0,o:0,p:0,q:0,r:0,s:0.032816,t:0,u:0,v:0,w:0,x:0.037504,y:0,z:0,GB:0,HB:0,IB:0,JB:0.004688,KB:0.004688,LB:0.004688,MB:0.004688,NB:0.004688,OB:0.018752,PB:0.009376,QB:0.009376,RB:0.009376,SB:0.014064,TB:0.014064,UB:0.014064,VB:0.028128,WB:0.028128,XB:0.065632,YB:0.501616,I:3.72227,ZB:0.009376},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","C","L","M","G","N","O","P","Q","H","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","GB","HB","IB","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","YB","I","ZB","","",""],E:"Edge",F:{"0":1694649600,"1":1697155200,"2":1698969600,"3":1701993600,"4":1706227200,"5":1708732800,C:1438128000,L:1447286400,M:1470096000,G:1491868800,N:1508198400,O:1525046400,P:1542067200,Q:1579046400,H:1581033600,R:1586736000,S:1590019200,T:1594857600,U:1598486400,V:1602201600,W:1605830400,X:1611360000,Y:1614816000,Z:1618358400,a:1622073600,b:1626912000,c:1630627200,d:1632441600,e:1634774400,f:1637539200,g:1641427200,h:1643932800,i:1646265600,j:1649635200,k:1651190400,l:1653955200,m:1655942400,n:1659657600,o:1661990400,p:1664755200,q:1666915200,r:1670198400,s:1673481600,t:1675900800,u:1678665600,v:1680825600,w:1683158400,x:1685664000,y:1689897600,z:1692576000,GB:1711152000,HB:1713398400,IB:1715990400,JB:1718841600,KB:1721865600,LB:1724371200,MB:1726704000,NB:1729123200,OB:1731542400,PB:1737417600,QB:1740614400,RB:1741219200,SB:1743984000,TB:1746316800,UB:1748476800,VB:1750896000,WB:1754611200,XB:1756944000,YB:1759363200,I:1761868800,ZB:1764806400},D:{C:"ms",L:"ms",M:"ms",G:"ms",N:"ms",O:"ms",P:"ms"}},C:{A:{"0":0,"1":0.1172,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,xC:0,UC:0,J:0,aB:0.004688,K:0,D:0,E:0,F:0,A:0,B:0.051568,C:0,L:0,M:0,G:0,N:0,O:0,P:0,bB:0,AB:0,BB:0,CB:0,DB:0,EB:0,FB:0,cB:0,dB:0,eB:0,fB:0,gB:0,hB:0,iB:0,jB:0,kB:0,lB:0,mB:0,nB:0,oB:0,pB:0.037504,qB:0,rB:0,sB:0,tB:0,uB:0,vB:0,wB:0,xB:0,yB:0.014064,zB:0,"0B":0,"1B":0,"2B":0,"3B":0,"4B":0,VC:0,"5B":0,WC:0,"6B":0,"7B":0,"8B":0,"9B":0,AC:0,BC:0,CC:0,DC:0,EC:0,FC:0,GC:0,HC:0,IC:0,JC:0,KC:0,LC:0,MC:0.004688,Q:0,H:0,R:0,XC:0,S:0,T:0,U:0,V:0,W:0,X:0,Y:0,Z:0,a:0,b:0,c:0,d:0,e:0,f:0,g:0,h:0,i:0,j:0,k:0,l:0,m:0,n:0,o:0,p:0,q:0,r:0,s:0,t:0,u:0,v:0,w:0,x:0,y:0.145328,z:0,GB:0,HB:0,IB:0.004688,JB:0,KB:0,LB:0.02344,MB:0,NB:0,OB:0,PB:0.009376,QB:0,RB:0,SB:0.009376,TB:0.009376,UB:0.004688,VB:0.004688,WB:0.004688,XB:0.079696,YB:0.009376,I:0.014064,ZB:0.032816,NC:0.614128,YC:0.72664,ZC:0,yC:0,zC:0,"0C":0,"1C":0},B:"moz",C:["xC","UC","0C","1C","J","aB","K","D","E","F","A","B","C","L","M","G","N","O","P","bB","6","7","8","9","AB","BB","CB","DB","EB","FB","cB","dB","eB","fB","gB","hB","iB","jB","kB","lB","mB","nB","oB","pB","qB","rB","sB","tB","uB","vB","wB","xB","yB","zB","0B","1B","2B","3B","4B","VC","5B","WC","6B","7B","8B","9B","AC","BC","CC","DC","EC","FC","GC","HC","IC","JC","KC","LC","MC","Q","H","R","XC","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","GB","HB","IB","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","YB","I","ZB","NC","YC","ZC","yC","zC"],E:"Firefox",F:{"0":1693267200,"1":1695686400,"2":1698105600,"3":1700524800,"4":1702944000,"5":1705968000,"6":1361232000,"7":1364860800,"8":1368489600,"9":1372118400,xC:1161648000,UC:1213660800,"0C":1246320000,"1C":1264032000,J:1300752000,aB:1308614400,K:1313452800,D:1317081600,E:1317081600,F:1320710400,A:1324339200,B:1327968000,C:1331596800,L:1335225600,M:1338854400,G:1342483200,N:1346112000,O:1349740800,P:1353628800,bB:1357603200,AB:1375747200,BB:1379376000,CB:1386633600,DB:1391472000,EB:1395100800,FB:1398729600,cB:1402358400,dB:1405987200,eB:1409616000,fB:1413244800,gB:1417392000,hB:1421107200,iB:1424736000,jB:1428278400,kB:1431475200,lB:1435881600,mB:1439251200,nB:1442880000,oB:1446508800,pB:1450137600,qB:1453852800,rB:1457395200,sB:1461628800,tB:1465257600,uB:1470096000,vB:1474329600,wB:1479168000,xB:1485216000,yB:1488844800,zB:1492560000,"0B":1497312000,"1B":1502150400,"2B":1506556800,"3B":1510617600,"4B":1516665600,VC:1520985600,"5B":1525824000,WC:1529971200,"6B":1536105600,"7B":1540252800,"8B":1544486400,"9B":1548720000,AC:1552953600,BC:1558396800,CC:1562630400,DC:1567468800,EC:1571788800,FC:1575331200,GC:1578355200,HC:1581379200,IC:1583798400,JC:1586304000,KC:1588636800,LC:1591056000,MC:1593475200,Q:1595894400,H:1598313600,R:1600732800,XC:1603152000,S:1605571200,T:1607990400,U:1611619200,V:1614038400,W:1616457600,X:1618790400,Y:1622505600,Z:1626134400,a:1628553600,b:1630972800,c:1633392000,d:1635811200,e:1638835200,f:1641859200,g:1644364800,h:1646697600,i:1649116800,j:1651536000,k:1653955200,l:1656374400,m:1658793600,n:1661212800,o:1663632000,p:1666051200,q:1668470400,r:1670889600,s:1673913600,t:1676332800,u:1678752000,v:1681171200,w:1683590400,x:1686009600,y:1688428800,z:1690848000,GB:1708387200,HB:1710806400,IB:1713225600,JB:1715644800,KB:1718064000,LB:1720483200,MB:1722902400,NB:1725321600,OB:1727740800,PB:1730160000,QB:1732579200,RB:1736208000,SB:1738627200,TB:1741046400,UB:1743465600,VB:1745884800,WB:1748304000,XB:1750723200,YB:1753142400,I:1755561600,ZB:1757980800,NC:1760400000,YC:1762819200,ZC:null,yC:null,zC:null}},D:{A:{"0":0.14064,"1":0.103136,"2":0.04688,"3":0.196896,"4":0.1172,"5":0.098448,"6":0,"7":0,"8":0,"9":0,J:0,aB:0,K:0,D:0,E:0,F:0,A:0,B:0,C:0,L:0,M:0,G:0,N:0,O:0,P:0,bB:0,AB:0,BB:0,CB:0,DB:0,EB:0,FB:0,cB:0,dB:0,eB:0,fB:0,gB:0,hB:0,iB:0,jB:0,kB:0,lB:0.004688,mB:0.004688,nB:0.004688,oB:0.004688,pB:0.004688,qB:0.004688,rB:0.009376,sB:0.004688,tB:0.009376,uB:0.014064,vB:0.014064,wB:0.004688,xB:0.004688,yB:0.014064,zB:0.009376,"0B":0.004688,"1B":0.004688,"2B":0.009376,"3B":0.004688,"4B":0.009376,VC:0.004688,"5B":0.004688,WC:0,"6B":0,"7B":0,"8B":0,"9B":0,AC:0.018752,BC:0,CC:0,DC:0.014064,EC:0.004688,FC:0,GC:0,HC:0,IC:0,JC:0,KC:0,LC:0.014064,MC:0.004688,Q:0.075008,H:0.004688,R:0.014064,S:0.04688,T:0,U:0.009376,V:0.009376,W:0.037504,X:0.004688,Y:0,Z:0,a:0.018752,b:0.014064,c:0.014064,d:0,e:0,f:0,g:0.014064,h:0.042192,i:0.018752,j:0.004688,k:0.014064,l:0.009376,m:0.079696,n:0.014064,o:0.173456,p:0.112512,q:0.07032,r:0.042192,s:0.731328,t:0.168768,u:0.089072,v:2.29712,w:0.060944,x:0.182832,y:0.037504,z:0.075008,GB:0.079696,HB:0.075008,IB:0.49224,JB:0.525056,KB:0.159392,LB:0.150016,MB:0.135952,NB:0.89072,OB:0.290656,PB:0.103136,QB:0.07032,RB:1.08762,SB:0.065632,TB:0.065632,UB:0.482864,VB:0.318784,WB:3.44099,XB:0.684448,YB:3.75978,I:11.1809,ZB:0.042192,NC:0.009376,YC:0,ZC:0},B:"webkit",C:["","","","","","","","J","aB","K","D","E","F","A","B","C","L","M","G","N","O","P","bB","6","7","8","9","AB","BB","CB","DB","EB","FB","cB","dB","eB","fB","gB","hB","iB","jB","kB","lB","mB","nB","oB","pB","qB","rB","sB","tB","uB","vB","wB","xB","yB","zB","0B","1B","2B","3B","4B","VC","5B","WC","6B","7B","8B","9B","AC","BC","CC","DC","EC","FC","GC","HC","IC","JC","KC","LC","MC","Q","H","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","GB","HB","IB","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","YB","I","ZB","NC","YC","ZC"],E:"Chrome",F:{"0":1694476800,"1":1696896000,"2":1698710400,"3":1701993600,"4":1705968000,"5":1708387200,"6":1337040000,"7":1340668800,"8":1343692800,"9":1348531200,J:1264377600,aB:1274745600,K:1283385600,D:1287619200,E:1291248000,F:1296777600,A:1299542400,B:1303862400,C:1307404800,L:1312243200,M:1316131200,G:1316131200,N:1319500800,O:1323734400,P:1328659200,bB:1332892800,AB:1352246400,BB:1357862400,CB:1361404800,DB:1364428800,EB:1369094400,FB:1374105600,cB:1376956800,dB:1384214400,eB:1389657600,fB:1392940800,gB:1397001600,hB:1400544000,iB:1405468800,jB:1409011200,kB:1412640000,lB:1416268800,mB:1421798400,nB:1425513600,oB:1429401600,pB:1432080000,qB:1437523200,rB:1441152000,sB:1444780800,tB:1449014400,uB:1453248000,vB:1456963200,wB:1460592000,xB:1464134400,yB:1469059200,zB:1472601600,"0B":1476230400,"1B":1480550400,"2B":1485302400,"3B":1489017600,"4B":1492560000,VC:1496707200,"5B":1500940800,WC:1504569600,"6B":1508198400,"7B":1512518400,"8B":1516752000,"9B":1520294400,AC:1523923200,BC:1527552000,CC:1532390400,DC:1536019200,EC:1539648000,FC:1543968000,GC:1548720000,HC:1552348800,IC:1555977600,JC:1559606400,KC:1564444800,LC:1568073600,MC:1571702400,Q:1575936000,H:1580860800,R:1586304000,S:1589846400,T:1594684800,U:1598313600,V:1601942400,W:1605571200,X:1611014400,Y:1614556800,Z:1618272000,a:1621987200,b:1626739200,c:1630368000,d:1632268800,e:1634601600,f:1637020800,g:1641340800,h:1643673600,i:1646092800,j:1648512000,k:1650931200,l:1653350400,m:1655769600,n:1659398400,o:1661817600,p:1664236800,q:1666656000,r:1669680000,s:1673308800,t:1675728000,u:1678147200,v:1680566400,w:1682985600,x:1685404800,y:1689724800,z:1692057600,GB:1710806400,HB:1713225600,IB:1715644800,JB:1718064000,KB:1721174400,LB:1724112000,MB:1726531200,NB:1728950400,OB:1731369600,PB:1736812800,QB:1738627200,RB:1741046400,SB:1743465600,TB:1745884800,UB:1748304000,VB:1750723200,WB:1754352000,XB:1756771200,YB:1759190400,I:1761609600,ZB:1764633600,NC:null,YC:null,ZC:null}},E:{A:{J:0,aB:0,K:0,D:0,E:0,F:0,A:0,B:0,C:0,L:0,M:0.009376,G:0,"2C":0,aC:0,"3C":0,"4C":0,"5C":0,"6C":0,bC:0,OC:0.004688,PC:0,"7C":0.018752,"8C":0.02344,"9C":0.004688,cC:0,dC:0.004688,QC:0.009376,AD:0.089072,RC:0.004688,eC:0.009376,fC:0.009376,gC:0.018752,hC:0.009376,iC:0.014064,BD:0.131264,SC:0.004688,jC:0.09376,kC:0.009376,lC:0.014064,mC:0.02344,nC:0.037504,CD:0.14064,TC:0.014064,oC:0.02344,pC:0.014064,qC:0.051568,rC:0.028128,DD:0.1172,sC:0.206272,tC:0.229712,ED:0.009376,FD:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","2C","aC","J","aB","3C","K","4C","D","5C","E","F","6C","A","bC","B","OC","C","PC","L","7C","M","8C","G","9C","cC","dC","QC","AD","RC","eC","fC","gC","hC","iC","BD","SC","jC","kC","lC","mC","nC","CD","TC","oC","pC","qC","rC","DD","sC","tC","ED","FD","",""],E:"Safari",F:{"2C":1205798400,aC:1226534400,J:1244419200,aB:1275868800,"3C":1311120000,K:1343174400,"4C":1382400000,D:1382400000,"5C":1410998400,E:1413417600,F:1443657600,"6C":1458518400,A:1474329600,bC:1490572800,B:1505779200,OC:1522281600,C:1537142400,PC:1553472000,L:1568851200,"7C":1585008000,M:1600214400,"8C":1619395200,G:1632096000,"9C":1635292800,cC:1639353600,dC:1647216000,QC:1652745600,AD:1658275200,RC:1662940800,eC:1666569600,fC:1670889600,gC:1674432000,hC:1679875200,iC:1684368000,BD:1690156800,SC:1695686400,jC:1698192000,kC:1702252800,lC:1705881600,mC:1709596800,nC:1715558400,CD:1722211200,TC:1726444800,oC:1730073600,pC:1733875200,qC:1737936000,rC:1743379200,DD:1747008000,sC:1757894400,tC:1762128000,ED:1762041600,FD:null}},F:{A:{"0":0,"1":0,"2":0,"3":0.009376,"4":0,"5":0.290656,"6":0,"7":0,"8":0,"9":0,F:0,B:0,C:0,G:0,N:0,O:0,P:0,bB:0,AB:0,BB:0,CB:0,DB:0,EB:0,FB:0,cB:0,dB:0,eB:0,fB:0,gB:0,hB:0,iB:0,jB:0,kB:0,lB:0,mB:0,nB:0,oB:0,pB:0,qB:0,rB:0,sB:0,tB:0,uB:0,vB:0,wB:0,xB:0,yB:0,zB:0,"0B":0,"1B":0,"2B":0,"3B":0,"4B":0,"5B":0,"6B":0,"7B":0,"8B":0,"9B":0,AC:0,BC:0,CC:0,DC:0,EC:0,FC:0,GC:0,HC:0,IC:0,JC:0,KC:0,LC:0,MC:0,Q:0,H:0,R:0,XC:0,S:0,T:0,U:0,V:0,W:0,X:0,Y:0,Z:0,a:0,b:0.075008,c:0.009376,d:0,e:0.028128,f:0,g:0,h:0,i:0,j:0,k:0,l:0,m:0,n:0,o:0,p:0,q:0,r:0,s:0,t:0,u:0,v:0,w:0,x:0,y:0,z:0,GD:0,HD:0,ID:0,JD:0,OC:0,uC:0,KD:0,PC:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","F","GD","HD","ID","JD","B","OC","uC","KD","C","PC","G","N","O","P","bB","6","7","8","9","AB","BB","CB","DB","EB","FB","cB","dB","eB","fB","gB","hB","iB","jB","kB","lB","mB","nB","oB","pB","qB","rB","sB","tB","uB","vB","wB","xB","yB","zB","0B","1B","2B","3B","4B","5B","6B","7B","8B","9B","AC","BC","CC","DC","EC","FC","GC","HC","IC","JC","KC","LC","MC","Q","H","R","XC","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","","",""],E:"Opera",F:{"0":1739404800,"1":1744675200,"2":1747094400,"3":1751414400,"4":1756339200,"5":1757548800,"6":1393891200,"7":1399334400,"8":1401753600,"9":1405987200,F:1150761600,GD:1223424000,HD:1251763200,ID:1267488000,JD:1277942400,B:1292457600,OC:1302566400,uC:1309219200,KD:1323129600,C:1323129600,PC:1352073600,G:1372723200,N:1377561600,O:1381104000,P:1386288000,bB:1390867200,AB:1409616000,BB:1413331200,CB:1417132800,DB:1422316800,EB:1425945600,FB:1430179200,cB:1433808000,dB:1438646400,eB:1442448000,fB:1445904000,gB:1449100800,hB:1454371200,iB:1457308800,jB:1462320000,kB:1465344000,lB:1470096000,mB:1474329600,nB:1477267200,oB:1481587200,pB:1486425600,qB:1490054400,rB:1494374400,sB:1498003200,tB:1502236800,uB:1506470400,vB:1510099200,wB:1515024000,xB:1517961600,yB:1521676800,zB:1525910400,"0B":1530144000,"1B":1534982400,"2B":1537833600,"3B":1543363200,"4B":1548201600,"5B":1554768000,"6B":1561593600,"7B":1566259200,"8B":1570406400,"9B":1573689600,AC:1578441600,BC:1583971200,CC:1587513600,DC:1592956800,EC:1595894400,FC:1600128000,GC:1603238400,HC:1613520000,IC:1612224000,JC:1616544000,KC:1619568000,LC:1623715200,MC:1627948800,Q:1631577600,H:1633392000,R:1635984000,XC:1638403200,S:1642550400,T:1644969600,U:1647993600,V:1650412800,W:1652745600,X:1654646400,Y:1657152000,Z:1660780800,a:1663113600,b:1668816000,c:1668643200,d:1671062400,e:1675209600,f:1677024000,g:1679529600,h:1681948800,i:1684195200,j:1687219200,k:1690329600,l:1692748800,m:1696204800,n:1699920000,o:1699920000,p:1702944000,q:1707264000,r:1710115200,s:1711497600,t:1716336000,u:1719273600,v:1721088000,w:1724284800,x:1727222400,y:1732665600,z:1736294400},D:{F:"o",B:"o",C:"o",GD:"o",HD:"o",ID:"o",JD:"o",OC:"o",uC:"o",KD:"o",PC:"o"}},G:{A:{E:0,aC:0,LD:0,vC:0.0011798,MD:0,ND:0.00471918,OD:0.00353939,PD:0,QD:0,RD:0.0106182,SD:0.0011798,TD:0.0188767,UD:0.219442,VD:0.00707877,WD:0.00235959,XD:0.0554504,YD:0,ZD:0.00589898,aD:0.00235959,bD:0.0106182,cD:0.0176969,dD:0.0224161,eD:0.0188767,cC:0.0153373,dC:0.0165171,QC:0.0176969,fD:0.256016,RC:0.0318545,eC:0.0589898,fC:0.0306747,gC:0.0566302,hC:0.0141575,iC:0.0235959,gD:0.34568,SC:0.0294949,jC:0.0353939,kC:0.0259555,lC:0.0365737,mC:0.0601696,nC:0.11444,hD:0.280791,TC:0.0625291,oC:0.132137,pC:0.0707877,qC:0.23006,rC:0.11798,iD:5.77274,sC:0.563942,tC:0.515571},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","aC","LD","vC","MD","ND","OD","E","PD","QD","RD","SD","TD","UD","VD","WD","XD","YD","ZD","aD","bD","cD","dD","eD","cC","dC","QC","fD","RC","eC","fC","gC","hC","iC","gD","SC","jC","kC","lC","mC","nC","hD","TC","oC","pC","qC","rC","iD","sC","tC","",""],E:"Safari on iOS",F:{aC:1270252800,LD:1283904000,vC:1299628800,MD:1331078400,ND:1359331200,OD:1394409600,E:1410912000,PD:1413763200,QD:1442361600,RD:1458518400,SD:1473724800,TD:1490572800,UD:1505779200,VD:1522281600,WD:1537142400,XD:1553472000,YD:1568851200,ZD:1572220800,aD:1580169600,bD:1585008000,cD:1600214400,dD:1619395200,eD:1632096000,cC:1639353600,dC:1647216000,QC:1652659200,fD:1658275200,RC:1662940800,eC:1666569600,fC:1670889600,gC:1674432000,hC:1679875200,iC:1684368000,gD:1690156800,SC:1694995200,jC:1698192000,kC:1702252800,lC:1705881600,mC:1709596800,nC:1715558400,hD:1722211200,TC:1726444800,oC:1730073600,pC:1733875200,qC:1737936000,rC:1743379200,iD:1747008000,sC:1757894400,tC:null}},H:{A:{jD:0.04},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","jD","","",""],E:"Opera Mini",F:{jD:1426464000}},I:{A:{UC:0,J:0,I:0.461543,kD:0,lD:0,mD:0,nD:0,vC:0.0000924288,oD:0,pD:0.000231072},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kD","lD","mD","UC","J","nD","vC","oD","pD","I","","",""],E:"Android Browser",F:{kD:1256515200,lD:1274313600,mD:1291593600,UC:1298332800,J:1318896000,nD:1341792000,vC:1374624000,oD:1386547200,pD:1401667200,I:1761609600}},J:{A:{D:0,A:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","D","A","","",""],E:"Blackberry Browser",F:{D:1325376000,A:1359504000}},K:{A:{A:0,B:0,C:0,H:0.825856,OC:0,uC:0,PC:0},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","OC","uC","C","PC","H","","",""],E:"Opera Mobile",F:{A:1287100800,B:1300752000,OC:1314835200,uC:1318291200,C:1330300800,PC:1349740800,H:1709769600},D:{H:"webkit"}},L:{A:{I:41.8556},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","I","","",""],E:"Chrome for Android",F:{I:1761609600}},M:{A:{NC:0.302784},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","NC","","",""],E:"Firefox for Android",F:{NC:1760400000}},N:{A:{A:0,B:0},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","","",""],E:"IE Mobile",F:{A:1340150400,B:1353456000}},O:{A:{QC:0.573696},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","QC","","",""],E:"UC Browser for Android",F:{QC:1710115200},D:{QC:"webkit"}},P:{A:{"6":0,"7":0.0108341,"8":0.0108341,"9":0.0216682,J:0,AB:0.0216682,BB:0.0216682,CB:0.0433363,DB:0.0541704,EB:0.227516,FB:1.50594,qD:0,rD:0,sD:0,tD:0,uD:0,bC:0,vD:0,wD:0,xD:0,yD:0,zD:0,RC:0,SC:0,TC:0,"0D":0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","J","qD","rD","sD","tD","uD","bC","vD","wD","xD","yD","zD","RC","SC","TC","0D","6","7","8","9","AB","BB","CB","DB","EB","FB","","",""],E:"Samsung Internet",F:{"6":1677369600,"7":1684454400,"8":1689292800,"9":1697587200,J:1461024000,qD:1481846400,rD:1509408000,sD:1528329600,tD:1546128000,uD:1554163200,bC:1567900800,vD:1582588800,wD:1593475200,xD:1605657600,yD:1618531200,zD:1629072000,RC:1640736000,SC:1651708800,TC:1659657600,"0D":1667260800,AB:1711497600,BB:1715126400,CB:1717718400,DB:1725667200,EB:1746057600,FB:1761264000}},Q:{A:{"1D":0.148736},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","1D","","",""],E:"QQ Browser",F:{"1D":1710288000}},R:{A:{"2D":0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","2D","","",""],E:"Baidu Browser",F:{"2D":1710201600}},S:{A:{"3D":0.021248,"4D":0},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","3D","4D","","",""],E:"KaiOS Browser",F:{"3D":1527811200,"4D":1631664000}}};
	return agents;
}

var hasRequiredAgents;

function requireAgents () {
	if (hasRequiredAgents) return agents$1;
	hasRequiredAgents = 1;

	const browsers = requireBrowsers$1().browsers;
	const versions = requireBrowserVersions().browserVersions;
	const agentsData = requireAgents$1();

	function unpackBrowserVersions(versionsData) {
	  return Object.keys(versionsData).reduce((usage, version) => {
	    usage[versions[version]] = versionsData[version];
	    return usage
	  }, {})
	}

	agents$1.agents = Object.keys(agentsData).reduce((map, key) => {
	  let versionsData = agentsData[key];
	  map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => {
	    if (entry === 'A') {
	      data.usage_global = unpackBrowserVersions(versionsData[entry]);
	    } else if (entry === 'C') {
	      data.versions = versionsData[entry].reduce((list, version) => {
	        if (version === '') {
	          list.push(null);
	        } else {
	          list.push(versions[version]);
	        }
	        return list
	      }, []);
	    } else if (entry === 'D') {
	      data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
	    } else if (entry === 'E') {
	      data.browser = versionsData[entry];
	    } else if (entry === 'F') {
	      data.release_date = Object.keys(versionsData[entry]).reduce(
	        (map2, key2) => {
	          map2[versions[key2]] = versionsData[entry][key2];
	          return map2
	        },
	        {}
	      );
	    } else {
	      // entry is B
	      data.prefix = versionsData[entry];
	    }
	    return data
	  }, {});
	  return map
	}, {});
	return agents$1;
}

var versions;
var hasRequiredVersions;

function requireVersions () {
	if (hasRequiredVersions) return versions;
	hasRequiredVersions = 1;
	versions = {
		"0.20": "39",
		"0.21": "41",
		"0.22": "41",
		"0.23": "41",
		"0.24": "41",
		"0.25": "42",
		"0.26": "42",
		"0.27": "43",
		"0.28": "43",
		"0.29": "43",
		"0.30": "44",
		"0.31": "45",
		"0.32": "45",
		"0.33": "45",
		"0.34": "45",
		"0.35": "45",
		"0.36": "47",
		"0.37": "49",
		"1.0": "49",
		"1.1": "50",
		"1.2": "51",
		"1.3": "52",
		"1.4": "53",
		"1.5": "54",
		"1.6": "56",
		"1.7": "58",
		"1.8": "59",
		"2.0": "61",
		"2.1": "61",
		"3.0": "66",
		"3.1": "66",
		"4.0": "69",
		"4.1": "69",
		"4.2": "69",
		"5.0": "73",
		"6.0": "76",
		"6.1": "76",
		"7.0": "78",
		"7.1": "78",
		"7.2": "78",
		"7.3": "78",
		"8.0": "80",
		"8.1": "80",
		"8.2": "80",
		"8.3": "80",
		"8.4": "80",
		"8.5": "80",
		"9.0": "83",
		"9.1": "83",
		"9.2": "83",
		"9.3": "83",
		"9.4": "83",
		"10.0": "85",
		"10.1": "85",
		"10.2": "85",
		"10.3": "85",
		"10.4": "85",
		"11.0": "87",
		"11.1": "87",
		"11.2": "87",
		"11.3": "87",
		"11.4": "87",
		"11.5": "87",
		"12.0": "89",
		"12.1": "89",
		"12.2": "89",
		"13.0": "91",
		"13.1": "91",
		"13.2": "91",
		"13.3": "91",
		"13.4": "91",
		"13.5": "91",
		"13.6": "91",
		"14.0": "93",
		"14.1": "93",
		"14.2": "93",
		"15.0": "94",
		"15.1": "94",
		"15.2": "94",
		"15.3": "94",
		"15.4": "94",
		"15.5": "94",
		"16.0": "96",
		"16.1": "96",
		"16.2": "96",
		"17.0": "98",
		"17.1": "98",
		"17.2": "98",
		"17.3": "98",
		"17.4": "98",
		"18.0": "100",
		"18.1": "100",
		"18.2": "100",
		"18.3": "100",
		"19.0": "102",
		"19.1": "102",
		"20.0": "104",
		"20.1": "104",
		"20.2": "104",
		"20.3": "104",
		"21.0": "106",
		"21.1": "106",
		"21.2": "106",
		"21.3": "106",
		"21.4": "106",
		"22.0": "108",
		"22.1": "108",
		"22.2": "108",
		"22.3": "108",
		"23.0": "110",
		"23.1": "110",
		"23.2": "110",
		"23.3": "110",
		"24.0": "112",
		"24.1": "112",
		"24.2": "112",
		"24.3": "112",
		"24.4": "112",
		"24.5": "112",
		"24.6": "112",
		"24.7": "112",
		"24.8": "112",
		"25.0": "114",
		"25.1": "114",
		"25.2": "114",
		"25.3": "114",
		"25.4": "114",
		"25.5": "114",
		"25.6": "114",
		"25.7": "114",
		"25.8": "114",
		"25.9": "114",
		"26.0": "116",
		"26.1": "116",
		"26.2": "116",
		"26.3": "116",
		"26.4": "116",
		"26.5": "116",
		"26.6": "116",
		"27.0": "118",
		"27.1": "118",
		"27.2": "118",
		"27.3": "118",
		"28.0": "120",
		"28.1": "120",
		"28.2": "120",
		"28.3": "120",
		"29.0": "122",
		"29.1": "122",
		"29.2": "122",
		"29.3": "122",
		"29.4": "122",
		"30.0": "124",
		"30.1": "124",
		"30.2": "124",
		"30.3": "124",
		"30.4": "124",
		"30.5": "124",
		"31.0": "126",
		"31.1": "126",
		"31.2": "126",
		"31.3": "126",
		"31.4": "126",
		"31.5": "126",
		"31.6": "126",
		"31.7": "126",
		"32.0": "128",
		"32.1": "128",
		"32.2": "128",
		"32.3": "128",
		"33.0": "130",
		"33.1": "130",
		"33.2": "130",
		"33.3": "130",
		"33.4": "130",
		"34.0": "132",
		"34.1": "132",
		"34.2": "132",
		"34.3": "132",
		"34.4": "132",
		"34.5": "132",
		"35.0": "134",
		"35.1": "134",
		"35.2": "134",
		"35.3": "134",
		"35.4": "134",
		"35.5": "134",
		"35.6": "134",
		"35.7": "134",
		"36.0": "136",
		"36.1": "136",
		"36.2": "136",
		"36.3": "136",
		"36.4": "136",
		"36.5": "136",
		"36.6": "136",
		"36.7": "136",
		"36.8": "136",
		"36.9": "136",
		"37.0": "138",
		"37.1": "138",
		"37.2": "138",
		"37.3": "138",
		"37.4": "138",
		"37.5": "138",
		"37.6": "138",
		"37.7": "138",
		"37.8": "138",
		"37.9": "138",
		"37.10": "138",
		"38.0": "140",
		"38.1": "140",
		"38.2": "140",
		"38.3": "140",
		"38.4": "140",
		"38.5": "140",
		"38.6": "140",
		"38.7": "140",
		"39.0": "142",
		"39.1": "142",
		"39.2": "142",
		"40.0": "144"
	};
	return versions;
}

const v4 = {"start":"2015-09-08","lts":"2015-10-12","maintenance":"2017-04-01","end":"2018-04-30","codename":"Argon"};
const v5 = {"start":"2015-10-29","maintenance":"2016-04-30","end":"2016-06-30"};
const v6 = {"start":"2016-04-26","lts":"2016-10-18","maintenance":"2018-04-30","end":"2019-04-30","codename":"Boron"};
const v7 = {"start":"2016-10-25","maintenance":"2017-04-30","end":"2017-06-30"};
const v8 = {"start":"2017-05-30","lts":"2017-10-31","maintenance":"2019-01-01","end":"2019-12-31","codename":"Carbon"};
const v9 = {"start":"2017-10-01","maintenance":"2018-04-01","end":"2018-06-30"};
const v10 = {"start":"2018-04-24","lts":"2018-10-30","maintenance":"2020-05-19","end":"2021-04-30","codename":"Dubnium"};
const v11 = {"start":"2018-10-23","maintenance":"2019-04-22","end":"2019-06-01"};
const v12 = {"start":"2019-04-23","lts":"2019-10-21","maintenance":"2020-11-30","end":"2022-04-30","codename":"Erbium"};
const v13 = {"start":"2019-10-22","maintenance":"2020-04-01","end":"2020-06-01"};
const v14 = {"start":"2020-04-21","lts":"2020-10-27","maintenance":"2021-10-19","end":"2023-04-30","codename":"Fermium"};
const v15 = {"start":"2020-10-20","maintenance":"2021-04-01","end":"2021-06-01"};
const v16 = {"start":"2021-04-20","lts":"2021-10-26","maintenance":"2022-10-18","end":"2023-09-11","codename":"Gallium"};
const v17 = {"start":"2021-10-19","maintenance":"2022-04-01","end":"2022-06-01"};
const v18 = {"start":"2022-04-19","lts":"2022-10-25","maintenance":"2023-10-18","end":"2025-04-30","codename":"Hydrogen"};
const v19 = {"start":"2022-10-18","maintenance":"2023-04-01","end":"2023-06-01"};
const v20 = {"start":"2023-04-18","lts":"2023-10-24","maintenance":"2024-10-22","end":"2026-04-30","codename":"Iron"};
const v21 = {"start":"2023-10-17","maintenance":"2024-04-01","end":"2024-06-01"};
const v22 = {"start":"2024-04-24","lts":"2024-10-29","maintenance":"2025-10-21","end":"2027-04-30","codename":"Jod"};
const v23 = {"start":"2024-10-16","maintenance":"2025-04-01","end":"2025-06-01"};
const v24 = {"start":"2025-05-06","lts":"2025-10-28","maintenance":"2026-10-20","end":"2028-04-30","codename":"Krypton"};
const v25 = {"start":"2025-10-15","maintenance":"2026-04-01","end":"2026-06-01"};
const v26 = {"start":"2026-04-22","lts":"2026-10-28","maintenance":"2027-10-20","end":"2029-04-30","codename":""};
const require$$4 = {
  "v0.8": {"start":"2012-06-25","end":"2014-07-31"},
  "v0.10": {"start":"2013-03-11","end":"2016-10-31"},
  "v0.12": {"start":"2015-02-06","end":"2016-12-31"},
  v4,
  v5,
  v6,
  v7,
  v8,
  v9,
  v10,
  v11,
  v12,
  v13,
  v14,
  v15,
  v16,
  v17,
  v18,
  v19,
  v20,
  v21,
  v22,
  v23,
  v24,
  v25,
  v26,
};

var error;
var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	function BrowserslistError(message) {
	  this.name = 'BrowserslistError';
	  this.message = message;
	  this.browserslist = true;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, BrowserslistError);
	  }
	}

	BrowserslistError.prototype = Error.prototype;

	error = BrowserslistError;
	return error;
}

var node$1 = {exports: {}};

var feature = {exports: {}};

var statuses;
var hasRequiredStatuses;

function requireStatuses () {
	if (hasRequiredStatuses) return statuses;
	hasRequiredStatuses = 1;
	statuses = {
	  1: 'ls', // WHATWG Living Standard
	  2: 'rec', // W3C Recommendation
	  3: 'pr', // W3C Proposed Recommendation
	  4: 'cr', // W3C Candidate Recommendation
	  5: 'wd', // W3C Working Draft
	  6: 'other', // Non-W3C, but reputable
	  7: 'unoff' // Unofficial, Editor's Draft or W3C "Note"
	};
	return statuses;
}

var supported;
var hasRequiredSupported;

function requireSupported () {
	if (hasRequiredSupported) return supported;
	hasRequiredSupported = 1;
	supported = {
	  y: 1 << 0,
	  n: 1 << 1,
	  a: 1 << 2,
	  p: 1 << 3,
	  u: 1 << 4,
	  x: 1 << 5,
	  d: 1 << 6
	};
	return supported;
}

var hasRequiredFeature;

function requireFeature () {
	if (hasRequiredFeature) return feature.exports;
	hasRequiredFeature = 1;

	const statuses = requireStatuses();
	const supported = requireSupported();
	const browsers = requireBrowsers$1().browsers;
	const versions = requireBrowserVersions().browserVersions;

	const MATH2LOG = Math.log(2);

	function unpackSupport(cipher) {
	  // bit flags
	  let stats = Object.keys(supported).reduce((list, support) => {
	    if (cipher & supported[support]) list.push(support);
	    return list
	  }, []);

	  // notes
	  let notes = cipher >> 7;
	  let notesArray = [];
	  while (notes) {
	    let note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
	    notesArray.unshift(`#${note}`);
	    notes -= Math.pow(2, note - 1);
	  }

	  return stats.concat(notesArray).join(' ')
	}

	function unpackFeature(packed) {
	  let unpacked = {
	    status: statuses[packed.B],
	    title: packed.C,
	    shown: packed.D
	  };
	  unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
	    let browser = packed.A[key];
	    browserStats[browsers[key]] = Object.keys(browser).reduce(
	      (stats, support) => {
	        let packedVersions = browser[support].split(' ');
	        let unpacked2 = unpackSupport(support);
	        packedVersions.forEach(v => (stats[versions[v]] = unpacked2));
	        return stats
	      },
	      {}
	    );
	    return browserStats
	  }, {});
	  return unpacked
	}

	feature.exports = unpackFeature;
	feature.exports.default = unpackFeature;
	return feature.exports;
}

var region = {exports: {}};

var hasRequiredRegion;

function requireRegion () {
	if (hasRequiredRegion) return region.exports;
	hasRequiredRegion = 1;

	const browsers = requireBrowsers$1().browsers;

	function unpackRegion(packed) {
	  return Object.keys(packed).reduce((list, browser) => {
	    let data = packed[browser];
	    list[browsers[browser]] = Object.keys(data).reduce((memo, key) => {
	      let stats = data[key];
	      if (key === '_') {
	        stats.split(' ').forEach(version => (memo[version] = null));
	      } else {
	        memo[key] = stats;
	      }
	      return memo
	    }, {});
	    return list
	  }, {})
	}

	region.exports = unpackRegion;
	region.exports.default = unpackRegion;
	return region.exports;
}

var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1.exports;
	hasRequiredNode$1 = 1;
	(function (module) {
		var feature = requireFeature().default;
		var region = requireRegion().default;
		var fs = require$$0$4;
		var path = require$$0$2$1;

		var BrowserslistError = requireError();

		var IS_SECTION = /^\s*\[(.+)]\s*$/;
		var CONFIG_PATTERN = /^browserslist-config-/;
		var SCOPED_CONFIG__PATTERN = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/;
		var FORMAT =
		  'Browserslist config should be a string or an array ' +
		  'of strings with browser queries';
		var PATHTYPE_UNKNOWN = 'unknown';
		var PATHTYPE_DIR = 'directory';
		var PATHTYPE_FILE = 'file';

		var dataTimeChecked = false;
		var statCache = {};
		var configPathCache = {};
		var parseConfigCache = {};

		function checkExtend(name) {
		  var use = ' Use `dangerousExtend` option to disable.';
		  if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name)) {
		    throw new BrowserslistError(
		      'Browserslist config needs `browserslist-config-` prefix. ' + use
		    )
		  }
		  if (name.replace(/^@[^/]+\//, '').indexOf('.') !== -1) {
		    throw new BrowserslistError(
		      '`.` not allowed in Browserslist config name. ' + use
		    )
		  }
		  if (name.indexOf('node_modules') !== -1) {
		    throw new BrowserslistError(
		      '`node_modules` not allowed in Browserslist config.' + use
		    )
		  }
		}

		function getPathType(filepath) {
		  var stats;
		  try {
		    stats = fs.existsSync(filepath) && fs.statSync(filepath);
		  } catch (err) {
		    /* c8 ignore start */
		    if (
		      err.code !== 'ENOENT' &&
		      err.code !== 'EACCES' &&
		      err.code !== 'ERR_ACCESS_DENIED'
		    ) {
		      throw err
		    }
		    /* c8 ignore end */
		  }

		  if (stats && stats.isDirectory()) return PATHTYPE_DIR
		  if (stats && stats.isFile()) return PATHTYPE_FILE

		  return PATHTYPE_UNKNOWN
		}

		function isFile(file) {
		  return getPathType(file) === PATHTYPE_FILE
		}

		function isDirectory(dir) {
		  return getPathType(dir) === PATHTYPE_DIR
		}

		function eachParent(file, callback, cache) {
		  var loc = path.resolve(file);
		  var pathsForCacheResult = [];
		  var result;
		  do {
		    if (!pathInRoot(loc)) {
		      break
		    }
		    if (cache && loc in cache) {
		      result = cache[loc];
		      break
		    }
		    pathsForCacheResult.push(loc);

		    if (!isDirectory(loc)) {
		      continue
		    }

		    var locResult = callback(loc);
		    if (typeof locResult !== 'undefined') {
		      result = locResult;
		      break
		    }
		  } while (loc !== (loc = path.dirname(loc)))

		  if (cache && !process.env.BROWSERSLIST_DISABLE_CACHE) {
		    pathsForCacheResult.forEach(function (cachePath) {
		      cache[cachePath] = result;
		    });
		  }
		  return result
		}

		function pathInRoot(p) {
		  if (!process.env.BROWSERSLIST_ROOT_PATH) return true
		  var rootPath = path.resolve(process.env.BROWSERSLIST_ROOT_PATH);
		  if (path.relative(rootPath, p).substring(0, 2) === '..') {
		    return false
		  }
		  return true
		}

		function check(section) {
		  if (Array.isArray(section)) {
		    for (var i = 0; i < section.length; i++) {
		      if (typeof section[i] !== 'string') {
		        throw new BrowserslistError(FORMAT)
		      }
		    }
		  } else if (typeof section !== 'string') {
		    throw new BrowserslistError(FORMAT)
		  }
		}

		function pickEnv(config, opts) {
		  if (typeof config !== 'object') return config

		  var name;
		  if (typeof opts.env === 'string') {
		    name = opts.env;
		  } else if (process.env.BROWSERSLIST_ENV) {
		    name = process.env.BROWSERSLIST_ENV;
		  } else if (process.env.NODE_ENV) {
		    name = process.env.NODE_ENV;
		  } else {
		    name = 'production';
		  }

		  if (opts.throwOnMissing) {
		    if (name && name !== 'defaults' && !config[name]) {
		      throw new BrowserslistError(
		        'Missing config for Browserslist environment `' + name + '`'
		      )
		    }
		  }

		  return config[name] || config.defaults
		}

		function parsePackage(file) {
		  var text = fs
		    .readFileSync(file)
		    .toString()
		    .replace(/^\uFEFF/m, '');
		  var list;
		  if (text.indexOf('"browserslist"') >= 0) {
		    list = JSON.parse(text).browserslist;
		  } else if (text.indexOf('"browserlist"') >= 0) {
		    var config = JSON.parse(text);
		    if (config.browserlist && !config.browserslist) {
		      throw new BrowserslistError(
		        '`browserlist` key instead of `browserslist` in ' + file
		      )
		    }
		  }
		  if (Array.isArray(list) || typeof list === 'string') {
		    list = { defaults: list };
		  }
		  for (var i in list) {
		    check(list[i]);
		  }

		  return list
		}

		function parsePackageOrReadConfig(file) {
		  if (file in parseConfigCache) {
		    return parseConfigCache[file]
		  }

		  var isPackage = path.basename(file) === 'package.json';
		  var result = isPackage ? parsePackage(file) : module.exports.readConfig(file);

		  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
		    parseConfigCache[file] = result;
		  }
		  return result
		}

		function latestReleaseTime(agents) {
		  var latest = 0;
		  for (var name in agents) {
		    var dates = agents[name].releaseDate || {};
		    for (var key in dates) {
		      if (latest < dates[key]) {
		        latest = dates[key];
		      }
		    }
		  }
		  return latest * 1000
		}

		function getMonthsPassed(date) {
		  var now = new Date();
		  var past = new Date(date);

		  var years = now.getFullYear() - past.getFullYear();
		  var months = now.getMonth() - past.getMonth();

		  return years * 12 + months
		}

		function normalizeStats(data, stats) {
		  if (!data) {
		    data = {};
		  }
		  if (stats && 'dataByBrowser' in stats) {
		    stats = stats.dataByBrowser;
		  }

		  if (typeof stats !== 'object') return undefined

		  var normalized = {};
		  for (var i in stats) {
		    var versions = Object.keys(stats[i]);
		    if (versions.length === 1 && data[i] && data[i].versions.length === 1) {
		      var normal = data[i].versions[0];
		      normalized[i] = {};
		      normalized[i][normal] = stats[i][versions[0]];
		    } else {
		      normalized[i] = stats[i];
		    }
		  }

		  return normalized
		}

		function normalizeUsageData(usageData, data) {
		  for (var browser in usageData) {
		    var browserUsage = usageData[browser];
		    // https://github.com/browserslist/browserslist/issues/431#issuecomment-565230615
		    // caniuse-db returns { 0: "percentage" } for `and_*` regional stats
		    if ('0' in browserUsage) {
		      var versions = data[browser].versions;
		      browserUsage[versions[versions.length - 1]] = browserUsage[0];
		      delete browserUsage[0];
		    }
		  }
		}

		module.exports = {
		  loadQueries: function loadQueries(ctx, name) {
		    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
		      checkExtend(name);
		    }
		    var queries = commonjsRequire(require.resolve(name, { paths: ['.', ctx.path] }));
		    if (typeof queries === 'object' && queries !== null && queries.__esModule) {
		      queries = queries.default;
		    }
		    if (queries) {
		      if (Array.isArray(queries)) {
		        return queries
		      } else if (typeof queries === 'object') {
		        if (!queries.defaults) queries.defaults = [];
		        return pickEnv(queries, ctx)
		      }
		    }
		    throw new BrowserslistError(
		      '`' +
		        name +
		        '` config exports not an array of queries' +
		        ' or an object of envs'
		    )
		  },

		  loadStat: function loadStat(ctx, name, data) {
		    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
		      checkExtend(name);
		    }
		    var stats = commonjsRequire(
		      // Use forward slashes for module paths, also on Windows.
		      require.resolve(path.posix.join(name, 'browserslist-stats.json'), {
		        paths: ['.']
		      })
		    );
		    return normalizeStats(data, stats)
		  },

		  getStat: function getStat(opts, data) {
		    var stats;
		    if (opts.stats) {
		      stats = opts.stats;
		    } else if (process.env.BROWSERSLIST_STATS) {
		      stats = process.env.BROWSERSLIST_STATS;
		    } else if (opts.path && path.resolve && fs.existsSync) {
		      stats = eachParent(
		        opts.path,
		        function (dir) {
		          var file = path.join(dir, 'browserslist-stats.json');
		          return isFile(file) ? file : undefined
		        },
		        statCache
		      );
		    }
		    if (typeof stats === 'string') {
		      try {
		        stats = JSON.parse(fs.readFileSync(stats));
		      } catch (e) {
		        throw new BrowserslistError("Can't read " + stats)
		      }
		    }
		    return normalizeStats(data, stats)
		  },

		  loadConfig: function loadConfig(opts) {
		    if (process.env.BROWSERSLIST) {
		      return process.env.BROWSERSLIST
		    } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {
		      var file = opts.config || process.env.BROWSERSLIST_CONFIG;
		      return pickEnv(parsePackageOrReadConfig(file), opts)
		    } else if (opts.path) {
		      return pickEnv(module.exports.findConfig(opts.path), opts)
		    } else {
		      return undefined
		    }
		  },

		  loadCountry: function loadCountry(usage, country, data) {
		    var code = country.replace(/[^\w-]/g, '');
		    if (!usage[code]) {
		      var compressed;
		      try {
		        compressed = commonjsRequire('caniuse-lite/data/regions/' + code + '.js');
		      } catch (e) {
		        throw new BrowserslistError('Unknown region name `' + code + '`.')
		      }
		      var usageData = region(compressed);
		      normalizeUsageData(usageData, data);
		      usage[country] = {};
		      for (var i in usageData) {
		        for (var j in usageData[i]) {
		          usage[country][i + ' ' + j] = usageData[i][j];
		        }
		      }
		    }
		  },

		  loadFeature: function loadFeature(features, name) {
		    name = name.replace(/[^\w-]/g, '');
		    if (features[name]) return
		    var compressed;
		    try {
		      compressed = commonjsRequire('caniuse-lite/data/features/' + name + '.js');
		    } catch (e) {
		      throw new BrowserslistError('Unknown feature name `' + name + '`.')
		    }
		    var stats = feature(compressed).stats;
		    features[name] = {};
		    for (var i in stats) {
		      features[name][i] = {};
		      for (var j in stats[i]) {
		        features[name][i][j] = stats[i][j];
		      }
		    }
		  },

		  parseConfig: function parseConfig(string) {
		    var result = { defaults: [] };
		    var sections = ['defaults'];

		    string
		      .toString()
		      .replace(/#[^\n]*/g, '')
		      .split(/\n|,/)
		      .map(function (line) {
		        return line.trim()
		      })
		      .filter(function (line) {
		        return line !== ''
		      })
		      .forEach(function (line) {
		        if (IS_SECTION.test(line)) {
		          sections = line.match(IS_SECTION)[1].trim().split(' ');
		          sections.forEach(function (section) {
		            if (result[section]) {
		              throw new BrowserslistError(
		                'Duplicate section ' + section + ' in Browserslist config'
		              )
		            }
		            result[section] = [];
		          });
		        } else {
		          sections.forEach(function (section) {
		            result[section].push(line);
		          });
		        }
		      });

		    return result
		  },

		  readConfig: function readConfig(file) {
		    if (!isFile(file)) {
		      throw new BrowserslistError("Can't read " + file + ' config')
		    }

		    return module.exports.parseConfig(fs.readFileSync(file))
		  },

		  findConfigFile: function findConfigFile(from) {
		    return eachParent(
		      from,
		      function (dir) {
		        var config = path.join(dir, 'browserslist');
		        var pkg = path.join(dir, 'package.json');
		        var rc = path.join(dir, '.browserslistrc');

		        var pkgBrowserslist;
		        if (isFile(pkg)) {
		          try {
		            pkgBrowserslist = parsePackage(pkg);
		          } catch (e) {
		            if (e.name === 'BrowserslistError') throw e
		            console.warn(
		              '[Browserslist] Could not parse ' + pkg + '. Ignoring it.'
		            );
		          }
		        }

		        if (isFile(config) && pkgBrowserslist) {
		          throw new BrowserslistError(
		            dir + ' contains both browserslist and package.json with browsers'
		          )
		        } else if (isFile(rc) && pkgBrowserslist) {
		          throw new BrowserslistError(
		            dir +
		              ' contains both .browserslistrc and package.json with browsers'
		          )
		        } else if (isFile(config) && isFile(rc)) {
		          throw new BrowserslistError(
		            dir + ' contains both .browserslistrc and browserslist'
		          )
		        } else if (isFile(config)) {
		          return config
		        } else if (isFile(rc)) {
		          return rc
		        } else if (pkgBrowserslist) {
		          return pkg
		        }
		      },
		      configPathCache
		    )
		  },

		  findConfig: function findConfig(from) {
		    var configFile = this.findConfigFile(from);

		    return configFile ? parsePackageOrReadConfig(configFile) : undefined
		  },

		  clearCaches: function clearCaches() {
		    dataTimeChecked = false;
		    statCache = {};
		    configPathCache = {};
		    parseConfigCache = {};

		    this.cache = {};
		  },

		  oldDataWarning: function oldDataWarning(agentsObj) {
		    if (dataTimeChecked) return
		    dataTimeChecked = true;
		    if (process.env.BROWSERSLIST_IGNORE_OLD_DATA) return

		    var latest = latestReleaseTime(agentsObj);
		    var monthsPassed = getMonthsPassed(latest);

		    if (latest !== 0 && monthsPassed >= 6) {
		      if (process.env.BROWSERSLIST_TRACE_WARNING) {
		        console.info('Last browser release in DB: ' + String(new Date(latest)));
		        console.trace();
		      }

		      var months = monthsPassed + ' ' + (monthsPassed > 1 ? 'months' : 'month');
		      console.warn(
		        'Browserslist: browsers data (caniuse-lite) is ' +
		          months +
		          ' old. Please run:\n' +
		          '  npx update-browserslist-db@latest\n' +
		          '  Why you should do it regularly: ' +
		          'https://github.com/browserslist/update-db#readme'
		      );
		    }
		  },

		  currentNode: function currentNode() {
		    return 'node ' + process.versions.node
		  },

		  env: process.env
		}; 
	} (node$1));
	return node$1.exports;
}

var parse$1;
var hasRequiredParse$2;

function requireParse$2 () {
	if (hasRequiredParse$2) return parse$1;
	hasRequiredParse$2 = 1;
	var AND_REGEXP = /^\s+and\s+(.*)/i;
	var OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i;

	function flatten(array) {
	  if (!Array.isArray(array)) return [array]
	  return array.reduce(function (a, b) {
	    return a.concat(flatten(b))
	  }, [])
	}

	function find(string, predicate) {
	  for (var max = string.length, n = 1; n <= max; n++) {
	    var parsed = string.substr(-n, n);
	    if (predicate(parsed, n, max)) {
	      return string.slice(0, -n)
	    }
	  }
	  return ''
	}

	function matchQuery(all, query) {
	  var node = { query: query };
	  if (query.indexOf('not ') === 0) {
	    node.not = true;
	    query = query.slice(4);
	  }

	  for (var name in all) {
	    var type = all[name];
	    var match = query.match(type.regexp);
	    if (match) {
	      node.type = name;
	      for (var i = 0; i < type.matches.length; i++) {
	        node[type.matches[i]] = match[i + 1];
	      }
	      return node
	    }
	  }

	  node.type = 'unknown';
	  return node
	}

	function matchBlock(all, string, qs) {
	  var node;
	  return find(string, function (parsed, n, max) {
	    if (AND_REGEXP.test(parsed)) {
	      node = matchQuery(all, parsed.match(AND_REGEXP)[1]);
	      node.compose = 'and';
	      qs.unshift(node);
	      return true
	    } else if (OR_REGEXP.test(parsed)) {
	      node = matchQuery(all, parsed.match(OR_REGEXP)[1]);
	      node.compose = 'or';
	      qs.unshift(node);
	      return true
	    } else if (n === max) {
	      node = matchQuery(all, parsed.trim());
	      node.compose = 'or';
	      qs.unshift(node);
	      return true
	    }
	    return false
	  })
	}

	parse$1 = function parse(all, queries) {
	  if (!Array.isArray(queries)) queries = [queries];
	  return flatten(
	    queries.map(function (block) {
	      var qs = [];
	      do {
	        block = matchBlock(all, block, qs);
	      } while (block)
	      return qs
	    })
	  )
	};
	return parse$1;
}

var browserslist_1;
var hasRequiredBrowserslist;

function requireBrowserslist () {
	if (hasRequiredBrowserslist) return browserslist_1;
	hasRequiredBrowserslist = 1;
	var bbm = requireDist();
	var jsReleases = require$$1;
	var agents = requireAgents().agents;
	var e2c = requireVersions();
	var jsEOL = require$$4;
	var path = require$$0$2$1;

	var BrowserslistError = requireError();
	var env = requireNode$1();
	var parseWithoutCache = requireParse$2(); // Will load browser.js in webpack

	var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
	var ANDROID_EVERGREEN_FIRST = '37';
	var OP_MOB_BLINK_FIRST = 14;
	var FIREFOX_ESR_VERSION = '140';

	// Helpers

	function isVersionsMatch(versionA, versionB) {
	  return (versionA + '.').indexOf(versionB + '.') === 0
	}

	function isEolReleased(name) {
	  var version = name.slice(1);
	  return browserslist.nodeVersions.some(function (i) {
	    return isVersionsMatch(i, version)
	  })
	}

	function normalize(versions) {
	  return versions.filter(function (version) {
	    return typeof version === 'string'
	  })
	}

	function normalizeElectron(version) {
	  var versionToUse = version;
	  if (version.split('.').length === 3) {
	    versionToUse = version.split('.').slice(0, -1).join('.');
	  }
	  return versionToUse
	}

	function nameMapper(name) {
	  return function mapName(version) {
	    return name + ' ' + version
	  }
	}

	function getMajor(version) {
	  return parseInt(version.split('.')[0])
	}

	function getMajorVersions(released, number) {
	  if (released.length === 0) return []
	  var majorVersions = uniq(released.map(getMajor));
	  var minimum = majorVersions[majorVersions.length - number];
	  if (!minimum) {
	    return released
	  }
	  var selected = [];
	  for (var i = released.length - 1; i >= 0; i--) {
	    if (minimum > getMajor(released[i])) break
	    selected.unshift(released[i]);
	  }
	  return selected
	}

	function uniq(array) {
	  var filtered = [];
	  for (var i = 0; i < array.length; i++) {
	    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
	  }
	  return filtered
	}

	function fillUsage(result, name, data) {
	  for (var i in data) {
	    result[name + ' ' + i] = data[i];
	  }
	}

	function generateFilter(sign, version) {
	  version = parseFloat(version);
	  if (sign === '>') {
	    return function (v) {
	      return parseLatestFloat(v) > version
	    }
	  } else if (sign === '>=') {
	    return function (v) {
	      return parseLatestFloat(v) >= version
	    }
	  } else if (sign === '<') {
	    return function (v) {
	      return parseFloat(v) < version
	    }
	  } else {
	    return function (v) {
	      return parseFloat(v) <= version
	    }
	  }

	  function parseLatestFloat(v) {
	    return parseFloat(v.split('-')[1] || v)
	  }
	}

	function generateSemverFilter(sign, version) {
	  version = version.split('.').map(parseSimpleInt);
	  version[1] = version[1] || 0;
	  version[2] = version[2] || 0;
	  if (sign === '>') {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(v, version) > 0
	    }
	  } else if (sign === '>=') {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(v, version) >= 0
	    }
	  } else if (sign === '<') {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(version, v) > 0
	    }
	  } else {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(version, v) >= 0
	    }
	  }
	}

	function parseSimpleInt(x) {
	  return parseInt(x)
	}

	function compare(a, b) {
	  if (a < b) return -1
	  if (a > b) return 1
	  return 0
	}

	function compareSemver(a, b) {
	  return (
	    compare(parseInt(a[0]), parseInt(b[0])) ||
	    compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) ||
	    compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'))
	  )
	}

	// this follows the npm-like semver behavior
	function semverFilterLoose(operator, range) {
	  range = range.split('.').map(parseSimpleInt);
	  if (typeof range[1] === 'undefined') {
	    range[1] = 'x';
	  }
	  // ignore any patch version because we only return minor versions
	  // range[2] = 'x'
	  switch (operator) {
	    case '<=':
	      return function (version) {
	        version = version.split('.').map(parseSimpleInt);
	        return compareSemverLoose(version, range) <= 0
	      }
	    case '>=':
	    default:
	      return function (version) {
	        version = version.split('.').map(parseSimpleInt);
	        return compareSemverLoose(version, range) >= 0
	      }
	  }
	}

	// this follows the npm-like semver behavior
	function compareSemverLoose(version, range) {
	  if (version[0] !== range[0]) {
	    return version[0] < range[0] ? -1 : 1
	  }
	  if (range[1] === 'x') {
	    return 0
	  }
	  if (version[1] !== range[1]) {
	    return version[1] < range[1] ? -1 : 1
	  }
	  return 0
	}

	function resolveVersion(data, version) {
	  if (data.versions.indexOf(version) !== -1) {
	    return version
	  } else if (browserslist.versionAliases[data.name][version]) {
	    return browserslist.versionAliases[data.name][version]
	  } else {
	    return false
	  }
	}

	function normalizeVersion(data, version) {
	  var resolved = resolveVersion(data, version);
	  if (resolved) {
	    return resolved
	  } else if (data.versions.length === 1) {
	    return data.versions[0]
	  } else {
	    return false
	  }
	}

	function filterByYear(since, context) {
	  since = since / 1000;
	  return Object.keys(agents).reduce(function (selected, name) {
	    var data = byName(name, context);
	    if (!data) return selected
	    var versions = Object.keys(data.releaseDate).filter(function (v) {
	      var date = data.releaseDate[v];
	      return date !== null && date >= since
	    });
	    return selected.concat(versions.map(nameMapper(data.name)))
	  }, [])
	}

	function cloneData(data) {
	  return {
	    name: data.name,
	    versions: data.versions,
	    released: data.released,
	    releaseDate: data.releaseDate
	  }
	}

	function byName(name, context) {
	  name = name.toLowerCase();
	  name = browserslist.aliases[name] || name;
	  if (context.mobileToDesktop && browserslist.desktopNames[name]) {
	    var desktop = browserslist.data[browserslist.desktopNames[name]];
	    if (name === 'android') {
	      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop)
	    } else {
	      var cloned = cloneData(desktop);
	      cloned.name = name;
	      return cloned
	    }
	  }
	  return browserslist.data[name]
	}

	function normalizeAndroidVersions(androidVersions, chromeVersions) {
	  var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST);
	  return androidVersions
	    .filter(function (version) {
	      return /^(?:[2-4]\.|[34]$)/.test(version)
	    })
	    .concat(chromeVersions.slice(iFirstEvergreen))
	}

	function copyObject(obj) {
	  var copy = {};
	  for (var key in obj) {
	    copy[key] = obj[key];
	  }
	  return copy
	}

	function normalizeAndroidData(android, chrome) {
	  android.released = normalizeAndroidVersions(android.released, chrome.released);
	  android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
	  android.releaseDate = copyObject(android.releaseDate);
	  android.released.forEach(function (v) {
	    if (android.releaseDate[v] === undefined) {
	      android.releaseDate[v] = chrome.releaseDate[v];
	    }
	  });
	  return android
	}

	function checkName(name, context) {
	  var data = byName(name, context);
	  if (!data) throw new BrowserslistError('Unknown browser ' + name)
	  return data
	}

	function unknownQuery(query) {
	  return new BrowserslistError(
	    'Unknown browser query `' +
	      query +
	      '`. ' +
	      'Maybe you are using old Browserslist or made typo in query.'
	  )
	}

	// Adjusts last X versions queries for some mobile browsers,
	// where caniuse data jumps from a legacy version to the latest
	function filterJumps(list, name, nVersions, context) {
	  var jump = 1;
	  switch (name) {
	    case 'android':
	      if (context.mobileToDesktop) return list
	      var released = browserslist.data.chrome.released;
	      jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST);
	      break
	    case 'op_mob':
	      var latest = browserslist.data.op_mob.released.slice(-1)[0];
	      jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1;
	      break
	    default:
	      return list
	  }
	  if (nVersions <= jump) {
	    return list.slice(-1)
	  }
	  return list.slice(jump - 1 - nVersions)
	}

	function isSupported(flags, withPartial) {
	  return (
	    typeof flags === 'string' &&
	    (flags.indexOf('y') >= 0 || (withPartial && flags.indexOf('a') >= 0))
	  )
	}

	function resolve(queries, context) {
	  return parseQueries(queries).reduce(function (result, node, index) {
	    if (node.not && index === 0) {
	      throw new BrowserslistError(
	        'Write any browsers query (for instance, `defaults`) ' +
	          'before `' +
	          node.query +
	          '`'
	      )
	    }
	    var type = QUERIES[node.type];
	    var array = type.select.call(browserslist, context, node).map(function (j) {
	      var parts = j.split(' ');
	      if (parts[1] === '0') {
	        return parts[0] + ' ' + byName(parts[0], context).versions[0]
	      } else {
	        return j
	      }
	    });

	    if (node.compose === 'and') {
	      if (node.not) {
	        return result.filter(function (j) {
	          return array.indexOf(j) === -1
	        })
	      } else {
	        return result.filter(function (j) {
	          return array.indexOf(j) !== -1
	        })
	      }
	    } else {
	      if (node.not) {
	        var filter = {};
	        array.forEach(function (j) {
	          filter[j] = true;
	        });
	        return result.filter(function (j) {
	          return !filter[j]
	        })
	      }
	      return result.concat(array)
	    }
	  }, [])
	}

	function prepareOpts(opts) {
	  if (typeof opts === 'undefined') opts = {};

	  if (typeof opts.path === 'undefined') {
	    opts.path = path.resolve ? path.resolve('.') : '.';
	  }

	  return opts
	}

	function prepareQueries(queries, opts) {
	  if (typeof queries === 'undefined' || queries === null) {
	    var config = browserslist.loadConfig(opts);
	    if (config) {
	      queries = config;
	    } else {
	      queries = browserslist.defaults;
	    }
	  }

	  return queries
	}

	function checkQueries(queries) {
	  if (!(typeof queries === 'string' || Array.isArray(queries))) {
	    throw new BrowserslistError(
	      'Browser queries must be an array or string. Got ' + typeof queries + '.'
	    )
	  }
	}

	var cache = {};
	var parseCache = {};

	function browserslist(queries, opts) {
	  opts = prepareOpts(opts);
	  queries = prepareQueries(queries, opts);
	  checkQueries(queries);

	  var needsPath = parseQueries(queries).some(function (node) {
	    return QUERIES[node.type].needsPath
	  });
	  var context = {
	    ignoreUnknownVersions: opts.ignoreUnknownVersions,
	    dangerousExtend: opts.dangerousExtend,
	    throwOnMissing: opts.throwOnMissing,
	    mobileToDesktop: opts.mobileToDesktop,
	    env: opts.env
	  };
	  // Removing to avoid using context.path without marking query as needsPath
	  if (needsPath) {
	    context.path = opts.path;
	  }

	  env.oldDataWarning(browserslist.data);
	  var stats = env.getStat(opts, browserslist.data);
	  if (stats) {
	    context.customUsage = {};
	    for (var browser in stats) {
	      fillUsage(context.customUsage, browser, stats[browser]);
	    }
	  }

	  var cacheKey = JSON.stringify([queries, context]);
	  if (cache[cacheKey]) return cache[cacheKey]

	  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {
	    name1 = name1.split(' ');
	    name2 = name2.split(' ');
	    if (name1[0] === name2[0]) {
	      // assumptions on caniuse data
	      // 1) version ranges never overlaps
	      // 2) if version is not a range, it never contains `-`
	      var version1 = name1[1].split('-')[0];
	      var version2 = name2[1].split('-')[0];
	      return compareSemver(version2.split('.'), version1.split('.'))
	    } else {
	      return compare(name1[0], name2[0])
	    }
	  });
	  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
	    cache[cacheKey] = result;
	  }
	  return result
	}

	function parseQueries(queries) {
	  var cacheKey = JSON.stringify(queries);
	  if (cacheKey in parseCache) return parseCache[cacheKey]
	  var result = parseWithoutCache(QUERIES, queries);
	  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
	    parseCache[cacheKey] = result;
	  }
	  return result
	}

	function loadCustomUsage(context, config) {
	  var stats = env.loadStat(context, config, browserslist.data);
	  if (stats) {
	    context.customUsage = {};
	    for (var browser in stats) {
	      fillUsage(context.customUsage, browser, stats[browser]);
	    }
	  }
	  if (!context.customUsage) {
	    throw new BrowserslistError('Custom usage statistics was not provided')
	  }
	  return context.customUsage
	}

	browserslist.parse = function (queries, opts) {
	  opts = prepareOpts(opts);
	  queries = prepareQueries(queries, opts);
	  checkQueries(queries);
	  return parseQueries(queries)
	};

	// Will be filled by Can I Use data below
	browserslist.cache = {};
	browserslist.data = {};
	browserslist.usage = {
	  global: {},
	  custom: null
	};

	// Default browsers query
	browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead'];

	// Browser names aliases
	browserslist.aliases = {
	  fx: 'firefox',
	  ff: 'firefox',
	  ios: 'ios_saf',
	  explorer: 'ie',
	  blackberry: 'bb',
	  explorermobile: 'ie_mob',
	  operamini: 'op_mini',
	  operamobile: 'op_mob',
	  chromeandroid: 'and_chr',
	  firefoxandroid: 'and_ff',
	  ucandroid: 'and_uc',
	  qqandroid: 'and_qq'
	};

	// Can I Use only provides a few versions for some browsers (e.g. and_chr).
	// Fallback to a similar browser for unknown versions
	// Note op_mob is not included as its chromium versions are not in sync with Opera desktop
	browserslist.desktopNames = {
	  and_chr: 'chrome',
	  and_ff: 'firefox',
	  ie_mob: 'ie',
	  android: 'chrome' // has extra processing logic
	};

	// Aliases to work with joined versions like `ios_saf 7.0-7.1`
	browserslist.versionAliases = {};

	browserslist.clearCaches = env.clearCaches;
	browserslist.parseConfig = env.parseConfig;
	browserslist.readConfig = env.readConfig;
	browserslist.findConfigFile = env.findConfigFile;
	browserslist.findConfig = env.findConfig;
	browserslist.loadConfig = env.loadConfig;

	browserslist.coverage = function (browsers, stats) {
	  var data;
	  if (typeof stats === 'undefined') {
	    data = browserslist.usage.global;
	  } else if (stats === 'my stats') {
	    var opts = {};
	    opts.path = path.resolve ? path.resolve('.') : '.';
	    var customStats = env.getStat(opts);
	    if (!customStats) {
	      throw new BrowserslistError('Custom usage statistics was not provided')
	    }
	    data = {};
	    for (var browser in customStats) {
	      fillUsage(data, browser, customStats[browser]);
	    }
	  } else if (typeof stats === 'string') {
	    if (stats.length > 2) {
	      stats = stats.toLowerCase();
	    } else {
	      stats = stats.toUpperCase();
	    }
	    env.loadCountry(browserslist.usage, stats, browserslist.data);
	    data = browserslist.usage[stats];
	  } else {
	    if ('dataByBrowser' in stats) {
	      stats = stats.dataByBrowser;
	    }
	    data = {};
	    for (var name in stats) {
	      for (var version in stats[name]) {
	        data[name + ' ' + version] = stats[name][version];
	      }
	    }
	  }

	  return browsers.reduce(function (all, i) {
	    var usage = data[i];
	    if (usage === undefined) {
	      usage = data[i.replace(/ \S+$/, ' 0')];
	    }
	    return all + (usage || 0)
	  }, 0)
	};

	function nodeQuery(context, node) {
	  var matched = browserslist.nodeVersions.filter(function (i) {
	    return isVersionsMatch(i, node.version)
	  });
	  if (matched.length === 0) {
	    if (context.ignoreUnknownVersions) {
	      return []
	    } else {
	      throw new BrowserslistError(
	        'Unknown version ' + node.version + ' of Node.js'
	      )
	    }
	  }
	  return ['node ' + matched[matched.length - 1]]
	}

	function sinceQuery(context, node) {
	  var year = parseInt(node.year);
	  var month = parseInt(node.month || '01') - 1;
	  var day = parseInt(node.day || '01');
	  return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context)
	}

	function bbmTransform(bbmVersions) {
	  var browsers = {
	    chrome: 'chrome',
	    chrome_android: 'and_chr',
	    edge: 'edge',
	    firefox: 'firefox',
	    firefox_android: 'and_ff',
	    safari: 'safari',
	    safari_ios: 'ios_saf',
	    webview_android: 'android',
	    samsunginternet_android: 'samsung',
	    opera_android: 'op_mob',
	    opera: 'opera',
	    qq_android: 'and_qq',
	    uc_android: 'and_uc',
	    kai_os: 'kaios'
	  };

	  return bbmVersions
	    .filter(function (version) {
	      return Object.keys(browsers).indexOf(version.browser) !== -1
	    })
	    .map(function (version) {
	      return browsers[version.browser] + ' >= ' + version.version
	    })
	}

	function coverQuery(context, node) {
	  var coverage = parseFloat(node.coverage);
	  var usage = browserslist.usage.global;
	  if (node.place) {
	    if (node.place.match(/^my\s+stats$/i)) {
	      if (!context.customUsage) {
	        throw new BrowserslistError('Custom usage statistics was not provided')
	      }
	      usage = context.customUsage;
	    } else {
	      var place;
	      if (node.place.length === 2) {
	        place = node.place.toUpperCase();
	      } else {
	        place = node.place.toLowerCase();
	      }
	      env.loadCountry(browserslist.usage, place, browserslist.data);
	      usage = browserslist.usage[place];
	    }
	  } else if (node.config) {
	    usage = loadCustomUsage(context, node.config);
	  }
	  var versions = Object.keys(usage).sort(function (a, b) {
	    return usage[b] - usage[a]
	  });
	  var covered = 0;
	  var result = [];
	  var version;
	  for (var i = 0; i < versions.length; i++) {
	    version = versions[i];
	    if (usage[version] === 0) break
	    covered += usage[version];
	    result.push(version);
	    if (covered >= coverage) break
	  }
	  return result
	}

	var QUERIES = {
	  last_major_versions: {
	    matches: ['versions'],
	    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
	    select: function (context, node) {
	      return Object.keys(agents).reduce(function (selected, name) {
	        var data = byName(name, context);
	        if (!data) return selected
	        var list = getMajorVersions(data.released, node.versions);
	        list = list.map(nameMapper(data.name));
	        list = filterJumps(list, data.name, node.versions, context);
	        return selected.concat(list)
	      }, [])
	    }
	  },
	  last_versions: {
	    matches: ['versions'],
	    regexp: /^last\s+(\d+)\s+versions?$/i,
	    select: function (context, node) {
	      return Object.keys(agents).reduce(function (selected, name) {
	        var data = byName(name, context);
	        if (!data) return selected
	        var list = data.released.slice(-node.versions);
	        list = list.map(nameMapper(data.name));
	        list = filterJumps(list, data.name, node.versions, context);
	        return selected.concat(list)
	      }, [])
	    }
	  },
	  last_electron_major_versions: {
	    matches: ['versions'],
	    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
	    select: function (context, node) {
	      var validVersions = getMajorVersions(Object.keys(e2c), node.versions);
	      return validVersions.map(function (i) {
	        return 'chrome ' + e2c[i]
	      })
	    }
	  },
	  last_node_major_versions: {
	    matches: ['versions'],
	    regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
	    select: function (context, node) {
	      return getMajorVersions(browserslist.nodeVersions, node.versions).map(
	        function (version) {
	          return 'node ' + version
	        }
	      )
	    }
	  },
	  last_browser_major_versions: {
	    matches: ['versions', 'browser'],
	    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
	    select: function (context, node) {
	      var data = checkName(node.browser, context);
	      var validVersions = getMajorVersions(data.released, node.versions);
	      var list = validVersions.map(nameMapper(data.name));
	      list = filterJumps(list, data.name, node.versions, context);
	      return list
	    }
	  },
	  last_electron_versions: {
	    matches: ['versions'],
	    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
	    select: function (context, node) {
	      return Object.keys(e2c)
	        .slice(-node.versions)
	        .map(function (i) {
	          return 'chrome ' + e2c[i]
	        })
	    }
	  },
	  last_node_versions: {
	    matches: ['versions'],
	    regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
	    select: function (context, node) {
	      return browserslist.nodeVersions
	        .slice(-node.versions)
	        .map(function (version) {
	          return 'node ' + version
	        })
	    }
	  },
	  last_browser_versions: {
	    matches: ['versions', 'browser'],
	    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
	    select: function (context, node) {
	      var data = checkName(node.browser, context);
	      var list = data.released.slice(-node.versions).map(nameMapper(data.name));
	      list = filterJumps(list, data.name, node.versions, context);
	      return list
	    }
	  },
	  unreleased_versions: {
	    matches: [],
	    regexp: /^unreleased\s+versions$/i,
	    select: function (context) {
	      return Object.keys(agents).reduce(function (selected, name) {
	        var data = byName(name, context);
	        if (!data) return selected
	        var list = data.versions.filter(function (v) {
	          return data.released.indexOf(v) === -1
	        });
	        list = list.map(nameMapper(data.name));
	        return selected.concat(list)
	      }, [])
	    }
	  },
	  unreleased_electron_versions: {
	    matches: [],
	    regexp: /^unreleased\s+electron\s+versions?$/i,
	    select: function () {
	      return []
	    }
	  },
	  unreleased_browser_versions: {
	    matches: ['browser'],
	    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
	    select: function (context, node) {
	      var data = checkName(node.browser, context);
	      return data.versions
	        .filter(function (v) {
	          return data.released.indexOf(v) === -1
	        })
	        .map(nameMapper(data.name))
	    }
	  },
	  last_years: {
	    matches: ['years'],
	    regexp: /^last\s+((\d+\.)?\d+)\s+years?$/i,
	    select: function (context, node) {
	      return filterByYear(Date.now() - YEAR * node.years, context)
	    }
	  },
	  since_y: {
	    matches: ['year'],
	    regexp: /^since (\d+)$/i,
	    select: sinceQuery
	  },
	  since_y_m: {
	    matches: ['year', 'month'],
	    regexp: /^since (\d+)-(\d+)$/i,
	    select: sinceQuery
	  },
	  since_y_m_d: {
	    matches: ['year', 'month', 'day'],
	    regexp: /^since (\d+)-(\d+)-(\d+)$/i,
	    select: sinceQuery
	  },
	  baseline: {
	    matches: ['year', 'availability', 'date', 'downstream', 'kaios'],
	    // Matches:
	    //   baseline 2024
	    //   baseline newly available
	    //   baseline widely available
	    //   baseline widely available on 2024-06-01
	    //   ...with downstream
	    //   ...including kaios
	    regexp:
	      /^baseline\s+(?:(\d+)|(newly|widely)\s+available(?:\s+on\s+(\d{4}-\d{2}-\d{2}))?)?(\s+with\s+downstream)?(\s+including\s+kaios)?$/i,
	    select: function (context, node) {
	      var baselineVersions;
	      var includeDownstream = !!node.downstream;
	      var includeKaiOS = !!node.kaios;
	      if (node.availability === 'newly' && node.date) {
	        throw new BrowserslistError(
	          'Using newly available with a date is not supported, please use "widely available on YYYY-MM-DD" and add 30 months to the date you specified.'
	        )
	      }
	      if (node.year) {
	        baselineVersions = bbm.getCompatibleVersions({
	          targetYear: node.year,
	          includeDownstreamBrowsers: includeDownstream,
	          includeKaiOS: includeKaiOS,
	          suppressWarnings: true
	        });
	      } else if (node.date) {
	        baselineVersions = bbm.getCompatibleVersions({
	          widelyAvailableOnDate: node.date,
	          includeDownstreamBrowsers: includeDownstream,
	          includeKaiOS: includeKaiOS,
	          suppressWarnings: true
	        });
	      } else if (node.availability === 'newly') {
	        var future30months = new Date().setMonth(new Date().getMonth() + 30);
	        baselineVersions = bbm.getCompatibleVersions({
	          widelyAvailableOnDate: future30months,
	          includeDownstreamBrowsers: includeDownstream,
	          includeKaiOS: includeKaiOS,
	          suppressWarnings: true
	        });
	      } else {
	        baselineVersions = bbm.getCompatibleVersions({
	          includeDownstreamBrowsers: includeDownstream,
	          includeKaiOS: includeKaiOS,
	          suppressWarnings: true
	        });
	      }
	      return resolve(bbmTransform(baselineVersions), context)
	    }
	  },
	  popularity: {
	    matches: ['sign', 'popularity'],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
	    select: function (context, node) {
	      var popularity = parseFloat(node.popularity);
	      var usage = browserslist.usage.global;
	      return Object.keys(usage).reduce(function (result, version) {
	        if (node.sign === '>') {
	          if (usage[version] > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<') {
	          if (usage[version] < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<=') {
	          if (usage[version] <= popularity) {
	            result.push(version);
	          }
	        } else if (usage[version] >= popularity) {
	          result.push(version);
	        }
	        return result
	      }, [])
	    }
	  },
	  popularity_in_my_stats: {
	    matches: ['sign', 'popularity'],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
	    select: function (context, node) {
	      var popularity = parseFloat(node.popularity);
	      if (!context.customUsage) {
	        throw new BrowserslistError('Custom usage statistics was not provided')
	      }
	      var usage = context.customUsage;
	      return Object.keys(usage).reduce(function (result, version) {
	        var percentage = usage[version];
	        if (percentage == null) {
	          return result
	        }

	        if (node.sign === '>') {
	          if (percentage > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<') {
	          if (percentage < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<=') {
	          if (percentage <= popularity) {
	            result.push(version);
	          }
	        } else if (percentage >= popularity) {
	          result.push(version);
	        }
	        return result
	      }, [])
	    }
	  },
	  popularity_in_config_stats: {
	    matches: ['sign', 'popularity', 'config'],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
	    select: function (context, node) {
	      var popularity = parseFloat(node.popularity);
	      var usage = loadCustomUsage(context, node.config);
	      return Object.keys(usage).reduce(function (result, version) {
	        var percentage = usage[version];
	        if (percentage == null) {
	          return result
	        }

	        if (node.sign === '>') {
	          if (percentage > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<') {
	          if (percentage < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<=') {
	          if (percentage <= popularity) {
	            result.push(version);
	          }
	        } else if (percentage >= popularity) {
	          result.push(version);
	        }
	        return result
	      }, [])
	    }
	  },
	  popularity_in_place: {
	    matches: ['sign', 'popularity', 'place'],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
	    select: function (context, node) {
	      var popularity = parseFloat(node.popularity);
	      var place = node.place;
	      if (place.length === 2) {
	        place = place.toUpperCase();
	      } else {
	        place = place.toLowerCase();
	      }
	      env.loadCountry(browserslist.usage, place, browserslist.data);
	      var usage = browserslist.usage[place];
	      return Object.keys(usage).reduce(function (result, version) {
	        var percentage = usage[version];
	        if (percentage == null) {
	          return result
	        }

	        if (node.sign === '>') {
	          if (percentage > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<') {
	          if (percentage < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === '<=') {
	          if (percentage <= popularity) {
	            result.push(version);
	          }
	        } else if (percentage >= popularity) {
	          result.push(version);
	        }
	        return result
	      }, [])
	    }
	  },
	  cover: {
	    matches: ['coverage'],
	    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
	    select: coverQuery
	  },
	  cover_in: {
	    matches: ['coverage', 'place'],
	    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
	    select: coverQuery
	  },
	  cover_config: {
	    matches: ['coverage', 'config'],
	    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/i,
	    select: coverQuery
	  },
	  supports: {
	    matches: ['supportType', 'feature'],
	    regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
	    select: function (context, node) {
	      env.loadFeature(browserslist.cache, node.feature);
	      var withPartial = node.supportType !== 'fully';
	      var features = browserslist.cache[node.feature];
	      var result = [];
	      for (var name in features) {
	        var data = byName(name, context);
	        // Only check desktop when latest released mobile has support
	        var iMax = data.released.length - 1;
	        while (iMax >= 0) {
	          if (data.released[iMax] in features[name]) break
	          iMax--;
	        }
	        var checkDesktop =
	          context.mobileToDesktop &&
	          name in browserslist.desktopNames &&
	          isSupported(features[name][data.released[iMax]], withPartial);
	        data.versions.forEach(function (version) {
	          var flags = features[name][version];
	          if (flags === undefined && checkDesktop) {
	            flags = features[browserslist.desktopNames[name]][version];
	          }
	          if (isSupported(flags, withPartial)) {
	            result.push(name + ' ' + version);
	          }
	        });
	      }
	      return result
	    }
	  },
	  electron_range: {
	    matches: ['from', 'to'],
	    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	    select: function (context, node) {
	      var fromToUse = normalizeElectron(node.from);
	      var toToUse = normalizeElectron(node.to);
	      var from = parseFloat(node.from);
	      var to = parseFloat(node.to);
	      if (!e2c[fromToUse]) {
	        throw new BrowserslistError('Unknown version ' + from + ' of electron')
	      }
	      if (!e2c[toToUse]) {
	        throw new BrowserslistError('Unknown version ' + to + ' of electron')
	      }
	      return Object.keys(e2c)
	        .filter(function (i) {
	          var parsed = parseFloat(i);
	          return parsed >= from && parsed <= to
	        })
	        .map(function (i) {
	          return 'chrome ' + e2c[i]
	        })
	    }
	  },
	  node_range: {
	    matches: ['from', 'to'],
	    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	    select: function (context, node) {
	      return browserslist.nodeVersions
	        .filter(semverFilterLoose('>=', node.from))
	        .filter(semverFilterLoose('<=', node.to))
	        .map(function (v) {
	          return 'node ' + v
	        })
	    }
	  },
	  browser_range: {
	    matches: ['browser', 'from', 'to'],
	    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	    select: function (context, node) {
	      var data = checkName(node.browser, context);
	      var from = parseFloat(normalizeVersion(data, node.from) || node.from);
	      var to = parseFloat(normalizeVersion(data, node.to) || node.to);
	      function filter(v) {
	        var parsed = parseFloat(v);
	        return parsed >= from && parsed <= to
	      }
	      return data.released.filter(filter).map(nameMapper(data.name))
	    }
	  },
	  electron_ray: {
	    matches: ['sign', 'version'],
	    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
	    select: function (context, node) {
	      var versionToUse = normalizeElectron(node.version);
	      return Object.keys(e2c)
	        .filter(generateFilter(node.sign, versionToUse))
	        .map(function (i) {
	          return 'chrome ' + e2c[i]
	        })
	    }
	  },
	  node_ray: {
	    matches: ['sign', 'version'],
	    regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
	    select: function (context, node) {
	      return browserslist.nodeVersions
	        .filter(generateSemverFilter(node.sign, node.version))
	        .map(function (v) {
	          return 'node ' + v
	        })
	    }
	  },
	  browser_ray: {
	    matches: ['browser', 'sign', 'version'],
	    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+|esr)$/i,
	    select: function (context, node) {
	      var version = node.version;
	      var data = checkName(node.browser, context);
	      var alias = browserslist.versionAliases[data.name][version.toLowerCase()];
	      if (alias) version = alias;
	      if (!/[\d.]+/.test(version)) {
	        throw new BrowserslistError(
	          'Unknown version ' + version + ' of ' + node.browser
	        )
	      }
	      return data.released
	        .filter(generateFilter(node.sign, version))
	        .map(function (v) {
	          return data.name + ' ' + v
	        })
	    }
	  },
	  firefox_esr: {
	    matches: [],
	    regexp: /^(firefox|ff|fx)\s+esr$/i,
	    select: function () {
	      return ['firefox ' + FIREFOX_ESR_VERSION]
	    }
	  },
	  opera_mini_all: {
	    matches: [],
	    regexp: /(operamini|op_mini)\s+all/i,
	    select: function () {
	      return ['op_mini all']
	    }
	  },
	  electron_version: {
	    matches: ['version'],
	    regexp: /^electron\s+([\d.]+)$/i,
	    select: function (context, node) {
	      var versionToUse = normalizeElectron(node.version);
	      var chrome = e2c[versionToUse];
	      if (!chrome) {
	        throw new BrowserslistError(
	          'Unknown version ' + node.version + ' of electron'
	        )
	      }
	      return ['chrome ' + chrome]
	    }
	  },
	  node_major_version: {
	    matches: ['version'],
	    regexp: /^node\s+(\d+)$/i,
	    select: nodeQuery
	  },
	  node_minor_version: {
	    matches: ['version'],
	    regexp: /^node\s+(\d+\.\d+)$/i,
	    select: nodeQuery
	  },
	  node_patch_version: {
	    matches: ['version'],
	    regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
	    select: nodeQuery
	  },
	  current_node: {
	    matches: [],
	    regexp: /^current\s+node$/i,
	    select: function (context) {
	      return [env.currentNode(resolve, context)]
	    }
	  },
	  maintained_node: {
	    matches: [],
	    regexp: /^maintained\s+node\s+versions$/i,
	    select: function (context) {
	      var now = Date.now();
	      var queries = Object.keys(jsEOL)
	        .filter(function (key) {
	          return (
	            now < Date.parse(jsEOL[key].end) &&
	            now > Date.parse(jsEOL[key].start) &&
	            isEolReleased(key)
	          )
	        })
	        .map(function (key) {
	          return 'node ' + key.slice(1)
	        });
	      return resolve(queries, context)
	    }
	  },
	  phantomjs_1_9: {
	    matches: [],
	    regexp: /^phantomjs\s+1.9$/i,
	    select: function () {
	      return ['safari 5']
	    }
	  },
	  phantomjs_2_1: {
	    matches: [],
	    regexp: /^phantomjs\s+2.1$/i,
	    select: function () {
	      return ['safari 6']
	    }
	  },
	  browser_version: {
	    matches: ['browser', 'version'],
	    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
	    select: function (context, node) {
	      var version = node.version;
	      if (/^tp$/i.test(version)) version = 'TP';
	      var data = checkName(node.browser, context);
	      var alias = normalizeVersion(data, version);
	      if (alias) {
	        version = alias;
	      } else {
	        if (version.indexOf('.') === -1) {
	          alias = version + '.0';
	        } else {
	          alias = version.replace(/\.0$/, '');
	        }
	        alias = normalizeVersion(data, alias);
	        if (alias) {
	          version = alias;
	        } else if (context.ignoreUnknownVersions) {
	          return []
	        } else {
	          throw new BrowserslistError(
	            'Unknown version ' + version + ' of ' + node.browser
	          )
	        }
	      }
	      return [data.name + ' ' + version]
	    }
	  },
	  browserslist_config: {
	    matches: [],
	    regexp: /^browserslist config$/i,
	    needsPath: true,
	    select: function (context) {
	      return browserslist(undefined, context)
	    }
	  },
	  extends: {
	    matches: ['config'],
	    regexp: /^extends (.+)$/i,
	    needsPath: true,
	    select: function (context, node) {
	      return resolve(env.loadQueries(context, node.config), context)
	    }
	  },
	  defaults: {
	    matches: [],
	    regexp: /^defaults$/i,
	    select: function (context) {
	      return resolve(browserslist.defaults, context)
	    }
	  },
	  dead: {
	    matches: [],
	    regexp: /^dead$/i,
	    select: function (context) {
	      var dead = [
	        'Baidu >= 0',
	        'ie <= 11',
	        'ie_mob <= 11',
	        'bb <= 10',
	        'op_mob <= 12.1',
	        'samsung 4'
	      ];
	      return resolve(dead, context)
	    }
	  },
	  unknown: {
	    matches: [],
	    regexp: /^(\w+)$/i,
	    select: function (context, node) {
	      if (byName(node.query, context)) {
	        throw new BrowserslistError(
	          'Specify versions in Browserslist query for browser ' + node.query
	        )
	      } else {
	        throw unknownQuery(node.query)
	      }
	    }
	  }
	}

	// Get and convert Can I Use data

	;(function () {
	  for (var name in agents) {
	    var browser = agents[name];
	    browserslist.data[name] = {
	      name: name,
	      versions: normalize(agents[name].versions),
	      released: normalize(agents[name].versions.slice(0, -3)),
	      releaseDate: agents[name].release_date
	    };
	    fillUsage(browserslist.usage.global, name, browser.usage_global);

	    browserslist.versionAliases[name] = {};
	    for (var i = 0; i < browser.versions.length; i++) {
	      var full = browser.versions[i];
	      if (!full) continue

	      if (full.indexOf('-') !== -1) {
	        var interval = full.split('-');
	        for (var j = 0; j < interval.length; j++) {
	          browserslist.versionAliases[name][interval[j]] = full;
	        }
	      }
	    }
	  }

	  browserslist.nodeVersions = jsReleases.map(function (release) {
	    return release.version
	  });
	})();

	browserslist.versionAliases.firefox.esr = FIREFOX_ESR_VERSION;

	browserslist_1 = browserslist;
	return browserslist_1;
}

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let p = process || {}, argv = p.argv || [], env = p.env || {};
	let isColorSupported =
		!(!!env.NO_COLOR || argv.includes("--no-color")) &&
		(!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || ((p.stdout || {}).isTTY && env.TERM !== "dumb") || !!env.CI);

	let formatter = (open, close, replace = open) =>
		input => {
			let string = "" + input, index = string.indexOf(close, open.length);
			return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close
		};

	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index)
		return result + string.substring(cursor)
	};

	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1b[0m", "\x1b[0m"),
			bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
			dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
			italic: f("\x1b[3m", "\x1b[23m"),
			underline: f("\x1b[4m", "\x1b[24m"),
			inverse: f("\x1b[7m", "\x1b[27m"),
			hidden: f("\x1b[8m", "\x1b[28m"),
			strikethrough: f("\x1b[9m", "\x1b[29m"),

			black: f("\x1b[30m", "\x1b[39m"),
			red: f("\x1b[31m", "\x1b[39m"),
			green: f("\x1b[32m", "\x1b[39m"),
			yellow: f("\x1b[33m", "\x1b[39m"),
			blue: f("\x1b[34m", "\x1b[39m"),
			magenta: f("\x1b[35m", "\x1b[39m"),
			cyan: f("\x1b[36m", "\x1b[39m"),
			white: f("\x1b[37m", "\x1b[39m"),
			gray: f("\x1b[90m", "\x1b[39m"),

			bgBlack: f("\x1b[40m", "\x1b[49m"),
			bgRed: f("\x1b[41m", "\x1b[49m"),
			bgGreen: f("\x1b[42m", "\x1b[49m"),
			bgYellow: f("\x1b[43m", "\x1b[49m"),
			bgBlue: f("\x1b[44m", "\x1b[49m"),
			bgMagenta: f("\x1b[45m", "\x1b[49m"),
			bgCyan: f("\x1b[46m", "\x1b[49m"),
			bgWhite: f("\x1b[47m", "\x1b[49m"),

			blackBright: f("\x1b[90m", "\x1b[39m"),
			redBright: f("\x1b[91m", "\x1b[39m"),
			greenBright: f("\x1b[92m", "\x1b[39m"),
			yellowBright: f("\x1b[93m", "\x1b[39m"),
			blueBright: f("\x1b[94m", "\x1b[39m"),
			magentaBright: f("\x1b[95m", "\x1b[39m"),
			cyanBright: f("\x1b[96m", "\x1b[39m"),
			whiteBright: f("\x1b[97m", "\x1b[39m"),

			bgBlackBright: f("\x1b[100m", "\x1b[49m"),
			bgRedBright: f("\x1b[101m", "\x1b[49m"),
			bgGreenBright: f("\x1b[102m", "\x1b[49m"),
			bgYellowBright: f("\x1b[103m", "\x1b[49m"),
			bgBlueBright: f("\x1b[104m", "\x1b[49m"),
			bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
			bgCyanBright: f("\x1b[106m", "\x1b[49m"),
			bgWhiteBright: f("\x1b[107m", "\x1b[49m"),
		}
	};

	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var borderRadius$1;
var hasRequiredBorderRadius$1;

function requireBorderRadius$1 () {
	if (hasRequiredBorderRadius$1) return borderRadius$1;
	hasRequiredBorderRadius$1 = 1;
	borderRadius$1={A:{A:{"1":"F A B","2":"K D E wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","257":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB","289":"UC 0C 1C","292":"xC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"J"},E:{"1":"aB D E F A B C L M G 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"J 2C aC","129":"K 3C 4C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z ID JD OC uC KD PC","2":"F GD HD"},G:{"1":"E LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"aC"},H:{"2":"jD"},I:{"1":"UC J I lD mD nD vC oD pD","33":"kD"},J:{"1":"D A"},K:{"1":"B C H OC uC PC","2":"A"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","257":"3D"}},B:4,C:"CSS3 Border-radius (rounded corners)",D:true};
	return borderRadius$1;
}

var cssBoxshadow;
var hasRequiredCssBoxshadow;

function requireCssBoxshadow () {
	if (hasRequiredCssBoxshadow) return cssBoxshadow;
	hasRequiredCssBoxshadow = 1;
	cssBoxshadow={A:{A:{"1":"F A B","2":"K D E wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC","33":"0C 1C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"J aB K D E F"},E:{"1":"K D E F A B C L M G 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"aB","164":"J 2C aC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z ID JD OC uC KD PC","2":"F GD HD"},G:{"1":"E MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"LD vC","164":"aC"},H:{"2":"jD"},I:{"1":"J I nD vC oD pD","164":"UC kD lD mD"},J:{"1":"A","33":"D"},K:{"1":"B C H OC uC PC","2":"A"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS3 Box-shadow",D:true};
	return cssBoxshadow;
}

var cssAnimation;
var hasRequiredCssAnimation;

function requireCssAnimation () {
	if (hasRequiredCssAnimation) return cssAnimation;
	hasRequiredCssAnimation = 1;
	cssAnimation={A:{A:{"1":"A B","2":"K D E F wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J 0C 1C","33":"aB K D E F A B C L M G"},D:{"1":"0 1 2 3 4 5 pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"2C aC","33":"K D E 3C 4C 5C","292":"J aB"},F:{"1":"0 1 2 3 4 5 cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F B GD HD ID JD OC uC KD","33":"6 7 8 9 C G N O P bB AB BB CB DB EB FB"},G:{"1":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"E ND OD PD","164":"aC LD vC MD"},H:{"2":"jD"},I:{"1":"I","33":"J nD vC oD pD","164":"UC kD lD mD"},J:{"33":"D A"},K:{"1":"H PC","2":"A B C OC uC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:5,C:"CSS Animation",D:true};
	return cssAnimation;
}

var cssTransitions;
var hasRequiredCssTransitions;

function requireCssTransitions () {
	if (hasRequiredCssTransitions) return cssTransitions;
	hasRequiredCssTransitions = 1;
	cssTransitions={A:{A:{"1":"A B","2":"K D E F wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C 1C","33":"aB K D E F A B C L M G","164":"J"},D:{"1":"0 1 2 3 4 5 CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB"},E:{"1":"D E F A B C L M G 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"K 3C","164":"J aB 2C aC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F GD HD","33":"C","164":"B ID JD OC uC KD"},G:{"1":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"ND","164":"aC LD vC MD"},H:{"2":"jD"},I:{"1":"I oD pD","33":"UC J kD lD mD nD vC"},J:{"1":"A","33":"D"},K:{"1":"H PC","33":"C","164":"A B OC uC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:5,C:"CSS3 Transitions",D:true};
	return cssTransitions;
}

var transforms2d;
var hasRequiredTransforms2d;

function requireTransforms2d () {
	if (hasRequiredTransforms2d) return transforms2d;
	hasRequiredTransforms2d = 1;
	transforms2d={A:{A:{"2":"wC","8":"K D E","129":"A B","161":"F"},B:{"1":"0 1 2 3 4 5 O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","129":"C L M G N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC","33":"J aB K D E F A B C L M G 0C 1C"},D:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"J aB K D E 2C aC 3C 4C 5C"},F:{"1":"0 1 2 3 4 5 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F GD HD","33":"6 7 8 B C G N O P bB ID JD OC uC KD"},G:{"1":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"E aC LD vC MD ND OD PD"},H:{"2":"jD"},I:{"1":"I","33":"UC J kD lD mD nD vC oD pD"},J:{"33":"D A"},K:{"1":"B C H OC uC PC","2":"A"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS3 2D Transforms",D:true};
	return transforms2d;
}

var transforms3d;
var hasRequiredTransforms3d;

function requireTransforms3d () {
	if (hasRequiredTransforms3d) return transforms3d;
	hasRequiredTransforms3d = 1;
	transforms3d={A:{A:{"2":"K D E F wC","132":"A B"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB K D E F 0C 1C","33":"A B C L M G"},D:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K D E F A B","33":"6 7 8 9 C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB"},E:{"1":"dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"2C aC","33":"J aB K D E 3C 4C 5C","257":"F A B C L M G 6C bC OC PC 7C 8C 9C cC"},F:{"1":"0 1 2 3 4 5 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 G N O P bB"},G:{"1":"dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"E aC LD vC MD ND OD PD","257":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC"},H:{"2":"jD"},I:{"1":"I","2":"kD lD mD","33":"UC J nD vC oD pD"},J:{"33":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"132":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:5,C:"CSS3 3D Transforms",D:true};
	return transforms3d;
}

var cssGradients;
var hasRequiredCssGradients;

function requireCssGradients () {
	if (hasRequiredCssGradients) return cssGradients;
	hasRequiredCssGradients = 1;
	cssGradients={A:{A:{"1":"A B","2":"K D E F wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C","260":"6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB","292":"J aB K D E F A B C L M G 1C"},D:{"1":"0 1 2 3 4 5 CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 A B C L M G N O P bB AB BB","548":"J aB K D E F"},E:{"1":"dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"2C aC","260":"D E F A B C L M G 4C 5C 6C bC OC PC 7C 8C 9C cC","292":"K 3C","804":"J aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F B GD HD ID JD","33":"C KD","164":"OC uC"},G:{"1":"dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","260":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC","292":"MD ND","804":"aC LD vC"},H:{"2":"jD"},I:{"1":"I oD pD","33":"J nD vC","548":"UC kD lD mD"},J:{"1":"A","548":"D"},K:{"1":"H PC","2":"A B","33":"C","164":"OC uC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS Gradients",D:true};
	return cssGradients;
}

var css3Boxsizing;
var hasRequiredCss3Boxsizing;

function requireCss3Boxsizing () {
	if (hasRequiredCss3Boxsizing) return css3Boxsizing;
	hasRequiredCss3Boxsizing = 1;
	css3Boxsizing={A:{A:{"1":"E F A B","8":"K D wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","33":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB 0C 1C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"J aB K D E F"},E:{"1":"K D E F A B C L M G 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"J aB 2C aC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GD HD ID JD OC uC KD PC","2":"F"},G:{"1":"E MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"aC LD vC"},H:{"1":"jD"},I:{"1":"J I nD vC oD pD","33":"UC kD lD mD"},J:{"1":"A","33":"D"},K:{"1":"A B C H OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:5,C:"CSS3 Box-sizing",D:true};
	return css3Boxsizing;
}

var cssFilters;
var hasRequiredCssFilters;

function requireCssFilters () {
	if (hasRequiredCssFilters) return cssFilters;
	hasRequiredCssFilters = 1;
	cssFilters={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","1028":"L M G N O P","1346":"C"},C:{"1":"0 1 2 3 4 5 hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C","196":"gB","516":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB 1C"},D:{"1":"0 1 2 3 4 5 zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K D E F A B C L M G N O","33":"6 7 8 9 P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB"},E:{"1":"A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC 3C","33":"K D E F 4C 5C"},F:{"1":"0 1 2 3 4 5 mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB"},G:{"1":"RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","33":"E ND OD PD QD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC","33":"oD pD"},J:{"2":"D","33":"A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D","33":"J qD rD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:5,C:"CSS Filter Effects",D:true};
	return cssFilters;
}

var cssFilterFunction;
var hasRequiredCssFilterFunction;

function requireCssFilterFunction () {
	if (hasRequiredCssFilterFunction) return cssFilterFunction;
	hasRequiredCssFilterFunction = 1;
	cssFilterFunction={A:{A:{"2":"K D E F A B wC"},B:{"2":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"2":"0 1 2 3 4 5 6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC 0C 1C"},D:{"2":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"1":"A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E 2C aC 3C 4C 5C","33":"F"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GD HD ID JD OC uC KD PC"},G:{"1":"SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD","33":"QD RD"},H:{"2":"jD"},I:{"2":"UC J I kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"2":"A B C H OC uC PC"},L:{"2":"I"},M:{"2":"NC"},N:{"2":"A B"},O:{"2":"QC"},P:{"2":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"2":"1D"},R:{"2":"2D"},S:{"2":"3D 4D"}},B:5,C:"CSS filter() function",D:true};
	return cssFilterFunction;
}

var cssBackdropFilter;
var hasRequiredCssBackdropFilter;

function requireCssBackdropFilter () {
	if (hasRequiredCssBackdropFilter) return cssBackdropFilter;
	hasRequiredCssBackdropFilter = 1;
	cssBackdropFilter={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N","257":"O P"},C:{"1":"0 1 2 3 4 5 m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC 0C 1C","578":"EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l"},D:{"1":"0 1 2 3 4 5 KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB","194":"tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC"},E:{"1":"TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E 2C aC 3C 4C 5C","33":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD"},F:{"1":"0 1 2 3 4 5 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB GD HD ID JD OC uC KD PC","194":"gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B"},G:{"1":"TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD","33":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB wD xD yD zD RC SC TC 0D","2":"J","194":"qD rD sD tD uD bC vD"},Q:{"2":"1D"},R:{"1":"2D"},S:{"2":"3D 4D"}},B:7,C:"CSS Backdrop Filter",D:true};
	return cssBackdropFilter;
}

var cssElementFunction;
var hasRequiredCssElementFunction;

function requireCssElementFunction () {
	if (hasRequiredCssElementFunction) return cssElementFunction;
	hasRequiredCssElementFunction = 1;
	cssElementFunction={A:{A:{"2":"K D E F A B wC"},B:{"2":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"33":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","164":"xC UC 0C 1C"},D:{"2":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"2":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GD HD ID JD OC uC KD PC"},G:{"2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"2":"UC J I kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"2":"A B C H OC uC PC"},L:{"2":"I"},M:{"33":"NC"},N:{"2":"A B"},O:{"2":"QC"},P:{"2":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"2":"1D"},R:{"2":"2D"},S:{"33":"3D 4D"}},B:5,C:"CSS element() function",D:true};
	return cssElementFunction;
}

var multicolumn;
var hasRequiredMulticolumn;

function requireMulticolumn () {
	if (hasRequiredMulticolumn) return multicolumn;
	hasRequiredMulticolumn = 1;
	multicolumn={A:{A:{"1":"A B","2":"K D E F wC"},B:{"1":"C L M G N O P","516":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"132":"yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B","164":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB 0C 1C","516":"9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a","1028":"0 1 2 3 4 5 b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC"},D:{"420":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB","516":"0 1 2 3 4 5 wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"1":"A B C L M G bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","132":"F 6C","164":"D E 5C","420":"J aB K 2C aC 3C 4C"},F:{"1":"C OC uC KD PC","2":"F B GD HD ID JD","420":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB","516":"0 1 2 3 4 5 jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},G:{"1":"SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","132":"QD RD","164":"E OD PD","420":"aC LD vC MD ND"},H:{"1":"jD"},I:{"420":"UC J kD lD mD nD vC oD pD","516":"I"},J:{"420":"D A"},K:{"1":"C OC uC PC","2":"A B","516":"H"},L:{"516":"I"},M:{"1028":"NC"},N:{"1":"A B"},O:{"516":"QC"},P:{"420":"J","516":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"516":"1D"},R:{"516":"2D"},S:{"164":"3D 4D"}},B:4,C:"CSS3 Multiple column layout",D:true};
	return multicolumn;
}

var userSelectNone;
var hasRequiredUserSelectNone;

function requireUserSelectNone () {
	if (hasRequiredUserSelectNone) return userSelectNone;
	hasRequiredUserSelectNone = 1;
	userSelectNone={A:{A:{"2":"K D E F wC","33":"A B"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","33":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","33":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC 0C 1C"},D:{"1":"0 1 2 3 4 5 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB"},E:{"33":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD"},F:{"1":"0 1 2 3 4 5 nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB"},G:{"33":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"1":"I","33":"UC J kD lD mD nD vC oD pD"},J:{"33":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"33":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","33":"J qD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","33":"3D"}},B:5,C:"CSS user-select: none",D:true};
	return userSelectNone;
}

var flexbox;
var hasRequiredFlexbox;

function requireFlexbox () {
	if (hasRequiredFlexbox) return flexbox;
	hasRequiredFlexbox = 1;
	flexbox={A:{A:{"2":"K D E F wC","1028":"B","1316":"A"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","164":"6 7 xC UC J aB K D E F A B C L M G N O P bB 0C 1C","516":"8 9 AB BB CB DB"},D:{"1":"0 1 2 3 4 5 FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"7 8 9 AB BB CB DB EB","164":"6 J aB K D E F A B C L M G N O P bB"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"D E 4C 5C","164":"J aB K 2C aC 3C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F B C GD HD ID JD OC uC KD","33":"G N"},G:{"1":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"E OD PD","164":"aC LD vC MD ND"},H:{"1":"jD"},I:{"1":"I oD pD","164":"UC J kD lD mD nD vC"},J:{"1":"A","164":"D"},K:{"1":"H PC","2":"A B C OC uC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"B","292":"A"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS Flexible Box Layout Module",D:true};
	return flexbox;
}

var calc;
var hasRequiredCalc;

function requireCalc () {
	if (hasRequiredCalc) return calc;
	hasRequiredCalc = 1;
	calc={A:{A:{"2":"K D E wC","260":"F","516":"A B"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C 1C","33":"J aB K D E F A B C L M G"},D:{"1":"0 1 2 3 4 5 CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K D E F A B C L M G N O P","33":"6 7 8 9 bB AB BB"},E:{"1":"D E F A B C L M G 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC 3C","33":"K"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC"},G:{"1":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","33":"ND"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC","132":"oD pD"},J:{"1":"A","2":"D"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"calc() as CSS unit value",D:true};
	return calc;
}

var backgroundImgOpts;
var hasRequiredBackgroundImgOpts;

function requireBackgroundImgOpts () {
	if (hasRequiredBackgroundImgOpts) return backgroundImgOpts;
	hasRequiredBackgroundImgOpts = 1;
	backgroundImgOpts={A:{A:{"1":"F A B","2":"K D E wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C","36":"1C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","516":"J aB K D E F A B C L M"},E:{"1":"D E F A B C L M G 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","772":"J aB K 2C aC 3C 4C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z ID JD OC uC KD PC","2":"F GD","36":"HD"},G:{"1":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","4":"aC LD vC ND","516":"MD"},H:{"132":"jD"},I:{"1":"I oD pD","36":"kD","516":"UC J nD vC","548":"lD mD"},J:{"1":"D A"},K:{"1":"A B C H OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS3 Background-image options",D:true};
	return backgroundImgOpts;
}

var backgroundClipText;
var hasRequiredBackgroundClipText;

function requireBackgroundClipText () {
	if (hasRequiredBackgroundClipText) return backgroundClipText;
	hasRequiredBackgroundClipText = 1;
	backgroundClipText={A:{A:{"2":"K D E F A B wC"},B:{"1":"G N O P","33":"C L M","129":"3 4 5 GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","161":"0 1 2 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},C:{"1":"0 1 2 3 4 5 vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB 0C 1C"},D:{"129":"3 4 5 GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","161":"0 1 2 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},E:{"2":"2C","129":"QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","388":"aB K D E F A B C L M G 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC","420":"J aC"},F:{"2":"F B C GD HD ID JD OC uC KD PC","129":"0 1 2 3 4 5 p q r s t u v w x y z","161":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o"},G:{"129":"QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","388":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC"},H:{"2":"jD"},I:{"16":"UC kD lD mD","129":"I","161":"J nD vC oD pD"},J:{"161":"D A"},K:{"16":"A B C OC uC PC","129":"H"},L:{"129":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"161":"QC"},P:{"1":"BB CB DB EB FB","161":"6 7 8 9 J AB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"161":"1D"},R:{"161":"2D"},S:{"1":"3D 4D"}},B:7,C:"Background-clip: text",D:true};
	return backgroundClipText;
}

var fontFeature;
var hasRequiredFontFeature;

function requireFontFeature () {
	if (hasRequiredFontFeature) return fontFeature;
	hasRequiredFontFeature = 1;
	fontFeature={A:{A:{"1":"A B","2":"K D E F wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C 1C","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB","164":"J aB K D E F A B C L M"},D:{"1":"0 1 2 3 4 5 uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K D E F A B C L M G","33":"7 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB","292":"6 N O P bB"},E:{"1":"A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"D E F 2C aC 4C 5C","4":"J aB K 3C"},F:{"1":"0 1 2 3 4 5 hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB"},G:{"1":"RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E OD PD QD","4":"aC LD vC MD ND"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC","33":"oD pD"},J:{"2":"D","33":"A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","33":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:2,C:"CSS font-feature-settings",D:true};
	return fontFeature;
}

var fontKerning;
var hasRequiredFontKerning;

function requireFontKerning () {
	if (hasRequiredFontKerning) return fontKerning;
	hasRequiredFontKerning = 1;
	fontKerning={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB 0C 1C","194":"AB BB CB DB EB FB cB dB eB fB"},D:{"1":"0 1 2 3 4 5 fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB","33":"FB cB dB eB"},E:{"1":"A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K 2C aC 3C 4C","33":"D E F 5C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C G GD HD ID JD OC uC KD PC","33":"N O P bB"},G:{"1":"WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND OD","33":"E PD QD RD SD TD UD VD"},H:{"2":"jD"},I:{"1":"I pD","2":"UC J kD lD mD nD vC","33":"oD"},J:{"2":"D","33":"A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS3 font-kerning",D:true};
	return fontKerning;
}

var borderImage$1;
var hasRequiredBorderImage$1;

function requireBorderImage$1 () {
	if (hasRequiredBorderImage$1) return borderImage$1;
	hasRequiredBorderImage$1 = 1;
	borderImage$1={A:{A:{"1":"B","2":"K D E F A wC"},B:{"1":"0 1 2 3 4 5 M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","129":"C L"},C:{"1":"0 1 2 3 4 5 wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC","260":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB","804":"J aB K D E F A B C L M 0C 1C"},D:{"1":"0 1 2 3 4 5 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","260":"xB yB zB 0B 1B","388":"cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB","1412":"6 7 8 9 G N O P bB AB BB CB DB EB FB","1956":"J aB K D E F A B C L M"},E:{"1":"dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","129":"A B C L M G 6C bC OC PC 7C 8C 9C cC","1412":"K D E F 4C 5C","1956":"J aB 2C aC 3C"},F:{"1":"0 1 2 3 4 5 pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F GD HD","260":"kB lB mB nB oB","388":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB","1796":"ID JD","1828":"B C OC uC KD PC"},G:{"1":"dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","129":"RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC","1412":"E ND OD PD QD","1956":"aC LD vC MD"},H:{"1828":"jD"},I:{"1":"I","388":"oD pD","1956":"UC J kD lD mD nD vC"},J:{"1412":"A","1924":"D"},K:{"1":"H","2":"A","1828":"B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"B","2":"A"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D","260":"qD rD","388":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","260":"3D"}},B:4,C:"CSS3 Border images",D:true};
	return borderImage$1;
}

var cssSelection;
var hasRequiredCssSelection;

function requireCssSelection () {
	if (hasRequiredCssSelection) return cssSelection;
	hasRequiredCssSelection = 1;
	cssSelection={A:{A:{"1":"F A B","2":"K D E wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","33":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 0C 1C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"1":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GD HD ID JD OC uC KD PC","2":"F"},G:{"2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"1":"I oD pD","2":"UC J kD lD mD nD vC"},J:{"1":"A","2":"D"},K:{"1":"C H uC PC","16":"A B OC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","33":"3D"}},B:5,C:"::selection CSS pseudo-element",D:true};
	return cssSelection;
}

var cssPlaceholder;
var hasRequiredCssPlaceholder;

function requireCssPlaceholder () {
	if (hasRequiredCssPlaceholder) return cssPlaceholder;
	hasRequiredCssPlaceholder = 1;
	cssPlaceholder={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","36":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","33":"6 7 8 9 bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB","130":"xC UC J aB K D E F A B C L M G N O P 0C 1C"},D:{"1":"0 1 2 3 4 5 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","36":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B"},E:{"1":"B C L M G bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J 2C aC","36":"aB K D E F A 3C 4C 5C 6C"},F:{"1":"0 1 2 3 4 5 qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","36":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB"},G:{"1":"TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD","36":"E vC MD ND OD PD QD RD SD"},H:{"2":"jD"},I:{"1":"I","36":"UC J kD lD mD nD vC oD pD"},J:{"36":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"36":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D","36":"J qD rD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","33":"3D"}},B:5,C:"::placeholder CSS pseudo-element",D:true};
	return cssPlaceholder;
}

var cssPlaceholderShown;
var hasRequiredCssPlaceholderShown;

function requireCssPlaceholderShown () {
	if (hasRequiredCssPlaceholderShown) return cssPlaceholderShown;
	hasRequiredCssPlaceholderShown = 1;
	cssPlaceholderShown={A:{A:{"2":"K D E F wC","292":"A B"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C 1C","164":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB"},D:{"1":"0 1 2 3 4 5 tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E 2C aC 3C 4C 5C"},F:{"1":"0 1 2 3 4 5 gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB GD HD ID JD OC uC KD PC"},G:{"1":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","164":"3D"}},B:5,C:":placeholder-shown CSS pseudo-class",D:true};
	return cssPlaceholderShown;
}

var cssHyphens;
var hasRequiredCssHyphens;

function requireCssHyphens () {
	if (hasRequiredCssHyphens) return cssHyphens;
	hasRequiredCssHyphens = 1;
	cssHyphens={A:{A:{"2":"K D E F wC","33":"A B"},B:{"1":"0 1 2 3 4 5 o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","33":"C L M G N O P","132":"Q H R S T U V W","260":"X Y Z a b c d e f g h i j k l m n"},C:{"1":"0 1 2 3 4 5 pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB 0C 1C","33":"6 7 8 9 K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB"},D:{"1":"0 1 2 3 4 5 X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B","132":"1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W"},E:{"1":"SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC","33":"K D E F A B C L M G 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD"},F:{"1":"0 1 2 3 4 5 a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB GD HD ID JD OC uC KD PC","132":"oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z"},G:{"1":"SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD","33":"E vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J","132":"qD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS Hyphenation",D:true};
	return cssHyphens;
}

var fullscreen$1;
var hasRequiredFullscreen$1;

function requireFullscreen$1 () {
	if (hasRequiredFullscreen$1) return fullscreen$1;
	hasRequiredFullscreen$1 = 1;
	fullscreen$1={A:{A:{"2":"K D E F A wC","548":"B"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","516":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB K D E F 0C 1C","676":"6 7 8 9 A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB","1700":"tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B"},D:{"1":"0 1 2 3 4 5 FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K D E F A B C L M","676":"G N O P bB","804":"6 7 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC"},E:{"1":"hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC","548":"dC QC AD RC eC fC gC","676":"3C","804":"K D E F A B C L M G 4C 5C 6C bC OC PC 7C 8C 9C cC"},F:{"1":"0 1 2 3 4 5 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F B C GD HD ID JD OC uC KD","804":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B"},G:{"2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD","2052":"WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"2":"UC J I kD lD mD nD vC oD pD"},J:{"2":"D","292":"A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A","548":"B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB bC vD wD xD yD zD RC SC TC 0D","804":"J qD rD sD tD uD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:1,C:"Fullscreen API",D:true};
	return fullscreen$1;
}

var mdnCssBackdropPseudoElement;
var hasRequiredMdnCssBackdropPseudoElement;

function requireMdnCssBackdropPseudoElement () {
	if (hasRequiredMdnCssBackdropPseudoElement) return mdnCssBackdropPseudoElement;
	hasRequiredMdnCssBackdropPseudoElement = 1;
	mdnCssBackdropPseudoElement={A:{D:{"1":"0 1 2 3 4 5 jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB","33":"eB fB gB hB iB"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","33":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB 0C 1C"},M:{"1":"NC"},A:{"2":"K D E F A wC","33":"B"},F:{"1":"0 1 2 3 4 5 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C G N O P GD HD ID JD OC uC KD PC","33":"6 7 8 9 bB"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC FD"},G:{"1":"dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},I:{"1":"I","2":"UC J kD lD mD nD vC","33":"oD pD"}},B:6,C:"CSS ::backdrop pseudo-element",D:undefined};
	return mdnCssBackdropPseudoElement;
}

var cssFileSelectorButton;
var hasRequiredCssFileSelectorButton;

function requireCssFileSelectorButton () {
	if (hasRequiredCssFileSelectorButton) return cssFileSelectorButton;
	hasRequiredCssFileSelectorButton = 1;
	cssFileSelectorButton={A:{D:{"1":"0 1 2 3 4 5 Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","33":"C L M G N O P Q H R S T U V W X"},C:{"1":"0 1 2 3 4 5 XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R 0C 1C"},M:{"1":"NC"},A:{"2":"K D E F wC","33":"A B"},F:{"1":"0 1 2 3 4 5 JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"G 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"FD","33":"J aB K D E F A B C L M 2C aC 3C 4C 5C 6C bC OC PC 7C"},G:{"1":"dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD"},P:{"1":"6 7 8 9 AB BB CB DB EB FB zD RC SC TC 0D","33":"J qD rD sD tD uD bC vD wD xD yD"},I:{"1":"I","2":"UC J kD lD mD nD vC","33":"oD pD"}},B:6,C:"::file-selector-button CSS pseudo-element",D:undefined};
	return cssFileSelectorButton;
}

var cssAutofill;
var hasRequiredCssAutofill;

function requireCssAutofill () {
	if (hasRequiredCssAutofill) return cssAutofill;
	hasRequiredCssAutofill = 1;
	cssAutofill={A:{D:{"1":"0 1 2 3 4 5 t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P","33":"Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s"},C:{"1":"0 1 2 3 4 5 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U 0C 1C"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"G 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"FD","33":"J aB K D E F A B C L M 2C aC 3C 4C 5C 6C bC OC PC 7C 8C"},G:{"1":"eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD"},P:{"1":"7 8 9 AB BB CB DB EB FB","33":"6 J qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},I:{"1":"I","2":"UC J kD lD mD nD vC","33":"oD pD"}},B:6,C:":autofill CSS pseudo-class",D:undefined};
	return cssAutofill;
}

var css3Tabsize;
var hasRequiredCss3Tabsize;

function requireCss3Tabsize () {
	if (hasRequiredCss3Tabsize) return css3Tabsize;
	hasRequiredCss3Tabsize = 1;
	css3Tabsize={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C 1C","33":"zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z","164":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB"},D:{"1":"0 1 2 3 4 5 oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 J aB K D E F A B C L M G N O P bB","132":"7 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB"},E:{"1":"M G 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K 2C aC 3C","132":"D E F A B C L 4C 5C 6C bC OC PC"},F:{"1":"0 1 2 3 4 5 FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F GD HD ID","132":"6 7 8 9 G N O P bB AB BB CB DB EB","164":"B C JD OC uC KD PC"},G:{"1":"bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND","132":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD"},H:{"164":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC","132":"oD pD"},J:{"132":"D A"},K:{"1":"H","2":"A","164":"B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"164":"3D 4D"}},B:4,C:"CSS3 tab-size",D:true};
	return css3Tabsize;
}

var intrinsicWidth;
var hasRequiredIntrinsicWidth;

function requireIntrinsicWidth () {
	if (hasRequiredIntrinsicWidth) return intrinsicWidth;
	hasRequiredIntrinsicWidth = 1;
	intrinsicWidth={A:{A:{"2":"K D E F A B wC"},B:{"2":"C L M G N O P","1025":"0 1 2 3 4 5 d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","1537":"Q H R S T U V W X Y Z a b c"},C:{"2":"xC","932":"6 7 8 9 UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B 0C 1C","2308":"0 1 2 3 4 5 AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC"},D:{"2":"6 7 J aB K D E F A B C L M G N O P bB","545":"8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB","1025":"0 1 2 3 4 5 d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","1537":"sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c"},E:{"1":"RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K 2C aC 3C","516":"B C L M G OC PC 7C 8C 9C cC dC QC AD","548":"F A 6C bC","676":"D E 4C 5C"},F:{"2":"F B C GD HD ID JD OC uC KD PC","513":"gB","545":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB","1025":"0 1 2 3 4 5 e f g h i j k l m n o p q r s t u v w x y z","1537":"fB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d"},G:{"1":"RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND","516":"cD dD eD cC dC QC fD","548":"QD RD SD TD UD VD WD XD YD ZD aD bD","676":"E OD PD"},H:{"2":"jD"},I:{"2":"UC J kD lD mD nD vC","545":"oD pD","1025":"I"},J:{"2":"D","545":"A"},K:{"2":"A B C OC uC PC","1025":"H"},L:{"1025":"I"},M:{"2308":"NC"},N:{"2":"A B"},O:{"1537":"QC"},P:{"545":"J","1025":"6 7 8 9 AB BB CB DB EB FB SC TC 0D","1537":"qD rD sD tD uD bC vD wD xD yD zD RC"},Q:{"1537":"1D"},R:{"1537":"2D"},S:{"932":"3D","2308":"4D"}},B:5,C:"Intrinsic & Extrinsic Sizing",D:true};
	return intrinsicWidth;
}

var cssWidthStretch;
var hasRequiredCssWidthStretch;

function requireCssWidthStretch () {
	if (hasRequiredCssWidthStretch) return cssWidthStretch;
	hasRequiredCssWidthStretch = 1;
	cssWidthStretch={A:{D:{"1":"VB WB XB YB I ZB NC YC ZC","2":"6 7 J aB K D E F A B C L M G N O P bB","33":"0 1 2 3 4 5 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},L:{"1":"I"},B:{"1":"VB WB XB YB I ZB","2":"C L M G N O P","33":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},C:{"2":"0 1 2 3 4 5 6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC 0C 1C","33":"ZC yC zC"},M:{"2":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"5","2":"F B C GD HD ID JD OC uC KD PC","33":"0 1 2 3 4 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},K:{"2":"A B C OC uC PC","33":"H"},E:{"2":"J aB K 2C aC 3C 4C FD","33":"D E F A B C L M G 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED"},G:{"2":"aC LD vC MD ND","33":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},P:{"2":"J","33":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},I:{"1":"I","2":"UC J kD lD mD nD vC","33":"oD pD"}},B:6,C:"width: stretch property",D:undefined};
	return cssWidthStretch;
}

var css3CursorsNewer;
var hasRequiredCss3CursorsNewer;

function requireCss3CursorsNewer () {
	if (hasRequiredCss3CursorsNewer) return css3CursorsNewer;
	hasRequiredCss3CursorsNewer = 1;
	css3CursorsNewer={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","33":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB 0C 1C"},D:{"1":"0 1 2 3 4 5 jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"J aB K D E 2C aC 3C 4C 5C"},F:{"1":"0 1 2 3 4 5 C AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z KD PC","2":"F B GD HD ID JD OC uC","33":"6 7 8 9 G N O P bB"},G:{"2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"33":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"2":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"2":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"2":"3D 4D"}},B:2,C:"CSS3 Cursors: zoom-in & zoom-out",D:true};
	return css3CursorsNewer;
}

var css3CursorsGrab;
var hasRequiredCss3CursorsGrab;

function requireCss3CursorsGrab () {
	if (hasRequiredCss3CursorsGrab) return css3CursorsGrab;
	hasRequiredCss3CursorsGrab = 1;
	css3CursorsGrab={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M"},C:{"1":"0 1 2 3 4 5 DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","33":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB 0C 1C"},D:{"1":"0 1 2 3 4 5 CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC"},E:{"1":"B C L M G OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"J aB K D E F A 2C aC 3C 4C 5C 6C bC"},F:{"1":"0 1 2 3 4 5 C 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z KD PC","2":"F B GD HD ID JD OC uC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B"},G:{"2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"33":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"2":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"2":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"2":"3D 4D"}},B:2,C:"CSS grab & grabbing cursors",D:true};
	return css3CursorsGrab;
}

var cssSticky;
var hasRequiredCssSticky;

function requireCssSticky () {
	if (hasRequiredCssSticky) return cssSticky;
	hasRequiredCssSticky = 1;
	cssSticky={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G","1028":"Q H R S T U V W X Y Z","4100":"N O P"},C:{"1":"0 1 2 3 4 5 VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB 0C 1C","194":"CB DB EB FB cB dB","516":"eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B"},D:{"1":"0 1 2 3 4 5 a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 J aB K D E F A B C L M G N O P bB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB","322":"9 AB BB CB DB EB FB cB dB eB fB gB hB iB yB zB 0B 1B","1028":"2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z"},E:{"1":"L M G 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K 2C aC 3C","33":"E F A B C 5C 6C bC OC PC","2084":"D 4C"},F:{"1":"0 1 2 3 4 5 MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB GD HD ID JD OC uC KD PC","322":"lB mB nB","1028":"oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC"},G:{"1":"YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","33":"E PD QD RD SD TD UD VD WD XD","2084":"ND OD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J qD"},Q:{"1028":"1D"},R:{"1":"2D"},S:{"1":"4D","516":"3D"}},B:5,C:"CSS position:sticky",D:true};
	return cssSticky;
}

var pointer;
var hasRequiredPointer;

function requirePointer () {
	if (hasRequiredPointer) return pointer;
	hasRequiredPointer = 1;
	pointer={A:{A:{"1":"B","2":"K D E F wC","164":"A"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB 0C 1C","8":"6 7 8 9 K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB","328":"nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B"},D:{"1":"0 1 2 3 4 5 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 J aB K D E F A B C L M G N O P bB","8":"8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB","584":"yB zB 0B"},E:{"1":"L M G 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K 2C aC 3C","8":"D E F A B C 4C 5C 6C bC OC","1096":"PC"},F:{"1":"0 1 2 3 4 5 oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","8":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB","584":"lB mB nB"},G:{"1":"ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","8":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD","6148":"YD"},H:{"2":"jD"},I:{"1":"I","8":"UC J kD lD mD nD vC oD pD"},J:{"8":"D A"},K:{"1":"H","2":"A","8":"B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"B","36":"A"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"qD","8":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","328":"3D"}},B:2,C:"Pointer events",D:true};
	return pointer;
}

var textDecoration$1;
var hasRequiredTextDecoration$1;

function requireTextDecoration$1 () {
	if (hasRequiredTextDecoration$1) return textDecoration$1;
	hasRequiredTextDecoration$1 = 1;
	textDecoration$1={A:{A:{"2":"K D E F A B wC"},B:{"2":"C L M G N O P","2052":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"2":"xC UC J aB 0C 1C","1028":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","1060":"6 7 8 9 K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB"},D:{"2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB","226":"CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B","2052":"0 1 2 3 4 5 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"2":"J aB K D 2C aC 3C 4C","772":"L M G PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","804":"E F A B C 6C bC OC","1316":"5C"},F:{"2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB GD HD ID JD OC uC KD PC","226":"hB iB jB kB lB mB nB oB pB","2052":"0 1 2 3 4 5 qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},G:{"2":"aC LD vC MD ND OD","292":"E PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"2":"A B C OC uC PC","2052":"H"},L:{"2052":"I"},M:{"1028":"NC"},N:{"2":"A B"},O:{"2052":"QC"},P:{"2":"J qD rD","2052":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"2052":"1D"},R:{"2052":"2D"},S:{"1028":"3D 4D"}},B:4,C:"text-decoration styling",D:true};
	return textDecoration$1;
}

var mdnTextDecorationShorthand;
var hasRequiredMdnTextDecorationShorthand;

function requireMdnTextDecorationShorthand () {
	if (hasRequiredMdnTextDecorationShorthand) return mdnTextDecorationShorthand;
	hasRequiredMdnTextDecorationShorthand = 1;
	mdnTextDecorationShorthand={A:{D:{"1":"0 1 2 3 4 5 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB 0C 1C"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB GD HD ID JD OC uC KD PC"},K:{"1":"H","2":"A B C OC uC PC"},E:{"2":"J aB K D 2C aC 3C 4C 5C FD","33":"E F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED"},G:{"2":"aC LD vC MD ND OD","33":"E PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J qD rD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"}},B:6,C:"text-decoration shorthand property",D:undefined};
	return mdnTextDecorationShorthand;
}

var mdnTextDecorationColor;
var hasRequiredMdnTextDecorationColor;

function requireMdnTextDecorationColor () {
	if (hasRequiredMdnTextDecorationColor) return mdnTextDecorationColor;
	hasRequiredMdnTextDecorationColor = 1;
	mdnTextDecorationColor={A:{D:{"1":"0 1 2 3 4 5 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB 0C 1C","33":"6 7 8 9 K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB GD HD ID JD OC uC KD PC"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"L M G PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB K D 2C aC 3C 4C 5C FD","33":"E F A B C 6C bC OC"},G:{"1":"XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND OD","33":"E PD QD RD SD TD UD VD WD"},P:{"1":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J qD rD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"}},B:6,C:"text-decoration-color property",D:undefined};
	return mdnTextDecorationColor;
}

var mdnTextDecorationLine;
var hasRequiredMdnTextDecorationLine;

function requireMdnTextDecorationLine () {
	if (hasRequiredMdnTextDecorationLine) return mdnTextDecorationLine;
	hasRequiredMdnTextDecorationLine = 1;
	mdnTextDecorationLine={A:{D:{"1":"0 1 2 3 4 5 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB 0C 1C","33":"6 7 8 9 K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB GD HD ID JD OC uC KD PC"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"L M G PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB K D 2C aC 3C 4C 5C FD","33":"E F A B C 6C bC OC"},G:{"1":"XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND OD","33":"E PD QD RD SD TD UD VD WD"},P:{"1":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J qD rD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"}},B:6,C:"text-decoration-line property",D:undefined};
	return mdnTextDecorationLine;
}

var mdnTextDecorationStyle;
var hasRequiredMdnTextDecorationStyle;

function requireMdnTextDecorationStyle () {
	if (hasRequiredMdnTextDecorationStyle) return mdnTextDecorationStyle;
	hasRequiredMdnTextDecorationStyle = 1;
	mdnTextDecorationStyle={A:{D:{"1":"0 1 2 3 4 5 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB 0C 1C","33":"6 7 8 9 K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB GD HD ID JD OC uC KD PC"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"L M G PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB K D 2C aC 3C 4C 5C FD","33":"E F A B C 6C bC OC"},G:{"1":"XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND OD","33":"E PD QD RD SD TD UD VD WD"},P:{"1":"6 7 8 9 AB BB CB DB EB FB sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J qD rD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"}},B:6,C:"text-decoration-style property",D:undefined};
	return mdnTextDecorationStyle;
}

var textSizeAdjust;
var hasRequiredTextSizeAdjust;

function requireTextSizeAdjust () {
	if (hasRequiredTextSizeAdjust) return textSizeAdjust;
	hasRequiredTextSizeAdjust = 1;
	textSizeAdjust={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","33":"C L M G N O P"},C:{"2":"0 1 2 3 4 5 6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC 0C 1C"},D:{"1":"0 1 2 3 4 5 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB","258":"CB"},E:{"2":"J aB K D E F A B C L M G 2C aC 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","258":"3C"},F:{"1":"0 1 2 3 4 5 pB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB qB GD HD ID JD OC uC KD PC"},G:{"2":"aC LD vC","33":"E MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"33":"NC"},N:{"161":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"2":"3D 4D"}},B:7,C:"CSS text-size-adjust",D:true};
	return textSizeAdjust;
}

var cssMasks;
var hasRequiredCssMasks;

function requireCssMasks () {
	if (hasRequiredCssMasks) return cssMasks;
	hasRequiredCssMasks = 1;
	cssMasks={A:{A:{"2":"K D E F A B wC"},B:{"1":"3 4 5 GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N","164":"0 1 2 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","3138":"O","12292":"P"},C:{"1":"0 1 2 3 4 5 zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC","260":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB 0C 1C"},D:{"1":"3 4 5 GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","164":"0 1 2 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"2C aC","164":"J aB K D E F A B C L M G 3C 4C 5C 6C bC OC PC 7C 8C 9C cC"},F:{"1":"0 1 2 3 4 5 p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","164":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o"},G:{"1":"dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","164":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC"},H:{"2":"jD"},I:{"1":"I","164":"oD pD","676":"UC J kD lD mD nD vC"},J:{"164":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"164":"QC"},P:{"1":"BB CB DB EB FB","164":"6 7 8 9 J AB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"164":"1D"},R:{"164":"2D"},S:{"1":"4D","260":"3D"}},B:4,C:"CSS Masks",D:true};
	return cssMasks;
}

var cssClipPath;
var hasRequiredCssClipPath;

function requireCssClipPath () {
	if (hasRequiredCssClipPath) return cssClipPath;
	hasRequiredCssClipPath = 1;
	cssClipPath={A:{A:{"2":"K D E F A B wC"},B:{"2":"C L M G N O","260":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","3138":"P"},C:{"1":"0 1 2 3 4 5 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC","132":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB 0C 1C","644":"tB uB vB wB xB yB zB"},D:{"2":"6 7 8 9 J aB K D E F A B C L M G N O P bB","260":"0 1 2 3 4 5 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","292":"AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B"},E:{"2":"J aB K 2C aC 3C 4C","260":"M G 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","292":"D E F A B C L 5C 6C bC OC PC"},F:{"2":"F B C GD HD ID JD OC uC KD PC","260":"0 1 2 3 4 5 oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","292":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB"},G:{"2":"aC LD vC MD ND","260":"YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","292":"E OD PD QD RD SD TD UD VD WD XD"},H:{"2":"jD"},I:{"2":"UC J kD lD mD nD vC","260":"I","292":"oD pD"},J:{"2":"D A"},K:{"2":"A B C OC uC PC","260":"H"},L:{"260":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"260":"QC"},P:{"260":"6 7 8 9 AB BB CB DB EB FB rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","292":"J qD"},Q:{"260":"1D"},R:{"260":"2D"},S:{"1":"4D","644":"3D"}},B:4,C:"CSS clip-path property (for HTML)",D:true};
	return cssClipPath;
}

var cssBoxdecorationbreak;
var hasRequiredCssBoxdecorationbreak;

function requireCssBoxdecorationbreak () {
	if (hasRequiredCssBoxdecorationbreak) return cssBoxdecorationbreak;
	hasRequiredCssBoxdecorationbreak = 1;
	cssBoxdecorationbreak={A:{A:{"2":"K D E F A B wC"},B:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P","164":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB"},C:{"1":"0 1 2 3 4 5 eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB 0C 1C"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 J aB K D E F A B C L M G N O P bB","164":"0 1 2 3 4 5 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB"},E:{"2":"J aB K 2C aC 3C","164":"D E F A B C L M G 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD"},F:{"1":"0 1 2 3 4 5 z","2":"F GD HD ID JD","129":"B C OC uC KD PC","164":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y"},G:{"2":"aC LD vC MD ND","164":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"132":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC","164":"oD pD"},J:{"2":"D","164":"A"},K:{"2":"A","129":"B C OC uC PC","164":"H"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"164":"QC"},P:{"164":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"164":"1D"},R:{"164":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS box-decoration-break",D:true};
	return cssBoxdecorationbreak;
}

var objectFit;
var hasRequiredObjectFit;

function requireObjectFit () {
	if (hasRequiredObjectFit) return objectFit;
	hasRequiredObjectFit = 1;
	objectFit={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G","260":"N O P"},C:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB 0C 1C"},D:{"1":"0 1 2 3 4 5 eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB"},E:{"1":"A B C L M G bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D 2C aC 3C 4C","132":"E F 5C 6C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F G N O P GD HD ID","33":"B C JD OC uC KD PC"},G:{"1":"SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND OD","132":"E PD QD RD"},H:{"33":"jD"},I:{"1":"I pD","2":"UC J kD lD mD nD vC oD"},J:{"2":"D A"},K:{"1":"H","2":"A","33":"B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS3 object-fit/object-position",D:true};
	return objectFit;
}

var cssShapes;
var hasRequiredCssShapes;

function requireCssShapes () {
	if (hasRequiredCssShapes) return cssShapes;
	hasRequiredCssShapes = 1;
	cssShapes={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB 0C 1C","322":"xB yB zB 0B 1B 2B 3B 4B VC 5B WC"},D:{"1":"0 1 2 3 4 5 jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB","194":"gB hB iB"},E:{"1":"B C L M G bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D 2C aC 3C 4C","33":"E F A 5C 6C"},F:{"1":"0 1 2 3 4 5 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB GD HD ID JD OC uC KD PC"},G:{"1":"TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND OD","33":"E PD QD RD SD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","2":"3D"}},B:4,C:"CSS Shapes Level 1",D:true};
	return cssShapes;
}

var textOverflow;
var hasRequiredTextOverflow;

function requireTextOverflow () {
	if (hasRequiredTextOverflow) return textOverflow;
	hasRequiredTextOverflow = 1;
	textOverflow={A:{A:{"1":"K D E F A B","2":"wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","8":"xC UC J aB K 0C 1C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"1":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z OC uC KD PC","33":"F GD HD ID JD"},G:{"1":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"1":"jD"},I:{"1":"UC J I kD lD mD nD vC oD pD"},J:{"1":"D A"},K:{"1":"H PC","33":"A B C OC uC"},L:{"1":"I"},M:{"1":"NC"},N:{"1":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:2,C:"CSS3 Text-overflow",D:true};
	return textOverflow;
}

var cssDeviceadaptation;
var hasRequiredCssDeviceadaptation;

function requireCssDeviceadaptation () {
	if (hasRequiredCssDeviceadaptation) return cssDeviceadaptation;
	hasRequiredCssDeviceadaptation = 1;
	cssDeviceadaptation={A:{A:{"2":"K D E F wC","164":"A B"},B:{"66":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","164":"C L M G N O P"},C:{"2":"0 1 2 3 4 5 6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC 0C 1C"},D:{"2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB","66":"0 1 2 3 4 5 FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"2":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD"},F:{"2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB GD HD ID JD OC uC KD PC","66":"0 1 2 3 4 5 mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},G:{"2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"292":"jD"},I:{"2":"UC J I kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"2":"A H","292":"B C OC uC PC"},L:{"2":"I"},M:{"2":"NC"},N:{"164":"A B"},O:{"2":"QC"},P:{"2":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"66":"1D"},R:{"2":"2D"},S:{"2":"3D 4D"}},B:5,C:"CSS Device Adaptation",D:true};
	return cssDeviceadaptation;
}

var cssMediaResolution;
var hasRequiredCssMediaResolution;

function requireCssMediaResolution () {
	if (hasRequiredCssMediaResolution) return cssMediaResolution;
	hasRequiredCssMediaResolution = 1;
	cssMediaResolution={A:{A:{"2":"K D E wC","132":"F A B"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","1028":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC","260":"J aB K D E F A B C L M G 0C 1C","1028":"6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC"},D:{"1":"0 1 2 3 4 5 CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","548":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB","1028":"FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC"},E:{"1":"RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"2C aC","548":"J aB K D E F A B C L M G 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD"},F:{"1":"0 1 2 3 4 5 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F","548":"B C GD HD ID JD OC uC KD","1028":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B"},G:{"1":"RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","16":"aC","548":"E LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD"},H:{"132":"jD"},I:{"1":"I","16":"kD lD","548":"UC J mD nD vC","1028":"oD pD"},J:{"548":"D A"},K:{"1":"H PC","548":"A B C OC uC"},L:{"1":"I"},M:{"1":"NC"},N:{"132":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB bC vD wD xD yD zD RC SC TC 0D","1028":"J qD rD sD tD uD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"Media Queries: resolution feature",D:true};
	return cssMediaResolution;
}

var cssTextAlignLast;
var hasRequiredCssTextAlignLast;

function requireCssTextAlignLast () {
	if (hasRequiredCssTextAlignLast) return cssTextAlignLast;
	hasRequiredCssTextAlignLast = 1;
	cssTextAlignLast={A:{A:{"132":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","4":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB K D E F A B 0C 1C","33":"6 7 8 9 C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB"},D:{"1":"0 1 2 3 4 5 tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB","322":"hB iB jB kB lB mB nB oB pB qB rB sB"},E:{"1":"RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD"},F:{"1":"0 1 2 3 4 5 gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 F B C G N O P bB GD HD ID JD OC uC KD PC","578":"8 9 AB BB CB DB EB FB cB dB eB fB"},G:{"1":"RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"132":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","33":"3D"}},B:4,C:"CSS3 text-align-last",D:true};
	return cssTextAlignLast;
}

var cssCrispEdges;
var hasRequiredCssCrispEdges;

function requireCssCrispEdges () {
	if (hasRequiredCssCrispEdges) return cssCrispEdges;
	hasRequiredCssCrispEdges = 1;
	cssCrispEdges={A:{A:{"2":"K wC","2340":"D E F A B"},B:{"2":"C L M G N O P","1025":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC 0C","513":"9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b","545":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 1C"},D:{"2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB","1025":"0 1 2 3 4 5 nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"1":"A B C L M G bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC 3C","164":"K","4644":"D E F 4C 5C 6C"},F:{"2":"6 7 8 9 F B G N O P bB AB BB CB DB GD HD ID JD OC uC","545":"C KD PC","1025":"0 1 2 3 4 5 EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},G:{"1":"SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC","4260":"MD ND","4644":"E OD PD QD RD"},H:{"2":"jD"},I:{"2":"UC J kD lD mD nD vC oD pD","1025":"I"},J:{"2":"D","4260":"A"},K:{"2":"A B OC uC","545":"C PC","1025":"H"},L:{"1025":"I"},M:{"1":"NC"},N:{"2340":"A B"},O:{"1025":"QC"},P:{"1025":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1025":"1D"},R:{"1025":"2D"},S:{"1":"4D","4097":"3D"}},B:4,C:"Crisp edges/pixelated images",D:true};
	return cssCrispEdges;
}

var cssLogicalProps;
var hasRequiredCssLogicalProps;

function requireCssLogicalProps () {
	if (hasRequiredCssLogicalProps) return cssLogicalProps;
	hasRequiredCssLogicalProps = 1;
	cssLogicalProps={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P","1028":"W X","1540":"Q H R S T U V"},C:{"1":"0 1 2 3 4 5 AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC","164":"6 7 8 9 UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB 0C 1C","1540":"nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B"},D:{"1":"0 1 2 3 4 5 Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","292":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC","1028":"W X","1540":"DC EC FC GC HC IC JC KC LC MC Q H R S T U V"},E:{"1":"G 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","292":"J aB K D E F A B C 2C aC 3C 4C 5C 6C bC OC","1540":"L M PC 7C","3076":"8C"},F:{"1":"0 1 2 3 4 5 KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","292":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B","1028":"IC JC","1540":"2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC"},G:{"1":"eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","292":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD","1540":"XD YD ZD aD bD cD","3076":"dD"},H:{"2":"jD"},I:{"1":"I","292":"UC J kD lD mD nD vC oD pD"},J:{"292":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB zD RC SC TC 0D","292":"J qD rD sD tD uD","1540":"bC vD wD xD yD"},Q:{"1540":"1D"},R:{"1":"2D"},S:{"1":"4D","1540":"3D"}},B:5,C:"CSS Logical Properties",D:true};
	return cssLogicalProps;
}

var cssAppearance;
var hasRequiredCssAppearance;

function requireCssAppearance () {
	if (hasRequiredCssAppearance) return cssAppearance;
	hasRequiredCssAppearance = 1;
	cssAppearance={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","33":"S","164":"Q H R","388":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","164":"hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q","676":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB 0C 1C"},D:{"1":"0 1 2 3 4 5 T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","33":"S","164":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R"},E:{"1":"dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","164":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC"},F:{"1":"0 1 2 3 4 5 HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"EC FC GC","164":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC"},G:{"1":"dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","164":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC"},H:{"2":"jD"},I:{"1":"I","164":"UC J kD lD mD nD vC oD pD"},J:{"164":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A","388":"B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB yD zD RC SC TC 0D","164":"J qD rD sD tD uD bC vD wD xD"},Q:{"164":"1D"},R:{"1":"2D"},S:{"1":"4D","164":"3D"}},B:5,C:"CSS Appearance",D:true};
	return cssAppearance;
}

var cssSnappoints;
var hasRequiredCssSnappoints;

function requireCssSnappoints () {
	if (hasRequiredCssSnappoints) return cssSnappoints;
	hasRequiredCssSnappoints = 1;
	cssSnappoints={A:{A:{"2":"K D E F wC","6308":"A","6436":"B"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","6436":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB 0C 1C","2052":"lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC"},D:{"1":"0 1 2 3 4 5 DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B","8258":"AC BC CC"},E:{"1":"B C L M G OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E 2C aC 3C 4C 5C","3108":"F A 6C bC"},F:{"1":"0 1 2 3 4 5 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB GD HD ID JD OC uC KD PC","8258":"0B 1B 2B 3B 4B 5B 6B 7B"},G:{"1":"UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD","3108":"QD RD SD TD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB bC vD wD xD yD zD RC SC TC 0D","2":"J qD rD sD tD uD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","2052":"3D"}},B:4,C:"CSS Scroll Snap",D:true};
	return cssSnappoints;
}

var cssRegions;
var hasRequiredCssRegions;

function requireCssRegions () {
	if (hasRequiredCssRegions) return cssRegions;
	hasRequiredCssRegions = 1;
	cssRegions={A:{A:{"2":"K D E F wC","420":"A B"},B:{"2":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","420":"C L M G N O P"},C:{"2":"0 1 2 3 4 5 6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC 0C 1C"},D:{"2":"0 1 2 3 4 5 J aB K D E F A B C L M hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","36":"G N O P","66":"6 7 8 9 bB AB BB CB DB EB FB cB dB eB fB gB"},E:{"2":"J aB K C L M G 2C aC 3C OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","33":"D E F A B 4C 5C 6C bC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GD HD ID JD OC uC KD PC"},G:{"2":"aC LD vC MD ND VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","33":"E OD PD QD RD SD TD UD"},H:{"2":"jD"},I:{"2":"UC J I kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"2":"A B C H OC uC PC"},L:{"2":"I"},M:{"2":"NC"},N:{"420":"A B"},O:{"2":"QC"},P:{"2":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"2":"1D"},R:{"2":"2D"},S:{"2":"3D 4D"}},B:5,C:"CSS Regions",D:true};
	return cssRegions;
}

var cssImageSet;
var hasRequiredCssImageSet;

function requireCssImageSet () {
	if (hasRequiredCssImageSet) return cssImageSet;
	hasRequiredCssImageSet = 1;
	cssImageSet={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P","164":"Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v","2049":"w"},C:{"1":"0 1 2 3 4 5 w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U 0C 1C","66":"V W","2305":"Y Z a b c d e f g h i j k l m n o p q r s t u v","2820":"X"},D:{"1":"0 1 2 3 4 5 x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 J aB K D E F A B C L M G N O P bB","164":"7 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v","2049":"w"},E:{"1":"SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC 3C","132":"A B C L bC OC PC 7C","164":"K D E F 4C 5C 6C","1540":"M G 8C 9C cC dC QC AD RC eC fC gC hC iC BD"},F:{"1":"0 1 2 3 4 5 j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","164":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h","2049":"i"},G:{"1":"SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","132":"SD TD UD VD WD XD YD ZD aD bD","164":"E ND OD PD QD RD","1540":"cD dD eD cC dC QC fD RC eC fC gC hC iC gD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC","164":"oD pD"},J:{"2":"D","164":"A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"164":"QC"},P:{"1":"9 AB BB CB DB EB FB","164":"6 7 8 J qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"164":"1D"},R:{"164":"2D"},S:{"2":"3D 4D"}},B:5,C:"CSS image-set",D:true};
	return cssImageSet;
}

var cssWritingMode;
var hasRequiredCssWritingMode;

function requireCssWritingMode () {
	if (hasRequiredCssWritingMode) return cssWritingMode;
	hasRequiredCssWritingMode = 1;
	cssWritingMode={A:{A:{"132":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB 0C 1C","322":"iB jB kB lB mB"},D:{"1":"0 1 2 3 4 5 uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K","16":"D","33":"6 7 8 9 E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB"},E:{"1":"B C L M G OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J 2C aC","16":"aB","33":"K D E F A 3C 4C 5C 6C bC"},F:{"1":"0 1 2 3 4 5 hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB"},G:{"1":"UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","16":"aC LD vC","33":"E MD ND OD PD QD RD SD TD"},H:{"2":"jD"},I:{"1":"I","2":"kD lD mD","33":"UC J nD vC oD pD"},J:{"33":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"36":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","33":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:2,C:"CSS writing-mode property",D:true};
	return cssWritingMode;
}

var cssCrossFade;
var hasRequiredCssCrossFade;

function requireCssCrossFade () {
	if (hasRequiredCssCrossFade) return cssCrossFade;
	hasRequiredCssCrossFade = 1;
	cssCrossFade={A:{A:{"2":"K D E F A B wC"},B:{"2":"C L M G N O P","33":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"2":"0 1 2 3 4 5 6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC 0C 1C"},D:{"2":"J aB K D E F A B C L M G N","33":"0 1 2 3 4 5 6 7 8 9 O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"1":"A B C L M G bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC","33":"K D E F 3C 4C 5C 6C"},F:{"2":"F B C GD HD ID JD OC uC KD PC","33":"0 1 2 3 4 5 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},G:{"1":"SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC","33":"E MD ND OD PD QD RD"},H:{"2":"jD"},I:{"2":"UC J kD lD mD nD vC","33":"I oD pD"},J:{"2":"D A"},K:{"2":"A B C OC uC PC","33":"H"},L:{"33":"I"},M:{"2":"NC"},N:{"2":"A B"},O:{"33":"QC"},P:{"33":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"33":"1D"},R:{"33":"2D"},S:{"2":"3D 4D"}},B:4,C:"CSS Cross-Fade Function",D:true};
	return cssCrossFade;
}

var cssReadOnlyWrite;
var hasRequiredCssReadOnlyWrite;

function requireCssReadOnlyWrite () {
	if (hasRequiredCssReadOnlyWrite) return cssReadOnlyWrite;
	hasRequiredCssReadOnlyWrite = 1;
	cssReadOnlyWrite={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C"},C:{"1":"0 1 2 3 4 5 MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","16":"xC","33":"6 7 8 9 UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC 0C 1C"},D:{"1":"0 1 2 3 4 5 iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","16":"J aB K D E F A B C L M","132":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","16":"2C aC","132":"J aB K D E 3C 4C 5C"},F:{"1":"0 1 2 3 4 5 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","16":"F B GD HD ID JD OC","132":"6 7 8 C G N O P bB uC KD PC"},G:{"1":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","16":"aC LD","132":"E vC MD ND OD PD"},H:{"2":"jD"},I:{"1":"I","16":"kD lD","132":"UC J mD nD vC oD pD"},J:{"1":"A","132":"D"},K:{"1":"H","2":"A B OC","132":"C uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","33":"3D"}},B:1,C:"CSS :read-only and :read-write selectors",D:true};
	return cssReadOnlyWrite;
}

var textEmphasis;
var hasRequiredTextEmphasis;

function requireTextEmphasis () {
	if (hasRequiredTextEmphasis) return textEmphasis;
	hasRequiredTextEmphasis = 1;
	textEmphasis={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P","164":"Q H R S T U V W X Y Z a b c d e f g h"},C:{"1":"0 1 2 3 4 5 sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB 0C 1C","322":"rB"},D:{"1":"0 1 2 3 4 5 i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB","164":"BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h"},E:{"1":"E F A B C L M G 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K 2C aC 3C","164":"D 4C"},F:{"1":"0 1 2 3 4 5 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","164":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U"},G:{"1":"E OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC","164":"oD pD"},J:{"2":"D","164":"A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB TC 0D","164":"J qD rD sD tD uD bC vD wD xD yD zD RC SC"},Q:{"164":"1D"},R:{"164":"2D"},S:{"1":"3D 4D"}},B:4,C:"text-emphasis styling",D:true};
	return textEmphasis;
}

var cssGrid;
var hasRequiredCssGrid;

function requireCssGrid () {
	if (hasRequiredCssGrid) return cssGrid;
	hasRequiredCssGrid = 1;
	cssGrid={A:{A:{"2":"K D E wC","8":"F","292":"A B"},B:{"1":"0 1 2 3 4 5 N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","292":"C L M G"},C:{"1":"0 1 2 3 4 5 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB K D E F A B C L M G N O P 0C 1C","8":"6 7 8 9 bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB","584":"mB nB oB pB qB rB sB tB uB vB wB xB","1025":"yB zB"},D:{"1":"0 1 2 3 4 5 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB","8":"BB CB DB EB","200":"FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B","1025":"3B"},E:{"1":"B C L M G bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB 2C aC 3C","8":"K D E F A 4C 5C 6C"},F:{"1":"0 1 2 3 4 5 qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB GD HD ID JD OC uC KD PC","200":"EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB"},G:{"1":"TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","8":"E ND OD PD QD RD SD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD","8":"vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"292":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"qD","8":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS Grid Layout (level 1)",D:true};
	return cssGrid;
}

var cssTextSpacing;
var hasRequiredCssTextSpacing;

function requireCssTextSpacing () {
	if (hasRequiredCssTextSpacing) return cssTextSpacing;
	hasRequiredCssTextSpacing = 1;
	cssTextSpacing={A:{A:{"2":"K D wC","161":"E F A B"},B:{"2":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","161":"C L M G N O P"},C:{"2":"0 1 2 3 4 5 6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC 0C 1C"},D:{"2":"0 1 2 3 4 5 6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC"},E:{"2":"J aB K D E F A B C L M G 2C aC 3C 4C 5C 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GD HD ID JD OC uC KD PC"},G:{"2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC"},H:{"2":"jD"},I:{"2":"UC J I kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"2":"A B C H OC uC PC"},L:{"2":"I"},M:{"2":"NC"},N:{"16":"A B"},O:{"2":"QC"},P:{"2":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"2":"1D"},R:{"2":"2D"},S:{"2":"3D 4D"}},B:5,C:"CSS Text 4 text-spacing",D:false};
	return cssTextSpacing;
}

var cssAnyLink;
var hasRequiredCssAnyLink;

function requireCssAnyLink () {
	if (hasRequiredCssAnyLink) return cssAnyLink;
	hasRequiredCssAnyLink = 1;
	cssAnyLink={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","16":"xC","33":"6 7 8 9 UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB 0C 1C"},D:{"1":"0 1 2 3 4 5 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","16":"J aB K D E F A B C L M","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","16":"J aB K 2C aC 3C","33":"D E 4C 5C"},F:{"1":"0 1 2 3 4 5 yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB"},G:{"1":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","16":"aC LD vC MD","33":"E ND OD PD"},H:{"2":"jD"},I:{"1":"I","16":"UC J kD lD mD nD vC","33":"oD pD"},J:{"16":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB uD bC vD wD xD yD zD RC SC TC 0D","16":"J","33":"qD rD sD tD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","33":"3D"}},B:5,C:"CSS :any-link selector",D:true};
	return cssAnyLink;
}

var mdnCssUnicodeBidiIsolate;
var hasRequiredMdnCssUnicodeBidiIsolate;

function requireMdnCssUnicodeBidiIsolate () {
	if (hasRequiredMdnCssUnicodeBidiIsolate) return mdnCssUnicodeBidiIsolate;
	hasRequiredMdnCssUnicodeBidiIsolate = 1;
	mdnCssUnicodeBidiIsolate={A:{D:{"1":"0 1 2 3 4 5 uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K D E F A B C L M G","33":"6 7 8 9 N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB K D E F 0C 1C","33":"6 7 8 9 A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"F B C GD HD ID JD OC uC KD PC","33":"6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"B C L M G OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB 2C aC 3C FD","33":"K D E F A 4C 5C 6C bC"},G:{"1":"UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","33":"E ND OD PD QD RD SD TD"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"}},B:6,C:"isolate from unicode-bidi",D:undefined};
	return mdnCssUnicodeBidiIsolate;
}

var mdnCssUnicodeBidiPlaintext;
var hasRequiredMdnCssUnicodeBidiPlaintext;

function requireMdnCssUnicodeBidiPlaintext () {
	if (hasRequiredMdnCssUnicodeBidiPlaintext) return mdnCssUnicodeBidiPlaintext;
	hasRequiredMdnCssUnicodeBidiPlaintext = 1;
	mdnCssUnicodeBidiPlaintext={A:{D:{"1":"0 1 2 3 4 5 uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB K D E F 0C 1C","33":"6 7 8 9 A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB GD HD ID JD OC uC KD PC"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"B C L M G OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB 2C aC 3C FD","33":"K D E F A 4C 5C 6C bC"},G:{"1":"UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","33":"E ND OD PD QD RD SD TD"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"}},B:6,C:"plaintext from unicode-bidi",D:undefined};
	return mdnCssUnicodeBidiPlaintext;
}

var mdnCssUnicodeBidiIsolateOverride;
var hasRequiredMdnCssUnicodeBidiIsolateOverride;

function requireMdnCssUnicodeBidiIsolateOverride () {
	if (hasRequiredMdnCssUnicodeBidiIsolateOverride) return mdnCssUnicodeBidiIsolateOverride;
	hasRequiredMdnCssUnicodeBidiIsolateOverride = 1;
	mdnCssUnicodeBidiIsolateOverride={A:{D:{"1":"0 1 2 3 4 5 uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB"},L:{"1":"I"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"xC UC J aB K D E F A B C L M G N 0C 1C","33":"6 7 8 9 O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"0 1 2 3 4 5 hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB GD HD ID JD OC uC KD PC"},K:{"1":"H","2":"A B C OC uC PC"},E:{"1":"B C L M G OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB K 2C aC 3C 4C FD","33":"D E F A 5C 6C bC"},G:{"1":"UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD ND","33":"E OD PD QD RD SD TD"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"}},B:6,C:"isolate-override from unicode-bidi",D:undefined};
	return mdnCssUnicodeBidiIsolateOverride;
}

var cssOverscrollBehavior;
var hasRequiredCssOverscrollBehavior;

function requireCssOverscrollBehavior () {
	if (hasRequiredCssOverscrollBehavior) return cssOverscrollBehavior;
	hasRequiredCssOverscrollBehavior = 1;
	cssOverscrollBehavior={A:{A:{"2":"K D E F wC","132":"A B"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","132":"C L M G N O","516":"P"},C:{"1":"0 1 2 3 4 5 VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 0C 1C"},D:{"1":"0 1 2 3 4 5 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B","260":"7B 8B"},E:{"1":"RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E F A B C L M 2C aC 3C 4C 5C 6C bC OC PC 7C","1090":"G 8C 9C cC dC QC AD"},F:{"1":"0 1 2 3 4 5 yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB GD HD ID JD OC uC KD PC","260":"wB xB"},G:{"1":"RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD","1090":"dD eD cC dC QC fD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"132":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J qD rD sD"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"4D","2":"3D"}},B:5,C:"CSS overscroll-behavior",D:true};
	return cssOverscrollBehavior;
}

var cssTextOrientation;
var hasRequiredCssTextOrientation;

function requireCssTextOrientation () {
	if (hasRequiredCssTextOrientation) return cssTextOrientation;
	hasRequiredCssTextOrientation = 1;
	cssTextOrientation={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB","2":"C L M G N O P"},C:{"1":"0 1 2 3 4 5 nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB 0C 1C","194":"kB lB mB"},D:{"1":"0 1 2 3 4 5 uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB"},E:{"1":"M G 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E F 2C aC 3C 4C 5C 6C","16":"A","33":"B C L bC OC PC 7C"},F:{"1":"0 1 2 3 4 5 hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z","2":"6 7 8 9 F B C G N O P bB AB BB CB DB EB FB cB dB eB fB gB GD HD ID JD OC uC KD PC"},G:{"1":"SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD QD RD"},H:{"2":"jD"},I:{"1":"I","2":"UC J kD lD mD nD vC oD pD"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D","2":"J"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:2,C:"CSS text-orientation",D:true};
	return cssTextOrientation;
}

var cssPrintColorAdjust;
var hasRequiredCssPrintColorAdjust;

function requireCssPrintColorAdjust () {
	if (hasRequiredCssPrintColorAdjust) return cssPrintColorAdjust;
	hasRequiredCssPrintColorAdjust = 1;
	cssPrintColorAdjust={A:{D:{"1":"TB UB VB WB XB YB I ZB NC YC ZC","2":"J aB K D E F A B C L M G N","33":"0 1 2 3 4 5 6 7 8 9 O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB"},L:{"1":"I"},B:{"1":"TB UB VB WB XB YB I ZB","2":"C L M G N O P","33":"0 1 2 3 4 5 Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB"},C:{"1":"0 1 2 3 4 5 g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 8 9 xC UC J aB K D E F A B C L M G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB 0C 1C","33":"uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f"},M:{"1":"NC"},A:{"2":"K D E F A B wC"},F:{"1":"4 5","2":"F B C GD HD ID JD OC uC KD PC","33":"0 1 2 3 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z"},K:{"2":"A B C OC uC PC","33":"H"},E:{"1":"dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED","2":"J aB 2C aC 3C FD","33":"K D E F A B C L M G 4C 5C 6C bC OC PC 7C 8C 9C cC"},G:{"1":"dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"aC LD vC MD","33":"E ND OD PD QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC"},P:{"1":"FB","33":"6 7 8 9 J AB BB CB DB EB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},I:{"1":"I","2":"UC J kD lD mD nD vC","33":"oD pD"}},B:6,C:"print-color-adjust property",D:undefined};
	return cssPrintColorAdjust;
}

var prefixes$1;
var hasRequiredPrefixes$1;

function requirePrefixes$1 () {
	if (hasRequiredPrefixes$1) return prefixes$1;
	hasRequiredPrefixes$1 = 1;
	let unpack = requireFeature();

	function browsersSort(a, b) {
	  a = a.split(' ');
	  b = b.split(' ');
	  if (a[0] > b[0]) {
	    return 1
	  } else if (a[0] < b[0]) {
	    return -1
	  } else {
	    return Math.sign(parseFloat(a[1]) - parseFloat(b[1]))
	  }
	}

	// Convert Can I Use data
	function f(data, opts, callback) {
	  data = unpack(data);

	  if (!callback) {
[callback, opts] = [opts, {}];
	  }

	  let match = opts.match || /\sx($|\s)/;
	  let need = [];

	  for (let browser in data.stats) {
	    let versions = data.stats[browser];
	    for (let version in versions) {
	      let support = versions[version];
	      if (support.match(match)) {
	        need.push(browser + ' ' + version);
	      }
	    }
	  }

	  callback(need.sort(browsersSort));
	}

	// Add data for all properties
	let result = {};

	function prefix(names, data) {
	  for (let name of names) {
	    result[name] = Object.assign({}, data);
	  }
	}

	function add(names, data) {
	  for (let name of names) {
	    result[name].browsers = result[name].browsers
	      .concat(data.browsers)
	      .sort(browsersSort);
	  }
	}

	prefixes$1 = result;

	// Border Radius
	let prefixBorderRadius = requireBorderRadius$1();

	f(prefixBorderRadius, browsers =>
	  prefix(
	    [
	      'border-radius',
	      'border-top-left-radius',
	      'border-top-right-radius',
	      'border-bottom-right-radius',
	      'border-bottom-left-radius'
	    ],
	    {
	      browsers,
	      feature: 'border-radius',
	      mistakes: ['-khtml-', '-ms-', '-o-']
	    }
	  )
	);

	// Box Shadow
	let prefixBoxshadow = requireCssBoxshadow();

	f(prefixBoxshadow, browsers =>
	  prefix(['box-shadow'], {
	    browsers,
	    feature: 'css-boxshadow',
	    mistakes: ['-khtml-']
	  })
	);

	// Animation
	let prefixAnimation = requireCssAnimation();

	f(prefixAnimation, browsers =>
	  prefix(
	    [
	      'animation',
	      'animation-name',
	      'animation-duration',
	      'animation-delay',
	      'animation-direction',
	      'animation-fill-mode',
	      'animation-iteration-count',
	      'animation-play-state',
	      'animation-timing-function',
	      '@keyframes'
	    ],
	    {
	      browsers,
	      feature: 'css-animation',
	      mistakes: ['-khtml-', '-ms-']
	    }
	  )
	);

	// Transition
	let prefixTransition = requireCssTransitions();

	f(prefixTransition, browsers =>
	  prefix(
	    [
	      'transition',
	      'transition-property',
	      'transition-duration',
	      'transition-delay',
	      'transition-timing-function'
	    ],
	    {
	      browsers,
	      feature: 'css-transitions',
	      mistakes: ['-khtml-', '-ms-']
	    }
	  )
	);

	// Transform 2D
	let prefixTransform2d = requireTransforms2d();

	f(prefixTransform2d, browsers =>
	  prefix(['transform', 'transform-origin'], {
	    browsers,
	    feature: 'transforms2d'
	  })
	);

	// Transform 3D
	let prefixTransforms3d = requireTransforms3d();

	f(prefixTransforms3d, browsers => {
	  prefix(['perspective', 'perspective-origin'], {
	    browsers,
	    feature: 'transforms3d'
	  });
	  return prefix(['transform-style'], {
	    browsers,
	    feature: 'transforms3d',
	    mistakes: ['-ms-', '-o-']
	  })
	});

	f(prefixTransforms3d, { match: /y\sx|y\s#2/ }, browsers =>
	  prefix(['backface-visibility'], {
	    browsers,
	    feature: 'transforms3d',
	    mistakes: ['-ms-', '-o-']
	  })
	);

	// Gradients
	let prefixGradients = requireCssGradients();

	f(prefixGradients, { match: /y\sx/ }, browsers =>
	  prefix(
	    [
	      'linear-gradient',
	      'repeating-linear-gradient',
	      'radial-gradient',
	      'repeating-radial-gradient'
	    ],
	    {
	      browsers,
	      feature: 'css-gradients',
	      mistakes: ['-ms-'],
	      props: [
	        'background',
	        'background-image',
	        'border-image',
	        'mask',
	        'list-style',
	        'list-style-image',
	        'content',
	        'mask-image'
	      ]
	    }
	  )
	);

	f(prefixGradients, { match: /a\sx/ }, browsers => {
	  browsers = browsers.map(i => {
	    if (/firefox|op/.test(i)) {
	      return i
	    } else {
	      return `${i} old`
	    }
	  });
	  return add(
	    [
	      'linear-gradient',
	      'repeating-linear-gradient',
	      'radial-gradient',
	      'repeating-radial-gradient'
	    ],
	    {
	      browsers}
	  )
	});

	// Box sizing
	let prefixBoxsizing = requireCss3Boxsizing();

	f(prefixBoxsizing, browsers =>
	  prefix(['box-sizing'], {
	    browsers,
	    feature: 'css3-boxsizing'
	  })
	);

	// Filter Effects
	let prefixFilters = requireCssFilters();

	f(prefixFilters, browsers =>
	  prefix(['filter'], {
	    browsers,
	    feature: 'css-filters'
	  })
	);

	// filter() function
	let prefixFilterFunction = requireCssFilterFunction();

	f(prefixFilterFunction, browsers =>
	  prefix(['filter-function'], {
	    browsers,
	    feature: 'css-filter-function',
	    props: [
	      'background',
	      'background-image',
	      'border-image',
	      'mask',
	      'list-style',
	      'list-style-image',
	      'content',
	      'mask-image'
	    ]
	  })
	);

	// Backdrop-filter
	let prefixBackdropFilter = requireCssBackdropFilter();

	f(prefixBackdropFilter, { match: /y\sx|y\s#2/ }, browsers =>
	  prefix(['backdrop-filter'], {
	    browsers,
	    feature: 'css-backdrop-filter'
	  })
	);

	// element() function
	let prefixElementFunction = requireCssElementFunction();

	f(prefixElementFunction, browsers =>
	  prefix(['element'], {
	    browsers,
	    feature: 'css-element-function',
	    props: [
	      'background',
	      'background-image',
	      'border-image',
	      'mask',
	      'list-style',
	      'list-style-image',
	      'content',
	      'mask-image'
	    ]
	  })
	);

	// Multicolumns
	let prefixMulticolumns = requireMulticolumn();

	f(prefixMulticolumns, browsers => {
	  prefix(
	    [
	      'columns',
	      'column-width',
	      'column-gap',
	      'column-rule',
	      'column-rule-color',
	      'column-rule-width',
	      'column-count',
	      'column-rule-style',
	      'column-span',
	      'column-fill'
	    ],
	    {
	      browsers,
	      feature: 'multicolumn'
	    }
	  );

	  let noff = browsers.filter(i => !/firefox/.test(i));
	  prefix(['break-before', 'break-after', 'break-inside'], {
	    browsers: noff,
	    feature: 'multicolumn'
	  });
	});

	// User select
	let prefixUserSelect = requireUserSelectNone();

	f(prefixUserSelect, browsers =>
	  prefix(['user-select'], {
	    browsers,
	    feature: 'user-select-none',
	    mistakes: ['-khtml-']
	  })
	);

	// Flexible Box Layout
	let prefixFlexbox = requireFlexbox();

	f(prefixFlexbox, { match: /a\sx/ }, browsers => {
	  browsers = browsers.map(i => {
	    if (/ie|firefox/.test(i)) {
	      return i
	    } else {
	      return `${i} 2009`
	    }
	  });
	  prefix(['display-flex', 'inline-flex'], {
	    browsers,
	    feature: 'flexbox',
	    props: ['display']
	  });
	  prefix(['flex', 'flex-grow', 'flex-shrink', 'flex-basis'], {
	    browsers,
	    feature: 'flexbox'
	  });
	  prefix(
	    [
	      'flex-direction',
	      'flex-wrap',
	      'flex-flow',
	      'justify-content',
	      'order',
	      'align-items',
	      'align-self',
	      'align-content'
	    ],
	    {
	      browsers,
	      feature: 'flexbox'
	    }
	  );
	});

	f(prefixFlexbox, { match: /y\sx/ }, browsers => {
	  add(['display-flex', 'inline-flex'], {
	    browsers});
	  add(['flex', 'flex-grow', 'flex-shrink', 'flex-basis'], {
	    browsers});
	  add(
	    [
	      'flex-direction',
	      'flex-wrap',
	      'flex-flow',
	      'justify-content',
	      'order',
	      'align-items',
	      'align-self',
	      'align-content'
	    ],
	    {
	      browsers}
	  );
	});

	// calc() unit
	let prefixCalc = requireCalc();

	f(prefixCalc, browsers =>
	  prefix(['calc'], {
	    browsers,
	    feature: 'calc',
	    props: ['*']
	  })
	);

	// Background options
	let prefixBackgroundOptions = requireBackgroundImgOpts();

	f(prefixBackgroundOptions, browsers =>
	  prefix(['background-origin', 'background-size'], {
	    browsers,
	    feature: 'background-img-opts'
	  })
	);

	// background-clip: text
	let prefixBackgroundClipText = requireBackgroundClipText();

	f(prefixBackgroundClipText, browsers =>
	  prefix(['background-clip'], {
	    browsers,
	    feature: 'background-clip-text'
	  })
	);

	// Font feature settings
	let prefixFontFeature = requireFontFeature();

	f(prefixFontFeature, browsers =>
	  prefix(
	    [
	      'font-feature-settings',
	      'font-variant-ligatures',
	      'font-language-override'
	    ],
	    {
	      browsers,
	      feature: 'font-feature'
	    }
	  )
	);

	// CSS font-kerning property
	let prefixFontKerning = requireFontKerning();

	f(prefixFontKerning, browsers =>
	  prefix(['font-kerning'], {
	    browsers,
	    feature: 'font-kerning'
	  })
	);

	// Border image
	let prefixBorderImage = requireBorderImage$1();

	f(prefixBorderImage, browsers =>
	  prefix(['border-image'], {
	    browsers,
	    feature: 'border-image'
	  })
	);

	// Selection selector
	let prefixSelection = requireCssSelection();

	f(prefixSelection, browsers =>
	  prefix(['::selection'], {
	    browsers,
	    feature: 'css-selection',
	    selector: true
	  })
	);

	// Placeholder selector
	let prefixPlaceholder = requireCssPlaceholder();

	f(prefixPlaceholder, browsers => {
	  prefix(['::placeholder'], {
	    browsers: browsers.concat(['ie 10 old', 'ie 11 old', 'firefox 18 old']),
	    feature: 'css-placeholder',
	    selector: true
	  });
	});

	// Placeholder-shown selector
	let prefixPlaceholderShown = requireCssPlaceholderShown();

	f(prefixPlaceholderShown, browsers => {
	  prefix([':placeholder-shown'], {
	    browsers,
	    feature: 'css-placeholder-shown',
	    selector: true
	  });
	});

	// Hyphenation
	let prefixHyphens = requireCssHyphens();

	f(prefixHyphens, browsers =>
	  prefix(['hyphens'], {
	    browsers,
	    feature: 'css-hyphens'
	  })
	);

	// Fullscreen selector
	let prefixFullscreen = requireFullscreen$1();

	f(prefixFullscreen, browsers =>
	  prefix([':fullscreen'], {
	    browsers,
	    feature: 'fullscreen',
	    selector: true
	  })
	);

	// ::backdrop pseudo-element
	// https://caniuse.com/mdn-css_selectors_backdrop
	let prefixBackdrop = requireMdnCssBackdropPseudoElement();

	f(prefixBackdrop, browsers =>
	  prefix(['::backdrop'], {
	    browsers,
	    feature: 'backdrop',
	    selector: true
	  })
	);

	// File selector button
	let prefixFileSelectorButton = requireCssFileSelectorButton();

	f(prefixFileSelectorButton, browsers =>
	  prefix(['::file-selector-button'], {
	    browsers,
	    feature: 'file-selector-button',
	    selector: true
	  })
	);

	// :autofill
	let prefixAutofill = requireCssAutofill();

	f(prefixAutofill, browsers =>
	  prefix([':autofill'], {
	    browsers,
	    feature: 'css-autofill',
	    selector: true
	  })
	);

	// Tab size
	let prefixTabsize = requireCss3Tabsize();

	f(prefixTabsize, browsers =>
	  prefix(['tab-size'], {
	    browsers,
	    feature: 'css3-tabsize'
	  })
	);

	// Intrinsic & extrinsic sizing
	let prefixIntrinsic = requireIntrinsicWidth();

	let sizeProps = [
	  'width',
	  'min-width',
	  'max-width',
	  'height',
	  'min-height',
	  'max-height',
	  'inline-size',
	  'min-inline-size',
	  'max-inline-size',
	  'block-size',
	  'min-block-size',
	  'max-block-size',
	  'grid',
	  'grid-template',
	  'grid-template-rows',
	  'grid-template-columns',
	  'grid-auto-columns',
	  'grid-auto-rows'
	];

	f(prefixIntrinsic, browsers =>
	  prefix(['max-content', 'min-content'], {
	    browsers,
	    feature: 'intrinsic-width',
	    props: sizeProps
	  })
	);

	f(prefixIntrinsic, { match: /x|\s#4/ }, browsers =>
	  prefix(['fill', 'fill-available'], {
	    browsers,
	    feature: 'intrinsic-width',
	    props: sizeProps
	  })
	);

	f(prefixIntrinsic, { match: /x|\s#5/ }, browsers => {
	  let ffFix = browsers.filter(i => {
	    let [name, version] = i.split(' ');
	    if (name === 'firefox' || name === 'and_ff') {
	      return parseInt(version) < 94
	    } else {
	      return true
	    }
	  });
	  return prefix(['fit-content'], {
	    browsers: ffFix,
	    feature: 'intrinsic-width',
	    props: sizeProps
	  })
	});

	// Stretch value

	let prefixStretch = requireCssWidthStretch();

	f(prefixStretch, browsers => {
	  f(prefixIntrinsic, { match: /x|\s#2/ }, firefox => {
	    browsers = browsers.concat(firefox);
	  });
	  return prefix(['stretch'], {
	    browsers,
	    feature: 'css-width-stretch',
	    props: sizeProps
	  })
	});

	// Zoom cursors
	let prefixCursorsNew = requireCss3CursorsNewer();

	f(prefixCursorsNew, browsers =>
	  prefix(['zoom-in', 'zoom-out'], {
	    browsers,
	    feature: 'css3-cursors-newer',
	    props: ['cursor']
	  })
	);

	// Grab cursors
	let prefixCursorsGrab = requireCss3CursorsGrab();

	f(prefixCursorsGrab, browsers =>
	  prefix(['grab', 'grabbing'], {
	    browsers,
	    feature: 'css3-cursors-grab',
	    props: ['cursor']
	  })
	);

	// Sticky position
	let prefixSticky = requireCssSticky();

	f(prefixSticky, browsers =>
	  prefix(['sticky'], {
	    browsers,
	    feature: 'css-sticky',
	    props: ['position']
	  })
	);

	// Pointer Events
	let prefixPointer = requirePointer();

	f(prefixPointer, browsers =>
	  prefix(['touch-action'], {
	    browsers,
	    feature: 'pointer'
	  })
	);

	// Text decoration
	let prefixDecoration = requireTextDecoration$1();

	f(prefixDecoration, { match: /x.*#[235]/ }, browsers =>
	  prefix(['text-decoration-skip', 'text-decoration-skip-ink'], {
	    browsers,
	    feature: 'text-decoration'
	  })
	);

	let prefixDecorationShorthand = requireMdnTextDecorationShorthand();

	f(prefixDecorationShorthand, browsers =>
	  prefix(['text-decoration'], {
	    browsers,
	    feature: 'text-decoration'
	  })
	);

	let prefixDecorationColor = requireMdnTextDecorationColor();

	f(prefixDecorationColor, browsers =>
	  prefix(['text-decoration-color'], {
	    browsers,
	    feature: 'text-decoration'
	  })
	);

	let prefixDecorationLine = requireMdnTextDecorationLine();

	f(prefixDecorationLine, browsers =>
	  prefix(['text-decoration-line'], {
	    browsers,
	    feature: 'text-decoration'
	  })
	);

	let prefixDecorationStyle = requireMdnTextDecorationStyle();

	f(prefixDecorationStyle, browsers =>
	  prefix(['text-decoration-style'], {
	    browsers,
	    feature: 'text-decoration'
	  })
	);

	// Text Size Adjust
	let prefixTextSizeAdjust = requireTextSizeAdjust();

	f(prefixTextSizeAdjust, browsers =>
	  prefix(['text-size-adjust'], {
	    browsers,
	    feature: 'text-size-adjust'
	  })
	);

	// CSS Masks
	let prefixCssMasks = requireCssMasks();

	f(prefixCssMasks, browsers => {
	  prefix(
	    [
	      'mask-clip',
	      'mask-composite',
	      'mask-image',
	      'mask-origin',
	      'mask-repeat',
	      'mask-border-repeat',
	      'mask-border-source'
	    ],
	    {
	      browsers,
	      feature: 'css-masks'
	    }
	  );
	  prefix(
	    [
	      'mask',
	      'mask-position',
	      'mask-size',
	      'mask-border',
	      'mask-border-outset',
	      'mask-border-width',
	      'mask-border-slice'
	    ],
	    {
	      browsers,
	      feature: 'css-masks'
	    }
	  );
	});

	// CSS clip-path property
	let prefixClipPath = requireCssClipPath();

	f(prefixClipPath, browsers =>
	  prefix(['clip-path'], {
	    browsers,
	    feature: 'css-clip-path'
	  })
	);

	// Fragmented Borders and Backgrounds
	let prefixBoxdecoration = requireCssBoxdecorationbreak();

	f(prefixBoxdecoration, browsers =>
	  prefix(['box-decoration-break'], {
	    browsers,
	    feature: 'css-boxdecorationbreak'
	  })
	);

	// CSS3 object-fit/object-position
	let prefixObjectFit = requireObjectFit();

	f(prefixObjectFit, browsers =>
	  prefix(['object-fit', 'object-position'], {
	    browsers,
	    feature: 'object-fit'
	  })
	);

	// CSS Shapes
	let prefixShapes = requireCssShapes();

	f(prefixShapes, browsers =>
	  prefix(['shape-margin', 'shape-outside', 'shape-image-threshold'], {
	    browsers,
	    feature: 'css-shapes'
	  })
	);

	// CSS3 text-overflow
	let prefixTextOverflow = requireTextOverflow();

	f(prefixTextOverflow, browsers =>
	  prefix(['text-overflow'], {
	    browsers,
	    feature: 'text-overflow'
	  })
	);

	// Viewport at-rule
	let prefixDeviceadaptation = requireCssDeviceadaptation();

	f(prefixDeviceadaptation, browsers =>
	  prefix(['@viewport'], {
	    browsers,
	    feature: 'css-deviceadaptation'
	  })
	);

	// Resolution Media Queries
	let prefixResolut = requireCssMediaResolution();

	f(prefixResolut, { match: /( x($| )|a #2)/ }, browsers =>
	  prefix(['@resolution'], {
	    browsers,
	    feature: 'css-media-resolution'
	  })
	);

	// CSS text-align-last
	let prefixTextAlignLast = requireCssTextAlignLast();

	f(prefixTextAlignLast, browsers =>
	  prefix(['text-align-last'], {
	    browsers,
	    feature: 'css-text-align-last'
	  })
	);

	// Crisp Edges Image Rendering Algorithm
	let prefixCrispedges = requireCssCrispEdges();

	f(prefixCrispedges, { match: /y x|a x #1/ }, browsers =>
	  prefix(['pixelated'], {
	    browsers,
	    feature: 'css-crisp-edges',
	    props: ['image-rendering']
	  })
	);

	f(prefixCrispedges, { match: /a x #2/ }, browsers =>
	  prefix(['image-rendering'], {
	    browsers,
	    feature: 'css-crisp-edges'
	  })
	);

	// Logical Properties
	let prefixLogicalProps = requireCssLogicalProps();

	f(prefixLogicalProps, browsers =>
	  prefix(
	    [
	      'border-inline-start',
	      'border-inline-end',
	      'margin-inline-start',
	      'margin-inline-end',
	      'padding-inline-start',
	      'padding-inline-end'
	    ],
	    {
	      browsers,
	      feature: 'css-logical-props'
	    }
	  )
	);

	f(prefixLogicalProps, { match: /x\s#2/ }, browsers =>
	  prefix(
	    [
	      'border-block-start',
	      'border-block-end',
	      'margin-block-start',
	      'margin-block-end',
	      'padding-block-start',
	      'padding-block-end'
	    ],
	    {
	      browsers,
	      feature: 'css-logical-props'
	    }
	  )
	);

	// CSS appearance
	let prefixAppearance = requireCssAppearance();

	f(prefixAppearance, { match: /#2|x/ }, browsers =>
	  prefix(['appearance'], {
	    browsers,
	    feature: 'css-appearance'
	  })
	);

	// CSS Scroll snap points
	let prefixSnappoints = requireCssSnappoints();

	f(prefixSnappoints, browsers =>
	  prefix(
	    [
	      'scroll-snap-type',
	      'scroll-snap-coordinate',
	      'scroll-snap-destination',
	      'scroll-snap-points-x',
	      'scroll-snap-points-y'
	    ],
	    {
	      browsers,
	      feature: 'css-snappoints'
	    }
	  )
	);

	// CSS Regions
	let prefixRegions = requireCssRegions();

	f(prefixRegions, browsers =>
	  prefix(['flow-into', 'flow-from', 'region-fragment'], {
	    browsers,
	    feature: 'css-regions'
	  })
	);

	// CSS image-set
	let prefixImageSet = requireCssImageSet();

	f(prefixImageSet, browsers =>
	  prefix(['image-set'], {
	    browsers,
	    feature: 'css-image-set',
	    props: [
	      'background',
	      'background-image',
	      'border-image',
	      'cursor',
	      'mask',
	      'mask-image',
	      'list-style',
	      'list-style-image',
	      'content'
	    ]
	  })
	);

	// Writing Mode
	let prefixWritingMode = requireCssWritingMode();

	f(prefixWritingMode, { match: /a|x/ }, browsers =>
	  prefix(['writing-mode'], {
	    browsers,
	    feature: 'css-writing-mode'
	  })
	);

	// Cross-Fade Function
	let prefixCrossFade = requireCssCrossFade();

	f(prefixCrossFade, browsers =>
	  prefix(['cross-fade'], {
	    browsers,
	    feature: 'css-cross-fade',
	    props: [
	      'background',
	      'background-image',
	      'border-image',
	      'mask',
	      'list-style',
	      'list-style-image',
	      'content',
	      'mask-image'
	    ]
	  })
	);

	// Read Only selector
	let prefixReadOnly = requireCssReadOnlyWrite();

	f(prefixReadOnly, browsers =>
	  prefix([':read-only', ':read-write'], {
	    browsers,
	    feature: 'css-read-only-write',
	    selector: true
	  })
	);

	// Text Emphasize
	let prefixTextEmphasis = requireTextEmphasis();

	f(prefixTextEmphasis, browsers =>
	  prefix(
	    [
	      'text-emphasis',
	      'text-emphasis-position',
	      'text-emphasis-style',
	      'text-emphasis-color'
	    ],
	    {
	      browsers,
	      feature: 'text-emphasis'
	    }
	  )
	);

	// CSS Grid Layout
	let prefixGrid = requireCssGrid();

	f(prefixGrid, browsers => {
	  prefix(['display-grid', 'inline-grid'], {
	    browsers,
	    feature: 'css-grid',
	    props: ['display']
	  });
	  prefix(
	    [
	      'grid-template-columns',
	      'grid-template-rows',
	      'grid-row-start',
	      'grid-column-start',
	      'grid-row-end',
	      'grid-column-end',
	      'grid-row',
	      'grid-column',
	      'grid-area',
	      'grid-template',
	      'grid-template-areas',
	      'place-self'
	    ],
	    {
	      browsers,
	      feature: 'css-grid'
	    }
	  );
	});

	f(prefixGrid, { match: /a x/ }, browsers =>
	  prefix(['grid-column-align', 'grid-row-align'], {
	    browsers,
	    feature: 'css-grid'
	  })
	);

	// CSS text-spacing
	let prefixTextSpacing = requireCssTextSpacing();

	f(prefixTextSpacing, browsers =>
	  prefix(['text-spacing'], {
	    browsers,
	    feature: 'css-text-spacing'
	  })
	);

	// :any-link selector
	let prefixAnyLink = requireCssAnyLink();

	f(prefixAnyLink, browsers =>
	  prefix([':any-link'], {
	    browsers,
	    feature: 'css-any-link',
	    selector: true
	  })
	);

	// unicode-bidi

	let bidiIsolate = requireMdnCssUnicodeBidiIsolate();

	f(bidiIsolate, browsers =>
	  prefix(['isolate'], {
	    browsers,
	    feature: 'css-unicode-bidi',
	    props: ['unicode-bidi']
	  })
	);

	let bidiPlaintext = requireMdnCssUnicodeBidiPlaintext();

	f(bidiPlaintext, browsers =>
	  prefix(['plaintext'], {
	    browsers,
	    feature: 'css-unicode-bidi',
	    props: ['unicode-bidi']
	  })
	);

	let bidiOverride = requireMdnCssUnicodeBidiIsolateOverride();

	f(bidiOverride, { match: /y x/ }, browsers =>
	  prefix(['isolate-override'], {
	    browsers,
	    feature: 'css-unicode-bidi',
	    props: ['unicode-bidi']
	  })
	);

	// overscroll-behavior selector
	let prefixOverscroll = requireCssOverscrollBehavior();

	f(prefixOverscroll, { match: /a #1/ }, browsers =>
	  prefix(['overscroll-behavior'], {
	    browsers,
	    feature: 'css-overscroll-behavior'
	  })
	);

	// text-orientation
	let prefixTextOrientation = requireCssTextOrientation();

	f(prefixTextOrientation, browsers =>
	  prefix(['text-orientation'], {
	    browsers,
	    feature: 'css-text-orientation'
	  })
	);

	// print-color-adjust
	let prefixPrintAdjust = requireCssPrintColorAdjust();

	f(prefixPrintAdjust, browsers =>
	  prefix(['print-color-adjust', 'color-adjust'], {
	    browsers,
	    feature: 'css-print-color-adjust'
	  })
	);
	return prefixes$1;
}

var utils = {};

var tokenize;
var hasRequiredTokenize;

function requireTokenize () {
	if (hasRequiredTokenize) return tokenize;
	hasRequiredTokenize = 1;

	const SINGLE_QUOTE = "'".charCodeAt(0);
	const DOUBLE_QUOTE = '"'.charCodeAt(0);
	const BACKSLASH = '\\'.charCodeAt(0);
	const SLASH = '/'.charCodeAt(0);
	const NEWLINE = '\n'.charCodeAt(0);
	const SPACE = ' '.charCodeAt(0);
	const FEED = '\f'.charCodeAt(0);
	const TAB = '\t'.charCodeAt(0);
	const CR = '\r'.charCodeAt(0);
	const OPEN_SQUARE = '['.charCodeAt(0);
	const CLOSE_SQUARE = ']'.charCodeAt(0);
	const OPEN_PARENTHESES = '('.charCodeAt(0);
	const CLOSE_PARENTHESES = ')'.charCodeAt(0);
	const OPEN_CURLY = '{'.charCodeAt(0);
	const CLOSE_CURLY = '}'.charCodeAt(0);
	const SEMICOLON = ';'.charCodeAt(0);
	const ASTERISK = '*'.charCodeAt(0);
	const COLON = ':'.charCodeAt(0);
	const AT = '@'.charCodeAt(0);

	const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
	const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
	const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
	const RE_HEX_ESCAPE = /[\da-f]/i;

	tokenize = function tokenizer(input, options = {}) {
	  let css = input.css.valueOf();
	  let ignore = options.ignoreErrors;

	  let code, content, escape, next, quote;
	  let currentToken, escaped, escapePos, n, prev;

	  let length = css.length;
	  let pos = 0;
	  let buffer = [];
	  let returned = [];

	  function position() {
	    return pos
	  }

	  function unclosed(what) {
	    throw input.error('Unclosed ' + what, pos)
	  }

	  function endOfFile() {
	    return returned.length === 0 && pos >= length
	  }

	  function nextToken(opts) {
	    if (returned.length) return returned.pop()
	    if (pos >= length) return

	    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;

	    code = css.charCodeAt(pos);

	    switch (code) {
	      case NEWLINE:
	      case SPACE:
	      case TAB:
	      case CR:
	      case FEED: {
	        next = pos;
	        do {
	          next += 1;
	          code = css.charCodeAt(next);
	        } while (
	          code === SPACE ||
	          code === NEWLINE ||
	          code === TAB ||
	          code === CR ||
	          code === FEED
	        )

	        currentToken = ['space', css.slice(pos, next)];
	        pos = next - 1;
	        break
	      }

	      case OPEN_SQUARE:
	      case CLOSE_SQUARE:
	      case OPEN_CURLY:
	      case CLOSE_CURLY:
	      case COLON:
	      case SEMICOLON:
	      case CLOSE_PARENTHESES: {
	        let controlChar = String.fromCharCode(code);
	        currentToken = [controlChar, controlChar, pos];
	        break
	      }

	      case OPEN_PARENTHESES: {
	        prev = buffer.length ? buffer.pop()[1] : '';
	        n = css.charCodeAt(pos + 1);
	        if (
	          prev === 'url' &&
	          n !== SINGLE_QUOTE &&
	          n !== DOUBLE_QUOTE &&
	          n !== SPACE &&
	          n !== NEWLINE &&
	          n !== TAB &&
	          n !== FEED &&
	          n !== CR
	        ) {
	          next = pos;
	          do {
	            escaped = false;
	            next = css.indexOf(')', next + 1);
	            if (next === -1) {
	              if (ignore || ignoreUnclosed) {
	                next = pos;
	                break
	              } else {
	                unclosed('bracket');
	              }
	            }
	            escapePos = next;
	            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
	              escapePos -= 1;
	              escaped = !escaped;
	            }
	          } while (escaped)

	          currentToken = ['brackets', css.slice(pos, next + 1), pos, next];

	          pos = next;
	        } else {
	          next = css.indexOf(')', pos + 1);
	          content = css.slice(pos, next + 1);

	          if (next === -1 || RE_BAD_BRACKET.test(content)) {
	            currentToken = ['(', '(', pos];
	          } else {
	            currentToken = ['brackets', content, pos, next];
	            pos = next;
	          }
	        }

	        break
	      }

	      case SINGLE_QUOTE:
	      case DOUBLE_QUOTE: {
	        quote = code === SINGLE_QUOTE ? "'" : '"';
	        next = pos;
	        do {
	          escaped = false;
	          next = css.indexOf(quote, next + 1);
	          if (next === -1) {
	            if (ignore || ignoreUnclosed) {
	              next = pos + 1;
	              break
	            } else {
	              unclosed('string');
	            }
	          }
	          escapePos = next;
	          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
	            escapePos -= 1;
	            escaped = !escaped;
	          }
	        } while (escaped)

	        currentToken = ['string', css.slice(pos, next + 1), pos, next];
	        pos = next;
	        break
	      }

	      case AT: {
	        RE_AT_END.lastIndex = pos + 1;
	        RE_AT_END.test(css);
	        if (RE_AT_END.lastIndex === 0) {
	          next = css.length - 1;
	        } else {
	          next = RE_AT_END.lastIndex - 2;
	        }

	        currentToken = ['at-word', css.slice(pos, next + 1), pos, next];

	        pos = next;
	        break
	      }

	      case BACKSLASH: {
	        next = pos;
	        escape = true;
	        while (css.charCodeAt(next + 1) === BACKSLASH) {
	          next += 1;
	          escape = !escape;
	        }
	        code = css.charCodeAt(next + 1);
	        if (
	          escape &&
	          code !== SLASH &&
	          code !== SPACE &&
	          code !== NEWLINE &&
	          code !== TAB &&
	          code !== CR &&
	          code !== FEED
	        ) {
	          next += 1;
	          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
	            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
	              next += 1;
	            }
	            if (css.charCodeAt(next + 1) === SPACE) {
	              next += 1;
	            }
	          }
	        }

	        currentToken = ['word', css.slice(pos, next + 1), pos, next];

	        pos = next;
	        break
	      }

	      default: {
	        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
	          next = css.indexOf('*/', pos + 2) + 1;
	          if (next === 0) {
	            if (ignore || ignoreUnclosed) {
	              next = css.length;
	            } else {
	              unclosed('comment');
	            }
	          }

	          currentToken = ['comment', css.slice(pos, next + 1), pos, next];
	          pos = next;
	        } else {
	          RE_WORD_END.lastIndex = pos + 1;
	          RE_WORD_END.test(css);
	          if (RE_WORD_END.lastIndex === 0) {
	            next = css.length - 1;
	          } else {
	            next = RE_WORD_END.lastIndex - 2;
	          }

	          currentToken = ['word', css.slice(pos, next + 1), pos, next];
	          buffer.push(currentToken);
	          pos = next;
	        }

	        break
	      }
	    }

	    pos++;
	    return currentToken
	  }

	  function back(token) {
	    returned.push(token);
	  }

	  return {
	    back,
	    endOfFile,
	    nextToken,
	    position
	  }
	};
	return tokenize;
}

var terminalHighlight_1;
var hasRequiredTerminalHighlight;

function requireTerminalHighlight () {
	if (hasRequiredTerminalHighlight) return terminalHighlight_1;
	hasRequiredTerminalHighlight = 1;

	let pico = /*@__PURE__*/ requirePicocolors();

	let tokenizer = requireTokenize();

	let Input;

	function registerInput(dependant) {
	  Input = dependant;
	}

	const HIGHLIGHT_THEME = {
	  ';': pico.yellow,
	  ':': pico.yellow,
	  '(': pico.cyan,
	  ')': pico.cyan,
	  '[': pico.yellow,
	  ']': pico.yellow,
	  '{': pico.yellow,
	  '}': pico.yellow,
	  'at-word': pico.cyan,
	  'brackets': pico.cyan,
	  'call': pico.cyan,
	  'class': pico.yellow,
	  'comment': pico.gray,
	  'hash': pico.magenta,
	  'string': pico.green
	};

	function getTokenType([type, value], processor) {
	  if (type === 'word') {
	    if (value[0] === '.') {
	      return 'class'
	    }
	    if (value[0] === '#') {
	      return 'hash'
	    }
	  }

	  if (!processor.endOfFile()) {
	    let next = processor.nextToken();
	    processor.back(next);
	    if (next[0] === 'brackets' || next[0] === '(') return 'call'
	  }

	  return type
	}

	function terminalHighlight(css) {
	  let processor = tokenizer(new Input(css), { ignoreErrors: true });
	  let result = '';
	  while (!processor.endOfFile()) {
	    let token = processor.nextToken();
	    let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
	    if (color) {
	      result += token[1]
	        .split(/\r?\n/)
	        .map(i => color(i))
	        .join('\n');
	    } else {
	      result += token[1];
	    }
	  }
	  return result
	}

	terminalHighlight.registerInput = registerInput;

	terminalHighlight_1 = terminalHighlight;
	return terminalHighlight_1;
}

var cssSyntaxError;
var hasRequiredCssSyntaxError;

function requireCssSyntaxError () {
	if (hasRequiredCssSyntaxError) return cssSyntaxError;
	hasRequiredCssSyntaxError = 1;

	let pico = /*@__PURE__*/ requirePicocolors();

	let terminalHighlight = requireTerminalHighlight();

	class CssSyntaxError extends Error {
	  constructor(message, line, column, source, file, plugin) {
	    super(message);
	    this.name = 'CssSyntaxError';
	    this.reason = message;

	    if (file) {
	      this.file = file;
	    }
	    if (source) {
	      this.source = source;
	    }
	    if (plugin) {
	      this.plugin = plugin;
	    }
	    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
	      if (typeof line === 'number') {
	        this.line = line;
	        this.column = column;
	      } else {
	        this.line = line.line;
	        this.column = line.column;
	        this.endLine = column.line;
	        this.endColumn = column.column;
	      }
	    }

	    this.setMessage();

	    if (Error.captureStackTrace) {
	      Error.captureStackTrace(this, CssSyntaxError);
	    }
	  }

	  setMessage() {
	    this.message = this.plugin ? this.plugin + ': ' : '';
	    this.message += this.file ? this.file : '<css input>';
	    if (typeof this.line !== 'undefined') {
	      this.message += ':' + this.line + ':' + this.column;
	    }
	    this.message += ': ' + this.reason;
	  }

	  showSourceCode(color) {
	    if (!this.source) return ''

	    let css = this.source;
	    if (color == null) color = pico.isColorSupported;

	    let aside = text => text;
	    let mark = text => text;
	    let highlight = text => text;
	    if (color) {
	      let { bold, gray, red } = pico.createColors(true);
	      mark = text => bold(red(text));
	      aside = text => gray(text);
	      if (terminalHighlight) {
	        highlight = text => terminalHighlight(text);
	      }
	    }

	    let lines = css.split(/\r?\n/);
	    let start = Math.max(this.line - 3, 0);
	    let end = Math.min(this.line + 2, lines.length);
	    let maxWidth = String(end).length;

	    return lines
	      .slice(start, end)
	      .map((line, index) => {
	        let number = start + 1 + index;
	        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
	        if (number === this.line) {
	          if (line.length > 160) {
	            let padding = 20;
	            let subLineStart = Math.max(0, this.column - padding);
	            let subLineEnd = Math.max(
	              this.column + padding,
	              this.endColumn + padding
	            );
	            let subLine = line.slice(subLineStart, subLineEnd);

	            let spacing =
	              aside(gutter.replace(/\d/g, ' ')) +
	              line
	                .slice(0, Math.min(this.column - 1, padding - 1))
	                .replace(/[^\t]/g, ' ');

	            return (
	              mark('>') +
	              aside(gutter) +
	              highlight(subLine) +
	              '\n ' +
	              spacing +
	              mark('^')
	            )
	          }

	          let spacing =
	            aside(gutter.replace(/\d/g, ' ')) +
	            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ');

	          return (
	            mark('>') +
	            aside(gutter) +
	            highlight(line) +
	            '\n ' +
	            spacing +
	            mark('^')
	          )
	        }

	        return ' ' + aside(gutter) + highlight(line)
	      })
	      .join('\n')
	  }

	  toString() {
	    let code = this.showSourceCode();
	    if (code) {
	      code = '\n\n' + code + '\n';
	    }
	    return this.name + ': ' + this.message + code
	  }
	}

	cssSyntaxError = CssSyntaxError;
	CssSyntaxError.default = CssSyntaxError;
	return cssSyntaxError;
}

var stringifier;
var hasRequiredStringifier;

function requireStringifier () {
	if (hasRequiredStringifier) return stringifier;
	hasRequiredStringifier = 1;

	const DEFAULT_RAW = {
	  after: '\n',
	  beforeClose: '\n',
	  beforeComment: '\n',
	  beforeDecl: '\n',
	  beforeOpen: ' ',
	  beforeRule: '\n',
	  colon: ': ',
	  commentLeft: ' ',
	  commentRight: ' ',
	  emptyBody: '',
	  indent: '    ',
	  semicolon: false
	};

	function capitalize(str) {
	  return str[0].toUpperCase() + str.slice(1)
	}

	class Stringifier {
	  constructor(builder) {
	    this.builder = builder;
	  }

	  atrule(node, semicolon) {
	    let name = '@' + node.name;
	    let params = node.params ? this.rawValue(node, 'params') : '';

	    if (typeof node.raws.afterName !== 'undefined') {
	      name += node.raws.afterName;
	    } else if (params) {
	      name += ' ';
	    }

	    if (node.nodes) {
	      this.block(node, name + params);
	    } else {
	      let end = (node.raws.between || '') + (semicolon ? ';' : '');
	      this.builder(name + params + end, node);
	    }
	  }

	  beforeAfter(node, detect) {
	    let value;
	    if (node.type === 'decl') {
	      value = this.raw(node, null, 'beforeDecl');
	    } else if (node.type === 'comment') {
	      value = this.raw(node, null, 'beforeComment');
	    } else if (detect === 'before') {
	      value = this.raw(node, null, 'beforeRule');
	    } else {
	      value = this.raw(node, null, 'beforeClose');
	    }

	    let buf = node.parent;
	    let depth = 0;
	    while (buf && buf.type !== 'root') {
	      depth += 1;
	      buf = buf.parent;
	    }

	    if (value.includes('\n')) {
	      let indent = this.raw(node, null, 'indent');
	      if (indent.length) {
	        for (let step = 0; step < depth; step++) value += indent;
	      }
	    }

	    return value
	  }

	  block(node, start) {
	    let between = this.raw(node, 'between', 'beforeOpen');
	    this.builder(start + between + '{', node, 'start');

	    let after;
	    if (node.nodes && node.nodes.length) {
	      this.body(node);
	      after = this.raw(node, 'after');
	    } else {
	      after = this.raw(node, 'after', 'emptyBody');
	    }

	    if (after) this.builder(after);
	    this.builder('}', node, 'end');
	  }

	  body(node) {
	    let last = node.nodes.length - 1;
	    while (last > 0) {
	      if (node.nodes[last].type !== 'comment') break
	      last -= 1;
	    }

	    let semicolon = this.raw(node, 'semicolon');
	    for (let i = 0; i < node.nodes.length; i++) {
	      let child = node.nodes[i];
	      let before = this.raw(child, 'before');
	      if (before) this.builder(before);
	      this.stringify(child, last !== i || semicolon);
	    }
	  }

	  comment(node) {
	    let left = this.raw(node, 'left', 'commentLeft');
	    let right = this.raw(node, 'right', 'commentRight');
	    this.builder('/*' + left + node.text + right + '*/', node);
	  }

	  decl(node, semicolon) {
	    let between = this.raw(node, 'between', 'colon');
	    let string = node.prop + between + this.rawValue(node, 'value');

	    if (node.important) {
	      string += node.raws.important || ' !important';
	    }

	    if (semicolon) string += ';';
	    this.builder(string, node);
	  }

	  document(node) {
	    this.body(node);
	  }

	  raw(node, own, detect) {
	    let value;
	    if (!detect) detect = own;

	    // Already had
	    if (own) {
	      value = node.raws[own];
	      if (typeof value !== 'undefined') return value
	    }

	    let parent = node.parent;

	    if (detect === 'before') {
	      // Hack for first rule in CSS
	      if (!parent || (parent.type === 'root' && parent.first === node)) {
	        return ''
	      }

	      // `root` nodes in `document` should use only their own raws
	      if (parent && parent.type === 'document') {
	        return ''
	      }
	    }

	    // Floating child without parent
	    if (!parent) return DEFAULT_RAW[detect]

	    // Detect style by other nodes
	    let root = node.root();
	    if (!root.rawCache) root.rawCache = {};
	    if (typeof root.rawCache[detect] !== 'undefined') {
	      return root.rawCache[detect]
	    }

	    if (detect === 'before' || detect === 'after') {
	      return this.beforeAfter(node, detect)
	    } else {
	      let method = 'raw' + capitalize(detect);
	      if (this[method]) {
	        value = this[method](root, node);
	      } else {
	        root.walk(i => {
	          value = i.raws[own];
	          if (typeof value !== 'undefined') return false
	        });
	      }
	    }

	    if (typeof value === 'undefined') value = DEFAULT_RAW[detect];

	    root.rawCache[detect] = value;
	    return value
	  }

	  rawBeforeClose(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && i.nodes.length > 0) {
	        if (typeof i.raws.after !== 'undefined') {
	          value = i.raws.after;
	          if (value.includes('\n')) {
	            value = value.replace(/[^\n]+$/, '');
	          }
	          return false
	        }
	      }
	    });
	    if (value) value = value.replace(/\S/g, '');
	    return value
	  }

	  rawBeforeComment(root, node) {
	    let value;
	    root.walkComments(i => {
	      if (typeof i.raws.before !== 'undefined') {
	        value = i.raws.before;
	        if (value.includes('\n')) {
	          value = value.replace(/[^\n]+$/, '');
	        }
	        return false
	      }
	    });
	    if (typeof value === 'undefined') {
	      value = this.raw(node, null, 'beforeDecl');
	    } else if (value) {
	      value = value.replace(/\S/g, '');
	    }
	    return value
	  }

	  rawBeforeDecl(root, node) {
	    let value;
	    root.walkDecls(i => {
	      if (typeof i.raws.before !== 'undefined') {
	        value = i.raws.before;
	        if (value.includes('\n')) {
	          value = value.replace(/[^\n]+$/, '');
	        }
	        return false
	      }
	    });
	    if (typeof value === 'undefined') {
	      value = this.raw(node, null, 'beforeRule');
	    } else if (value) {
	      value = value.replace(/\S/g, '');
	    }
	    return value
	  }

	  rawBeforeOpen(root) {
	    let value;
	    root.walk(i => {
	      if (i.type !== 'decl') {
	        value = i.raws.between;
	        if (typeof value !== 'undefined') return false
	      }
	    });
	    return value
	  }

	  rawBeforeRule(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && (i.parent !== root || root.first !== i)) {
	        if (typeof i.raws.before !== 'undefined') {
	          value = i.raws.before;
	          if (value.includes('\n')) {
	            value = value.replace(/[^\n]+$/, '');
	          }
	          return false
	        }
	      }
	    });
	    if (value) value = value.replace(/\S/g, '');
	    return value
	  }

	  rawColon(root) {
	    let value;
	    root.walkDecls(i => {
	      if (typeof i.raws.between !== 'undefined') {
	        value = i.raws.between.replace(/[^\s:]/g, '');
	        return false
	      }
	    });
	    return value
	  }

	  rawEmptyBody(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && i.nodes.length === 0) {
	        value = i.raws.after;
	        if (typeof value !== 'undefined') return false
	      }
	    });
	    return value
	  }

	  rawIndent(root) {
	    if (root.raws.indent) return root.raws.indent
	    let value;
	    root.walk(i => {
	      let p = i.parent;
	      if (p && p !== root && p.parent && p.parent === root) {
	        if (typeof i.raws.before !== 'undefined') {
	          let parts = i.raws.before.split('\n');
	          value = parts[parts.length - 1];
	          value = value.replace(/\S/g, '');
	          return false
	        }
	      }
	    });
	    return value
	  }

	  rawSemicolon(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
	        value = i.raws.semicolon;
	        if (typeof value !== 'undefined') return false
	      }
	    });
	    return value
	  }

	  rawValue(node, prop) {
	    let value = node[prop];
	    let raw = node.raws[prop];
	    if (raw && raw.value === value) {
	      return raw.raw
	    }

	    return value
	  }

	  root(node) {
	    this.body(node);
	    if (node.raws.after) this.builder(node.raws.after);
	  }

	  rule(node) {
	    this.block(node, this.rawValue(node, 'selector'));
	    if (node.raws.ownSemicolon) {
	      this.builder(node.raws.ownSemicolon, node, 'end');
	    }
	  }

	  stringify(node, semicolon) {
	    /* c8 ignore start */
	    if (!this[node.type]) {
	      throw new Error(
	        'Unknown AST node type ' +
	          node.type +
	          '. ' +
	          'Maybe you need to change PostCSS stringifier.'
	      )
	    }
	    /* c8 ignore stop */
	    this[node.type](node, semicolon);
	  }
	}

	stringifier = Stringifier;
	Stringifier.default = Stringifier;
	return stringifier;
}

var stringify_1$1;
var hasRequiredStringify$1;

function requireStringify$1 () {
	if (hasRequiredStringify$1) return stringify_1$1;
	hasRequiredStringify$1 = 1;

	let Stringifier = requireStringifier();

	function stringify(node, builder) {
	  let str = new Stringifier(builder);
	  str.stringify(node);
	}

	stringify_1$1 = stringify;
	stringify.default = stringify;
	return stringify_1$1;
}

var symbols = {};

var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;

	symbols.isClean = Symbol('isClean');

	symbols.my = Symbol('my');
	return symbols;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;

	let CssSyntaxError = requireCssSyntaxError();
	let Stringifier = requireStringifier();
	let stringify = requireStringify$1();
	let { isClean, my } = requireSymbols();

	function cloneNode(obj, parent) {
	  let cloned = new obj.constructor();

	  for (let i in obj) {
	    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
	      /* c8 ignore next 2 */
	      continue
	    }
	    if (i === 'proxyCache') continue
	    let value = obj[i];
	    let type = typeof value;

	    if (i === 'parent' && type === 'object') {
	      if (parent) cloned[i] = parent;
	    } else if (i === 'source') {
	      cloned[i] = value;
	    } else if (Array.isArray(value)) {
	      cloned[i] = value.map(j => cloneNode(j, cloned));
	    } else {
	      if (type === 'object' && value !== null) value = cloneNode(value);
	      cloned[i] = value;
	    }
	  }

	  return cloned
	}

	function sourceOffset(inputCSS, position) {
	  // Not all custom syntaxes support `offset` in `source.start` and `source.end`
	  if (position && typeof position.offset !== 'undefined') {
	    return position.offset
	  }

	  let column = 1;
	  let line = 1;
	  let offset = 0;

	  for (let i = 0; i < inputCSS.length; i++) {
	    if (line === position.line && column === position.column) {
	      offset = i;
	      break
	    }

	    if (inputCSS[i] === '\n') {
	      column = 1;
	      line += 1;
	    } else {
	      column += 1;
	    }
	  }

	  return offset
	}

	class Node {
	  get proxyOf() {
	    return this
	  }

	  constructor(defaults = {}) {
	    this.raws = {};
	    this[isClean] = false;
	    this[my] = true;

	    for (let name in defaults) {
	      if (name === 'nodes') {
	        this.nodes = [];
	        for (let node of defaults[name]) {
	          if (typeof node.clone === 'function') {
	            this.append(node.clone());
	          } else {
	            this.append(node);
	          }
	        }
	      } else {
	        this[name] = defaults[name];
	      }
	    }
	  }

	  addToError(error) {
	    error.postcssNode = this;
	    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
	      let s = this.source;
	      error.stack = error.stack.replace(
	        /\n\s{4}at /,
	        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
	      );
	    }
	    return error
	  }

	  after(add) {
	    this.parent.insertAfter(this, add);
	    return this
	  }

	  assign(overrides = {}) {
	    for (let name in overrides) {
	      this[name] = overrides[name];
	    }
	    return this
	  }

	  before(add) {
	    this.parent.insertBefore(this, add);
	    return this
	  }

	  cleanRaws(keepBetween) {
	    delete this.raws.before;
	    delete this.raws.after;
	    if (!keepBetween) delete this.raws.between;
	  }

	  clone(overrides = {}) {
	    let cloned = cloneNode(this);
	    for (let name in overrides) {
	      cloned[name] = overrides[name];
	    }
	    return cloned
	  }

	  cloneAfter(overrides = {}) {
	    let cloned = this.clone(overrides);
	    this.parent.insertAfter(this, cloned);
	    return cloned
	  }

	  cloneBefore(overrides = {}) {
	    let cloned = this.clone(overrides);
	    this.parent.insertBefore(this, cloned);
	    return cloned
	  }

	  error(message, opts = {}) {
	    if (this.source) {
	      let { end, start } = this.rangeBy(opts);
	      return this.source.input.error(
	        message,
	        { column: start.column, line: start.line },
	        { column: end.column, line: end.line },
	        opts
	      )
	    }
	    return new CssSyntaxError(message)
	  }

	  getProxyProcessor() {
	    return {
	      get(node, prop) {
	        if (prop === 'proxyOf') {
	          return node
	        } else if (prop === 'root') {
	          return () => node.root().toProxy()
	        } else {
	          return node[prop]
	        }
	      },

	      set(node, prop, value) {
	        if (node[prop] === value) return true
	        node[prop] = value;
	        if (
	          prop === 'prop' ||
	          prop === 'value' ||
	          prop === 'name' ||
	          prop === 'params' ||
	          prop === 'important' ||
	          /* c8 ignore next */
	          prop === 'text'
	        ) {
	          node.markDirty();
	        }
	        return true
	      }
	    }
	  }

	  /* c8 ignore next 3 */
	  markClean() {
	    this[isClean] = true;
	  }

	  markDirty() {
	    if (this[isClean]) {
	      this[isClean] = false;
	      let next = this;
	      while ((next = next.parent)) {
	        next[isClean] = false;
	      }
	    }
	  }

	  next() {
	    if (!this.parent) return undefined
	    let index = this.parent.index(this);
	    return this.parent.nodes[index + 1]
	  }

	  positionBy(opts = {}) {
	    let pos = this.source.start;
	    if (opts.index) {
	      pos = this.positionInside(opts.index);
	    } else if (opts.word) {
	      let inputString =
	        'document' in this.source.input
	          ? this.source.input.document
	          : this.source.input.css;
	      let stringRepresentation = inputString.slice(
	        sourceOffset(inputString, this.source.start),
	        sourceOffset(inputString, this.source.end)
	      );
	      let index = stringRepresentation.indexOf(opts.word);
	      if (index !== -1) pos = this.positionInside(index);
	    }
	    return pos
	  }

	  positionInside(index) {
	    let column = this.source.start.column;
	    let line = this.source.start.line;
	    let inputString =
	      'document' in this.source.input
	        ? this.source.input.document
	        : this.source.input.css;
	    let offset = sourceOffset(inputString, this.source.start);
	    let end = offset + index;

	    for (let i = offset; i < end; i++) {
	      if (inputString[i] === '\n') {
	        column = 1;
	        line += 1;
	      } else {
	        column += 1;
	      }
	    }

	    return { column, line, offset: end }
	  }

	  prev() {
	    if (!this.parent) return undefined
	    let index = this.parent.index(this);
	    return this.parent.nodes[index - 1]
	  }

	  rangeBy(opts = {}) {
	    let inputString =
	      'document' in this.source.input
	        ? this.source.input.document
	        : this.source.input.css;
	    let start = {
	      column: this.source.start.column,
	      line: this.source.start.line,
	      offset: sourceOffset(inputString, this.source.start)
	    };
	    let end = this.source.end
	      ? {
	          column: this.source.end.column + 1,
	          line: this.source.end.line,
	          offset:
	            typeof this.source.end.offset === 'number'
	              ? // `source.end.offset` is exclusive, so we don't need to add 1
	                this.source.end.offset
	              : // Since line/column in this.source.end is inclusive,
	                // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
	                // So, we add 1 to convert it to exclusive.
	                sourceOffset(inputString, this.source.end) + 1
	        }
	      : {
	          column: start.column + 1,
	          line: start.line,
	          offset: start.offset + 1
	        };

	    if (opts.word) {
	      let stringRepresentation = inputString.slice(
	        sourceOffset(inputString, this.source.start),
	        sourceOffset(inputString, this.source.end)
	      );
	      let index = stringRepresentation.indexOf(opts.word);
	      if (index !== -1) {
	        start = this.positionInside(index);
	        end = this.positionInside(index + opts.word.length);
	      }
	    } else {
	      if (opts.start) {
	        start = {
	          column: opts.start.column,
	          line: opts.start.line,
	          offset: sourceOffset(inputString, opts.start)
	        };
	      } else if (opts.index) {
	        start = this.positionInside(opts.index);
	      }

	      if (opts.end) {
	        end = {
	          column: opts.end.column,
	          line: opts.end.line,
	          offset: sourceOffset(inputString, opts.end)
	        };
	      } else if (typeof opts.endIndex === 'number') {
	        end = this.positionInside(opts.endIndex);
	      } else if (opts.index) {
	        end = this.positionInside(opts.index + 1);
	      }
	    }

	    if (
	      end.line < start.line ||
	      (end.line === start.line && end.column <= start.column)
	    ) {
	      end = {
	        column: start.column + 1,
	        line: start.line,
	        offset: start.offset + 1
	      };
	    }

	    return { end, start }
	  }

	  raw(prop, defaultType) {
	    let str = new Stringifier();
	    return str.raw(this, prop, defaultType)
	  }

	  remove() {
	    if (this.parent) {
	      this.parent.removeChild(this);
	    }
	    this.parent = undefined;
	    return this
	  }

	  replaceWith(...nodes) {
	    if (this.parent) {
	      let bookmark = this;
	      let foundSelf = false;
	      for (let node of nodes) {
	        if (node === this) {
	          foundSelf = true;
	        } else if (foundSelf) {
	          this.parent.insertAfter(bookmark, node);
	          bookmark = node;
	        } else {
	          this.parent.insertBefore(bookmark, node);
	        }
	      }

	      if (!foundSelf) {
	        this.remove();
	      }
	    }

	    return this
	  }

	  root() {
	    let result = this;
	    while (result.parent && result.parent.type !== 'document') {
	      result = result.parent;
	    }
	    return result
	  }

	  toJSON(_, inputs) {
	    let fixed = {};
	    let emitInputs = inputs == null;
	    inputs = inputs || new Map();
	    let inputsNextIndex = 0;

	    for (let name in this) {
	      if (!Object.prototype.hasOwnProperty.call(this, name)) {
	        /* c8 ignore next 2 */
	        continue
	      }
	      if (name === 'parent' || name === 'proxyCache') continue
	      let value = this[name];

	      if (Array.isArray(value)) {
	        fixed[name] = value.map(i => {
	          if (typeof i === 'object' && i.toJSON) {
	            return i.toJSON(null, inputs)
	          } else {
	            return i
	          }
	        });
	      } else if (typeof value === 'object' && value.toJSON) {
	        fixed[name] = value.toJSON(null, inputs);
	      } else if (name === 'source') {
	        if (value == null) continue
	        let inputId = inputs.get(value.input);
	        if (inputId == null) {
	          inputId = inputsNextIndex;
	          inputs.set(value.input, inputsNextIndex);
	          inputsNextIndex++;
	        }
	        fixed[name] = {
	          end: value.end,
	          inputId,
	          start: value.start
	        };
	      } else {
	        fixed[name] = value;
	      }
	    }

	    if (emitInputs) {
	      fixed.inputs = [...inputs.keys()].map(input => input.toJSON());
	    }

	    return fixed
	  }

	  toProxy() {
	    if (!this.proxyCache) {
	      this.proxyCache = new Proxy(this, this.getProxyProcessor());
	    }
	    return this.proxyCache
	  }

	  toString(stringifier = stringify) {
	    if (stringifier.stringify) stringifier = stringifier.stringify;
	    let result = '';
	    stringifier(this, i => {
	      result += i;
	    });
	    return result
	  }

	  warn(result, text, opts = {}) {
	    let data = { node: this };
	    for (let i in opts) data[i] = opts[i];
	    return result.warn(text, data)
	  }
	}

	node = Node;
	Node.default = Node;
	return node;
}

var comment;
var hasRequiredComment;

function requireComment () {
	if (hasRequiredComment) return comment;
	hasRequiredComment = 1;

	let Node = requireNode();

	class Comment extends Node {
	  constructor(defaults) {
	    super(defaults);
	    this.type = 'comment';
	  }
	}

	comment = Comment;
	Comment.default = Comment;
	return comment;
}

var declaration$1;
var hasRequiredDeclaration$1;

function requireDeclaration$1 () {
	if (hasRequiredDeclaration$1) return declaration$1;
	hasRequiredDeclaration$1 = 1;

	let Node = requireNode();

	class Declaration extends Node {
	  get variable() {
	    return this.prop.startsWith('--') || this.prop[0] === '$'
	  }

	  constructor(defaults) {
	    if (
	      defaults &&
	      typeof defaults.value !== 'undefined' &&
	      typeof defaults.value !== 'string'
	    ) {
	      defaults = { ...defaults, value: String(defaults.value) };
	    }
	    super(defaults);
	    this.type = 'decl';
	  }
	}

	declaration$1 = Declaration;
	Declaration.default = Declaration;
	return declaration$1;
}

var container;
var hasRequiredContainer;

function requireContainer () {
	if (hasRequiredContainer) return container;
	hasRequiredContainer = 1;

	let Comment = requireComment();
	let Declaration = requireDeclaration$1();
	let Node = requireNode();
	let { isClean, my } = requireSymbols();

	let AtRule, parse, Root, Rule;

	function cleanSource(nodes) {
	  return nodes.map(i => {
	    if (i.nodes) i.nodes = cleanSource(i.nodes);
	    delete i.source;
	    return i
	  })
	}

	function markTreeDirty(node) {
	  node[isClean] = false;
	  if (node.proxyOf.nodes) {
	    for (let i of node.proxyOf.nodes) {
	      markTreeDirty(i);
	    }
	  }
	}

	class Container extends Node {
	  get first() {
	    if (!this.proxyOf.nodes) return undefined
	    return this.proxyOf.nodes[0]
	  }

	  get last() {
	    if (!this.proxyOf.nodes) return undefined
	    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
	  }

	  append(...children) {
	    for (let child of children) {
	      let nodes = this.normalize(child, this.last);
	      for (let node of nodes) this.proxyOf.nodes.push(node);
	    }

	    this.markDirty();

	    return this
	  }

	  cleanRaws(keepBetween) {
	    super.cleanRaws(keepBetween);
	    if (this.nodes) {
	      for (let node of this.nodes) node.cleanRaws(keepBetween);
	    }
	  }

	  each(callback) {
	    if (!this.proxyOf.nodes) return undefined
	    let iterator = this.getIterator();

	    let index, result;
	    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
	      index = this.indexes[iterator];
	      result = callback(this.proxyOf.nodes[index], index);
	      if (result === false) break

	      this.indexes[iterator] += 1;
	    }

	    delete this.indexes[iterator];
	    return result
	  }

	  every(condition) {
	    return this.nodes.every(condition)
	  }

	  getIterator() {
	    if (!this.lastEach) this.lastEach = 0;
	    if (!this.indexes) this.indexes = {};

	    this.lastEach += 1;
	    let iterator = this.lastEach;
	    this.indexes[iterator] = 0;

	    return iterator
	  }

	  getProxyProcessor() {
	    return {
	      get(node, prop) {
	        if (prop === 'proxyOf') {
	          return node
	        } else if (!node[prop]) {
	          return node[prop]
	        } else if (
	          prop === 'each' ||
	          (typeof prop === 'string' && prop.startsWith('walk'))
	        ) {
	          return (...args) => {
	            return node[prop](
	              ...args.map(i => {
	                if (typeof i === 'function') {
	                  return (child, index) => i(child.toProxy(), index)
	                } else {
	                  return i
	                }
	              })
	            )
	          }
	        } else if (prop === 'every' || prop === 'some') {
	          return cb => {
	            return node[prop]((child, ...other) =>
	              cb(child.toProxy(), ...other)
	            )
	          }
	        } else if (prop === 'root') {
	          return () => node.root().toProxy()
	        } else if (prop === 'nodes') {
	          return node.nodes.map(i => i.toProxy())
	        } else if (prop === 'first' || prop === 'last') {
	          return node[prop].toProxy()
	        } else {
	          return node[prop]
	        }
	      },

	      set(node, prop, value) {
	        if (node[prop] === value) return true
	        node[prop] = value;
	        if (prop === 'name' || prop === 'params' || prop === 'selector') {
	          node.markDirty();
	        }
	        return true
	      }
	    }
	  }

	  index(child) {
	    if (typeof child === 'number') return child
	    if (child.proxyOf) child = child.proxyOf;
	    return this.proxyOf.nodes.indexOf(child)
	  }

	  insertAfter(exist, add) {
	    let existIndex = this.index(exist);
	    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
	    existIndex = this.index(exist);
	    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);

	    let index;
	    for (let id in this.indexes) {
	      index = this.indexes[id];
	      if (existIndex < index) {
	        this.indexes[id] = index + nodes.length;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  insertBefore(exist, add) {
	    let existIndex = this.index(exist);
	    let type = existIndex === 0 ? 'prepend' : false;
	    let nodes = this.normalize(
	      add,
	      this.proxyOf.nodes[existIndex],
	      type
	    ).reverse();
	    existIndex = this.index(exist);
	    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);

	    let index;
	    for (let id in this.indexes) {
	      index = this.indexes[id];
	      if (existIndex <= index) {
	        this.indexes[id] = index + nodes.length;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  normalize(nodes, sample) {
	    if (typeof nodes === 'string') {
	      nodes = cleanSource(parse(nodes).nodes);
	    } else if (typeof nodes === 'undefined') {
	      nodes = [];
	    } else if (Array.isArray(nodes)) {
	      nodes = nodes.slice(0);
	      for (let i of nodes) {
	        if (i.parent) i.parent.removeChild(i, 'ignore');
	      }
	    } else if (nodes.type === 'root' && this.type !== 'document') {
	      nodes = nodes.nodes.slice(0);
	      for (let i of nodes) {
	        if (i.parent) i.parent.removeChild(i, 'ignore');
	      }
	    } else if (nodes.type) {
	      nodes = [nodes];
	    } else if (nodes.prop) {
	      if (typeof nodes.value === 'undefined') {
	        throw new Error('Value field is missed in node creation')
	      } else if (typeof nodes.value !== 'string') {
	        nodes.value = String(nodes.value);
	      }
	      nodes = [new Declaration(nodes)];
	    } else if (nodes.selector || nodes.selectors) {
	      nodes = [new Rule(nodes)];
	    } else if (nodes.name) {
	      nodes = [new AtRule(nodes)];
	    } else if (nodes.text) {
	      nodes = [new Comment(nodes)];
	    } else {
	      throw new Error('Unknown node type in node creation')
	    }

	    let processed = nodes.map(i => {
	      /* c8 ignore next */
	      if (!i[my]) Container.rebuild(i);
	      i = i.proxyOf;
	      if (i.parent) i.parent.removeChild(i);
	      if (i[isClean]) markTreeDirty(i);

	      if (!i.raws) i.raws = {};
	      if (typeof i.raws.before === 'undefined') {
	        if (sample && typeof sample.raws.before !== 'undefined') {
	          i.raws.before = sample.raws.before.replace(/\S/g, '');
	        }
	      }
	      i.parent = this.proxyOf;
	      return i
	    });

	    return processed
	  }

	  prepend(...children) {
	    children = children.reverse();
	    for (let child of children) {
	      let nodes = this.normalize(child, this.first, 'prepend').reverse();
	      for (let node of nodes) this.proxyOf.nodes.unshift(node);
	      for (let id in this.indexes) {
	        this.indexes[id] = this.indexes[id] + nodes.length;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  push(child) {
	    child.parent = this;
	    this.proxyOf.nodes.push(child);
	    return this
	  }

	  removeAll() {
	    for (let node of this.proxyOf.nodes) node.parent = undefined;
	    this.proxyOf.nodes = [];

	    this.markDirty();

	    return this
	  }

	  removeChild(child) {
	    child = this.index(child);
	    this.proxyOf.nodes[child].parent = undefined;
	    this.proxyOf.nodes.splice(child, 1);

	    let index;
	    for (let id in this.indexes) {
	      index = this.indexes[id];
	      if (index >= child) {
	        this.indexes[id] = index - 1;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  replaceValues(pattern, opts, callback) {
	    if (!callback) {
	      callback = opts;
	      opts = {};
	    }

	    this.walkDecls(decl => {
	      if (opts.props && !opts.props.includes(decl.prop)) return
	      if (opts.fast && !decl.value.includes(opts.fast)) return

	      decl.value = decl.value.replace(pattern, callback);
	    });

	    this.markDirty();

	    return this
	  }

	  some(condition) {
	    return this.nodes.some(condition)
	  }

	  walk(callback) {
	    return this.each((child, i) => {
	      let result;
	      try {
	        result = callback(child, i);
	      } catch (e) {
	        throw child.addToError(e)
	      }
	      if (result !== false && child.walk) {
	        result = child.walk(callback);
	      }

	      return result
	    })
	  }

	  walkAtRules(name, callback) {
	    if (!callback) {
	      callback = name;
	      return this.walk((child, i) => {
	        if (child.type === 'atrule') {
	          return callback(child, i)
	        }
	      })
	    }
	    if (name instanceof RegExp) {
	      return this.walk((child, i) => {
	        if (child.type === 'atrule' && name.test(child.name)) {
	          return callback(child, i)
	        }
	      })
	    }
	    return this.walk((child, i) => {
	      if (child.type === 'atrule' && child.name === name) {
	        return callback(child, i)
	      }
	    })
	  }

	  walkComments(callback) {
	    return this.walk((child, i) => {
	      if (child.type === 'comment') {
	        return callback(child, i)
	      }
	    })
	  }

	  walkDecls(prop, callback) {
	    if (!callback) {
	      callback = prop;
	      return this.walk((child, i) => {
	        if (child.type === 'decl') {
	          return callback(child, i)
	        }
	      })
	    }
	    if (prop instanceof RegExp) {
	      return this.walk((child, i) => {
	        if (child.type === 'decl' && prop.test(child.prop)) {
	          return callback(child, i)
	        }
	      })
	    }
	    return this.walk((child, i) => {
	      if (child.type === 'decl' && child.prop === prop) {
	        return callback(child, i)
	      }
	    })
	  }

	  walkRules(selector, callback) {
	    if (!callback) {
	      callback = selector;

	      return this.walk((child, i) => {
	        if (child.type === 'rule') {
	          return callback(child, i)
	        }
	      })
	    }
	    if (selector instanceof RegExp) {
	      return this.walk((child, i) => {
	        if (child.type === 'rule' && selector.test(child.selector)) {
	          return callback(child, i)
	        }
	      })
	    }
	    return this.walk((child, i) => {
	      if (child.type === 'rule' && child.selector === selector) {
	        return callback(child, i)
	      }
	    })
	  }
	}

	Container.registerParse = dependant => {
	  parse = dependant;
	};

	Container.registerRule = dependant => {
	  Rule = dependant;
	};

	Container.registerAtRule = dependant => {
	  AtRule = dependant;
	};

	Container.registerRoot = dependant => {
	  Root = dependant;
	};

	container = Container;
	Container.default = Container;

	/* c8 ignore start */
	Container.rebuild = node => {
	  if (node.type === 'atrule') {
	    Object.setPrototypeOf(node, AtRule.prototype);
	  } else if (node.type === 'rule') {
	    Object.setPrototypeOf(node, Rule.prototype);
	  } else if (node.type === 'decl') {
	    Object.setPrototypeOf(node, Declaration.prototype);
	  } else if (node.type === 'comment') {
	    Object.setPrototypeOf(node, Comment.prototype);
	  } else if (node.type === 'root') {
	    Object.setPrototypeOf(node, Root.prototype);
	  }

	  node[my] = true;

	  if (node.nodes) {
	    node.nodes.forEach(child => {
	      Container.rebuild(child);
	    });
	  }
	};
	/* c8 ignore stop */
	return container;
}

var atRule$1;
var hasRequiredAtRule$1;

function requireAtRule$1 () {
	if (hasRequiredAtRule$1) return atRule$1;
	hasRequiredAtRule$1 = 1;

	let Container = requireContainer();

	class AtRule extends Container {
	  constructor(defaults) {
	    super(defaults);
	    this.type = 'atrule';
	  }

	  append(...children) {
	    if (!this.proxyOf.nodes) this.nodes = [];
	    return super.append(...children)
	  }

	  prepend(...children) {
	    if (!this.proxyOf.nodes) this.nodes = [];
	    return super.prepend(...children)
	  }
	}

	atRule$1 = AtRule;
	AtRule.default = AtRule;

	Container.registerAtRule(AtRule);
	return atRule$1;
}

var document$1;
var hasRequiredDocument;

function requireDocument () {
	if (hasRequiredDocument) return document$1;
	hasRequiredDocument = 1;

	let Container = requireContainer();

	let LazyResult, Processor;

	class Document extends Container {
	  constructor(defaults) {
	    // type needs to be passed to super, otherwise child roots won't be normalized correctly
	    super({ type: 'document', ...defaults });

	    if (!this.nodes) {
	      this.nodes = [];
	    }
	  }

	  toResult(opts = {}) {
	    let lazy = new LazyResult(new Processor(), this, opts);

	    return lazy.stringify()
	  }
	}

	Document.registerLazyResult = dependant => {
	  LazyResult = dependant;
	};

	Document.registerProcessor = dependant => {
	  Processor = dependant;
	};

	document$1 = Document;
	Document.default = Document;
	return document$1;
}

var nonSecure;
var hasRequiredNonSecure;

function requireNonSecure () {
	if (hasRequiredNonSecure) return nonSecure;
	hasRequiredNonSecure = 1;
	// This alphabet uses `A-Za-z0-9_-` symbols.
	// The order of characters is optimized for better gzip and brotli compression.
	// References to the same file (works both for gzip and brotli):
	// `'use`, `andom`, and `rict'`
	// References to the brotli default dictionary:
	// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
	let urlAlphabet =
	  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';

	let customAlphabet = (alphabet, defaultSize = 21) => {
	  return (size = defaultSize) => {
	    let id = '';
	    // A compact alternative for `for (var i = 0; i < step; i++)`.
	    let i = size | 0;
	    while (i--) {
	      // `| 0` is more compact and faster than `Math.floor()`.
	      id += alphabet[(Math.random() * alphabet.length) | 0];
	    }
	    return id
	  }
	};

	let nanoid = (size = 21) => {
	  let id = '';
	  // A compact alternative for `for (var i = 0; i < step; i++)`.
	  let i = size | 0;
	  while (i--) {
	    // `| 0` is more compact and faster than `Math.floor()`.
	    id += urlAlphabet[(Math.random() * 64) | 0];
	  }
	  return id
	};

	nonSecure = { nanoid, customAlphabet };
	return nonSecure;
}

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	base64.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};
	return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64Vlq;

function requireBase64Vlq () {
	if (hasRequiredBase64Vlq) return base64Vlq;
	hasRequiredBase64Vlq = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = requireBase64();

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	base64Vlq.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq;
}

var util = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports$1) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports$1.getArg = getArg;

		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;

		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports$1.urlParse = urlParse;

		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports$1.urlGenerate = urlGenerate;

		var MAX_CACHED_INPUTS = 32;

		/**
		 * Takes some function `f(input) -> result` and returns a memoized version of
		 * `f`.
		 *
		 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
		 * memoization is a dumb-simple, linear least-recently-used cache.
		 */
		function lruMemoize(f) {
		  var cache = [];

		  return function(input) {
		    for (var i = 0; i < cache.length; i++) {
		      if (cache[i].input === input) {
		        var temp = cache[0];
		        cache[0] = cache[i];
		        cache[i] = temp;
		        return cache[0].result;
		      }
		    }

		    var result = f(input);

		    cache.unshift({
		      input,
		      result,
		    });

		    if (cache.length > MAX_CACHED_INPUTS) {
		      cache.pop();
		    }

		    return result;
		  };
		}

		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		var normalize = lruMemoize(function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports$1.isAbsolute(path);
		  // Split the path into parts between `/` characters. This is much faster than
		  // using `.split(/\/+/g)`.
		  var parts = [];
		  var start = 0;
		  var i = 0;
		  while (true) {
		    start = i;
		    i = path.indexOf("/", start);
		    if (i === -1) {
		      parts.push(path.slice(start));
		      break;
		    } else {
		      parts.push(path.slice(start, i));
		      while (i < path.length && path[i] === "/") {
		        i++;
		      }
		    }
		  }

		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');

		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }

		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		});
		exports$1.normalize = normalize;

		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }

		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }

		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }

		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }

		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports$1.join = join;

		exports$1.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};

		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }

		  aRoot = aRoot.replace(/\/$/, '');

		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }

		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }

		    ++level;
		  }

		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports$1.relative = relative;

		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());

		function identity (s) {
		  return s;
		}

		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }

		  return aStr;
		}
		exports$1.toSetString = supportsNullProto ? identity : toSetString;

		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }

		  return aStr;
		}
		exports$1.fromSetString = supportsNullProto ? identity : fromSetString;

		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }

		  var length = s.length;

		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }

		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }

		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }

		  return true;
		}

		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByOriginalPositions = compareByOriginalPositions;

		function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp;

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;

		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

		function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;

		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }

		  if (aStr1 === null) {
		    return 1; // aStr2 !== null
		  }

		  if (aStr2 === null) {
		    return -1; // aStr1 !== null
		  }

		  if (aStr1 > aStr2) {
		    return 1;
		  }

		  return -1;
		}

		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

		/**
		 * Strip any JSON XSSI avoidance prefix from the string (as documented
		 * in the source maps specification), and then parse the string as
		 * JSON.
		 */
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports$1.parseSourceMapInput = parseSourceMapInput;

		/**
		 * Compute the URL of a source given the the source root, the source's
		 * URL, and the source map's URL.
		 */
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';

		  if (sourceRoot) {
		    // This follows what Chrome does.
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    // The spec says:
		    //   Line 4: An optional source root, useful for relocating source
		    //   files on a server or removing repeated values in the
		    //   “sources” entry.  This value is prepended to the individual
		    //   entries in the “source” field.
		    sourceURL = sourceRoot + sourceURL;
		  }

		  // Historically, SourceMapConsumer did not take the sourceMapURL as
		  // a parameter.  This mode is still somewhat supported, which is why
		  // this code block is conditional.  However, it's preferable to pass
		  // the source map URL to SourceMapConsumer, so that this function
		  // can implement the source URL resolution algorithm as outlined in
		  // the spec.  This block is basically the equivalent of:
		  //    new URL(sourceURL, sourceMapURL).toString()
		  // ... except it avoids using URL, which wasn't available in the
		  // older releases of node still supported by this library.
		  //
		  // The spec says:
		  //   If the sources are not absolute URLs after prepending of the
		  //   “sourceRoot”, the sources are resolved relative to the
		  //   SourceMap (like resolving script src in a html document).
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      // Strip the last path component, but keep the "/".
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }

		  return normalize(sourceURL);
		}
		exports$1.computeSourceURL = computeSourceURL; 
	} (util));
	return util;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredArraySet;

function requireArraySet () {
	if (hasRequiredArraySet) return arraySet;
	hasRequiredArraySet = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	arraySet.ArraySet = ArraySet;
	return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredMappingList;

function requireMappingList () {
	if (hasRequiredMappingList) return mappingList;
	hasRequiredMappingList = 1;
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	mappingList.MappingList = MappingList;
	return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapGenerator;

function requireSourceMapGenerator () {
	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	hasRequiredSourceMapGenerator = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = requireBase64Vlq();
	var util = requireUtil();
	var ArraySet = requireArraySet().ArraySet;
	var MappingList = requireMappingList().MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    }));
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      if (this._validateMapping(generated, original, source, name) === false) {
	        return;
	      }
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	      var message = 'original.line and original.column are not numbers -- you probably meant to omit ' +
	      'the original mapping entirely and only map the generated position. If so, pass ' +
	      'null for the original mapping instead of an object with empty or null values.';

	      if (this._ignoreInvalidMapping) {
	        if (typeof console !== 'undefined' && console.warn) {
	          console.warn(message);
	        }
	        return false;
	      } else {
	        throw new Error(message);
	      }
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      var message = 'Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      });

	      if (this._ignoreInvalidMapping) {
	        if (typeof console !== 'undefined' && console.warn) {
	          console.warn(message);
	        }
	        return false;
	      } else {
	        throw new Error(message)
	      }
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBinarySearch;

function requireBinarySearch () {
	if (hasRequiredBinarySearch) return binarySearch;
	hasRequiredBinarySearch = 1;
	(function (exports$1) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		exports$1.GREATEST_LOWER_BOUND = 1;
		exports$1.LEAST_UPPER_BOUND = 2;

		/**
		 * Recursive implementation of binary search.
		 *
		 * @param aLow Indices here and lower do not contain the needle.
		 * @param aHigh Indices here and higher do not contain the needle.
		 * @param aNeedle The element being searched for.
		 * @param aHaystack The non-empty array being searched.
		 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 */
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		  // This function terminates when one of the following is true:
		  //
		  //   1. We find the exact element we are looking for.
		  //
		  //   2. We did not find the exact element, but we can return the index of
		  //      the next-closest element.
		  //
		  //   3. We did not find the exact element, and there is no next-closest
		  //      element than the one we are searching for, so we return -1.
		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
		  if (cmp === 0) {
		    // Found the element we are looking for.
		    return mid;
		  }
		  else if (cmp > 0) {
		    // Our needle is greater than aHaystack[mid].
		    if (aHigh - mid > 1) {
		      // The element is in the upper half.
		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // The exact needle element was not found in this haystack. Determine if
		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports$1.LEAST_UPPER_BOUND) {
		      return aHigh < aHaystack.length ? aHigh : -1;
		    } else {
		      return mid;
		    }
		  }
		  else {
		    // Our needle is less than aHaystack[mid].
		    if (mid - aLow > 1) {
		      // The element is in the lower half.
		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports$1.LEAST_UPPER_BOUND) {
		      return mid;
		    } else {
		      return aLow < 0 ? -1 : aLow;
		    }
		  }
		}

		/**
		 * This is an implementation of binary search which will always try and return
		 * the index of the closest element if there is no exact hit. This is because
		 * mappings between original and generated line/col pairs are single points,
		 * and there is an implicit region between each of them, so a miss just means
		 * that you aren't on the very start of a region.
		 *
		 * @param aNeedle The element you are looking for.
		 * @param aHaystack The array that is being searched.
		 * @param aCompare A function which takes the needle and an element in the
		 *     array and returns -1, 0, or 1 depending on whether the needle is less
		 *     than, equal to, or greater than the element, respectively.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
		 */
		exports$1.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		  if (aHaystack.length === 0) {
		    return -1;
		  }

		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
		                              aCompare, aBias || exports$1.GREATEST_LOWER_BOUND);
		  if (index < 0) {
		    return -1;
		  }

		  // We have found either the exact element, or the next-closest element than
		  // the one we are searching for. However, there may be more than one such
		  // element. Make sure we always return the smallest of these.
		  while (index - 1 >= 0) {
		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
		      break;
		    }
		    --index;
		  }

		  return index;
		}; 
	} (binarySearch));
	return binarySearch;
}

var quickSort = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredQuickSort;

function requireQuickSort () {
	if (hasRequiredQuickSort) return quickSort;
	hasRequiredQuickSort = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	function SortTemplate(comparator) {

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot, false) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	  return doQuickSort;
	}

	function cloneSort(comparator) {
	  let template = SortTemplate.toString();
	  let templateFn = new Function(`return ${template}`)();
	  return templateFn(comparator);
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */

	let sortCache = new WeakMap();
	quickSort.quickSort = function (ary, comparator, start = 0) {
	  let doQuickSort = sortCache.get(comparator);
	  if (doQuickSort === void 0) {
	    doQuickSort = cloneSort(comparator);
	    sortCache.set(comparator, doQuickSort);
	  }
	  doQuickSort(ary, comparator, start, ary.length - 1);
	};
	return quickSort;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapConsumer;

function requireSourceMapConsumer () {
	if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
	hasRequiredSourceMapConsumer = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var binarySearch = requireBinarySearch();
	var ArraySet = requireArraySet().ArraySet;
	var base64VLQ = requireBase64Vlq();
	var quickSort = requireQuickSort().quickSort;

	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    var boundCallback = aCallback.bind(context);
	    var names = this._names;
	    var sources = this._sources;
	    var sourceMapURL = this._sourceMapURL;

	    for (var i = 0, n = mappings.length; i < n; i++) {
	      var mapping = mappings[i];
	      var source = mapping.source === null ? null : sources.at(mapping.source);
	      if(source !== null) {
	        source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
	      }
	      boundCallback({
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : names.at(mapping.name)
	      });
	    }
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number is 1-based.
	 *   - column: Optional. the column number in the original source.
	 *    The column number is 0-based.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *    line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *    The column number is 0-based.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The first parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);

	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Utility function to find the index of a source.  Returns -1 if not
	 * found.
	 */
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }

	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }

	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @param String aSourceMapURL
	 *        The URL at which the source map can be found (optional)
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */

	const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
	function sortGenerated(array, start) {
	  let l = array.length;
	  let n = array.length - start;
	  if (n <= 1) {
	    return;
	  } else if (n == 2) {
	    let a = array[start];
	    let b = array[start + 1];
	    if (compareGenerated(a, b) > 0) {
	      array[start] = b;
	      array[start + 1] = a;
	    }
	  } else if (n < 20) {
	    for (let i = start; i < l; i++) {
	      for (let j = i; j > start; j--) {
	        let a = array[j - 1];
	        let b = array[j];
	        if (compareGenerated(a, b) <= 0) {
	          break;
	        }
	        array[j - 1] = b;
	        array[j] = a;
	      }
	    }
	  } else {
	    quickSort(array, compareGenerated, start);
	  }
	}
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, segment, end, value;

	    let subarrayStart = 0;
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;

	        sortGenerated(generatedMappings, subarrayStart);
	        subarrayStart = generatedMappings.length;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        aStr.slice(index, end);

	        segment = [];
	        while (index < end) {
	          base64VLQ.decode(aStr, index, temp);
	          value = temp.value;
	          index = temp.rest;
	          segment.push(value);
	        }

	        if (segment.length === 2) {
	          throw new Error('Found a source, but no line and column');
	        }

	        if (segment.length === 3) {
	          throw new Error('Found a source and line, but no column');
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          let currentSource = mapping.source;
	          while (originalMappings.length <= currentSource) {
	            originalMappings.push(null);
	          }
	          if (originalMappings[currentSource] === null) {
	            originalMappings[currentSource] = [];
	          }
	          originalMappings[currentSource].push(mapping);
	        }
	      }
	    }

	    sortGenerated(generatedMappings, subarrayStart);
	    this.__generatedMappings = generatedMappings;

	    for (var i = 0; i < originalMappings.length; i++) {
	      if (originalMappings[i] != null) {
	        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
	      }
	    }
	    this.__originalMappings = [].concat(...originalMappings);
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }

	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The first parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content || content === '') {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based. 
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if(source !== null) {
	          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };

	sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	return sourceMapConsumer;
}

var sourceNode = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceNode;

function requireSourceNode () {
	if (hasRequiredSourceNode) return sourceNode;
	hasRequiredSourceNode = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	var util = requireUtil();

	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	sourceNode.SourceNode = SourceNode;
	return sourceNode;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMap;

function requireSourceMap () {
	if (hasRequiredSourceMap) return sourceMap;
	hasRequiredSourceMap = 1;
	sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
	sourceMap.SourceNode = requireSourceNode().SourceNode;
	return sourceMap;
}

var previousMap;
var hasRequiredPreviousMap;

function requirePreviousMap () {
	if (hasRequiredPreviousMap) return previousMap;
	hasRequiredPreviousMap = 1;

	let { existsSync, readFileSync } = require$$0$4;
	let { dirname, join } = require$$0$2$1;
	let { SourceMapConsumer, SourceMapGenerator } = requireSourceMap();

	function fromBase64(str) {
	  if (Buffer) {
	    return Buffer.from(str, 'base64').toString()
	  } else {
	    /* c8 ignore next 2 */
	    return window.atob(str)
	  }
	}

	class PreviousMap {
	  constructor(css, opts) {
	    if (opts.map === false) return
	    this.loadAnnotation(css);
	    this.inline = this.startWith(this.annotation, 'data:');

	    let prev = opts.map ? opts.map.prev : undefined;
	    let text = this.loadMap(opts.from, prev);
	    if (!this.mapFile && opts.from) {
	      this.mapFile = opts.from;
	    }
	    if (this.mapFile) this.root = dirname(this.mapFile);
	    if (text) this.text = text;
	  }

	  consumer() {
	    if (!this.consumerCache) {
	      this.consumerCache = new SourceMapConsumer(this.text);
	    }
	    return this.consumerCache
	  }

	  decodeInline(text) {
	    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
	    let baseUri = /^data:application\/json;base64,/;
	    let charsetUri = /^data:application\/json;charset=utf-?8,/;
	    let uri = /^data:application\/json,/;

	    let uriMatch = text.match(charsetUri) || text.match(uri);
	    if (uriMatch) {
	      return decodeURIComponent(text.substr(uriMatch[0].length))
	    }

	    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);
	    if (baseUriMatch) {
	      return fromBase64(text.substr(baseUriMatch[0].length))
	    }

	    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
	    throw new Error('Unsupported source map encoding ' + encoding)
	  }

	  getAnnotationURL(sourceMapString) {
	    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
	  }

	  isMap(map) {
	    if (typeof map !== 'object') return false
	    return (
	      typeof map.mappings === 'string' ||
	      typeof map._mappings === 'string' ||
	      Array.isArray(map.sections)
	    )
	  }

	  loadAnnotation(css) {
	    let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
	    if (!comments) return

	    // sourceMappingURLs from comments, strings, etc.
	    let start = css.lastIndexOf(comments.pop());
	    let end = css.indexOf('*/', start);

	    if (start > -1 && end > -1) {
	      // Locate the last sourceMappingURL to avoid pickin
	      this.annotation = this.getAnnotationURL(css.substring(start, end));
	    }
	  }

	  loadFile(path) {
	    this.root = dirname(path);
	    if (existsSync(path)) {
	      this.mapFile = path;
	      return readFileSync(path, 'utf-8').toString().trim()
	    }
	  }

	  loadMap(file, prev) {
	    if (prev === false) return false

	    if (prev) {
	      if (typeof prev === 'string') {
	        return prev
	      } else if (typeof prev === 'function') {
	        let prevPath = prev(file);
	        if (prevPath) {
	          let map = this.loadFile(prevPath);
	          if (!map) {
	            throw new Error(
	              'Unable to load previous source map: ' + prevPath.toString()
	            )
	          }
	          return map
	        }
	      } else if (prev instanceof SourceMapConsumer) {
	        return SourceMapGenerator.fromSourceMap(prev).toString()
	      } else if (prev instanceof SourceMapGenerator) {
	        return prev.toString()
	      } else if (this.isMap(prev)) {
	        return JSON.stringify(prev)
	      } else {
	        throw new Error(
	          'Unsupported previous source map format: ' + prev.toString()
	        )
	      }
	    } else if (this.inline) {
	      return this.decodeInline(this.annotation)
	    } else if (this.annotation) {
	      let map = this.annotation;
	      if (file) map = join(dirname(file), map);
	      return this.loadFile(map)
	    }
	  }

	  startWith(string, start) {
	    if (!string) return false
	    return string.substr(0, start.length) === start
	  }

	  withContent() {
	    return !!(
	      this.consumer().sourcesContent &&
	      this.consumer().sourcesContent.length > 0
	    )
	  }
	}

	previousMap = PreviousMap;
	PreviousMap.default = PreviousMap;
	return previousMap;
}

var input;
var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input;
	hasRequiredInput = 1;

	let { nanoid } = /*@__PURE__*/ requireNonSecure();
	let { isAbsolute, resolve } = require$$0$2$1;
	let { SourceMapConsumer, SourceMapGenerator } = requireSourceMap();
	let { fileURLToPath, pathToFileURL } = require$$0$5;

	let CssSyntaxError = requireCssSyntaxError();
	let PreviousMap = requirePreviousMap();
	let terminalHighlight = requireTerminalHighlight();

	let lineToIndexCache = Symbol('lineToIndexCache');

	let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	let pathAvailable = Boolean(resolve && isAbsolute);

	function getLineToIndex(input) {
	  if (input[lineToIndexCache]) return input[lineToIndexCache]
	  let lines = input.css.split('\n');
	  let lineToIndex = new Array(lines.length);
	  let prevIndex = 0;

	  for (let i = 0, l = lines.length; i < l; i++) {
	    lineToIndex[i] = prevIndex;
	    prevIndex += lines[i].length + 1;
	  }

	  input[lineToIndexCache] = lineToIndex;
	  return lineToIndex
	}

	class Input {
	  get from() {
	    return this.file || this.id
	  }

	  constructor(css, opts = {}) {
	    if (
	      css === null ||
	      typeof css === 'undefined' ||
	      (typeof css === 'object' && !css.toString)
	    ) {
	      throw new Error(`PostCSS received ${css} instead of CSS string`)
	    }

	    this.css = css.toString();

	    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
	      this.hasBOM = true;
	      this.css = this.css.slice(1);
	    } else {
	      this.hasBOM = false;
	    }

	    this.document = this.css;
	    if (opts.document) this.document = opts.document.toString();

	    if (opts.from) {
	      if (
	        !pathAvailable ||
	        /^\w+:\/\//.test(opts.from) ||
	        isAbsolute(opts.from)
	      ) {
	        this.file = opts.from;
	      } else {
	        this.file = resolve(opts.from);
	      }
	    }

	    if (pathAvailable && sourceMapAvailable) {
	      let map = new PreviousMap(this.css, opts);
	      if (map.text) {
	        this.map = map;
	        let file = map.consumer().file;
	        if (!this.file && file) this.file = this.mapResolve(file);
	      }
	    }

	    if (!this.file) {
	      this.id = '<input css ' + nanoid(6) + '>';
	    }
	    if (this.map) this.map.file = this.from;
	  }

	  error(message, line, column, opts = {}) {
	    let endColumn, endLine, endOffset, offset, result;

	    if (line && typeof line === 'object') {
	      let start = line;
	      let end = column;
	      if (typeof start.offset === 'number') {
	        offset = start.offset;
	        let pos = this.fromOffset(offset);
	        line = pos.line;
	        column = pos.col;
	      } else {
	        line = start.line;
	        column = start.column;
	        offset = this.fromLineAndColumn(line, column);
	      }
	      if (typeof end.offset === 'number') {
	        endOffset = end.offset;
	        let pos = this.fromOffset(endOffset);
	        endLine = pos.line;
	        endColumn = pos.col;
	      } else {
	        endLine = end.line;
	        endColumn = end.column;
	        endOffset = this.fromLineAndColumn(end.line, end.column);
	      }
	    } else if (!column) {
	      offset = line;
	      let pos = this.fromOffset(offset);
	      line = pos.line;
	      column = pos.col;
	    } else {
	      offset = this.fromLineAndColumn(line, column);
	    }

	    let origin = this.origin(line, column, endLine, endColumn);
	    if (origin) {
	      result = new CssSyntaxError(
	        message,
	        origin.endLine === undefined
	          ? origin.line
	          : { column: origin.column, line: origin.line },
	        origin.endLine === undefined
	          ? origin.column
	          : { column: origin.endColumn, line: origin.endLine },
	        origin.source,
	        origin.file,
	        opts.plugin
	      );
	    } else {
	      result = new CssSyntaxError(
	        message,
	        endLine === undefined ? line : { column, line },
	        endLine === undefined ? column : { column: endColumn, line: endLine },
	        this.css,
	        this.file,
	        opts.plugin
	      );
	    }

	    result.input = { column, endColumn, endLine, endOffset, line, offset, source: this.css };
	    if (this.file) {
	      if (pathToFileURL) {
	        result.input.url = pathToFileURL(this.file).toString();
	      }
	      result.input.file = this.file;
	    }

	    return result
	  }

	  fromLineAndColumn(line, column) {
	    let lineToIndex = getLineToIndex(this);
	    let index = lineToIndex[line - 1];
	    return index + column - 1
	  }

	  fromOffset(offset) {
	    let lineToIndex = getLineToIndex(this);
	    let lastLine = lineToIndex[lineToIndex.length - 1];

	    let min = 0;
	    if (offset >= lastLine) {
	      min = lineToIndex.length - 1;
	    } else {
	      let max = lineToIndex.length - 2;
	      let mid;
	      while (min < max) {
	        mid = min + ((max - min) >> 1);
	        if (offset < lineToIndex[mid]) {
	          max = mid - 1;
	        } else if (offset >= lineToIndex[mid + 1]) {
	          min = mid + 1;
	        } else {
	          min = mid;
	          break
	        }
	      }
	    }
	    return {
	      col: offset - lineToIndex[min] + 1,
	      line: min + 1
	    }
	  }

	  mapResolve(file) {
	    if (/^\w+:\/\//.test(file)) {
	      return file
	    }
	    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
	  }

	  origin(line, column, endLine, endColumn) {
	    if (!this.map) return false
	    let consumer = this.map.consumer();

	    let from = consumer.originalPositionFor({ column, line });
	    if (!from.source) return false

	    let to;
	    if (typeof endLine === 'number') {
	      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
	    }

	    let fromUrl;

	    if (isAbsolute(from.source)) {
	      fromUrl = pathToFileURL(from.source);
	    } else {
	      fromUrl = new URL(
	        from.source,
	        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
	      );
	    }

	    let result = {
	      column: from.column,
	      endColumn: to && to.column,
	      endLine: to && to.line,
	      line: from.line,
	      url: fromUrl.toString()
	    };

	    if (fromUrl.protocol === 'file:') {
	      if (fileURLToPath) {
	        result.file = fileURLToPath(fromUrl);
	      } else {
	        /* c8 ignore next 2 */
	        throw new Error(`file: protocol is not available in this PostCSS build`)
	      }
	    }

	    let source = consumer.sourceContentFor(from.source);
	    if (source) result.source = source;

	    return result
	  }

	  toJSON() {
	    let json = {};
	    for (let name of ['hasBOM', 'css', 'file', 'id']) {
	      if (this[name] != null) {
	        json[name] = this[name];
	      }
	    }
	    if (this.map) {
	      json.map = { ...this.map };
	      if (json.map.consumerCache) {
	        json.map.consumerCache = undefined;
	      }
	    }
	    return json
	  }
	}

	input = Input;
	Input.default = Input;

	if (terminalHighlight && terminalHighlight.registerInput) {
	  terminalHighlight.registerInput(Input);
	}
	return input;
}

var root;
var hasRequiredRoot;

function requireRoot () {
	if (hasRequiredRoot) return root;
	hasRequiredRoot = 1;

	let Container = requireContainer();

	let LazyResult, Processor;

	class Root extends Container {
	  constructor(defaults) {
	    super(defaults);
	    this.type = 'root';
	    if (!this.nodes) this.nodes = [];
	  }

	  normalize(child, sample, type) {
	    let nodes = super.normalize(child);

	    if (sample) {
	      if (type === 'prepend') {
	        if (this.nodes.length > 1) {
	          sample.raws.before = this.nodes[1].raws.before;
	        } else {
	          delete sample.raws.before;
	        }
	      } else if (this.first !== sample) {
	        for (let node of nodes) {
	          node.raws.before = sample.raws.before;
	        }
	      }
	    }

	    return nodes
	  }

	  removeChild(child, ignore) {
	    let index = this.index(child);

	    if (!ignore && index === 0 && this.nodes.length > 1) {
	      this.nodes[1].raws.before = this.nodes[index].raws.before;
	    }

	    return super.removeChild(child)
	  }

	  toResult(opts = {}) {
	    let lazy = new LazyResult(new Processor(), this, opts);
	    return lazy.stringify()
	  }
	}

	Root.registerLazyResult = dependant => {
	  LazyResult = dependant;
	};

	Root.registerProcessor = dependant => {
	  Processor = dependant;
	};

	root = Root;
	Root.default = Root;

	Container.registerRoot(Root);
	return root;
}

var list_1;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return list_1;
	hasRequiredList = 1;

	let list = {
	  comma(string) {
	    return list.split(string, [','], true)
	  },

	  space(string) {
	    let spaces = [' ', '\n', '\t'];
	    return list.split(string, spaces)
	  },

	  split(string, separators, last) {
	    let array = [];
	    let current = '';
	    let split = false;

	    let func = 0;
	    let inQuote = false;
	    let prevQuote = '';
	    let escape = false;

	    for (let letter of string) {
	      if (escape) {
	        escape = false;
	      } else if (letter === '\\') {
	        escape = true;
	      } else if (inQuote) {
	        if (letter === prevQuote) {
	          inQuote = false;
	        }
	      } else if (letter === '"' || letter === "'") {
	        inQuote = true;
	        prevQuote = letter;
	      } else if (letter === '(') {
	        func += 1;
	      } else if (letter === ')') {
	        if (func > 0) func -= 1;
	      } else if (func === 0) {
	        if (separators.includes(letter)) split = true;
	      }

	      if (split) {
	        if (current !== '') array.push(current.trim());
	        current = '';
	        split = false;
	      } else {
	        current += letter;
	      }
	    }

	    if (last || current !== '') array.push(current.trim());
	    return array
	  }
	};

	list_1 = list;
	list.default = list;
	return list_1;
}

var rule;
var hasRequiredRule;

function requireRule () {
	if (hasRequiredRule) return rule;
	hasRequiredRule = 1;

	let Container = requireContainer();
	let list = requireList();

	class Rule extends Container {
	  get selectors() {
	    return list.comma(this.selector)
	  }

	  set selectors(values) {
	    let match = this.selector ? this.selector.match(/,\s*/) : null;
	    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
	    this.selector = values.join(sep);
	  }

	  constructor(defaults) {
	    super(defaults);
	    this.type = 'rule';
	    if (!this.nodes) this.nodes = [];
	  }
	}

	rule = Rule;
	Rule.default = Rule;

	Container.registerRule(Rule);
	return rule;
}

var fromJSON_1;
var hasRequiredFromJSON;

function requireFromJSON () {
	if (hasRequiredFromJSON) return fromJSON_1;
	hasRequiredFromJSON = 1;

	let AtRule = requireAtRule$1();
	let Comment = requireComment();
	let Declaration = requireDeclaration$1();
	let Input = requireInput();
	let PreviousMap = requirePreviousMap();
	let Root = requireRoot();
	let Rule = requireRule();

	function fromJSON(json, inputs) {
	  if (Array.isArray(json)) return json.map(n => fromJSON(n))

	  let { inputs: ownInputs, ...defaults } = json;
	  if (ownInputs) {
	    inputs = [];
	    for (let input of ownInputs) {
	      let inputHydrated = { ...input, __proto__: Input.prototype };
	      if (inputHydrated.map) {
	        inputHydrated.map = {
	          ...inputHydrated.map,
	          __proto__: PreviousMap.prototype
	        };
	      }
	      inputs.push(inputHydrated);
	    }
	  }
	  if (defaults.nodes) {
	    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));
	  }
	  if (defaults.source) {
	    let { inputId, ...source } = defaults.source;
	    defaults.source = source;
	    if (inputId != null) {
	      defaults.source.input = inputs[inputId];
	    }
	  }
	  if (defaults.type === 'root') {
	    return new Root(defaults)
	  } else if (defaults.type === 'decl') {
	    return new Declaration(defaults)
	  } else if (defaults.type === 'rule') {
	    return new Rule(defaults)
	  } else if (defaults.type === 'comment') {
	    return new Comment(defaults)
	  } else if (defaults.type === 'atrule') {
	    return new AtRule(defaults)
	  } else {
	    throw new Error('Unknown node type: ' + json.type)
	  }
	}

	fromJSON_1 = fromJSON;
	fromJSON.default = fromJSON;
	return fromJSON_1;
}

var mapGenerator;
var hasRequiredMapGenerator;

function requireMapGenerator () {
	if (hasRequiredMapGenerator) return mapGenerator;
	hasRequiredMapGenerator = 1;

	let { dirname, relative, resolve, sep } = require$$0$2$1;
	let { SourceMapConsumer, SourceMapGenerator } = requireSourceMap();
	let { pathToFileURL } = require$$0$5;

	let Input = requireInput();

	let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	let pathAvailable = Boolean(dirname && resolve && relative && sep);

	class MapGenerator {
	  constructor(stringify, root, opts, cssString) {
	    this.stringify = stringify;
	    this.mapOpts = opts.map || {};
	    this.root = root;
	    this.opts = opts;
	    this.css = cssString;
	    this.originalCSS = cssString;
	    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;

	    this.memoizedFileURLs = new Map();
	    this.memoizedPaths = new Map();
	    this.memoizedURLs = new Map();
	  }

	  addAnnotation() {
	    let content;

	    if (this.isInline()) {
	      content =
	        'data:application/json;base64,' + this.toBase64(this.map.toString());
	    } else if (typeof this.mapOpts.annotation === 'string') {
	      content = this.mapOpts.annotation;
	    } else if (typeof this.mapOpts.annotation === 'function') {
	      content = this.mapOpts.annotation(this.opts.to, this.root);
	    } else {
	      content = this.outputFile() + '.map';
	    }
	    let eol = '\n';
	    if (this.css.includes('\r\n')) eol = '\r\n';

	    this.css += eol + '/*# sourceMappingURL=' + content + ' */';
	  }

	  applyPrevMaps() {
	    for (let prev of this.previous()) {
	      let from = this.toUrl(this.path(prev.file));
	      let root = prev.root || dirname(prev.file);
	      let map;

	      if (this.mapOpts.sourcesContent === false) {
	        map = new SourceMapConsumer(prev.text);
	        if (map.sourcesContent) {
	          map.sourcesContent = null;
	        }
	      } else {
	        map = prev.consumer();
	      }

	      this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
	    }
	  }

	  clearAnnotation() {
	    if (this.mapOpts.annotation === false) return

	    if (this.root) {
	      let node;
	      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
	        node = this.root.nodes[i];
	        if (node.type !== 'comment') continue
	        if (node.text.startsWith('# sourceMappingURL=')) {
	          this.root.removeChild(i);
	        }
	      }
	    } else if (this.css) {
	      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, '');
	    }
	  }

	  generate() {
	    this.clearAnnotation();
	    if (pathAvailable && sourceMapAvailable && this.isMap()) {
	      return this.generateMap()
	    } else {
	      let result = '';
	      this.stringify(this.root, i => {
	        result += i;
	      });
	      return [result]
	    }
	  }

	  generateMap() {
	    if (this.root) {
	      this.generateString();
	    } else if (this.previous().length === 1) {
	      let prev = this.previous()[0].consumer();
	      prev.file = this.outputFile();
	      this.map = SourceMapGenerator.fromSourceMap(prev, {
	        ignoreInvalidMapping: true
	      });
	    } else {
	      this.map = new SourceMapGenerator({
	        file: this.outputFile(),
	        ignoreInvalidMapping: true
	      });
	      this.map.addMapping({
	        generated: { column: 0, line: 1 },
	        original: { column: 0, line: 1 },
	        source: this.opts.from
	          ? this.toUrl(this.path(this.opts.from))
	          : '<no source>'
	      });
	    }

	    if (this.isSourcesContent()) this.setSourcesContent();
	    if (this.root && this.previous().length > 0) this.applyPrevMaps();
	    if (this.isAnnotation()) this.addAnnotation();

	    if (this.isInline()) {
	      return [this.css]
	    } else {
	      return [this.css, this.map]
	    }
	  }

	  generateString() {
	    this.css = '';
	    this.map = new SourceMapGenerator({
	      file: this.outputFile(),
	      ignoreInvalidMapping: true
	    });

	    let line = 1;
	    let column = 1;

	    let noSource = '<no source>';
	    let mapping = {
	      generated: { column: 0, line: 0 },
	      original: { column: 0, line: 0 },
	      source: ''
	    };

	    let last, lines;
	    this.stringify(this.root, (str, node, type) => {
	      this.css += str;

	      if (node && type !== 'end') {
	        mapping.generated.line = line;
	        mapping.generated.column = column - 1;
	        if (node.source && node.source.start) {
	          mapping.source = this.sourcePath(node);
	          mapping.original.line = node.source.start.line;
	          mapping.original.column = node.source.start.column - 1;
	          this.map.addMapping(mapping);
	        } else {
	          mapping.source = noSource;
	          mapping.original.line = 1;
	          mapping.original.column = 0;
	          this.map.addMapping(mapping);
	        }
	      }

	      lines = str.match(/\n/g);
	      if (lines) {
	        line += lines.length;
	        last = str.lastIndexOf('\n');
	        column = str.length - last;
	      } else {
	        column += str.length;
	      }

	      if (node && type !== 'start') {
	        let p = node.parent || { raws: {} };
	        let childless =
	          node.type === 'decl' || (node.type === 'atrule' && !node.nodes);
	        if (!childless || node !== p.last || p.raws.semicolon) {
	          if (node.source && node.source.end) {
	            mapping.source = this.sourcePath(node);
	            mapping.original.line = node.source.end.line;
	            mapping.original.column = node.source.end.column - 1;
	            mapping.generated.line = line;
	            mapping.generated.column = column - 2;
	            this.map.addMapping(mapping);
	          } else {
	            mapping.source = noSource;
	            mapping.original.line = 1;
	            mapping.original.column = 0;
	            mapping.generated.line = line;
	            mapping.generated.column = column - 1;
	            this.map.addMapping(mapping);
	          }
	        }
	      }
	    });
	  }

	  isAnnotation() {
	    if (this.isInline()) {
	      return true
	    }
	    if (typeof this.mapOpts.annotation !== 'undefined') {
	      return this.mapOpts.annotation
	    }
	    if (this.previous().length) {
	      return this.previous().some(i => i.annotation)
	    }
	    return true
	  }

	  isInline() {
	    if (typeof this.mapOpts.inline !== 'undefined') {
	      return this.mapOpts.inline
	    }

	    let annotation = this.mapOpts.annotation;
	    if (typeof annotation !== 'undefined' && annotation !== true) {
	      return false
	    }

	    if (this.previous().length) {
	      return this.previous().some(i => i.inline)
	    }
	    return true
	  }

	  isMap() {
	    if (typeof this.opts.map !== 'undefined') {
	      return !!this.opts.map
	    }
	    return this.previous().length > 0
	  }

	  isSourcesContent() {
	    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
	      return this.mapOpts.sourcesContent
	    }
	    if (this.previous().length) {
	      return this.previous().some(i => i.withContent())
	    }
	    return true
	  }

	  outputFile() {
	    if (this.opts.to) {
	      return this.path(this.opts.to)
	    } else if (this.opts.from) {
	      return this.path(this.opts.from)
	    } else {
	      return 'to.css'
	    }
	  }

	  path(file) {
	    if (this.mapOpts.absolute) return file
	    if (file.charCodeAt(0) === 60 /* `<` */) return file
	    if (/^\w+:\/\//.test(file)) return file
	    let cached = this.memoizedPaths.get(file);
	    if (cached) return cached

	    let from = this.opts.to ? dirname(this.opts.to) : '.';

	    if (typeof this.mapOpts.annotation === 'string') {
	      from = dirname(resolve(from, this.mapOpts.annotation));
	    }

	    let path = relative(from, file);
	    this.memoizedPaths.set(file, path);

	    return path
	  }

	  previous() {
	    if (!this.previousMaps) {
	      this.previousMaps = [];
	      if (this.root) {
	        this.root.walk(node => {
	          if (node.source && node.source.input.map) {
	            let map = node.source.input.map;
	            if (!this.previousMaps.includes(map)) {
	              this.previousMaps.push(map);
	            }
	          }
	        });
	      } else {
	        let input = new Input(this.originalCSS, this.opts);
	        if (input.map) this.previousMaps.push(input.map);
	      }
	    }

	    return this.previousMaps
	  }

	  setSourcesContent() {
	    let already = {};
	    if (this.root) {
	      this.root.walk(node => {
	        if (node.source) {
	          let from = node.source.input.from;
	          if (from && !already[from]) {
	            already[from] = true;
	            let fromUrl = this.usesFileUrls
	              ? this.toFileUrl(from)
	              : this.toUrl(this.path(from));
	            this.map.setSourceContent(fromUrl, node.source.input.css);
	          }
	        }
	      });
	    } else if (this.css) {
	      let from = this.opts.from
	        ? this.toUrl(this.path(this.opts.from))
	        : '<no source>';
	      this.map.setSourceContent(from, this.css);
	    }
	  }

	  sourcePath(node) {
	    if (this.mapOpts.from) {
	      return this.toUrl(this.mapOpts.from)
	    } else if (this.usesFileUrls) {
	      return this.toFileUrl(node.source.input.from)
	    } else {
	      return this.toUrl(this.path(node.source.input.from))
	    }
	  }

	  toBase64(str) {
	    if (Buffer) {
	      return Buffer.from(str).toString('base64')
	    } else {
	      return window.btoa(unescape(encodeURIComponent(str)))
	    }
	  }

	  toFileUrl(path) {
	    let cached = this.memoizedFileURLs.get(path);
	    if (cached) return cached

	    if (pathToFileURL) {
	      let fileURL = pathToFileURL(path).toString();
	      this.memoizedFileURLs.set(path, fileURL);

	      return fileURL
	    } else {
	      throw new Error(
	        '`map.absolute` option is not available in this PostCSS build'
	      )
	    }
	  }

	  toUrl(path) {
	    let cached = this.memoizedURLs.get(path);
	    if (cached) return cached

	    if (sep === '\\') {
	      path = path.replace(/\\/g, '/');
	    }

	    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
	    this.memoizedURLs.set(path, url);

	    return url
	  }
	}

	mapGenerator = MapGenerator;
	return mapGenerator;
}

var parser;
var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;

	let AtRule = requireAtRule$1();
	let Comment = requireComment();
	let Declaration = requireDeclaration$1();
	let Root = requireRoot();
	let Rule = requireRule();
	let tokenizer = requireTokenize();

	const SAFE_COMMENT_NEIGHBOR = {
	  empty: true,
	  space: true
	};

	function findLastWithPosition(tokens) {
	  for (let i = tokens.length - 1; i >= 0; i--) {
	    let token = tokens[i];
	    let pos = token[3] || token[2];
	    if (pos) return pos
	  }
	}

	class Parser {
	  constructor(input) {
	    this.input = input;

	    this.root = new Root();
	    this.current = this.root;
	    this.spaces = '';
	    this.semicolon = false;

	    this.createTokenizer();
	    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
	  }

	  atrule(token) {
	    let node = new AtRule();
	    node.name = token[1].slice(1);
	    if (node.name === '') {
	      this.unnamedAtrule(node, token);
	    }
	    this.init(node, token[2]);

	    let type;
	    let prev;
	    let shift;
	    let last = false;
	    let open = false;
	    let params = [];
	    let brackets = [];

	    while (!this.tokenizer.endOfFile()) {
	      token = this.tokenizer.nextToken();
	      type = token[0];

	      if (type === '(' || type === '[') {
	        brackets.push(type === '(' ? ')' : ']');
	      } else if (type === '{' && brackets.length > 0) {
	        brackets.push('}');
	      } else if (type === brackets[brackets.length - 1]) {
	        brackets.pop();
	      }

	      if (brackets.length === 0) {
	        if (type === ';') {
	          node.source.end = this.getPosition(token[2]);
	          node.source.end.offset++;
	          this.semicolon = true;
	          break
	        } else if (type === '{') {
	          open = true;
	          break
	        } else if (type === '}') {
	          if (params.length > 0) {
	            shift = params.length - 1;
	            prev = params[shift];
	            while (prev && prev[0] === 'space') {
	              prev = params[--shift];
	            }
	            if (prev) {
	              node.source.end = this.getPosition(prev[3] || prev[2]);
	              node.source.end.offset++;
	            }
	          }
	          this.end(token);
	          break
	        } else {
	          params.push(token);
	        }
	      } else {
	        params.push(token);
	      }

	      if (this.tokenizer.endOfFile()) {
	        last = true;
	        break
	      }
	    }

	    node.raws.between = this.spacesAndCommentsFromEnd(params);
	    if (params.length) {
	      node.raws.afterName = this.spacesAndCommentsFromStart(params);
	      this.raw(node, 'params', params);
	      if (last) {
	        token = params[params.length - 1];
	        node.source.end = this.getPosition(token[3] || token[2]);
	        node.source.end.offset++;
	        this.spaces = node.raws.between;
	        node.raws.between = '';
	      }
	    } else {
	      node.raws.afterName = '';
	      node.params = '';
	    }

	    if (open) {
	      node.nodes = [];
	      this.current = node;
	    }
	  }

	  checkMissedSemicolon(tokens) {
	    let colon = this.colon(tokens);
	    if (colon === false) return

	    let founded = 0;
	    let token;
	    for (let j = colon - 1; j >= 0; j--) {
	      token = tokens[j];
	      if (token[0] !== 'space') {
	        founded += 1;
	        if (founded === 2) break
	      }
	    }
	    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
	    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
	    // And because we need it after that one we do +1 to get the next one.
	    throw this.input.error(
	      'Missed semicolon',
	      token[0] === 'word' ? token[3] + 1 : token[2]
	    )
	  }

	  colon(tokens) {
	    let brackets = 0;
	    let prev, token, type;
	    for (let [i, element] of tokens.entries()) {
	      token = element;
	      type = token[0];

	      if (type === '(') {
	        brackets += 1;
	      }
	      if (type === ')') {
	        brackets -= 1;
	      }
	      if (brackets === 0 && type === ':') {
	        if (!prev) {
	          this.doubleColon(token);
	        } else if (prev[0] === 'word' && prev[1] === 'progid') {
	          continue
	        } else {
	          return i
	        }
	      }

	      prev = token;
	    }
	    return false
	  }

	  comment(token) {
	    let node = new Comment();
	    this.init(node, token[2]);
	    node.source.end = this.getPosition(token[3] || token[2]);
	    node.source.end.offset++;

	    let text = token[1].slice(2, -2);
	    if (/^\s*$/.test(text)) {
	      node.text = '';
	      node.raws.left = text;
	      node.raws.right = '';
	    } else {
	      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
	      node.text = match[2];
	      node.raws.left = match[1];
	      node.raws.right = match[3];
	    }
	  }

	  createTokenizer() {
	    this.tokenizer = tokenizer(this.input);
	  }

	  decl(tokens, customProperty) {
	    let node = new Declaration();
	    this.init(node, tokens[0][2]);

	    let last = tokens[tokens.length - 1];
	    if (last[0] === ';') {
	      this.semicolon = true;
	      tokens.pop();
	    }

	    node.source.end = this.getPosition(
	      last[3] || last[2] || findLastWithPosition(tokens)
	    );
	    node.source.end.offset++;

	    while (tokens[0][0] !== 'word') {
	      if (tokens.length === 1) this.unknownWord(tokens);
	      node.raws.before += tokens.shift()[1];
	    }
	    node.source.start = this.getPosition(tokens[0][2]);

	    node.prop = '';
	    while (tokens.length) {
	      let type = tokens[0][0];
	      if (type === ':' || type === 'space' || type === 'comment') {
	        break
	      }
	      node.prop += tokens.shift()[1];
	    }

	    node.raws.between = '';

	    let token;
	    while (tokens.length) {
	      token = tokens.shift();

	      if (token[0] === ':') {
	        node.raws.between += token[1];
	        break
	      } else {
	        if (token[0] === 'word' && /\w/.test(token[1])) {
	          this.unknownWord([token]);
	        }
	        node.raws.between += token[1];
	      }
	    }

	    if (node.prop[0] === '_' || node.prop[0] === '*') {
	      node.raws.before += node.prop[0];
	      node.prop = node.prop.slice(1);
	    }

	    let firstSpaces = [];
	    let next;
	    while (tokens.length) {
	      next = tokens[0][0];
	      if (next !== 'space' && next !== 'comment') break
	      firstSpaces.push(tokens.shift());
	    }

	    this.precheckMissedSemicolon(tokens);

	    for (let i = tokens.length - 1; i >= 0; i--) {
	      token = tokens[i];
	      if (token[1].toLowerCase() === '!important') {
	        node.important = true;
	        let string = this.stringFrom(tokens, i);
	        string = this.spacesFromEnd(tokens) + string;
	        if (string !== ' !important') node.raws.important = string;
	        break
	      } else if (token[1].toLowerCase() === 'important') {
	        let cache = tokens.slice(0);
	        let str = '';
	        for (let j = i; j > 0; j--) {
	          let type = cache[j][0];
	          if (str.trim().startsWith('!') && type !== 'space') {
	            break
	          }
	          str = cache.pop()[1] + str;
	        }
	        if (str.trim().startsWith('!')) {
	          node.important = true;
	          node.raws.important = str;
	          tokens = cache;
	        }
	      }

	      if (token[0] !== 'space' && token[0] !== 'comment') {
	        break
	      }
	    }

	    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');

	    if (hasWord) {
	      node.raws.between += firstSpaces.map(i => i[1]).join('');
	      firstSpaces = [];
	    }
	    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);

	    if (node.value.includes(':') && !customProperty) {
	      this.checkMissedSemicolon(tokens);
	    }
	  }

	  doubleColon(token) {
	    throw this.input.error(
	      'Double colon',
	      { offset: token[2] },
	      { offset: token[2] + token[1].length }
	    )
	  }

	  emptyRule(token) {
	    let node = new Rule();
	    this.init(node, token[2]);
	    node.selector = '';
	    node.raws.between = '';
	    this.current = node;
	  }

	  end(token) {
	    if (this.current.nodes && this.current.nodes.length) {
	      this.current.raws.semicolon = this.semicolon;
	    }
	    this.semicolon = false;

	    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
	    this.spaces = '';

	    if (this.current.parent) {
	      this.current.source.end = this.getPosition(token[2]);
	      this.current.source.end.offset++;
	      this.current = this.current.parent;
	    } else {
	      this.unexpectedClose(token);
	    }
	  }

	  endFile() {
	    if (this.current.parent) this.unclosedBlock();
	    if (this.current.nodes && this.current.nodes.length) {
	      this.current.raws.semicolon = this.semicolon;
	    }
	    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
	    this.root.source.end = this.getPosition(this.tokenizer.position());
	  }

	  freeSemicolon(token) {
	    this.spaces += token[1];
	    if (this.current.nodes) {
	      let prev = this.current.nodes[this.current.nodes.length - 1];
	      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
	        prev.raws.ownSemicolon = this.spaces;
	        this.spaces = '';
	        prev.source.end = this.getPosition(token[2]);
	        prev.source.end.offset += prev.raws.ownSemicolon.length;
	      }
	    }
	  }

	  // Helpers

	  getPosition(offset) {
	    let pos = this.input.fromOffset(offset);
	    return {
	      column: pos.col,
	      line: pos.line,
	      offset
	    }
	  }

	  init(node, offset) {
	    this.current.push(node);
	    node.source = {
	      input: this.input,
	      start: this.getPosition(offset)
	    };
	    node.raws.before = this.spaces;
	    this.spaces = '';
	    if (node.type !== 'comment') this.semicolon = false;
	  }

	  other(start) {
	    let end = false;
	    let type = null;
	    let colon = false;
	    let bracket = null;
	    let brackets = [];
	    let customProperty = start[1].startsWith('--');

	    let tokens = [];
	    let token = start;
	    while (token) {
	      type = token[0];
	      tokens.push(token);

	      if (type === '(' || type === '[') {
	        if (!bracket) bracket = token;
	        brackets.push(type === '(' ? ')' : ']');
	      } else if (customProperty && colon && type === '{') {
	        if (!bracket) bracket = token;
	        brackets.push('}');
	      } else if (brackets.length === 0) {
	        if (type === ';') {
	          if (colon) {
	            this.decl(tokens, customProperty);
	            return
	          } else {
	            break
	          }
	        } else if (type === '{') {
	          this.rule(tokens);
	          return
	        } else if (type === '}') {
	          this.tokenizer.back(tokens.pop());
	          end = true;
	          break
	        } else if (type === ':') {
	          colon = true;
	        }
	      } else if (type === brackets[brackets.length - 1]) {
	        brackets.pop();
	        if (brackets.length === 0) bracket = null;
	      }

	      token = this.tokenizer.nextToken();
	    }

	    if (this.tokenizer.endOfFile()) end = true;
	    if (brackets.length > 0) this.unclosedBracket(bracket);

	    if (end && colon) {
	      if (!customProperty) {
	        while (tokens.length) {
	          token = tokens[tokens.length - 1][0];
	          if (token !== 'space' && token !== 'comment') break
	          this.tokenizer.back(tokens.pop());
	        }
	      }
	      this.decl(tokens, customProperty);
	    } else {
	      this.unknownWord(tokens);
	    }
	  }

	  parse() {
	    let token;
	    while (!this.tokenizer.endOfFile()) {
	      token = this.tokenizer.nextToken();

	      switch (token[0]) {
	        case 'space':
	          this.spaces += token[1];
	          break

	        case ';':
	          this.freeSemicolon(token);
	          break

	        case '}':
	          this.end(token);
	          break

	        case 'comment':
	          this.comment(token);
	          break

	        case 'at-word':
	          this.atrule(token);
	          break

	        case '{':
	          this.emptyRule(token);
	          break

	        default:
	          this.other(token);
	          break
	      }
	    }
	    this.endFile();
	  }

	  precheckMissedSemicolon(/* tokens */) {
	    // Hook for Safe Parser
	  }

	  raw(node, prop, tokens, customProperty) {
	    let token, type;
	    let length = tokens.length;
	    let value = '';
	    let clean = true;
	    let next, prev;

	    for (let i = 0; i < length; i += 1) {
	      token = tokens[i];
	      type = token[0];
	      if (type === 'space' && i === length - 1 && !customProperty) {
	        clean = false;
	      } else if (type === 'comment') {
	        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';
	        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';
	        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
	          if (value.slice(-1) === ',') {
	            clean = false;
	          } else {
	            value += token[1];
	          }
	        } else {
	          clean = false;
	        }
	      } else {
	        value += token[1];
	      }
	    }
	    if (!clean) {
	      let raw = tokens.reduce((all, i) => all + i[1], '');
	      node.raws[prop] = { raw, value };
	    }
	    node[prop] = value;
	  }

	  rule(tokens) {
	    tokens.pop();

	    let node = new Rule();
	    this.init(node, tokens[0][2]);

	    node.raws.between = this.spacesAndCommentsFromEnd(tokens);
	    this.raw(node, 'selector', tokens);
	    this.current = node;
	  }

	  spacesAndCommentsFromEnd(tokens) {
	    let lastTokenType;
	    let spaces = '';
	    while (tokens.length) {
	      lastTokenType = tokens[tokens.length - 1][0];
	      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
	      spaces = tokens.pop()[1] + spaces;
	    }
	    return spaces
	  }

	  // Errors

	  spacesAndCommentsFromStart(tokens) {
	    let next;
	    let spaces = '';
	    while (tokens.length) {
	      next = tokens[0][0];
	      if (next !== 'space' && next !== 'comment') break
	      spaces += tokens.shift()[1];
	    }
	    return spaces
	  }

	  spacesFromEnd(tokens) {
	    let lastTokenType;
	    let spaces = '';
	    while (tokens.length) {
	      lastTokenType = tokens[tokens.length - 1][0];
	      if (lastTokenType !== 'space') break
	      spaces = tokens.pop()[1] + spaces;
	    }
	    return spaces
	  }

	  stringFrom(tokens, from) {
	    let result = '';
	    for (let i = from; i < tokens.length; i++) {
	      result += tokens[i][1];
	    }
	    tokens.splice(from, tokens.length - from);
	    return result
	  }

	  unclosedBlock() {
	    let pos = this.current.source.start;
	    throw this.input.error('Unclosed block', pos.line, pos.column)
	  }

	  unclosedBracket(bracket) {
	    throw this.input.error(
	      'Unclosed bracket',
	      { offset: bracket[2] },
	      { offset: bracket[2] + 1 }
	    )
	  }

	  unexpectedClose(token) {
	    throw this.input.error(
	      'Unexpected }',
	      { offset: token[2] },
	      { offset: token[2] + 1 }
	    )
	  }

	  unknownWord(tokens) {
	    throw this.input.error(
	      'Unknown word ' + tokens[0][1],
	      { offset: tokens[0][2] },
	      { offset: tokens[0][2] + tokens[0][1].length }
	    )
	  }

	  unnamedAtrule(node, token) {
	    throw this.input.error(
	      'At-rule without name',
	      { offset: token[2] },
	      { offset: token[2] + token[1].length }
	    )
	  }
	}

	parser = Parser;
	return parser;
}

var parse_1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse_1;
	hasRequiredParse$1 = 1;

	let Container = requireContainer();
	let Input = requireInput();
	let Parser = requireParser();

	function parse(css, opts) {
	  let input = new Input(css, opts);
	  let parser = new Parser(input);
	  try {
	    parser.parse();
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (e.name === 'CssSyntaxError' && opts && opts.from) {
	        if (/\.scss$/i.test(opts.from)) {
	          e.message +=
	            '\nYou tried to parse SCSS with ' +
	            'the standard CSS parser; ' +
	            'try again with the postcss-scss parser';
	        } else if (/\.sass/i.test(opts.from)) {
	          e.message +=
	            '\nYou tried to parse Sass with ' +
	            'the standard CSS parser; ' +
	            'try again with the postcss-sass parser';
	        } else if (/\.less$/i.test(opts.from)) {
	          e.message +=
	            '\nYou tried to parse Less with ' +
	            'the standard CSS parser; ' +
	            'try again with the postcss-less parser';
	        }
	      }
	    }
	    throw e
	  }

	  return parser.root
	}

	parse_1 = parse;
	parse.default = parse;

	Container.registerParse(parse);
	return parse_1;
}

var warning;
var hasRequiredWarning;

function requireWarning () {
	if (hasRequiredWarning) return warning;
	hasRequiredWarning = 1;

	class Warning {
	  constructor(text, opts = {}) {
	    this.type = 'warning';
	    this.text = text;

	    if (opts.node && opts.node.source) {
	      let range = opts.node.rangeBy(opts);
	      this.line = range.start.line;
	      this.column = range.start.column;
	      this.endLine = range.end.line;
	      this.endColumn = range.end.column;
	    }

	    for (let opt in opts) this[opt] = opts[opt];
	  }

	  toString() {
	    if (this.node) {
	      return this.node.error(this.text, {
	        index: this.index,
	        plugin: this.plugin,
	        word: this.word
	      }).message
	    }

	    if (this.plugin) {
	      return this.plugin + ': ' + this.text
	    }

	    return this.text
	  }
	}

	warning = Warning;
	Warning.default = Warning;
	return warning;
}

var result;
var hasRequiredResult;

function requireResult () {
	if (hasRequiredResult) return result;
	hasRequiredResult = 1;

	let Warning = requireWarning();

	class Result {
	  get content() {
	    return this.css
	  }

	  constructor(processor, root, opts) {
	    this.processor = processor;
	    this.messages = [];
	    this.root = root;
	    this.opts = opts;
	    this.css = '';
	    this.map = undefined;
	  }

	  toString() {
	    return this.css
	  }

	  warn(text, opts = {}) {
	    if (!opts.plugin) {
	      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
	        opts.plugin = this.lastPlugin.postcssPlugin;
	      }
	    }

	    let warning = new Warning(text, opts);
	    this.messages.push(warning);

	    return warning
	  }

	  warnings() {
	    return this.messages.filter(i => i.type === 'warning')
	  }
	}

	result = Result;
	Result.default = Result;
	return result;
}

/* eslint-disable no-console */

var warnOnce;
var hasRequiredWarnOnce;

function requireWarnOnce () {
	if (hasRequiredWarnOnce) return warnOnce;
	hasRequiredWarnOnce = 1;

	let printed = {};

	warnOnce = function warnOnce(message) {
	  if (printed[message]) return
	  printed[message] = true;

	  if (typeof console !== 'undefined' && console.warn) {
	    console.warn(message);
	  }
	};
	return warnOnce;
}

var lazyResult;
var hasRequiredLazyResult;

function requireLazyResult () {
	if (hasRequiredLazyResult) return lazyResult;
	hasRequiredLazyResult = 1;

	let Container = requireContainer();
	let Document = requireDocument();
	let MapGenerator = requireMapGenerator();
	let parse = requireParse$1();
	let Result = requireResult();
	let Root = requireRoot();
	let stringify = requireStringify$1();
	let { isClean, my } = requireSymbols();
	let warnOnce = requireWarnOnce();

	const TYPE_TO_CLASS_NAME = {
	  atrule: 'AtRule',
	  comment: 'Comment',
	  decl: 'Declaration',
	  document: 'Document',
	  root: 'Root',
	  rule: 'Rule'
	};

	const PLUGIN_PROPS = {
	  AtRule: true,
	  AtRuleExit: true,
	  Comment: true,
	  CommentExit: true,
	  Declaration: true,
	  DeclarationExit: true,
	  Document: true,
	  DocumentExit: true,
	  Once: true,
	  OnceExit: true,
	  postcssPlugin: true,
	  prepare: true,
	  Root: true,
	  RootExit: true,
	  Rule: true,
	  RuleExit: true
	};

	const NOT_VISITORS = {
	  Once: true,
	  postcssPlugin: true,
	  prepare: true
	};

	const CHILDREN = 0;

	function isPromise(obj) {
	  return typeof obj === 'object' && typeof obj.then === 'function'
	}

	function getEvents(node) {
	  let key = false;
	  let type = TYPE_TO_CLASS_NAME[node.type];
	  if (node.type === 'decl') {
	    key = node.prop.toLowerCase();
	  } else if (node.type === 'atrule') {
	    key = node.name.toLowerCase();
	  }

	  if (key && node.append) {
	    return [
	      type,
	      type + '-' + key,
	      CHILDREN,
	      type + 'Exit',
	      type + 'Exit-' + key
	    ]
	  } else if (key) {
	    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
	  } else if (node.append) {
	    return [type, CHILDREN, type + 'Exit']
	  } else {
	    return [type, type + 'Exit']
	  }
	}

	function toStack(node) {
	  let events;
	  if (node.type === 'document') {
	    events = ['Document', CHILDREN, 'DocumentExit'];
	  } else if (node.type === 'root') {
	    events = ['Root', CHILDREN, 'RootExit'];
	  } else {
	    events = getEvents(node);
	  }

	  return {
	    eventIndex: 0,
	    events,
	    iterator: 0,
	    node,
	    visitorIndex: 0,
	    visitors: []
	  }
	}

	function cleanMarks(node) {
	  node[isClean] = false;
	  if (node.nodes) node.nodes.forEach(i => cleanMarks(i));
	  return node
	}

	let postcss = {};

	class LazyResult {
	  get content() {
	    return this.stringify().content
	  }

	  get css() {
	    return this.stringify().css
	  }

	  get map() {
	    return this.stringify().map
	  }

	  get messages() {
	    return this.sync().messages
	  }

	  get opts() {
	    return this.result.opts
	  }

	  get processor() {
	    return this.result.processor
	  }

	  get root() {
	    return this.sync().root
	  }

	  get [Symbol.toStringTag]() {
	    return 'LazyResult'
	  }

	  constructor(processor, css, opts) {
	    this.stringified = false;
	    this.processed = false;

	    let root;
	    if (
	      typeof css === 'object' &&
	      css !== null &&
	      (css.type === 'root' || css.type === 'document')
	    ) {
	      root = cleanMarks(css);
	    } else if (css instanceof LazyResult || css instanceof Result) {
	      root = cleanMarks(css.root);
	      if (css.map) {
	        if (typeof opts.map === 'undefined') opts.map = {};
	        if (!opts.map.inline) opts.map.inline = false;
	        opts.map.prev = css.map;
	      }
	    } else {
	      let parser = parse;
	      if (opts.syntax) parser = opts.syntax.parse;
	      if (opts.parser) parser = opts.parser;
	      if (parser.parse) parser = parser.parse;

	      try {
	        root = parser(css, opts);
	      } catch (error) {
	        this.processed = true;
	        this.error = error;
	      }

	      if (root && !root[my]) {
	        /* c8 ignore next 2 */
	        Container.rebuild(root);
	      }
	    }

	    this.result = new Result(processor, root, opts);
	    this.helpers = { ...postcss, postcss, result: this.result };
	    this.plugins = this.processor.plugins.map(plugin => {
	      if (typeof plugin === 'object' && plugin.prepare) {
	        return { ...plugin, ...plugin.prepare(this.result) }
	      } else {
	        return plugin
	      }
	    });
	  }

	  async() {
	    if (this.error) return Promise.reject(this.error)
	    if (this.processed) return Promise.resolve(this.result)
	    if (!this.processing) {
	      this.processing = this.runAsync();
	    }
	    return this.processing
	  }

	  catch(onRejected) {
	    return this.async().catch(onRejected)
	  }

	  finally(onFinally) {
	    return this.async().then(onFinally, onFinally)
	  }

	  getAsyncError() {
	    throw new Error('Use process(css).then(cb) to work with async plugins')
	  }

	  handleError(error, node) {
	    let plugin = this.result.lastPlugin;
	    try {
	      if (node) node.addToError(error);
	      this.error = error;
	      if (error.name === 'CssSyntaxError' && !error.plugin) {
	        error.plugin = plugin.postcssPlugin;
	        error.setMessage();
	      } else if (plugin.postcssVersion) {
	        if (process.env.NODE_ENV !== 'production') {
	          let pluginName = plugin.postcssPlugin;
	          let pluginVer = plugin.postcssVersion;
	          let runtimeVer = this.result.processor.version;
	          let a = pluginVer.split('.');
	          let b = runtimeVer.split('.');

	          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
	            // eslint-disable-next-line no-console
	            console.error(
	              'Unknown error from PostCSS plugin. Your current PostCSS ' +
	                'version is ' +
	                runtimeVer +
	                ', but ' +
	                pluginName +
	                ' uses ' +
	                pluginVer +
	                '. Perhaps this is the source of the error below.'
	            );
	          }
	        }
	      }
	    } catch (err) {
	      /* c8 ignore next 3 */
	      // eslint-disable-next-line no-console
	      if (console && console.error) console.error(err);
	    }
	    return error
	  }

	  prepareVisitors() {
	    this.listeners = {};
	    let add = (plugin, type, cb) => {
	      if (!this.listeners[type]) this.listeners[type] = [];
	      this.listeners[type].push([plugin, cb]);
	    };
	    for (let plugin of this.plugins) {
	      if (typeof plugin === 'object') {
	        for (let event in plugin) {
	          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
	            throw new Error(
	              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
	                `Try to update PostCSS (${this.processor.version} now).`
	            )
	          }
	          if (!NOT_VISITORS[event]) {
	            if (typeof plugin[event] === 'object') {
	              for (let filter in plugin[event]) {
	                if (filter === '*') {
	                  add(plugin, event, plugin[event][filter]);
	                } else {
	                  add(
	                    plugin,
	                    event + '-' + filter.toLowerCase(),
	                    plugin[event][filter]
	                  );
	                }
	              }
	            } else if (typeof plugin[event] === 'function') {
	              add(plugin, event, plugin[event]);
	            }
	          }
	        }
	      }
	    }
	    this.hasListener = Object.keys(this.listeners).length > 0;
	  }

	  async runAsync() {
	    this.plugin = 0;
	    for (let i = 0; i < this.plugins.length; i++) {
	      let plugin = this.plugins[i];
	      let promise = this.runOnRoot(plugin);
	      if (isPromise(promise)) {
	        try {
	          await promise;
	        } catch (error) {
	          throw this.handleError(error)
	        }
	      }
	    }

	    this.prepareVisitors();
	    if (this.hasListener) {
	      let root = this.result.root;
	      while (!root[isClean]) {
	        root[isClean] = true;
	        let stack = [toStack(root)];
	        while (stack.length > 0) {
	          let promise = this.visitTick(stack);
	          if (isPromise(promise)) {
	            try {
	              await promise;
	            } catch (e) {
	              let node = stack[stack.length - 1].node;
	              throw this.handleError(e, node)
	            }
	          }
	        }
	      }

	      if (this.listeners.OnceExit) {
	        for (let [plugin, visitor] of this.listeners.OnceExit) {
	          this.result.lastPlugin = plugin;
	          try {
	            if (root.type === 'document') {
	              let roots = root.nodes.map(subRoot =>
	                visitor(subRoot, this.helpers)
	              );

	              await Promise.all(roots);
	            } else {
	              await visitor(root, this.helpers);
	            }
	          } catch (e) {
	            throw this.handleError(e)
	          }
	        }
	      }
	    }

	    this.processed = true;
	    return this.stringify()
	  }

	  runOnRoot(plugin) {
	    this.result.lastPlugin = plugin;
	    try {
	      if (typeof plugin === 'object' && plugin.Once) {
	        if (this.result.root.type === 'document') {
	          let roots = this.result.root.nodes.map(root =>
	            plugin.Once(root, this.helpers)
	          );

	          if (isPromise(roots[0])) {
	            return Promise.all(roots)
	          }

	          return roots
	        }

	        return plugin.Once(this.result.root, this.helpers)
	      } else if (typeof plugin === 'function') {
	        return plugin(this.result.root, this.result)
	      }
	    } catch (error) {
	      throw this.handleError(error)
	    }
	  }

	  stringify() {
	    if (this.error) throw this.error
	    if (this.stringified) return this.result
	    this.stringified = true;

	    this.sync();

	    let opts = this.result.opts;
	    let str = stringify;
	    if (opts.syntax) str = opts.syntax.stringify;
	    if (opts.stringifier) str = opts.stringifier;
	    if (str.stringify) str = str.stringify;

	    let map = new MapGenerator(str, this.result.root, this.result.opts);
	    let data = map.generate();
	    this.result.css = data[0];
	    this.result.map = data[1];

	    return this.result
	  }

	  sync() {
	    if (this.error) throw this.error
	    if (this.processed) return this.result
	    this.processed = true;

	    if (this.processing) {
	      throw this.getAsyncError()
	    }

	    for (let plugin of this.plugins) {
	      let promise = this.runOnRoot(plugin);
	      if (isPromise(promise)) {
	        throw this.getAsyncError()
	      }
	    }

	    this.prepareVisitors();
	    if (this.hasListener) {
	      let root = this.result.root;
	      while (!root[isClean]) {
	        root[isClean] = true;
	        this.walkSync(root);
	      }
	      if (this.listeners.OnceExit) {
	        if (root.type === 'document') {
	          for (let subRoot of root.nodes) {
	            this.visitSync(this.listeners.OnceExit, subRoot);
	          }
	        } else {
	          this.visitSync(this.listeners.OnceExit, root);
	        }
	      }
	    }

	    return this.result
	  }

	  then(onFulfilled, onRejected) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (!('from' in this.opts)) {
	        warnOnce(
	          'Without `from` option PostCSS could generate wrong source map ' +
	            'and will not find Browserslist config. Set it to CSS file path ' +
	            'or to `undefined` to prevent this warning.'
	        );
	      }
	    }
	    return this.async().then(onFulfilled, onRejected)
	  }

	  toString() {
	    return this.css
	  }

	  visitSync(visitors, node) {
	    for (let [plugin, visitor] of visitors) {
	      this.result.lastPlugin = plugin;
	      let promise;
	      try {
	        promise = visitor(node, this.helpers);
	      } catch (e) {
	        throw this.handleError(e, node.proxyOf)
	      }
	      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
	        return true
	      }
	      if (isPromise(promise)) {
	        throw this.getAsyncError()
	      }
	    }
	  }

	  visitTick(stack) {
	    let visit = stack[stack.length - 1];
	    let { node, visitors } = visit;

	    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
	      stack.pop();
	      return
	    }

	    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
	      let [plugin, visitor] = visitors[visit.visitorIndex];
	      visit.visitorIndex += 1;
	      if (visit.visitorIndex === visitors.length) {
	        visit.visitors = [];
	        visit.visitorIndex = 0;
	      }
	      this.result.lastPlugin = plugin;
	      try {
	        return visitor(node.toProxy(), this.helpers)
	      } catch (e) {
	        throw this.handleError(e, node)
	      }
	    }

	    if (visit.iterator !== 0) {
	      let iterator = visit.iterator;
	      let child;
	      while ((child = node.nodes[node.indexes[iterator]])) {
	        node.indexes[iterator] += 1;
	        if (!child[isClean]) {
	          child[isClean] = true;
	          stack.push(toStack(child));
	          return
	        }
	      }
	      visit.iterator = 0;
	      delete node.indexes[iterator];
	    }

	    let events = visit.events;
	    while (visit.eventIndex < events.length) {
	      let event = events[visit.eventIndex];
	      visit.eventIndex += 1;
	      if (event === CHILDREN) {
	        if (node.nodes && node.nodes.length) {
	          node[isClean] = true;
	          visit.iterator = node.getIterator();
	        }
	        return
	      } else if (this.listeners[event]) {
	        visit.visitors = this.listeners[event];
	        return
	      }
	    }
	    stack.pop();
	  }

	  walkSync(node) {
	    node[isClean] = true;
	    let events = getEvents(node);
	    for (let event of events) {
	      if (event === CHILDREN) {
	        if (node.nodes) {
	          node.each(child => {
	            if (!child[isClean]) this.walkSync(child);
	          });
	        }
	      } else {
	        let visitors = this.listeners[event];
	        if (visitors) {
	          if (this.visitSync(visitors, node.toProxy())) return
	        }
	      }
	    }
	  }

	  warnings() {
	    return this.sync().warnings()
	  }
	}

	LazyResult.registerPostcss = dependant => {
	  postcss = dependant;
	};

	lazyResult = LazyResult;
	LazyResult.default = LazyResult;

	Root.registerLazyResult(LazyResult);
	Document.registerLazyResult(LazyResult);
	return lazyResult;
}

var noWorkResult;
var hasRequiredNoWorkResult;

function requireNoWorkResult () {
	if (hasRequiredNoWorkResult) return noWorkResult;
	hasRequiredNoWorkResult = 1;

	let MapGenerator = requireMapGenerator();
	let parse = requireParse$1();
	const Result = requireResult();
	let stringify = requireStringify$1();
	let warnOnce = requireWarnOnce();

	class NoWorkResult {
	  get content() {
	    return this.result.css
	  }

	  get css() {
	    return this.result.css
	  }

	  get map() {
	    return this.result.map
	  }

	  get messages() {
	    return []
	  }

	  get opts() {
	    return this.result.opts
	  }

	  get processor() {
	    return this.result.processor
	  }

	  get root() {
	    if (this._root) {
	      return this._root
	    }

	    let root;
	    let parser = parse;

	    try {
	      root = parser(this._css, this._opts);
	    } catch (error) {
	      this.error = error;
	    }

	    if (this.error) {
	      throw this.error
	    } else {
	      this._root = root;
	      return root
	    }
	  }

	  get [Symbol.toStringTag]() {
	    return 'NoWorkResult'
	  }

	  constructor(processor, css, opts) {
	    css = css.toString();
	    this.stringified = false;

	    this._processor = processor;
	    this._css = css;
	    this._opts = opts;
	    this._map = undefined;
	    let root;

	    let str = stringify;
	    this.result = new Result(this._processor, root, this._opts);
	    this.result.css = css;

	    let self = this;
	    Object.defineProperty(this.result, 'root', {
	      get() {
	        return self.root
	      }
	    });

	    let map = new MapGenerator(str, root, this._opts, css);
	    if (map.isMap()) {
	      let [generatedCSS, generatedMap] = map.generate();
	      if (generatedCSS) {
	        this.result.css = generatedCSS;
	      }
	      if (generatedMap) {
	        this.result.map = generatedMap;
	      }
	    } else {
	      map.clearAnnotation();
	      this.result.css = map.css;
	    }
	  }

	  async() {
	    if (this.error) return Promise.reject(this.error)
	    return Promise.resolve(this.result)
	  }

	  catch(onRejected) {
	    return this.async().catch(onRejected)
	  }

	  finally(onFinally) {
	    return this.async().then(onFinally, onFinally)
	  }

	  sync() {
	    if (this.error) throw this.error
	    return this.result
	  }

	  then(onFulfilled, onRejected) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (!('from' in this._opts)) {
	        warnOnce(
	          'Without `from` option PostCSS could generate wrong source map ' +
	            'and will not find Browserslist config. Set it to CSS file path ' +
	            'or to `undefined` to prevent this warning.'
	        );
	      }
	    }

	    return this.async().then(onFulfilled, onRejected)
	  }

	  toString() {
	    return this._css
	  }

	  warnings() {
	    return []
	  }
	}

	noWorkResult = NoWorkResult;
	NoWorkResult.default = NoWorkResult;
	return noWorkResult;
}

var processor$1;
var hasRequiredProcessor$1;

function requireProcessor$1 () {
	if (hasRequiredProcessor$1) return processor$1;
	hasRequiredProcessor$1 = 1;

	let Document = requireDocument();
	let LazyResult = requireLazyResult();
	let NoWorkResult = requireNoWorkResult();
	let Root = requireRoot();

	class Processor {
	  constructor(plugins = []) {
	    this.version = '8.5.6';
	    this.plugins = this.normalize(plugins);
	  }

	  normalize(plugins) {
	    let normalized = [];
	    for (let i of plugins) {
	      if (i.postcss === true) {
	        i = i();
	      } else if (i.postcss) {
	        i = i.postcss;
	      }

	      if (typeof i === 'object' && Array.isArray(i.plugins)) {
	        normalized = normalized.concat(i.plugins);
	      } else if (typeof i === 'object' && i.postcssPlugin) {
	        normalized.push(i);
	      } else if (typeof i === 'function') {
	        normalized.push(i);
	      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
	        if (process.env.NODE_ENV !== 'production') {
	          throw new Error(
	            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
	              'one of the syntax/parser/stringifier options as outlined ' +
	              'in your PostCSS runner documentation.'
	          )
	        }
	      } else {
	        throw new Error(i + ' is not a PostCSS plugin')
	      }
	    }
	    return normalized
	  }

	  process(css, opts = {}) {
	    if (
	      !this.plugins.length &&
	      !opts.parser &&
	      !opts.stringifier &&
	      !opts.syntax
	    ) {
	      return new NoWorkResult(this, css, opts)
	    } else {
	      return new LazyResult(this, css, opts)
	    }
	  }

	  use(plugin) {
	    this.plugins = this.plugins.concat(this.normalize([plugin]));
	    return this
	  }
	}

	processor$1 = Processor;
	Processor.default = Processor;

	Root.registerProcessor(Processor);
	Document.registerProcessor(Processor);
	return processor$1;
}

var postcss_1;
var hasRequiredPostcss;

function requirePostcss () {
	if (hasRequiredPostcss) return postcss_1;
	hasRequiredPostcss = 1;

	let AtRule = requireAtRule$1();
	let Comment = requireComment();
	let Container = requireContainer();
	let CssSyntaxError = requireCssSyntaxError();
	let Declaration = requireDeclaration$1();
	let Document = requireDocument();
	let fromJSON = requireFromJSON();
	let Input = requireInput();
	let LazyResult = requireLazyResult();
	let list = requireList();
	let Node = requireNode();
	let parse = requireParse$1();
	let Processor = requireProcessor$1();
	let Result = requireResult();
	let Root = requireRoot();
	let Rule = requireRule();
	let stringify = requireStringify$1();
	let Warning = requireWarning();

	function postcss(...plugins) {
	  if (plugins.length === 1 && Array.isArray(plugins[0])) {
	    plugins = plugins[0];
	  }
	  return new Processor(plugins)
	}

	postcss.plugin = function plugin(name, initializer) {
	  let warningPrinted = false;
	  function creator(...args) {
	    // eslint-disable-next-line no-console
	    if (console && console.warn && !warningPrinted) {
	      warningPrinted = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        name +
	          ': postcss.plugin was deprecated. Migration guide:\n' +
	          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
	      );
	      if (process.env.LANG && process.env.LANG.startsWith('cn')) {
	        /* c8 ignore next 7 */
	        // eslint-disable-next-line no-console
	        console.warn(
	          name +
	            ': 里面 postcss.plugin 被弃用. 迁移指南:\n' +
	            'https://www.w3ctech.com/topic/2226'
	        );
	      }
	    }
	    let transformer = initializer(...args);
	    transformer.postcssPlugin = name;
	    transformer.postcssVersion = new Processor().version;
	    return transformer
	  }

	  let cache;
	  Object.defineProperty(creator, 'postcss', {
	    get() {
	      if (!cache) cache = creator();
	      return cache
	    }
	  });

	  creator.process = function (css, processOpts, pluginOpts) {
	    return postcss([creator(pluginOpts)]).process(css, processOpts)
	  };

	  return creator
	};

	postcss.stringify = stringify;
	postcss.parse = parse;
	postcss.fromJSON = fromJSON;
	postcss.list = list;

	postcss.comment = defaults => new Comment(defaults);
	postcss.atRule = defaults => new AtRule(defaults);
	postcss.decl = defaults => new Declaration(defaults);
	postcss.rule = defaults => new Rule(defaults);
	postcss.root = defaults => new Root(defaults);
	postcss.document = defaults => new Document(defaults);

	postcss.CssSyntaxError = CssSyntaxError;
	postcss.Declaration = Declaration;
	postcss.Container = Container;
	postcss.Processor = Processor;
	postcss.Document = Document;
	postcss.Comment = Comment;
	postcss.Warning = Warning;
	postcss.AtRule = AtRule;
	postcss.Result = Result;
	postcss.Input = Input;
	postcss.Rule = Rule;
	postcss.Root = Root;
	postcss.Node = Node;

	LazyResult.registerPostcss(postcss);

	postcss_1 = postcss;
	postcss.default = postcss;
	return postcss_1;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	let { list } = requirePostcss();

	/**
	 * Throw special error, to tell beniary,
	 * that this error is from Autoprefixer.
	 */
	utils.error = function (text) {
	  let err = new Error(text);
	  err.autoprefixer = true;
	  throw err
	};

	/**
	 * Return array, that doesn’t contain duplicates.
	 */
	utils.uniq = function (array) {
	  return [...new Set(array)]
	};

	/**
	 * Return "-webkit-" on "-webkit- old"
	 */
	utils.removeNote = function (string) {
	  if (!string.includes(' ')) {
	    return string
	  }

	  return string.split(' ')[0]
	};

	/**
	 * Escape RegExp symbols
	 */
	utils.escapeRegexp = function (string) {
	  return string.replace(/[$()*+-.?[\\\]^{|}]/g, '\\$&')
	};

	/**
	 * Return regexp to check, that CSS string contain word
	 */
	utils.regexp = function (word, escape = true) {
	  if (escape) {
	    word = this.escapeRegexp(word);
	  }
	  return new RegExp(`(^|[\\s,(])(${word}($|[\\s(,]))`, 'gi')
	};

	/**
	 * Change comma list
	 */
	utils.editList = function (value, callback) {
	  let origin = list.comma(value);
	  let changed = callback(origin, []);

	  if (origin === changed) {
	    return value
	  }

	  let join = value.match(/,\s*/);
	  join = join ? join[0] : ', ';
	  return changed.join(join)
	};

	/**
	 * Split the selector into parts.
	 * It returns 3 level deep array because selectors can be comma
	 * separated (1), space separated (2), and combined (3)
	 * @param {String} selector selector string
	 * @return {Array<Array<Array>>} 3 level deep array of split selector
	 * @see utils.test.js for examples
	 */
	utils.splitSelector = function (selector) {
	  return list.comma(selector).map(i => {
	    return list.space(i).map(k => {
	      return k.split(/(?=\.|#)/g)
	    })
	  })
	};

	/**
	 * Return true if a given value only contains numbers.
	 * @param {*} value
	 * @returns {boolean}
	 */
	utils.isPureNumber = function (value) {
	  if (typeof value === 'number') {
	    return true
	  }
	  if (typeof value === 'string') {
	    return /^[0-9]+$/.test(value)
	  }
	  return false
	};
	return utils;
}

var browsers;
var hasRequiredBrowsers;

function requireBrowsers () {
	if (hasRequiredBrowsers) return browsers;
	hasRequiredBrowsers = 1;
	let browserslist = requireBrowserslist();
	let { agents } = requireAgents();

	let utils = requireUtils();

	class Browsers {
	  constructor(data, requirements, options, browserslistOpts) {
	    this.data = data;
	    this.options = options || {};
	    this.browserslistOpts = browserslistOpts || {};
	    this.selected = this.parse(requirements);
	  }

	  /**
	   * Return all prefixes for default browser data
	   */
	  static prefixes() {
	    if (this.prefixesCache) {
	      return this.prefixesCache
	    }

	    this.prefixesCache = [];
	    for (let name in agents) {
	      this.prefixesCache.push(`-${agents[name].prefix}-`);
	    }

	    this.prefixesCache = utils
	      .uniq(this.prefixesCache)
	      .sort((a, b) => b.length - a.length);

	    return this.prefixesCache
	  }

	  /**
	   * Check is value contain any possible prefix
	   */
	  static withPrefix(value) {
	    if (!this.prefixesRegexp) {
	      this.prefixesRegexp = new RegExp(this.prefixes().join('|'));
	    }

	    return this.prefixesRegexp.test(value)
	  }

	  /**
	   * Is browser is selected by requirements
	   */
	  isSelected(browser) {
	    return this.selected.includes(browser)
	  }

	  /**
	   * Return browsers selected by requirements
	   */
	  parse(requirements) {
	    let opts = {};
	    for (let i in this.browserslistOpts) {
	      opts[i] = this.browserslistOpts[i];
	    }
	    opts.path = this.options.from;
	    return browserslist(requirements, opts)
	  }

	  /**
	   * Return prefix for selected browser
	   */
	  prefix(browser) {
	    let [name, version] = browser.split(' ');
	    let data = this.data[name];

	    let prefix = data.prefix_exceptions && data.prefix_exceptions[version];
	    if (!prefix) {
	      prefix = data.prefix;
	    }
	    return `-${prefix}-`
	  }
	}

	browsers = Browsers;
	return browsers;
}

var info;
var hasRequiredInfo;

function requireInfo () {
	if (hasRequiredInfo) return info;
	hasRequiredInfo = 1;
	let browserslist = requireBrowserslist();

	function capitalize(str) {
	  return str.slice(0, 1).toUpperCase() + str.slice(1)
	}

	const NAMES = {
	  and_chr: 'Chrome for Android',
	  and_ff: 'Firefox for Android',
	  and_qq: 'QQ Browser',
	  and_uc: 'UC for Android',
	  baidu: 'Baidu Browser',
	  ie: 'IE',
	  ie_mob: 'IE Mobile',
	  ios_saf: 'iOS Safari',
	  kaios: 'KaiOS Browser',
	  op_mini: 'Opera Mini',
	  op_mob: 'Opera Mobile',
	  samsung: 'Samsung Internet'
	};

	function prefix(name, prefixes, note) {
	  let out = `  ${name}`;
	  if (note) out += ' *';
	  out += ': ';
	  out += prefixes.map(i => i.replace(/^-(.*)-$/g, '$1')).join(', ');
	  out += '\n';
	  return out
	}

	info = function (prefixes) {
	  if (prefixes.browsers.selected.length === 0) {
	    return 'No browsers selected'
	  }

	  let versions = {};
	  for (let browser of prefixes.browsers.selected) {
	    let parts = browser.split(' ');
	    let name = parts[0];
	    let version = parts[1];

	    name = NAMES[name] || capitalize(name);
	    if (versions[name]) {
	      versions[name].push(version);
	    } else {
	      versions[name] = [version];
	    }
	  }

	  let out = 'Browsers:\n';
	  for (let browser in versions) {
	    let list = versions[browser];
	    list = list.sort((a, b) => parseFloat(b) - parseFloat(a));
	    out += `  ${browser}: ${list.join(', ')}\n`;
	  }

	  let coverage = browserslist.coverage(prefixes.browsers.selected);
	  let round = Math.round(coverage * 100) / 100.0;
	  out += `\nThese browsers account for ${round}% of all users globally\n`;

	  let atrules = [];
	  for (let name in prefixes.add) {
	    let data = prefixes.add[name];
	    if (name[0] === '@' && data.prefixes) {
	      atrules.push(prefix(name, data.prefixes));
	    }
	  }
	  if (atrules.length > 0) {
	    out += `\nAt-Rules:\n${atrules.sort().join('')}`;
	  }

	  let selectors = [];
	  for (let selector of prefixes.add.selectors) {
	    if (selector.prefixes) {
	      selectors.push(prefix(selector.name, selector.prefixes));
	    }
	  }
	  if (selectors.length > 0) {
	    out += `\nSelectors:\n${selectors.sort().join('')}`;
	  }

	  let values = [];
	  let props = [];
	  let hadGrid = false;
	  for (let name in prefixes.add) {
	    let data = prefixes.add[name];
	    if (name[0] !== '@' && data.prefixes) {
	      let grid = name.indexOf('grid-') === 0;
	      if (grid) hadGrid = true;
	      props.push(prefix(name, data.prefixes, grid));
	    }

	    if (!Array.isArray(data.values)) {
	      continue
	    }
	    for (let value of data.values) {
	      let grid = value.name.includes('grid');
	      if (grid) hadGrid = true;
	      let string = prefix(value.name, value.prefixes, grid);
	      if (!values.includes(string)) {
	        values.push(string);
	      }
	    }
	  }

	  if (props.length > 0) {
	    out += `\nProperties:\n${props.sort().join('')}`;
	  }
	  if (values.length > 0) {
	    out += `\nValues:\n${values.sort().join('')}`;
	  }
	  if (hadGrid) {
	    out += '\n* - Prefixes will be added only on grid: true option.\n';
	  }

	  if (!atrules.length && !selectors.length && !props.length && !values.length) {
	    out +=
	      "\nAwesome! Your browsers don't require any vendor prefixes." +
	      '\nNow you can remove Autoprefixer from build steps.';
	  }

	  return out
	};
	return info;
}

var vendor;
var hasRequiredVendor;

function requireVendor () {
	if (hasRequiredVendor) return vendor;
	hasRequiredVendor = 1;
	vendor = {
	  prefix(prop) {
	    let match = prop.match(/^(-\w+-)/);
	    if (match) {
	      return match[0]
	    }

	    return ''
	  },

	  unprefixed(prop) {
	    return prop.replace(/^-\w+-/, '')
	  }
	};
	return vendor;
}

var prefixer;
var hasRequiredPrefixer;

function requirePrefixer () {
	if (hasRequiredPrefixer) return prefixer;
	hasRequiredPrefixer = 1;
	let Browsers = requireBrowsers();
	let utils = requireUtils();
	let vendor = requireVendor();

	/**
	 * Recursively clone objects
	 */
	function clone(obj, parent) {
	  let cloned = new obj.constructor();

	  for (let i of Object.keys(obj || {})) {
	    let value = obj[i];
	    if (i === 'parent' && typeof value === 'object') {
	      if (parent) {
	        cloned[i] = parent;
	      }
	    } else if (i === 'source' || i === null) {
	      cloned[i] = value;
	    } else if (Array.isArray(value)) {
	      cloned[i] = value.map(x => clone(x, cloned));
	    } else if (
	      i !== '_autoprefixerPrefix' &&
	      i !== '_autoprefixerValues' &&
	      i !== 'proxyCache'
	    ) {
	      if (typeof value === 'object' && value !== null) {
	        value = clone(value, cloned);
	      }
	      cloned[i] = value;
	    }
	  }

	  return cloned
	}

	class Prefixer {
	  constructor(name, prefixes, all) {
	    this.prefixes = prefixes;
	    this.name = name;
	    this.all = all;
	  }

	  /**
	   * Clone node and clean autprefixer custom caches
	   */
	  static clone(node, overrides) {
	    let cloned = clone(node);
	    for (let name in overrides) {
	      cloned[name] = overrides[name];
	    }
	    return cloned
	  }

	  /**
	   * Add hack to selected names
	   */
	  static hack(klass) {
	    if (!this.hacks) {
	      this.hacks = {};
	    }
	    return klass.names.map(name => {
	      this.hacks[name] = klass;
	      return this.hacks[name]
	    })
	  }

	  /**
	   * Load hacks for some names
	   */
	  static load(name, prefixes, all) {
	    let Klass = this.hacks && this.hacks[name];
	    if (Klass) {
	      return new Klass(name, prefixes, all)
	    } else {
	      return new this(name, prefixes, all)
	    }
	  }

	  /**
	   * Shortcut for Prefixer.clone
	   */
	  clone(node, overrides) {
	    return Prefixer.clone(node, overrides)
	  }

	  /**
	   * Find prefix in node parents
	   */
	  parentPrefix(node) {
	    let prefix;

	    if (typeof node._autoprefixerPrefix !== 'undefined') {
	      prefix = node._autoprefixerPrefix;
	    } else if (node.type === 'decl' && node.prop[0] === '-') {
	      prefix = vendor.prefix(node.prop);
	    } else if (node.type === 'root') {
	      prefix = false;
	    } else if (
	      node.type === 'rule' &&
	      node.selector.includes(':-') &&
	      /:(-\w+-)/.test(node.selector)
	    ) {
	      prefix = node.selector.match(/:(-\w+-)/)[1];
	    } else if (node.type === 'atrule' && node.name[0] === '-') {
	      prefix = vendor.prefix(node.name);
	    } else {
	      prefix = this.parentPrefix(node.parent);
	    }

	    if (!Browsers.prefixes().includes(prefix)) {
	      prefix = false;
	    }

	    node._autoprefixerPrefix = prefix;

	    return node._autoprefixerPrefix
	  }

	  /**
	   * Clone node with prefixes
	   */
	  process(node, result) {
	    if (!this.check(node)) {
	      return undefined
	    }

	    let parent = this.parentPrefix(node);

	    let prefixes = this.prefixes.filter(
	      prefix => !parent || parent === utils.removeNote(prefix)
	    );

	    let added = [];
	    for (let prefix of prefixes) {
	      if (this.add(node, prefix, added.concat([prefix]), result)) {
	        added.push(prefix);
	      }
	    }

	    return added
	  }
	}

	prefixer = Prefixer;
	return prefixer;
}

var atRule;
var hasRequiredAtRule;

function requireAtRule () {
	if (hasRequiredAtRule) return atRule;
	hasRequiredAtRule = 1;
	let Prefixer = requirePrefixer();

	class AtRule extends Prefixer {
	  /**
	   * Clone and add prefixes for at-rule
	   */
	  add(rule, prefix) {
	    let prefixed = prefix + rule.name;

	    let already = rule.parent.some(
	      i => i.name === prefixed && i.params === rule.params
	    );
	    if (already) {
	      return undefined
	    }

	    let cloned = this.clone(rule, { name: prefixed });
	    return rule.parent.insertBefore(rule, cloned)
	  }

	  /**
	   * Clone node with prefixes
	   */
	  process(node) {
	    let parent = this.parentPrefix(node);

	    for (let prefix of this.prefixes) {
	      if (!parent || parent === prefix) {
	        this.add(node, prefix);
	      }
	    }
	  }
	}

	atRule = AtRule;
	return atRule;
}

var declaration;
var hasRequiredDeclaration;

function requireDeclaration () {
	if (hasRequiredDeclaration) return declaration;
	hasRequiredDeclaration = 1;
	let Browsers = requireBrowsers();
	let Prefixer = requirePrefixer();
	let utils = requireUtils();

	class Declaration extends Prefixer {
	  /**
	   * Clone and add prefixes for declaration
	   */
	  add(decl, prefix, prefixes, result) {
	    let prefixed = this.prefixed(decl.prop, prefix);
	    if (
	      this.isAlready(decl, prefixed) ||
	      this.otherPrefixes(decl.value, prefix)
	    ) {
	      return undefined
	    }
	    return this.insert(decl, prefix, prefixes, result)
	  }

	  /**
	   * Calculate indentation to create visual cascade
	   */
	  calcBefore(prefixes, decl, prefix = '') {
	    let max = this.maxPrefixed(prefixes, decl);
	    let diff = max - utils.removeNote(prefix).length;

	    let before = decl.raw('before');
	    if (diff > 0) {
	      before += Array(diff).fill(' ').join('');
	    }

	    return before
	  }

	  /**
	   * Always true, because we already get prefixer by property name
	   */
	  check(/* decl */) {
	    return true
	  }

	  /**
	   * Clone and insert new declaration
	   */
	  insert(decl, prefix, prefixes) {
	    let cloned = this.set(this.clone(decl), prefix);
	    if (!cloned) return undefined

	    let already = decl.parent.some(
	      i => i.prop === cloned.prop && i.value === cloned.value
	    );
	    if (already) {
	      return undefined
	    }

	    if (this.needCascade(decl)) {
	      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
	    }
	    return decl.parent.insertBefore(decl, cloned)
	  }

	  /**
	   * Did this declaration has this prefix above
	   */
	  isAlready(decl, prefixed) {
	    let already = this.all.group(decl).up(i => i.prop === prefixed);
	    if (!already) {
	      already = this.all.group(decl).down(i => i.prop === prefixed);
	    }
	    return already
	  }

	  /**
	   * Return maximum length of possible prefixed property
	   */
	  maxPrefixed(prefixes, decl) {
	    if (decl._autoprefixerMax) {
	      return decl._autoprefixerMax
	    }

	    let max = 0;
	    for (let prefix of prefixes) {
	      prefix = utils.removeNote(prefix);
	      if (prefix.length > max) {
	        max = prefix.length;
	      }
	    }
	    decl._autoprefixerMax = max;

	    return decl._autoprefixerMax
	  }

	  /**
	   * Should we use visual cascade for prefixes
	   */
	  needCascade(decl) {
	    if (!decl._autoprefixerCascade) {
	      decl._autoprefixerCascade =
	        this.all.options.cascade !== false && decl.raw('before').includes('\n');
	    }
	    return decl._autoprefixerCascade
	  }

	  /**
	   * Return unprefixed version of property
	   */
	  normalize(prop) {
	    return prop
	  }

	  /**
	   * Return list of prefixed properties to clean old prefixes
	   */
	  old(prop, prefix) {
	    return [this.prefixed(prop, prefix)]
	  }

	  /**
	   * Check `value`, that it contain other prefixes, rather than `prefix`
	   */
	  otherPrefixes(value, prefix) {
	    for (let other of Browsers.prefixes()) {
	      if (other === prefix) {
	        continue
	      }
	      if (value.includes(other)) {
	        return value.replace(/var\([^)]+\)/, '').includes(other)
	      }
	    }
	    return false
	  }

	  /**
	   * Return prefixed version of property
	   */
	  prefixed(prop, prefix) {
	    return prefix + prop
	  }

	  /**
	   * Add spaces for visual cascade
	   */
	  process(decl, result) {
	    if (!this.needCascade(decl)) {
	      super.process(decl, result);
	      return
	    }

	    let prefixes = super.process(decl, result);

	    if (!prefixes || !prefixes.length) {
	      return
	    }

	    this.restoreBefore(decl);
	    decl.raws.before = this.calcBefore(prefixes, decl);
	  }

	  /**
	   * Remove visual cascade
	   */
	  restoreBefore(decl) {
	    let lines = decl.raw('before').split('\n');
	    let min = lines[lines.length - 1];

	    this.all.group(decl).up(prefixed => {
	      let array = prefixed.raw('before').split('\n');
	      let last = array[array.length - 1];
	      if (last.length < min.length) {
	        min = last;
	      }
	    });

	    lines[lines.length - 1] = min;
	    decl.raws.before = lines.join('\n');
	  }

	  /**
	   * Set prefix to declaration
	   */
	  set(decl, prefix) {
	    decl.prop = this.prefixed(decl.prop, prefix);
	    return decl
	  }
	}

	declaration = Declaration;
	return declaration;
}

/**
 * Return flexbox spec versions by prefix
 */

var flexSpec;
var hasRequiredFlexSpec;

function requireFlexSpec () {
	if (hasRequiredFlexSpec) return flexSpec;
	hasRequiredFlexSpec = 1;
	flexSpec = function (prefix) {
	  let spec;
	  if (prefix === '-webkit- 2009' || prefix === '-moz-') {
	    spec = 2009;
	  } else if (prefix === '-ms-') {
	    spec = 2012;
	  } else if (prefix === '-webkit-') {
	    spec = 'final';
	  }

	  if (prefix === '-webkit- 2009') {
	    prefix = '-webkit-';
	  }

	  return [spec, prefix]
	};
	return flexSpec;
}

var alignContent;
var hasRequiredAlignContent;

function requireAlignContent () {
	if (hasRequiredAlignContent) return alignContent;
	hasRequiredAlignContent = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class AlignContent extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'align-content'
	  }

	  /**
	   * Change property name for 2012 spec
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2012) {
	      return prefix + 'flex-line-pack'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Change value for 2012 spec and ignore prefix for 2009
	   */
	  set(decl, prefix) {
	    let spec = flexSpec(prefix)[0];
	    if (spec === 2012) {
	      decl.value = AlignContent.oldValues[decl.value] || decl.value;
	      return super.set(decl, prefix)
	    }
	    if (spec === 'final') {
	      return super.set(decl, prefix)
	    }
	    return undefined
	  }
	}

	AlignContent.names = ['align-content', 'flex-line-pack'];

	AlignContent.oldValues = {
	  'flex-end': 'end',
	  'flex-start': 'start',
	  'space-around': 'distribute',
	  'space-between': 'justify'
	};

	alignContent = AlignContent;
	return alignContent;
}

var alignItems;
var hasRequiredAlignItems;

function requireAlignItems () {
	if (hasRequiredAlignItems) return alignItems;
	hasRequiredAlignItems = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class AlignItems extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'align-items'
	  }

	  /**
	   * Change property name for 2009 and 2012 specs
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2009) {
	      return prefix + 'box-align'
	    }
	    if (spec === 2012) {
	      return prefix + 'flex-align'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Change value for 2009 and 2012 specs
	   */
	  set(decl, prefix) {
	    let spec = flexSpec(prefix)[0];
	    if (spec === 2009 || spec === 2012) {
	      decl.value = AlignItems.oldValues[decl.value] || decl.value;
	    }
	    return super.set(decl, prefix)
	  }
	}

	AlignItems.names = ['align-items', 'flex-align', 'box-align'];

	AlignItems.oldValues = {
	  'flex-end': 'end',
	  'flex-start': 'start'
	};

	alignItems = AlignItems;
	return alignItems;
}

var alignSelf;
var hasRequiredAlignSelf;

function requireAlignSelf () {
	if (hasRequiredAlignSelf) return alignSelf;
	hasRequiredAlignSelf = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class AlignSelf extends Declaration {
	  check(decl) {
	    return (
	      decl.parent &&
	      !decl.parent.some(i => {
	        return i.prop && i.prop.startsWith('grid-')
	      })
	    )
	  }

	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'align-self'
	  }

	  /**
	   * Change property name for 2012 specs
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2012) {
	      return prefix + 'flex-item-align'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Change value for 2012 spec and ignore prefix for 2009
	   */
	  set(decl, prefix) {
	    let spec = flexSpec(prefix)[0];
	    if (spec === 2012) {
	      decl.value = AlignSelf.oldValues[decl.value] || decl.value;
	      return super.set(decl, prefix)
	    }
	    if (spec === 'final') {
	      return super.set(decl, prefix)
	    }
	    return undefined
	  }
	}

	AlignSelf.names = ['align-self', 'flex-item-align'];

	AlignSelf.oldValues = {
	  'flex-end': 'end',
	  'flex-start': 'start'
	};

	alignSelf = AlignSelf;
	return alignSelf;
}

var animation;
var hasRequiredAnimation;

function requireAnimation () {
	if (hasRequiredAnimation) return animation;
	hasRequiredAnimation = 1;
	let Declaration = requireDeclaration();

	class Animation extends Declaration {
	  /**
	   * Don’t add prefixes for modern values.
	   */
	  check(decl) {
	    return !decl.value.split(/\s+/).some(i => {
	      let lower = i.toLowerCase();
	      return lower === 'reverse' || lower === 'alternate-reverse'
	    })
	  }
	}

	Animation.names = ['animation', 'animation-direction'];

	animation = Animation;
	return animation;
}

var appearance;
var hasRequiredAppearance;

function requireAppearance () {
	if (hasRequiredAppearance) return appearance;
	hasRequiredAppearance = 1;
	let Declaration = requireDeclaration();
	let utils = requireUtils();

	class Appearance extends Declaration {
	  constructor(name, prefixes, all) {
	    super(name, prefixes, all);

	    if (this.prefixes) {
	      this.prefixes = utils.uniq(
	        this.prefixes.map(i => {
	          if (i === '-ms-') {
	            return '-webkit-'
	          }
	          return i
	        })
	      );
	    }
	  }
	}

	Appearance.names = ['appearance'];

	appearance = Appearance;
	return appearance;
}

var oldSelector;
var hasRequiredOldSelector;

function requireOldSelector () {
	if (hasRequiredOldSelector) return oldSelector;
	hasRequiredOldSelector = 1;
	class OldSelector {
	  constructor(selector, prefix) {
	    this.prefix = prefix;
	    this.prefixed = selector.prefixed(this.prefix);
	    this.regexp = selector.regexp(this.prefix);

	    this.prefixeds = selector
	      .possible()
	      .map(x => [selector.prefixed(x), selector.regexp(x)]);

	    this.unprefixed = selector.name;
	    this.nameRegexp = selector.regexp();
	  }

	  /**
	   * Does rule contain an unnecessary prefixed selector
	   */
	  check(rule) {
	    if (!rule.selector.includes(this.prefixed)) {
	      return false
	    }
	    if (!rule.selector.match(this.regexp)) {
	      return false
	    }
	    if (this.isHack(rule)) {
	      return false
	    }
	    return true
	  }

	  /**
	   * Is rule a hack without unprefixed version bottom
	   */
	  isHack(rule) {
	    let index = rule.parent.index(rule) + 1;
	    let rules = rule.parent.nodes;

	    while (index < rules.length) {
	      let before = rules[index].selector;
	      if (!before) {
	        return true
	      }

	      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {
	        return false
	      }

	      let some = false;
	      for (let [string, regexp] of this.prefixeds) {
	        if (before.includes(string) && before.match(regexp)) {
	          some = true;
	          break
	        }
	      }

	      if (!some) {
	        return true
	      }

	      index += 1;
	    }

	    return true
	  }
	}

	oldSelector = OldSelector;
	return oldSelector;
}

var selector;
var hasRequiredSelector;

function requireSelector () {
	if (hasRequiredSelector) return selector;
	hasRequiredSelector = 1;
	let { list } = requirePostcss();

	let Browsers = requireBrowsers();
	let OldSelector = requireOldSelector();
	let Prefixer = requirePrefixer();
	let utils = requireUtils();

	class Selector extends Prefixer {
	  constructor(name, prefixes, all) {
	    super(name, prefixes, all);
	    this.regexpCache = new Map();
	  }

	  /**
	   * Clone and add prefixes for at-rule
	   */
	  add(rule, prefix) {
	    let prefixeds = this.prefixeds(rule);

	    if (this.already(rule, prefixeds, prefix)) {
	      return
	    }

	    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] });
	    rule.parent.insertBefore(rule, cloned);
	  }

	  /**
	   * Is rule already prefixed before
	   */
	  already(rule, prefixeds, prefix) {
	    let index = rule.parent.index(rule) - 1;

	    while (index >= 0) {
	      let before = rule.parent.nodes[index];

	      if (before.type !== 'rule') {
	        return false
	      }

	      let some = false;
	      for (let key in prefixeds[this.name]) {
	        let prefixed = prefixeds[this.name][key];
	        if (before.selector === prefixed) {
	          if (prefix === key) {
	            return true
	          } else {
	            some = true;
	            break
	          }
	        }
	      }
	      if (!some) {
	        return false
	      }

	      index -= 1;
	    }

	    return false
	  }

	  /**
	   * Is rule selectors need to be prefixed
	   */
	  check(rule) {
	    if (rule.selector.includes(this.name)) {
	      return !!rule.selector.match(this.regexp())
	    }

	    return false
	  }

	  /**
	   * Return function to fast find prefixed selector
	   */
	  old(prefix) {
	    return new OldSelector(this, prefix)
	  }

	  /**
	   * All possible prefixes
	   */
	  possible() {
	    return Browsers.prefixes()
	  }

	  /**
	   * Return prefixed version of selector
	   */
	  prefixed(prefix) {
	    return this.name.replace(/^(\W*)/, `$1${prefix}`)
	  }

	  /**
	   * Return all possible selector prefixes
	   */
	  prefixeds(rule) {
	    if (rule._autoprefixerPrefixeds) {
	      if (rule._autoprefixerPrefixeds[this.name]) {
	        return rule._autoprefixerPrefixeds
	      }
	    } else {
	      rule._autoprefixerPrefixeds = {};
	    }

	    let prefixeds = {};
	    if (rule.selector.includes(',')) {
	      let ruleParts = list.comma(rule.selector);
	      let toProcess = ruleParts.filter(el => el.includes(this.name));

	      for (let prefix of this.possible()) {
	        prefixeds[prefix] = toProcess
	          .map(el => this.replace(el, prefix))
	          .join(', ');
	      }
	    } else {
	      for (let prefix of this.possible()) {
	        prefixeds[prefix] = this.replace(rule.selector, prefix);
	      }
	    }

	    rule._autoprefixerPrefixeds[this.name] = prefixeds;
	    return rule._autoprefixerPrefixeds
	  }

	  /**
	   * Lazy loadRegExp for name
	   */
	  regexp(prefix) {
	    if (!this.regexpCache.has(prefix)) {
	      let name = prefix ? this.prefixed(prefix) : this.name;
	      this.regexpCache.set(
	        prefix,
	        new RegExp(`(^|[^:"'=])${utils.escapeRegexp(name)}`, 'gi')
	      );
	    }

	    return this.regexpCache.get(prefix)
	  }

	  /**
	   * Replace selectors by prefixed one
	   */
	  replace(selector, prefix) {
	    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)
	  }
	}

	selector = Selector;
	return selector;
}

var autofill;
var hasRequiredAutofill;

function requireAutofill () {
	if (hasRequiredAutofill) return autofill;
	hasRequiredAutofill = 1;
	let Selector = requireSelector();
	let utils = requireUtils();

	class Autofill extends Selector {
	  constructor(name, prefixes, all) {
	    super(name, prefixes, all);

	    if (this.prefixes) {
	      this.prefixes = utils.uniq(this.prefixes.map(() => '-webkit-'));
	    }
	  }

	  /**
	   * Return different selectors depend on prefix
	   */
	  prefixed(prefix) {
	    if (prefix === '-webkit-') {
	      return ':-webkit-autofill'
	    }
	    return `:${prefix}autofill`
	  }
	}

	Autofill.names = [':autofill'];

	autofill = Autofill;
	return autofill;
}

var backdropFilter;
var hasRequiredBackdropFilter;

function requireBackdropFilter () {
	if (hasRequiredBackdropFilter) return backdropFilter;
	hasRequiredBackdropFilter = 1;
	let Declaration = requireDeclaration();
	let utils = requireUtils();

	class BackdropFilter extends Declaration {
	  constructor(name, prefixes, all) {
	    super(name, prefixes, all);

	    if (this.prefixes) {
	      this.prefixes = utils.uniq(
	        this.prefixes.map(i => {
	          return i === '-ms-' ? '-webkit-' : i
	        })
	      );
	    }
	  }
	}

	BackdropFilter.names = ['backdrop-filter'];

	backdropFilter = BackdropFilter;
	return backdropFilter;
}

var backgroundClip;
var hasRequiredBackgroundClip;

function requireBackgroundClip () {
	if (hasRequiredBackgroundClip) return backgroundClip;
	hasRequiredBackgroundClip = 1;
	let Declaration = requireDeclaration();
	let utils = requireUtils();

	class BackgroundClip extends Declaration {
	  constructor(name, prefixes, all) {
	    super(name, prefixes, all);

	    if (this.prefixes) {
	      this.prefixes = utils.uniq(
	        this.prefixes.map(i => {
	          return i === '-ms-' ? '-webkit-' : i
	        })
	      );
	    }
	  }

	  check(decl) {
	    return decl.value.toLowerCase() === 'text'
	  }
	}

	BackgroundClip.names = ['background-clip'];

	backgroundClip = BackgroundClip;
	return backgroundClip;
}

var backgroundSize;
var hasRequiredBackgroundSize;

function requireBackgroundSize () {
	if (hasRequiredBackgroundSize) return backgroundSize;
	hasRequiredBackgroundSize = 1;
	let Declaration = requireDeclaration();

	class BackgroundSize extends Declaration {
	  /**
	   * Duplication parameter for -webkit- browsers
	   */
	  set(decl, prefix) {
	    let value = decl.value.toLowerCase();
	    if (
	      prefix === '-webkit-' &&
	      !value.includes(' ') &&
	      value !== 'contain' &&
	      value !== 'cover'
	    ) {
	      decl.value = decl.value + ' ' + decl.value;
	    }
	    return super.set(decl, prefix)
	  }
	}

	BackgroundSize.names = ['background-size'];

	backgroundSize = BackgroundSize;
	return backgroundSize;
}

var blockLogical;
var hasRequiredBlockLogical;

function requireBlockLogical () {
	if (hasRequiredBlockLogical) return blockLogical;
	hasRequiredBlockLogical = 1;
	let Declaration = requireDeclaration();

	class BlockLogical extends Declaration {
	  /**
	   * Return property name by spec
	   */
	  normalize(prop) {
	    if (prop.includes('-before')) {
	      return prop.replace('-before', '-block-start')
	    }
	    return prop.replace('-after', '-block-end')
	  }

	  /**
	   * Use old syntax for -moz- and -webkit-
	   */
	  prefixed(prop, prefix) {
	    if (prop.includes('-start')) {
	      return prefix + prop.replace('-block-start', '-before')
	    }
	    return prefix + prop.replace('-block-end', '-after')
	  }
	}

	BlockLogical.names = [
	  'border-block-start',
	  'border-block-end',
	  'margin-block-start',
	  'margin-block-end',
	  'padding-block-start',
	  'padding-block-end',
	  'border-before',
	  'border-after',
	  'margin-before',
	  'margin-after',
	  'padding-before',
	  'padding-after'
	];

	blockLogical = BlockLogical;
	return blockLogical;
}

var borderImage;
var hasRequiredBorderImage;

function requireBorderImage () {
	if (hasRequiredBorderImage) return borderImage;
	hasRequiredBorderImage = 1;
	let Declaration = requireDeclaration();

	class BorderImage extends Declaration {
	  /**
	   * Remove fill parameter for prefixed declarations
	   */
	  set(decl, prefix) {
	    decl.value = decl.value.replace(/\s+fill(\s)/, '$1');
	    return super.set(decl, prefix)
	  }
	}

	BorderImage.names = ['border-image'];

	borderImage = BorderImage;
	return borderImage;
}

var borderRadius;
var hasRequiredBorderRadius;

function requireBorderRadius () {
	if (hasRequiredBorderRadius) return borderRadius;
	hasRequiredBorderRadius = 1;
	let Declaration = requireDeclaration();

	class BorderRadius extends Declaration {
	  /**
	   * Return unprefixed version of property
	   */
	  normalize(prop) {
	    return BorderRadius.toNormal[prop] || prop
	  }

	  /**
	   * Change syntax, when add Mozilla prefix
	   */
	  prefixed(prop, prefix) {
	    if (prefix === '-moz-') {
	      return prefix + (BorderRadius.toMozilla[prop] || prop)
	    }
	    return super.prefixed(prop, prefix)
	  }
	}

	BorderRadius.names = ['border-radius'];

	BorderRadius.toMozilla = {};
	BorderRadius.toNormal = {};

	for (let ver of ['top', 'bottom']) {
	  for (let hor of ['left', 'right']) {
	    let normal = `border-${ver}-${hor}-radius`;
	    let mozilla = `border-radius-${ver}${hor}`;

	    BorderRadius.names.push(normal);
	    BorderRadius.names.push(mozilla);

	    BorderRadius.toMozilla[normal] = mozilla;
	    BorderRadius.toNormal[mozilla] = normal;
	  }
	}

	borderRadius = BorderRadius;
	return borderRadius;
}

var breakProps;
var hasRequiredBreakProps;

function requireBreakProps () {
	if (hasRequiredBreakProps) return breakProps;
	hasRequiredBreakProps = 1;
	let Declaration = requireDeclaration();

	class BreakProps extends Declaration {
	  /**
	   * Don’t prefix some values
	   */
	  insert(decl, prefix, prefixes) {
	    if (decl.prop !== 'break-inside') {
	      return super.insert(decl, prefix, prefixes)
	    }
	    if (/region/i.test(decl.value) || /page/i.test(decl.value)) {
	      return undefined
	    }
	    return super.insert(decl, prefix, prefixes)
	  }

	  /**
	   * Return property name by final spec
	   */
	  normalize(prop) {
	    if (prop.includes('inside')) {
	      return 'break-inside'
	    }
	    if (prop.includes('before')) {
	      return 'break-before'
	    }
	    return 'break-after'
	  }

	  /**
	   * Change name for -webkit- and -moz- prefix
	   */
	  prefixed(prop, prefix) {
	    return `${prefix}column-${prop}`
	  }

	  /**
	   * Change prefixed value for avoid-column and avoid-page
	   */
	  set(decl, prefix) {
	    if (
	      (decl.prop === 'break-inside' && decl.value === 'avoid-column') ||
	      decl.value === 'avoid-page'
	    ) {
	      decl.value = 'avoid';
	    }
	    return super.set(decl, prefix)
	  }
	}

	BreakProps.names = [
	  'break-inside',
	  'page-break-inside',
	  'column-break-inside',
	  'break-before',
	  'page-break-before',
	  'column-break-before',
	  'break-after',
	  'page-break-after',
	  'column-break-after'
	];

	breakProps = BreakProps;
	return breakProps;
}

var oldValue;
var hasRequiredOldValue;

function requireOldValue () {
	if (hasRequiredOldValue) return oldValue;
	hasRequiredOldValue = 1;
	let utils = requireUtils();

	class OldValue {
	  constructor(unprefixed, prefixed, string, regexp) {
	    this.unprefixed = unprefixed;
	    this.prefixed = prefixed;
	    this.string = string || prefixed;
	    this.regexp = regexp || utils.regexp(prefixed);
	  }

	  /**
	   * Check, that value contain old value
	   */
	  check(value) {
	    if (value.includes(this.string)) {
	      return !!value.match(this.regexp)
	    }
	    return false
	  }
	}

	oldValue = OldValue;
	return oldValue;
}

var value$1;
var hasRequiredValue;

function requireValue () {
	if (hasRequiredValue) return value$1;
	hasRequiredValue = 1;
	let OldValue = requireOldValue();
	let Prefixer = requirePrefixer();
	let utils = requireUtils();
	let vendor = requireVendor();

	class Value extends Prefixer {
	  /**
	   * Clone decl for each prefixed values
	   */
	  static save(prefixes, decl) {
	    let prop = decl.prop;
	    let result = [];

	    for (let prefix in decl._autoprefixerValues) {
	      let value = decl._autoprefixerValues[prefix];

	      if (value === decl.value) {
	        continue
	      }

	      let item;
	      let propPrefix = vendor.prefix(prop);

	      if (propPrefix === '-pie-') {
	        continue
	      }

	      if (propPrefix === prefix) {
	        item = decl.value = value;
	        result.push(item);
	        continue
	      }

	      let prefixed = prefixes.prefixed(prop, prefix);
	      let rule = decl.parent;

	      if (!rule.every(i => i.prop !== prefixed)) {
	        result.push(item);
	        continue
	      }

	      let trimmed = value.replace(/\s+/, ' ');
	      let already = rule.some(
	        i => i.prop === decl.prop && i.value.replace(/\s+/, ' ') === trimmed
	      );

	      if (already) {
	        result.push(item);
	        continue
	      }

	      let cloned = this.clone(decl, { value });
	      item = decl.parent.insertBefore(decl, cloned);

	      result.push(item);
	    }

	    return result
	  }

	  /**
	   * Save values with next prefixed token
	   */
	  add(decl, prefix) {
	    if (!decl._autoprefixerValues) {
	      decl._autoprefixerValues = {};
	    }
	    let value = decl._autoprefixerValues[prefix] || this.value(decl);

	    let before;
	    do {
	      before = value;
	      value = this.replace(value, prefix);
	      if (value === false) return
	    } while (value !== before)

	    decl._autoprefixerValues[prefix] = value;
	  }

	  /**
	   * Is declaration need to be prefixed
	   */
	  check(decl) {
	    let value = decl.value;
	    if (!value.includes(this.name)) {
	      return false
	    }

	    return !!value.match(this.regexp())
	  }

	  /**
	   * Return function to fast find prefixed value
	   */
	  old(prefix) {
	    return new OldValue(this.name, prefix + this.name)
	  }

	  /**
	   * Lazy regexp loading
	   */
	  regexp() {
	    return this.regexpCache || (this.regexpCache = utils.regexp(this.name))
	  }

	  /**
	   * Add prefix to values in string
	   */
	  replace(string, prefix) {
	    return string.replace(this.regexp(), `$1${prefix}$2`)
	  }

	  /**
	   * Get value with comments if it was not changed
	   */
	  value(decl) {
	    if (decl.raws.value && decl.raws.value.value === decl.value) {
	      return decl.raws.value.raw
	    } else {
	      return decl.value
	    }
	  }
	}

	value$1 = Value;
	return value$1;
}

var crossFade;
var hasRequiredCrossFade;

function requireCrossFade () {
	if (hasRequiredCrossFade) return crossFade;
	hasRequiredCrossFade = 1;
	let list = requirePostcss().list;

	let Value = requireValue();

	class CrossFade extends Value {
	  replace(string, prefix) {
	    return list
	      .space(string)
	      .map(value => {
	        if (value.slice(0, +this.name.length + 1) !== this.name + '(') {
	          return value
	        }

	        let close = value.lastIndexOf(')');
	        let after = value.slice(close + 1);
	        let args = value.slice(this.name.length + 1, close);

	        if (prefix === '-webkit-') {
	          let match = args.match(/\d*.?\d+%?/);
	          if (match) {
	            args = args.slice(match[0].length).trim();
	            args += `, ${match[0]}`;
	          } else {
	            args += ', 0.5';
	          }
	        }
	        return prefix + this.name + '(' + args + ')' + after
	      })
	      .join(' ')
	  }
	}

	CrossFade.names = ['cross-fade'];

	crossFade = CrossFade;
	return crossFade;
}

var displayFlex;
var hasRequiredDisplayFlex;

function requireDisplayFlex () {
	if (hasRequiredDisplayFlex) return displayFlex;
	hasRequiredDisplayFlex = 1;
	let OldValue = requireOldValue();
	let Value = requireValue();
	let flexSpec = requireFlexSpec();

	class DisplayFlex extends Value {
	  constructor(name, prefixes) {
	    super(name, prefixes);
	    if (name === 'display-flex') {
	      this.name = 'flex';
	    }
	  }

	  /**
	   * Faster check for flex value
	   */
	  check(decl) {
	    return decl.prop === 'display' && decl.value === this.name
	  }

	  /**
	   * Change value for old specs
	   */
	  old(prefix) {
	    let prefixed = this.prefixed(prefix);
	    if (!prefixed) return undefined
	    return new OldValue(this.name, prefixed)
	  }

	  /**
	   * Return value by spec
	   */
	  prefixed(prefix) {
	    let spec, value
	    ;[spec, prefix] = flexSpec(prefix);

	    if (spec === 2009) {
	      if (this.name === 'flex') {
	        value = 'box';
	      } else {
	        value = 'inline-box';
	      }
	    } else if (spec === 2012) {
	      if (this.name === 'flex') {
	        value = 'flexbox';
	      } else {
	        value = 'inline-flexbox';
	      }
	    } else if (spec === 'final') {
	      value = this.name;
	    }

	    return prefix + value
	  }

	  /**
	   * Add prefix to value depend on flebox spec version
	   */
	  replace(string, prefix) {
	    return this.prefixed(prefix)
	  }
	}

	DisplayFlex.names = ['display-flex', 'inline-flex'];

	displayFlex = DisplayFlex;
	return displayFlex;
}

var displayGrid;
var hasRequiredDisplayGrid;

function requireDisplayGrid () {
	if (hasRequiredDisplayGrid) return displayGrid;
	hasRequiredDisplayGrid = 1;
	let Value = requireValue();

	class DisplayGrid extends Value {
	  constructor(name, prefixes) {
	    super(name, prefixes);
	    if (name === 'display-grid') {
	      this.name = 'grid';
	    }
	  }

	  /**
	   * Faster check for flex value
	   */
	  check(decl) {
	    return decl.prop === 'display' && decl.value === this.name
	  }
	}

	DisplayGrid.names = ['display-grid', 'inline-grid'];

	displayGrid = DisplayGrid;
	return displayGrid;
}

var fileSelectorButton;
var hasRequiredFileSelectorButton;

function requireFileSelectorButton () {
	if (hasRequiredFileSelectorButton) return fileSelectorButton;
	hasRequiredFileSelectorButton = 1;
	let Selector = requireSelector();
	let utils = requireUtils();

	class FileSelectorButton extends Selector {
	  constructor(name, prefixes, all) {
	    super(name, prefixes, all);

	    if (this.prefixes) {
	      this.prefixes = utils.uniq(this.prefixes.map(() => '-webkit-'));
	    }
	  }

	  /**
	   * Return different selectors depend on prefix
	   */
	  prefixed(prefix) {
	    if (prefix === '-webkit-') {
	      return '::-webkit-file-upload-button'
	    }
	    return `::${prefix}file-selector-button`
	  }
	}

	FileSelectorButton.names = ['::file-selector-button'];

	fileSelectorButton = FileSelectorButton;
	return fileSelectorButton;
}

var filter;
var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter;
	hasRequiredFilter = 1;
	let Declaration = requireDeclaration();

	class Filter extends Declaration {
	  /**
	   * Check is it Internet Explorer filter
	   */
	  check(decl) {
	    let v = decl.value;
	    return (
	      !v.toLowerCase().includes('alpha(') &&
	      !v.includes('DXImageTransform.Microsoft') &&
	      !v.includes('data:image/svg+xml')
	    )
	  }
	}

	Filter.names = ['filter'];

	filter = Filter;
	return filter;
}

var filterValue;
var hasRequiredFilterValue;

function requireFilterValue () {
	if (hasRequiredFilterValue) return filterValue;
	hasRequiredFilterValue = 1;
	let Value = requireValue();

	class FilterValue extends Value {
	  constructor(name, prefixes) {
	    super(name, prefixes);
	    if (name === 'filter-function') {
	      this.name = 'filter';
	    }
	  }
	}

	FilterValue.names = ['filter', 'filter-function'];

	filterValue = FilterValue;
	return filterValue;
}

var flex;
var hasRequiredFlex;

function requireFlex () {
	if (hasRequiredFlex) return flex;
	hasRequiredFlex = 1;
	let list = requirePostcss().list;

	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class Flex extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'flex'
	  }

	  /**
	   * Change property name for 2009 spec
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2009) {
	      return prefix + 'box-flex'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Spec 2009 supports only first argument
	   * Spec 2012 disallows unitless basis
	   */
	  set(decl, prefix) {
	    let spec = flexSpec(prefix)[0];
	    if (spec === 2009) {
	      decl.value = list.space(decl.value)[0];
	      decl.value = Flex.oldValues[decl.value] || decl.value;
	      return super.set(decl, prefix)
	    }
	    if (spec === 2012) {
	      let components = list.space(decl.value);
	      if (components.length === 3 && components[2] === '0') {
	        decl.value = components.slice(0, 2).concat('0px').join(' ');
	      }
	    }
	    return super.set(decl, prefix)
	  }
	}

	Flex.names = ['flex', 'box-flex'];

	Flex.oldValues = {
	  auto: '1',
	  none: '0'
	};

	flex = Flex;
	return flex;
}

var flexBasis;
var hasRequiredFlexBasis;

function requireFlexBasis () {
	if (hasRequiredFlexBasis) return flexBasis;
	hasRequiredFlexBasis = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class FlexBasis extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'flex-basis'
	  }

	  /**
	   * Return flex property for 2012 spec
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2012) {
	      return prefix + 'flex-preferred-size'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Ignore 2009 spec and use flex property for 2012
	   */
	  set(decl, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2012 || spec === 'final') {
	      return super.set(decl, prefix)
	    }
	    return undefined
	  }
	}

	FlexBasis.names = ['flex-basis', 'flex-preferred-size'];

	flexBasis = FlexBasis;
	return flexBasis;
}

var flexDirection;
var hasRequiredFlexDirection;

function requireFlexDirection () {
	if (hasRequiredFlexDirection) return flexDirection;
	hasRequiredFlexDirection = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class FlexDirection extends Declaration {
	  /**
	   * Use two properties for 2009 spec
	   */
	  insert(decl, prefix, prefixes) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec !== 2009) {
	      return super.insert(decl, prefix, prefixes)
	    }
	    let already = decl.parent.some(
	      i =>
	        i.prop === prefix + 'box-orient' || i.prop === prefix + 'box-direction'
	    );
	    if (already) {
	      return undefined
	    }

	    let v = decl.value;
	    let dir, orient;
	    if (v === 'inherit' || v === 'initial' || v === 'unset') {
	      orient = v;
	      dir = v;
	    } else {
	      orient = v.includes('row') ? 'horizontal' : 'vertical';
	      dir = v.includes('reverse') ? 'reverse' : 'normal';
	    }

	    let cloned = this.clone(decl);
	    cloned.prop = prefix + 'box-orient';
	    cloned.value = orient;
	    if (this.needCascade(decl)) {
	      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
	    }
	    decl.parent.insertBefore(decl, cloned);

	    cloned = this.clone(decl);
	    cloned.prop = prefix + 'box-direction';
	    cloned.value = dir;
	    if (this.needCascade(decl)) {
	      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
	    }
	    return decl.parent.insertBefore(decl, cloned)
	  }

	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'flex-direction'
	  }

	  /**
	   * Clean two properties for 2009 spec
	   */
	  old(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2009) {
	      return [prefix + 'box-orient', prefix + 'box-direction']
	    } else {
	      return super.old(prop, prefix)
	    }
	  }
	}

	FlexDirection.names = ['flex-direction', 'box-direction', 'box-orient'];

	flexDirection = FlexDirection;
	return flexDirection;
}

var flexFlow;
var hasRequiredFlexFlow;

function requireFlexFlow () {
	if (hasRequiredFlexFlow) return flexFlow;
	hasRequiredFlexFlow = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class FlexFlow extends Declaration {
	  /**
	   * Use two properties for 2009 spec
	   */
	  insert(decl, prefix, prefixes) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec !== 2009) {
	      return super.insert(decl, prefix, prefixes)
	    }
	    let values = decl.value
	      .split(/\s+/)
	      .filter(i => i !== 'wrap' && i !== 'nowrap' && 'wrap-reverse');
	    if (values.length === 0) {
	      return undefined
	    }

	    let already = decl.parent.some(
	      i =>
	        i.prop === prefix + 'box-orient' || i.prop === prefix + 'box-direction'
	    );
	    if (already) {
	      return undefined
	    }

	    let value = values[0];
	    let orient = value.includes('row') ? 'horizontal' : 'vertical';
	    let dir = value.includes('reverse') ? 'reverse' : 'normal';

	    let cloned = this.clone(decl);
	    cloned.prop = prefix + 'box-orient';
	    cloned.value = orient;
	    if (this.needCascade(decl)) {
	      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
	    }
	    decl.parent.insertBefore(decl, cloned);

	    cloned = this.clone(decl);
	    cloned.prop = prefix + 'box-direction';
	    cloned.value = dir;
	    if (this.needCascade(decl)) {
	      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
	    }
	    return decl.parent.insertBefore(decl, cloned)
	  }
	}

	FlexFlow.names = ['flex-flow', 'box-direction', 'box-orient'];

	flexFlow = FlexFlow;
	return flexFlow;
}

var flexGrow;
var hasRequiredFlexGrow;

function requireFlexGrow () {
	if (hasRequiredFlexGrow) return flexGrow;
	hasRequiredFlexGrow = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class Flex extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'flex'
	  }

	  /**
	   * Return flex property for 2009 and 2012 specs
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2009) {
	      return prefix + 'box-flex'
	    }
	    if (spec === 2012) {
	      return prefix + 'flex-positive'
	    }
	    return super.prefixed(prop, prefix)
	  }
	}

	Flex.names = ['flex-grow', 'flex-positive'];

	flexGrow = Flex;
	return flexGrow;
}

var flexShrink;
var hasRequiredFlexShrink;

function requireFlexShrink () {
	if (hasRequiredFlexShrink) return flexShrink;
	hasRequiredFlexShrink = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class FlexShrink extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'flex-shrink'
	  }

	  /**
	   * Return flex property for 2012 spec
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2012) {
	      return prefix + 'flex-negative'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Ignore 2009 spec and use flex property for 2012
	   */
	  set(decl, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2012 || spec === 'final') {
	      return super.set(decl, prefix)
	    }
	    return undefined
	  }
	}

	FlexShrink.names = ['flex-shrink', 'flex-negative'];

	flexShrink = FlexShrink;
	return flexShrink;
}

var flexWrap;
var hasRequiredFlexWrap;

function requireFlexWrap () {
	if (hasRequiredFlexWrap) return flexWrap;
	hasRequiredFlexWrap = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class FlexWrap extends Declaration {
	  /**
	   * Don't add prefix for 2009 spec
	   */
	  set(decl, prefix) {
	    let spec = flexSpec(prefix)[0];
	    if (spec !== 2009) {
	      return super.set(decl, prefix)
	    }
	    return undefined
	  }
	}

	FlexWrap.names = ['flex-wrap'];

	flexWrap = FlexWrap;
	return flexWrap;
}

var fullscreen;
var hasRequiredFullscreen;

function requireFullscreen () {
	if (hasRequiredFullscreen) return fullscreen;
	hasRequiredFullscreen = 1;
	let Selector = requireSelector();

	class Fullscreen extends Selector {
	  /**
	   * Return different selectors depend on prefix
	   */
	  prefixed(prefix) {
	    if (prefix === '-webkit-') {
	      return ':-webkit-full-screen'
	    }
	    if (prefix === '-moz-') {
	      return ':-moz-full-screen'
	    }
	    return `:${prefix}fullscreen`
	  }
	}

	Fullscreen.names = [':fullscreen'];

	fullscreen = Fullscreen;
	return fullscreen;
}

var normalizeRange;
var hasRequiredNormalizeRange;

function requireNormalizeRange () {
	if (hasRequiredNormalizeRange) return normalizeRange;
	hasRequiredNormalizeRange = 1;
	normalizeRange = {
	  wrap: wrapRange,
	  limit: limitRange,
	  validate: validateRange,
	  test: testRange,
	  curry: curry,
	  name: name
	};

	function wrapRange(min, max, value) {
	  var maxLessMin = max - min;
	  return ((value - min) % maxLessMin + maxLessMin) % maxLessMin + min;
	}

	function limitRange(min, max, value) {
	  return Math.max(min, Math.min(max, value));
	}

	function validateRange(min, max, value, minExclusive, maxExclusive) {
	  if (!testRange(min, max, value, minExclusive, maxExclusive)) {
	    throw new Error(value + ' is outside of range [' + min + ',' + max + ')');
	  }
	  return value;
	}

	function testRange(min, max, value, minExclusive, maxExclusive) {
	  return !(
	       value < min ||
	       value > max ||
	       (maxExclusive && (value === max)) ||
	       (minExclusive && (value === min))
	  );
	}

	function name(min, max, minExcl, maxExcl) {
	  return (minExcl ? '(' : '[') + min + ',' + max + (maxExcl ? ')' : ']');
	}

	function curry(min, max, minExclusive, maxExclusive) {
	  var boundNameFn = name.bind(null, min, max, minExclusive, maxExclusive);
	  return {
	    wrap: wrapRange.bind(null, min, max),
	    limit: limitRange.bind(null, min, max),
	    validate: function(value) {
	      return validateRange(min, max, value, minExclusive, maxExclusive);
	    },
	    test: function(value) {
	      return testRange(min, max, value, minExclusive, maxExclusive);
	    },
	    toString: boundNameFn,
	    name: boundNameFn
	  };
	}
	return normalizeRange;
}

var parse;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;
	var openParentheses = "(".charCodeAt(0);
	var closeParentheses = ")".charCodeAt(0);
	var singleQuote = "'".charCodeAt(0);
	var doubleQuote = '"'.charCodeAt(0);
	var backslash = "\\".charCodeAt(0);
	var slash = "/".charCodeAt(0);
	var comma = ",".charCodeAt(0);
	var colon = ":".charCodeAt(0);
	var star = "*".charCodeAt(0);
	var uLower = "u".charCodeAt(0);
	var uUpper = "U".charCodeAt(0);
	var plus = "+".charCodeAt(0);
	var isUnicodeRange = /^[a-f0-9?-]+$/i;

	parse = function(input) {
	  var tokens = [];
	  var value = input;

	  var next,
	    quote,
	    prev,
	    token,
	    escape,
	    escapePos,
	    whitespacePos,
	    parenthesesOpenPos;
	  var pos = 0;
	  var code = value.charCodeAt(pos);
	  var max = value.length;
	  var stack = [{ nodes: tokens }];
	  var balanced = 0;
	  var parent;

	  var name = "";
	  var before = "";
	  var after = "";

	  while (pos < max) {
	    // Whitespaces
	    if (code <= 32) {
	      next = pos;
	      do {
	        next += 1;
	        code = value.charCodeAt(next);
	      } while (code <= 32);
	      token = value.slice(pos, next);

	      prev = tokens[tokens.length - 1];
	      if (code === closeParentheses && balanced) {
	        after = token;
	      } else if (prev && prev.type === "div") {
	        prev.after = token;
	        prev.sourceEndIndex += token.length;
	      } else if (
	        code === comma ||
	        code === colon ||
	        (code === slash &&
	          value.charCodeAt(next + 1) !== star &&
	          (!parent ||
	            (parent && parent.type === "function" && parent.value !== "calc")))
	      ) {
	        before = token;
	      } else {
	        tokens.push({
	          type: "space",
	          sourceIndex: pos,
	          sourceEndIndex: next,
	          value: token
	        });
	      }

	      pos = next;

	      // Quotes
	    } else if (code === singleQuote || code === doubleQuote) {
	      next = pos;
	      quote = code === singleQuote ? "'" : '"';
	      token = {
	        type: "string",
	        sourceIndex: pos,
	        quote: quote
	      };
	      do {
	        escape = false;
	        next = value.indexOf(quote, next + 1);
	        if (~next) {
	          escapePos = next;
	          while (value.charCodeAt(escapePos - 1) === backslash) {
	            escapePos -= 1;
	            escape = !escape;
	          }
	        } else {
	          value += quote;
	          next = value.length - 1;
	          token.unclosed = true;
	        }
	      } while (escape);
	      token.value = value.slice(pos + 1, next);
	      token.sourceEndIndex = token.unclosed ? next : next + 1;
	      tokens.push(token);
	      pos = next + 1;
	      code = value.charCodeAt(pos);

	      // Comments
	    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
	      next = value.indexOf("*/", pos);

	      token = {
	        type: "comment",
	        sourceIndex: pos,
	        sourceEndIndex: next + 2
	      };

	      if (next === -1) {
	        token.unclosed = true;
	        next = value.length;
	        token.sourceEndIndex = next;
	      }

	      token.value = value.slice(pos + 2, next);
	      tokens.push(token);

	      pos = next + 2;
	      code = value.charCodeAt(pos);

	      // Operation within calc
	    } else if (
	      (code === slash || code === star) &&
	      parent &&
	      parent.type === "function" &&
	      parent.value === "calc"
	    ) {
	      token = value[pos];
	      tokens.push({
	        type: "word",
	        sourceIndex: pos - before.length,
	        sourceEndIndex: pos + token.length,
	        value: token
	      });
	      pos += 1;
	      code = value.charCodeAt(pos);

	      // Dividers
	    } else if (code === slash || code === comma || code === colon) {
	      token = value[pos];

	      tokens.push({
	        type: "div",
	        sourceIndex: pos - before.length,
	        sourceEndIndex: pos + token.length,
	        value: token,
	        before: before,
	        after: ""
	      });
	      before = "";

	      pos += 1;
	      code = value.charCodeAt(pos);

	      // Open parentheses
	    } else if (openParentheses === code) {
	      // Whitespaces after open parentheses
	      next = pos;
	      do {
	        next += 1;
	        code = value.charCodeAt(next);
	      } while (code <= 32);
	      parenthesesOpenPos = pos;
	      token = {
	        type: "function",
	        sourceIndex: pos - name.length,
	        value: name,
	        before: value.slice(parenthesesOpenPos + 1, next)
	      };
	      pos = next;

	      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
	        next -= 1;
	        do {
	          escape = false;
	          next = value.indexOf(")", next + 1);
	          if (~next) {
	            escapePos = next;
	            while (value.charCodeAt(escapePos - 1) === backslash) {
	              escapePos -= 1;
	              escape = !escape;
	            }
	          } else {
	            value += ")";
	            next = value.length - 1;
	            token.unclosed = true;
	          }
	        } while (escape);
	        // Whitespaces before closed
	        whitespacePos = next;
	        do {
	          whitespacePos -= 1;
	          code = value.charCodeAt(whitespacePos);
	        } while (code <= 32);
	        if (parenthesesOpenPos < whitespacePos) {
	          if (pos !== whitespacePos + 1) {
	            token.nodes = [
	              {
	                type: "word",
	                sourceIndex: pos,
	                sourceEndIndex: whitespacePos + 1,
	                value: value.slice(pos, whitespacePos + 1)
	              }
	            ];
	          } else {
	            token.nodes = [];
	          }
	          if (token.unclosed && whitespacePos + 1 !== next) {
	            token.after = "";
	            token.nodes.push({
	              type: "space",
	              sourceIndex: whitespacePos + 1,
	              sourceEndIndex: next,
	              value: value.slice(whitespacePos + 1, next)
	            });
	          } else {
	            token.after = value.slice(whitespacePos + 1, next);
	            token.sourceEndIndex = next;
	          }
	        } else {
	          token.after = "";
	          token.nodes = [];
	        }
	        pos = next + 1;
	        token.sourceEndIndex = token.unclosed ? next : pos;
	        code = value.charCodeAt(pos);
	        tokens.push(token);
	      } else {
	        balanced += 1;
	        token.after = "";
	        token.sourceEndIndex = pos + 1;
	        tokens.push(token);
	        stack.push(token);
	        tokens = token.nodes = [];
	        parent = token;
	      }
	      name = "";

	      // Close parentheses
	    } else if (closeParentheses === code && balanced) {
	      pos += 1;
	      code = value.charCodeAt(pos);

	      parent.after = after;
	      parent.sourceEndIndex += after.length;
	      after = "";
	      balanced -= 1;
	      stack[stack.length - 1].sourceEndIndex = pos;
	      stack.pop();
	      parent = stack[balanced];
	      tokens = parent.nodes;

	      // Words
	    } else {
	      next = pos;
	      do {
	        if (code === backslash) {
	          next += 1;
	        }
	        next += 1;
	        code = value.charCodeAt(next);
	      } while (
	        next < max &&
	        !(
	          code <= 32 ||
	          code === singleQuote ||
	          code === doubleQuote ||
	          code === comma ||
	          code === colon ||
	          code === slash ||
	          code === openParentheses ||
	          (code === star &&
	            parent &&
	            parent.type === "function" &&
	            parent.value === "calc") ||
	          (code === slash &&
	            parent.type === "function" &&
	            parent.value === "calc") ||
	          (code === closeParentheses && balanced)
	        )
	      );
	      token = value.slice(pos, next);

	      if (openParentheses === code) {
	        name = token;
	      } else if (
	        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
	        plus === token.charCodeAt(1) &&
	        isUnicodeRange.test(token.slice(2))
	      ) {
	        tokens.push({
	          type: "unicode-range",
	          sourceIndex: pos,
	          sourceEndIndex: next,
	          value: token
	        });
	      } else {
	        tokens.push({
	          type: "word",
	          sourceIndex: pos,
	          sourceEndIndex: next,
	          value: token
	        });
	      }

	      pos = next;
	    }
	  }

	  for (pos = stack.length - 1; pos; pos -= 1) {
	    stack[pos].unclosed = true;
	    stack[pos].sourceEndIndex = value.length;
	  }

	  return stack[0].nodes;
	};
	return parse;
}

var walk;
var hasRequiredWalk;

function requireWalk () {
	if (hasRequiredWalk) return walk;
	hasRequiredWalk = 1;
	walk = function walk(nodes, cb, bubble) {
	  var i, max, node, result;

	  for (i = 0, max = nodes.length; i < max; i += 1) {
	    node = nodes[i];
	    if (!bubble) {
	      result = cb(node, i, nodes);
	    }

	    if (
	      result !== false &&
	      node.type === "function" &&
	      Array.isArray(node.nodes)
	    ) {
	      walk(node.nodes, cb, bubble);
	    }

	    if (bubble) {
	      cb(node, i, nodes);
	    }
	  }
	};
	return walk;
}

var stringify_1;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;
	function stringifyNode(node, custom) {
	  var type = node.type;
	  var value = node.value;
	  var buf;
	  var customResult;

	  if (custom && (customResult = custom(node)) !== undefined) {
	    return customResult;
	  } else if (type === "word" || type === "space") {
	    return value;
	  } else if (type === "string") {
	    buf = node.quote || "";
	    return buf + value + (node.unclosed ? "" : buf);
	  } else if (type === "comment") {
	    return "/*" + value + (node.unclosed ? "" : "*/");
	  } else if (type === "div") {
	    return (node.before || "") + value + (node.after || "");
	  } else if (Array.isArray(node.nodes)) {
	    buf = stringify(node.nodes, custom);
	    if (type !== "function") {
	      return buf;
	    }
	    return (
	      value +
	      "(" +
	      (node.before || "") +
	      buf +
	      (node.after || "") +
	      (node.unclosed ? "" : ")")
	    );
	  }
	  return value;
	}

	function stringify(nodes, custom) {
	  var result, i;

	  if (Array.isArray(nodes)) {
	    result = "";
	    for (i = nodes.length - 1; ~i; i -= 1) {
	      result = stringifyNode(nodes[i], custom) + result;
	    }
	    return result;
	  }
	  return stringifyNode(nodes, custom);
	}

	stringify_1 = stringify;
	return stringify_1;
}

var unit;
var hasRequiredUnit;

function requireUnit () {
	if (hasRequiredUnit) return unit;
	hasRequiredUnit = 1;
	var minus = "-".charCodeAt(0);
	var plus = "+".charCodeAt(0);
	var dot = ".".charCodeAt(0);
	var exp = "e".charCodeAt(0);
	var EXP = "E".charCodeAt(0);

	// Check if three code points would start a number
	// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
	function likeNumber(value) {
	  var code = value.charCodeAt(0);
	  var nextCode;

	  if (code === plus || code === minus) {
	    nextCode = value.charCodeAt(1);

	    if (nextCode >= 48 && nextCode <= 57) {
	      return true;
	    }

	    var nextNextCode = value.charCodeAt(2);

	    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
	      return true;
	    }

	    return false;
	  }

	  if (code === dot) {
	    nextCode = value.charCodeAt(1);

	    if (nextCode >= 48 && nextCode <= 57) {
	      return true;
	    }

	    return false;
	  }

	  if (code >= 48 && code <= 57) {
	    return true;
	  }

	  return false;
	}

	// Consume a number
	// https://www.w3.org/TR/css-syntax-3/#consume-number
	unit = function(value) {
	  var pos = 0;
	  var length = value.length;
	  var code;
	  var nextCode;
	  var nextNextCode;

	  if (length === 0 || !likeNumber(value)) {
	    return false;
	  }

	  code = value.charCodeAt(pos);

	  if (code === plus || code === minus) {
	    pos++;
	  }

	  while (pos < length) {
	    code = value.charCodeAt(pos);

	    if (code < 48 || code > 57) {
	      break;
	    }

	    pos += 1;
	  }

	  code = value.charCodeAt(pos);
	  nextCode = value.charCodeAt(pos + 1);

	  if (code === dot && nextCode >= 48 && nextCode <= 57) {
	    pos += 2;

	    while (pos < length) {
	      code = value.charCodeAt(pos);

	      if (code < 48 || code > 57) {
	        break;
	      }

	      pos += 1;
	    }
	  }

	  code = value.charCodeAt(pos);
	  nextCode = value.charCodeAt(pos + 1);
	  nextNextCode = value.charCodeAt(pos + 2);

	  if (
	    (code === exp || code === EXP) &&
	    ((nextCode >= 48 && nextCode <= 57) ||
	      ((nextCode === plus || nextCode === minus) &&
	        nextNextCode >= 48 &&
	        nextNextCode <= 57))
	  ) {
	    pos += nextCode === plus || nextCode === minus ? 3 : 2;

	    while (pos < length) {
	      code = value.charCodeAt(pos);

	      if (code < 48 || code > 57) {
	        break;
	      }

	      pos += 1;
	    }
	  }

	  return {
	    number: value.slice(0, pos),
	    unit: value.slice(pos)
	  };
	};
	return unit;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	var parse = requireParse();
	var walk = requireWalk();
	var stringify = requireStringify();

	function ValueParser(value) {
	  if (this instanceof ValueParser) {
	    this.nodes = parse(value);
	    return this;
	  }
	  return new ValueParser(value);
	}

	ValueParser.prototype.toString = function() {
	  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
	};

	ValueParser.prototype.walk = function(cb, bubble) {
	  walk(this.nodes, cb, bubble);
	  return this;
	};

	ValueParser.unit = requireUnit();

	ValueParser.walk = walk;

	ValueParser.stringify = stringify;

	lib = ValueParser;
	return lib;
}

var gradient;
var hasRequiredGradient;

function requireGradient () {
	if (hasRequiredGradient) return gradient;
	hasRequiredGradient = 1;
	let range = requireNormalizeRange();
	let parser = requireLib();

	let OldValue = requireOldValue();
	let utils = requireUtils();
	let Value = requireValue();

	let IS_DIRECTION = /top|left|right|bottom/gi;

	class Gradient extends Value {
	  /**
	   * Do not add non-webkit prefixes for list-style and object
	   */
	  add(decl, prefix) {
	    let p = decl.prop;
	    if (p.includes('mask')) {
	      if (prefix === '-webkit-' || prefix === '-webkit- old') {
	        return super.add(decl, prefix)
	      }
	    } else if (
	      p === 'list-style' ||
	      p === 'list-style-image' ||
	      p === 'content'
	    ) {
	      if (prefix === '-webkit-' || prefix === '-webkit- old') {
	        return super.add(decl, prefix)
	      }
	    } else {
	      return super.add(decl, prefix)
	    }
	    return undefined
	  }

	  /**
	   * Get div token from exists parameters
	   */
	  cloneDiv(params) {
	    for (let i of params) {
	      if (i.type === 'div' && i.value === ',') {
	        return i
	      }
	    }
	    return { after: ' ', type: 'div', value: ',' }
	  }

	  /**
	   * Change colors syntax to old webkit
	   */
	  colorStops(params) {
	    let result = [];
	    for (let i = 0; i < params.length; i++) {
	      let pos;
	      let param = params[i];
	      let item;
	      if (i === 0) {
	        continue
	      }

	      let color = parser.stringify(param[0]);
	      if (param[1] && param[1].type === 'word') {
	        pos = param[1].value;
	      } else if (param[2] && param[2].type === 'word') {
	        pos = param[2].value;
	      }

	      let stop;
	      if (i === 1 && (!pos || pos === '0%')) {
	        stop = `from(${color})`;
	      } else if (i === params.length - 1 && (!pos || pos === '100%')) {
	        stop = `to(${color})`;
	      } else if (pos) {
	        stop = `color-stop(${pos}, ${color})`;
	      } else {
	        stop = `color-stop(${color})`;
	      }

	      let div = param[param.length - 1];
	      params[i] = [{ type: 'word', value: stop }];
	      if (div.type === 'div' && div.value === ',') {
	        item = params[i].push(div);
	      }
	      result.push(item);
	    }
	    return result
	  }

	  /**
	   * Change new direction to old
	   */
	  convertDirection(params) {
	    if (params.length > 0) {
	      if (params[0].value === 'to') {
	        this.fixDirection(params);
	      } else if (params[0].value.includes('deg')) {
	        this.fixAngle(params);
	      } else if (this.isRadial(params)) {
	        this.fixRadial(params);
	      }
	    }
	    return params
	  }

	  /**
	   * Add 90 degrees
	   */
	  fixAngle(params) {
	    let first = params[0].value;
	    first = parseFloat(first);
	    first = Math.abs(450 - first) % 360;
	    first = this.roundFloat(first, 3);
	    params[0].value = `${first}deg`;
	  }

	  /**
	   * Replace `to top left` to `bottom right`
	   */
	  fixDirection(params) {
	    params.splice(0, 2);

	    for (let param of params) {
	      if (param.type === 'div') {
	        break
	      }
	      if (param.type === 'word') {
	        param.value = this.revertDirection(param.value);
	      }
	    }
	  }

	  /**
	   * Fix radial direction syntax
	   */
	  fixRadial(params) {
	    let first = [];
	    let second = [];
	    let a, b, c, i, next;

	    for (i = 0; i < params.length - 2; i++) {
	      a = params[i];
	      b = params[i + 1];
	      c = params[i + 2];
	      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {
	        next = i + 3;
	        break
	      } else {
	        first.push(a);
	      }
	    }

	    let div;
	    for (i = next; i < params.length; i++) {
	      if (params[i].type === 'div') {
	        div = params[i];
	        break
	      } else {
	        second.push(params[i]);
	      }
	    }

	    params.splice(0, i, ...second, div, ...first);
	  }

	  /**
	   * Look for at word
	   */
	  isRadial(params) {
	    let state = 'before';
	    for (let param of params) {
	      if (state === 'before' && param.type === 'space') {
	        state = 'at';
	      } else if (state === 'at' && param.value === 'at') {
	        state = 'after';
	      } else if (state === 'after' && param.type === 'space') {
	        return true
	      } else if (param.type === 'div') {
	        break
	      } else {
	        state = 'before';
	      }
	    }
	    return false
	  }

	  /**
	   * Replace old direction to new
	   */
	  newDirection(params) {
	    if (params[0].value === 'to') {
	      return params
	    }
	    IS_DIRECTION.lastIndex = 0; // reset search index of global regexp
	    if (!IS_DIRECTION.test(params[0].value)) {
	      return params
	    }

	    params.unshift(
	      {
	        type: 'word',
	        value: 'to'
	      },
	      {
	        type: 'space',
	        value: ' '
	      }
	    );

	    for (let i = 2; i < params.length; i++) {
	      if (params[i].type === 'div') {
	        break
	      }
	      if (params[i].type === 'word') {
	        params[i].value = this.revertDirection(params[i].value);
	      }
	    }

	    return params
	  }

	  /**
	   * Normalize angle
	   */
	  normalize(nodes, gradientName) {
	    if (!nodes[0]) return nodes

	    if (/-?\d+(.\d+)?grad/.test(nodes[0].value)) {
	      nodes[0].value = this.normalizeUnit(nodes[0].value, 400);
	    } else if (/-?\d+(.\d+)?rad/.test(nodes[0].value)) {
	      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI);
	    } else if (/-?\d+(.\d+)?turn/.test(nodes[0].value)) {
	      nodes[0].value = this.normalizeUnit(nodes[0].value, 1);
	    } else if (nodes[0].value.includes('deg')) {
	      let num = parseFloat(nodes[0].value);
	      num = range.wrap(0, 360, num);
	      nodes[0].value = `${num}deg`;
	    }

	    if (
	      gradientName === 'linear-gradient' ||
	      gradientName === 'repeating-linear-gradient'
	    ) {
	      let direction = nodes[0].value;

	      // Unitless zero for `<angle>` values are allowed in CSS gradients and transforms.
	      // Spec: https://github.com/w3c/csswg-drafts/commit/602789171429b2231223ab1e5acf8f7f11652eb3
	      if (direction === '0deg' || direction === '0') {
	        nodes = this.replaceFirst(nodes, 'to', ' ', 'top');
	      } else if (direction === '90deg') {
	        nodes = this.replaceFirst(nodes, 'to', ' ', 'right');
	      } else if (direction === '180deg') {
	        nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom'); // default value
	      } else if (direction === '270deg') {
	        nodes = this.replaceFirst(nodes, 'to', ' ', 'left');
	      }
	    }

	    return nodes
	  }

	  /**
	   * Convert angle unit to deg
	   */
	  normalizeUnit(str, full) {
	    let num = parseFloat(str);
	    let deg = (num / full) * 360;
	    return `${deg}deg`
	  }

	  /**
	   * Remove old WebKit gradient too
	   */
	  old(prefix) {
	    if (prefix === '-webkit-') {
	      let type;
	      if (this.name === 'linear-gradient') {
	        type = 'linear';
	      } else if (this.name === 'repeating-linear-gradient') {
	        type = 'repeating-linear';
	      } else if (this.name === 'repeating-radial-gradient') {
	        type = 'repeating-radial';
	      } else {
	        type = 'radial';
	      }
	      let string = '-gradient';
	      let regexp = utils.regexp(
	        `-webkit-(${type}-gradient|gradient\\(\\s*${type})`,
	        false
	      );

	      return new OldValue(this.name, prefix + this.name, string, regexp)
	    } else {
	      return super.old(prefix)
	    }
	  }

	  /**
	   * Change direction syntax to old webkit
	   */
	  oldDirection(params) {
	    let div = this.cloneDiv(params[0]);

	    if (params[0][0].value !== 'to') {
	      return params.unshift([
	        { type: 'word', value: Gradient.oldDirections.bottom },
	        div
	      ])
	    } else {
	      let words = [];
	      for (let node of params[0].slice(2)) {
	        if (node.type === 'word') {
	          words.push(node.value.toLowerCase());
	        }
	      }

	      words = words.join(' ');
	      let old = Gradient.oldDirections[words] || words;

	      params[0] = [{ type: 'word', value: old }, div];
	      return params[0]
	    }
	  }

	  /**
	   * Convert to old webkit syntax
	   */
	  oldWebkit(node) {
	    let { nodes } = node;
	    let string = parser.stringify(node.nodes);

	    if (this.name !== 'linear-gradient') {
	      return false
	    }
	    if (nodes[0] && nodes[0].value.includes('deg')) {
	      return false
	    }
	    if (
	      string.includes('px') ||
	      string.includes('-corner') ||
	      string.includes('-side')
	    ) {
	      return false
	    }

	    let params = [[]];
	    for (let i of nodes) {
	      params[params.length - 1].push(i);
	      if (i.type === 'div' && i.value === ',') {
	        params.push([]);
	      }
	    }

	    this.oldDirection(params);
	    this.colorStops(params);

	    node.nodes = [];
	    for (let param of params) {
	      node.nodes = node.nodes.concat(param);
	    }

	    node.nodes.unshift(
	      { type: 'word', value: 'linear' },
	      this.cloneDiv(node.nodes)
	    );
	    node.value = '-webkit-gradient';

	    return true
	  }

	  /**
	   * Change degrees for webkit prefix
	   */
	  replace(string, prefix) {
	    let ast = parser(string);
	    for (let node of ast.nodes) {
	      let gradientName = this.name; // gradient name
	      if (node.type === 'function' && node.value === gradientName) {
	        node.nodes = this.newDirection(node.nodes);
	        node.nodes = this.normalize(node.nodes, gradientName);
	        if (prefix === '-webkit- old') {
	          let changes = this.oldWebkit(node);
	          if (!changes) {
	            return false
	          }
	        } else {
	          node.nodes = this.convertDirection(node.nodes);
	          node.value = prefix + node.value;
	        }
	      }
	    }
	    return ast.toString()
	  }

	  /**
	   * Replace first token
	   */
	  replaceFirst(params, ...words) {
	    let prefix = words.map(i => {
	      if (i === ' ') {
	        return { type: 'space', value: i }
	      }
	      return { type: 'word', value: i }
	    });
	    return prefix.concat(params.slice(1))
	  }

	  revertDirection(word) {
	    return Gradient.directions[word.toLowerCase()] || word
	  }

	  /**
	   * Round float and save digits under dot
	   */
	  roundFloat(float, digits) {
	    return parseFloat(float.toFixed(digits))
	  }
	}

	Gradient.names = [
	  'linear-gradient',
	  'repeating-linear-gradient',
	  'radial-gradient',
	  'repeating-radial-gradient'
	];

	Gradient.directions = {
	  bottom: 'top',
	  left: 'right',
	  right: 'left',
	  top: 'bottom' // default value
	};

	// Direction to replace
	Gradient.oldDirections = {
	  'bottom': 'left top, left bottom',
	  'bottom left': 'right top, left bottom',
	  'bottom right': 'left top, right bottom',
	  'left': 'right top, left top',

	  'left bottom': 'right top, left bottom',
	  'left top': 'right bottom, left top',
	  'right': 'left top, right top',
	  'right bottom': 'left top, right bottom',
	  'right top': 'left bottom, right top',
	  'top': 'left bottom, left top',
	  'top left': 'right bottom, left top',
	  'top right': 'left bottom, right top'
	};

	gradient = Gradient;
	return gradient;
}

var gridUtils = {};

var hasRequiredGridUtils;

function requireGridUtils () {
	if (hasRequiredGridUtils) return gridUtils;
	hasRequiredGridUtils = 1;
	let parser = requireLib();
	let list = requirePostcss().list;

	let uniq = requireUtils().uniq;
	let escapeRegexp = requireUtils().escapeRegexp;
	let splitSelector = requireUtils().splitSelector;

	function convert(value) {
	  if (
	    value &&
	    value.length === 2 &&
	    value[0] === 'span' &&
	    parseInt(value[1], 10) > 0
	  ) {
	    return [false, parseInt(value[1], 10)]
	  }

	  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {
	    return [parseInt(value[0], 10), false]
	  }

	  return [false, false]
	}

	gridUtils.translate = translate;

	function translate(values, startIndex, endIndex) {
	  let startValue = values[startIndex];
	  let endValue = values[endIndex];

	  if (!startValue) {
	    return [false, false]
	  }

	  let [start, spanStart] = convert(startValue);
	  let [end, spanEnd] = convert(endValue);

	  if (start && !endValue) {
	    return [start, false]
	  }

	  if (spanStart && end) {
	    return [end - spanStart, spanStart]
	  }

	  if (start && spanEnd) {
	    return [start, spanEnd]
	  }

	  if (start && end) {
	    return [start, end - start]
	  }

	  return [false, false]
	}

	gridUtils.parse = parse;

	function parse(decl) {
	  let node = parser(decl.value);

	  let values = [];
	  let current = 0;
	  values[current] = [];

	  for (let i of node.nodes) {
	    if (i.type === 'div') {
	      current += 1;
	      values[current] = [];
	    } else if (i.type === 'word') {
	      values[current].push(i.value);
	    }
	  }

	  return values
	}

	gridUtils.insertDecl = insertDecl;

	function insertDecl(decl, prop, value) {
	  if (value && !decl.parent.some(i => i.prop === `-ms-${prop}`)) {
	    decl.cloneBefore({
	      prop: `-ms-${prop}`,
	      value: value.toString()
	    });
	  }
	}

	// Track transforms

	gridUtils.prefixTrackProp = prefixTrackProp;

	function prefixTrackProp({ prefix, prop }) {
	  return prefix + prop.replace('template-', '')
	}

	function transformRepeat({ nodes }, { gap }) {
	  let { count, size } = nodes.reduce(
	    (result, node) => {
	      if (node.type === 'div' && node.value === ',') {
	        result.key = 'size';
	      } else {
	        result[result.key].push(parser.stringify(node));
	      }
	      return result
	    },
	    {
	      count: [],
	      key: 'count',
	      size: []
	    }
	  );

	  // insert gap values
	  if (gap) {
	    size = size.filter(i => i.trim());
	    let val = [];
	    for (let i = 1; i <= count; i++) {
	      size.forEach((item, index) => {
	        if (index > 0 || i > 1) {
	          val.push(gap);
	        }
	        val.push(item);
	      });
	    }

	    return val.join(' ')
	  }

	  return `(${size.join('')})[${count.join('')}]`
	}

	gridUtils.prefixTrackValue = prefixTrackValue;

	function prefixTrackValue({ gap, value }) {
	  let result = parser(value).nodes.reduce((nodes, node) => {
	    if (node.type === 'function' && node.value === 'repeat') {
	      return nodes.concat({
	        type: 'word',
	        value: transformRepeat(node, { gap })
	      })
	    }
	    if (gap && node.type === 'space') {
	      return nodes.concat(
	        {
	          type: 'space',
	          value: ' '
	        },
	        {
	          type: 'word',
	          value: gap
	        },
	        node
	      )
	    }
	    return nodes.concat(node)
	  }, []);

	  return parser.stringify(result)
	}

	// Parse grid-template-areas

	let DOTS = /^\.+$/;

	function track(start, end) {
	  return { end, span: end - start, start }
	}

	function getColumns(line) {
	  return line.trim().split(/\s+/g)
	}

	gridUtils.parseGridAreas = parseGridAreas;

	function parseGridAreas({ gap, rows }) {
	  return rows.reduce((areas, line, rowIndex) => {
	    if (gap.row) rowIndex *= 2;

	    if (line.trim() === '') return areas

	    getColumns(line).forEach((area, columnIndex) => {
	      if (DOTS.test(area)) return

	      if (gap.column) columnIndex *= 2;

	      if (typeof areas[area] === 'undefined') {
	        areas[area] = {
	          column: track(columnIndex + 1, columnIndex + 2),
	          row: track(rowIndex + 1, rowIndex + 2)
	        };
	      } else {
	        let { column, row } = areas[area];

	        column.start = Math.min(column.start, columnIndex + 1);
	        column.end = Math.max(column.end, columnIndex + 2);
	        column.span = column.end - column.start;

	        row.start = Math.min(row.start, rowIndex + 1);
	        row.end = Math.max(row.end, rowIndex + 2);
	        row.span = row.end - row.start;
	      }
	    });

	    return areas
	  }, {})
	}

	// Parse grid-template

	function testTrack(node) {
	  return node.type === 'word' && /^\[.+]$/.test(node.value)
	}

	function verifyRowSize(result) {
	  if (result.areas.length > result.rows.length) {
	    result.rows.push('auto');
	  }
	  return result
	}

	gridUtils.parseTemplate = parseTemplate;

	function parseTemplate({ decl, gap }) {
	  let gridTemplate = parser(decl.value).nodes.reduce(
	    (result, node) => {
	      let { type, value } = node;

	      if (testTrack(node) || type === 'space') return result

	      // area
	      if (type === 'string') {
	        result = verifyRowSize(result);
	        result.areas.push(value);
	      }

	      // values and function
	      if (type === 'word' || type === 'function') {
	        result[result.key].push(parser.stringify(node));
	      }

	      // divider(/)
	      if (type === 'div' && value === '/') {
	        result.key = 'columns';
	        result = verifyRowSize(result);
	      }

	      return result
	    },
	    {
	      areas: [],
	      columns: [],
	      key: 'rows',
	      rows: []
	    }
	  );

	  return {
	    areas: parseGridAreas({
	      gap,
	      rows: gridTemplate.areas
	    }),
	    columns: prefixTrackValue({
	      gap: gap.column,
	      value: gridTemplate.columns.join(' ')
	    }),
	    rows: prefixTrackValue({
	      gap: gap.row,
	      value: gridTemplate.rows.join(' ')
	    })
	  }
	}

	// Insert parsed grid areas

	/**
	 * Get an array of -ms- prefixed props and values
	 * @param  {Object} [area] area object with column and row data
	 * @param  {Boolean} [addRowSpan] should we add grid-column-row value?
	 * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?
	 * @return {Array<Object>}
	 */
	function getMSDecls(area, addRowSpan = false, addColumnSpan = false) {
	  let result = [
	    {
	      prop: '-ms-grid-row',
	      value: String(area.row.start)
	    }
	  ];
	  if (area.row.span > 1 || addRowSpan) {
	    result.push({
	      prop: '-ms-grid-row-span',
	      value: String(area.row.span)
	    });
	  }
	  result.push({
	    prop: '-ms-grid-column',
	    value: String(area.column.start)
	  });
	  if (area.column.span > 1 || addColumnSpan) {
	    result.push({
	      prop: '-ms-grid-column-span',
	      value: String(area.column.span)
	    });
	  }
	  return result
	}

	function getParentMedia(parent) {
	  if (parent.type === 'atrule' && parent.name === 'media') {
	    return parent
	  }
	  if (!parent.parent) {
	    return false
	  }
	  return getParentMedia(parent.parent)
	}

	/**
	 * change selectors for rules with duplicate grid-areas.
	 * @param  {Array<Rule>} rules
	 * @param  {Array<String>} templateSelectors
	 * @return {Array<Rule>} rules with changed selectors
	 */
	function changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {
	  ruleSelectors = ruleSelectors.map(selector => {
	    let selectorBySpace = list.space(selector);
	    let selectorByComma = list.comma(selector);

	    if (selectorBySpace.length > selectorByComma.length) {
	      selector = selectorBySpace.slice(-1).join('');
	    }
	    return selector
	  });

	  return ruleSelectors.map(ruleSelector => {
	    let newSelector = templateSelectors.map((tplSelector, index) => {
	      let space = index === 0 ? '' : ' ';
	      return `${space}${tplSelector} > ${ruleSelector}`
	    });

	    return newSelector
	  })
	}

	/**
	 * check if selector of rules are equal
	 * @param  {Rule} ruleA
	 * @param  {Rule} ruleB
	 * @return {Boolean}
	 */
	function selectorsEqual(ruleA, ruleB) {
	  return ruleA.selectors.some(sel => {
	    return ruleB.selectors.includes(sel)
	  })
	}

	/**
	 * Parse data from all grid-template(-areas) declarations
	 * @param  {Root} css css root
	 * @return {Object} parsed data
	 */
	function parseGridTemplatesData(css) {
	  let parsed = [];

	  // we walk through every grid-template(-areas) declaration and store
	  // data with the same area names inside the item
	  css.walkDecls(/grid-template(-areas)?$/, d => {
	    let rule = d.parent;
	    let media = getParentMedia(rule);
	    let gap = getGridGap(d);
	    let inheritedGap = inheritGridGap(d, gap);
	    let { areas } = parseTemplate({ decl: d, gap: inheritedGap || gap });
	    let areaNames = Object.keys(areas);

	    // skip node if it doesn't have areas
	    if (areaNames.length === 0) {
	      return true
	    }

	    // check parsed array for item that include the same area names
	    // return index of that item
	    let index = parsed.reduce((acc, { allAreas }, idx) => {
	      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area));
	      return hasAreas ? idx : acc
	    }, null);

	    if (index !== null) {
	      // index is found, add the grid-template data to that item
	      let { allAreas, rules } = parsed[index];

	      // check if rule has no duplicate area names
	      let hasNoDuplicates = rules.some(r => {
	        return r.hasDuplicates === false && selectorsEqual(r, rule)
	      });

	      let duplicatesFound = false;

	      // check need to gather all duplicate area names
	      let duplicateAreaNames = rules.reduce((acc, r) => {
	        if (!r.params && selectorsEqual(r, rule)) {
	          duplicatesFound = true;
	          return r.duplicateAreaNames
	        }
	        if (!duplicatesFound) {
	          areaNames.forEach(name => {
	            if (r.areas[name]) {
	              acc.push(name);
	            }
	          });
	        }
	        return uniq(acc)
	      }, []);

	      // update grid-row/column-span values for areas with duplicate
	      // area names. @see #1084 and #1146
	      rules.forEach(r => {
	        areaNames.forEach(name => {
	          let area = r.areas[name];
	          if (area && area.row.span !== areas[name].row.span) {
	            areas[name].row.updateSpan = true;
	          }

	          if (area && area.column.span !== areas[name].column.span) {
	            areas[name].column.updateSpan = true;
	          }
	        });
	      });

	      parsed[index].allAreas = uniq([...allAreas, ...areaNames]);
	      parsed[index].rules.push({
	        areas,
	        duplicateAreaNames,
	        hasDuplicates: !hasNoDuplicates,
	        node: rule,
	        params: media.params,
	        selectors: rule.selectors
	      });
	    } else {
	      // index is NOT found, push the new item to the parsed array
	      parsed.push({
	        allAreas: areaNames,
	        areasCount: 0,
	        rules: [
	          {
	            areas,
	            duplicateAreaNames: [],
	            duplicateRules: [],
	            hasDuplicates: false,
	            node: rule,
	            params: media.params,
	            selectors: rule.selectors
	          }
	        ]
	      });
	    }

	    return undefined
	  });

	  return parsed
	}

	/**
	 * insert prefixed grid-area declarations
	 * @param  {Root}  css css root
	 * @param  {Function} isDisabled check if the rule is disabled
	 * @return {void}
	 */
	gridUtils.insertAreas = insertAreas;

	function insertAreas(css, isDisabled) {
	  // parse grid-template declarations
	  let gridTemplatesData = parseGridTemplatesData(css);

	  // return undefined if no declarations found
	  if (gridTemplatesData.length === 0) {
	    return undefined
	  }

	  // we need to store the rules that we will insert later
	  let rulesToInsert = {};

	  css.walkDecls('grid-area', gridArea => {
	    let gridAreaRule = gridArea.parent;
	    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row';
	    let gridAreaMedia = getParentMedia(gridAreaRule);

	    if (isDisabled(gridArea)) {
	      return undefined
	    }

	    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule);

	    let value = gridArea.value;
	    // found the data that matches grid-area identifier
	    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0];

	    if (!data) {
	      return true
	    }

	    let lastArea = data.allAreas[data.allAreas.length - 1];
	    let selectorBySpace = list.space(gridAreaRule.selector);
	    let selectorByComma = list.comma(gridAreaRule.selector);
	    let selectorIsComplex =
	      selectorBySpace.length > 1 &&
	      selectorBySpace.length > selectorByComma.length;

	    // prevent doubling of prefixes
	    if (hasPrefixedRow) {
	      return false
	    }

	    // create the empty object with the key as the last area name
	    // e.g if we have templates with "a b c" values, "c" will be the last area
	    if (!rulesToInsert[lastArea]) {
	      rulesToInsert[lastArea] = {};
	    }

	    let lastRuleIsSet = false;

	    // walk through every grid-template rule data
	    for (let rule of data.rules) {
	      let area = rule.areas[value];
	      let hasDuplicateName = rule.duplicateAreaNames.includes(value);

	      // if we can't find the area name, update lastRule and continue
	      if (!area) {
	        let lastRule = rulesToInsert[lastArea].lastRule;
	        let lastRuleIndex;
	        if (lastRule) {
	          lastRuleIndex = css.index(lastRule);
	        } else {
	          /* c8 ignore next 2 */
	          lastRuleIndex = -1;
	        }

	        if (gridAreaRuleIndex > lastRuleIndex) {
	          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;
	        }
	        continue
	      }

	      // for grid-templates inside media rule we need to create empty
	      // array to push prefixed grid-area rules later
	      if (rule.params && !rulesToInsert[lastArea][rule.params]) {
	        rulesToInsert[lastArea][rule.params] = [];
	      }

	      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {
	        // grid-template has no duplicates and not inside media rule

	        getMSDecls(area, false, false)
	          .reverse()
	          .forEach(i =>
	            gridAreaRule.prepend(
	              Object.assign(i, {
	                raws: {
	                  between: gridArea.raws.between
	                }
	              })
	            )
	          );

	        rulesToInsert[lastArea].lastRule = gridAreaRule;
	        lastRuleIsSet = true;
	      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {
	        // grid-template has duplicates and not inside media rule
	        let cloned = gridAreaRule.clone();
	        cloned.removeAll();

	        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
	          .reverse()
	          .forEach(i =>
	            cloned.prepend(
	              Object.assign(i, {
	                raws: {
	                  between: gridArea.raws.between
	                }
	              })
	            )
	          );

	        cloned.selectors = changeDuplicateAreaSelectors(
	          cloned.selectors,
	          rule.selectors
	        );

	        if (rulesToInsert[lastArea].lastRule) {
	          rulesToInsert[lastArea].lastRule.after(cloned);
	        }
	        rulesToInsert[lastArea].lastRule = cloned;
	        lastRuleIsSet = true;
	      } else if (
	        rule.hasDuplicates &&
	        !rule.params &&
	        selectorIsComplex &&
	        gridAreaRule.selector.includes(rule.selectors[0])
	      ) {
	        // grid-template has duplicates and not inside media rule
	        // and the selector is complex
	        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove());
	        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
	          .reverse()
	          .forEach(i =>
	            gridAreaRule.prepend(
	              Object.assign(i, {
	                raws: {
	                  between: gridArea.raws.between
	                }
	              })
	            )
	          );
	      } else if (rule.params) {
	        // grid-template is inside media rule
	        // if we're inside media rule, we need to store prefixed rules
	        // inside rulesToInsert object to be able to preserve the order of media
	        // rules and merge them easily
	        let cloned = gridAreaRule.clone();
	        cloned.removeAll();

	        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
	          .reverse()
	          .forEach(i =>
	            cloned.prepend(
	              Object.assign(i, {
	                raws: {
	                  between: gridArea.raws.between
	                }
	              })
	            )
	          );

	        if (rule.hasDuplicates && hasDuplicateName) {
	          cloned.selectors = changeDuplicateAreaSelectors(
	            cloned.selectors,
	            rule.selectors
	          );
	        }

	        cloned.raws = rule.node.raws;

	        if (css.index(rule.node.parent) > gridAreaRuleIndex) {
	          // append the prefixed rules right inside media rule
	          // with grid-template
	          rule.node.parent.append(cloned);
	        } else {
	          // store the rule to insert later
	          rulesToInsert[lastArea][rule.params].push(cloned);
	        }

	        // set new rule as last rule ONLY if we didn't set lastRule for
	        // this grid-area before
	        if (!lastRuleIsSet) {
	          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;
	        }
	      }
	    }

	    return undefined
	  });

	  // append stored rules inside the media rules
	  Object.keys(rulesToInsert).forEach(area => {
	    let data = rulesToInsert[area];
	    let lastRule = data.lastRule;
	    Object.keys(data)
	      .reverse()
	      .filter(p => p !== 'lastRule')
	      .forEach(params => {
	        if (data[params].length > 0 && lastRule) {
	          lastRule.after({ name: 'media', params });
	          lastRule.next().append(data[params]);
	        }
	      });
	  });

	  return undefined
	}

	/**
	 * Warn user if grid area identifiers are not found
	 * @param  {Object} areas
	 * @param  {Declaration} decl
	 * @param  {Result} result
	 * @return {void}
	 */
	gridUtils.warnMissedAreas = warnMissedAreas;

	function warnMissedAreas(areas, decl, result) {
	  let missed = Object.keys(areas);

	  decl.root().walkDecls('grid-area', gridArea => {
	    missed = missed.filter(e => e !== gridArea.value);
	  });

	  if (missed.length > 0) {
	    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '));
	  }

	  return undefined
	}

	/**
	 * compare selectors with grid-area rule and grid-template rule
	 * show warning if grid-template selector is not found
	 * (this function used for grid-area rule)
	 * @param  {Declaration} decl
	 * @param  {Result} result
	 * @return {void}
	 */
	gridUtils.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound;

	function warnTemplateSelectorNotFound(decl, result) {
	  let rule = decl.parent;
	  let root = decl.root();
	  let duplicatesFound = false;

	  // slice selector array. Remove the last part (for comparison)
	  let slicedSelectorArr = list
	    .space(rule.selector)
	    .filter(str => str !== '>')
	    .slice(0, -1);

	  // we need to compare only if selector is complex.
	  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex
	  if (slicedSelectorArr.length > 0) {
	    let gridTemplateFound = false;
	    let foundAreaSelector = null;

	    root.walkDecls(/grid-template(-areas)?$/, d => {
	      let parent = d.parent;
	      let templateSelectors = parent.selectors;

	      let { areas } = parseTemplate({ decl: d, gap: getGridGap(d) });
	      let hasArea = areas[decl.value];

	      // find the the matching selectors
	      for (let tplSelector of templateSelectors) {
	        if (gridTemplateFound) {
	          break
	        }
	        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>');

	        gridTemplateFound = tplSelectorArr.every(
	          (item, idx) => item === slicedSelectorArr[idx]
	        );
	      }

	      if (gridTemplateFound || !hasArea) {
	        return true
	      }

	      if (!foundAreaSelector) {
	        foundAreaSelector = parent.selector;
	      }

	      // if we found the duplicate area with different selector
	      if (foundAreaSelector && foundAreaSelector !== parent.selector) {
	        duplicatesFound = true;
	      }

	      return undefined
	    });

	    // warn user if we didn't find template
	    if (!gridTemplateFound && duplicatesFound) {
	      decl.warn(
	        result,
	        'Autoprefixer cannot find a grid-template ' +
	          `containing the duplicate grid-area "${decl.value}" ` +
	          `with full selector matching: ${slicedSelectorArr.join(' ')}`
	      );
	    }
	  }
	}

	/**
	 * warn user if both grid-area and grid-(row|column)
	 * declarations are present in the same rule
	 * @param  {Declaration} decl
	 * @param  {Result} result
	 * @return {void}
	 */
	gridUtils.warnIfGridRowColumnExists = warnIfGridRowColumnExists;

	function warnIfGridRowColumnExists(decl, result) {
	  let rule = decl.parent;
	  let decls = [];
	  rule.walkDecls(/^grid-(row|column)/, d => {
	    if (
	      !d.prop.endsWith('-end') &&
	      !d.value.startsWith('span') &&
	      !d.prop.endsWith('-gap')
	    ) {
	      decls.push(d);
	    }
	  });
	  if (decls.length > 0) {
	    decls.forEach(d => {
	      d.warn(
	        result,
	        'You already have a grid-area declaration present in the rule. ' +
	          `You should use either grid-area or ${d.prop}, not both`
	      );
	    });
	  }

	  return undefined
	}

	// Gap utils

	gridUtils.getGridGap = getGridGap;

	function getGridGap(decl) {
	  let gap = {};

	  // try to find gap
	  let testGap = /^(grid-)?((row|column)-)?gap$/;
	  decl.parent.walkDecls(testGap, ({ prop, value }) => {
	    if (/^(grid-)?gap$/.test(prop)) {
	      let [row, , column] = parser(value).nodes;

	      gap.row = row && parser.stringify(row);
	      gap.column = column ? parser.stringify(column) : gap.row;
	    }
	    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value;
	    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value;
	  });

	  return gap
	}

	/**
	 * parse media parameters (for example 'min-width: 500px')
	 * @param  {String} params parameter to parse
	 * @return {}
	 */
	function parseMediaParams(params) {
	  if (!params) {
	    return []
	  }
	  let parsed = parser(params);
	  let prop;
	  let value;

	  parsed.walk(node => {
	    if (node.type === 'word' && /min|max/g.test(node.value)) {
	      prop = node.value;
	    } else if (node.value.includes('px')) {
	      value = parseInt(node.value.replace(/\D/g, ''));
	    }
	  });

	  return [prop, value]
	}

	/**
	 * Compare the selectors and decide if we
	 * need to inherit gap from compared selector or not.
	 * @type {String} selA
	 * @type {String} selB
	 * @return {Boolean}
	 */
	function shouldInheritGap(selA, selB) {
	  let result;

	  // get arrays of selector split in 3-deep array
	  let splitSelectorArrA = splitSelector(selA);
	  let splitSelectorArrB = splitSelector(selB);

	  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {
	    // abort if selectorA has lower descendant specificity then selectorB
	    // (e.g '.grid' and '.hello .world .grid')
	    return false
	  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {
	    // if selectorA has higher descendant specificity then selectorB
	    // (e.g '.foo .bar .grid' and '.grid')

	    let idx = splitSelectorArrA[0].reduce((res, [item], index) => {
	      let firstSelectorPart = splitSelectorArrB[0][0][0];
	      if (item === firstSelectorPart) {
	        return index
	      }
	      return false
	    }, false);

	    if (idx) {
	      result = splitSelectorArrB[0].every((arr, index) => {
	        return arr.every(
	          (part, innerIndex) =>
	            // because selectorA has more space elements, we need to slice
	            // selectorA array by 'idx' number to compare them
	            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part
	        )
	      });
	    }
	  } else {
	    // if selectorA has the same descendant specificity as selectorB
	    // this condition covers cases such as: '.grid.foo.bar' and '.grid'
	    result = splitSelectorArrB.some(byCommaArr => {
	      return byCommaArr.every((bySpaceArr, index) => {
	        return bySpaceArr.every(
	          (part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part
	        )
	      })
	    });
	  }

	  return result
	}
	/**
	 * inherit grid gap values from the closest rule above
	 * with the same selector
	 * @param  {Declaration} decl
	 * @param  {Object} gap gap values
	 * @return {Object | Boolean} return gap values or false (if not found)
	 */
	gridUtils.inheritGridGap = inheritGridGap;

	function inheritGridGap(decl, gap) {
	  let rule = decl.parent;
	  let mediaRule = getParentMedia(rule);
	  let root = rule.root();

	  // get an array of selector split in 3-deep array
	  let splitSelectorArr = splitSelector(rule.selector);

	  // abort if the rule already has gaps
	  if (Object.keys(gap).length > 0) {
	    return false
	  }

	  // e.g ['min-width']
	  let [prop] = parseMediaParams(mediaRule.params);

	  let lastBySpace = splitSelectorArr[0];

	  // get escaped value from the selector
	  // if we have '.grid-2.foo.bar' selector, will be '\.grid\-2'
	  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);

	  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`);

	  // find the closest rule with the same selector
	  let closestRuleGap;
	  root.walkRules(regexp, r => {
	    let gridGap;

	    // abort if are checking the same rule
	    if (rule.toString() === r.toString()) {
	      return false
	    }

	    // find grid-gap values
	    r.walkDecls('grid-gap', d => (gridGap = getGridGap(d)));

	    // skip rule without gaps
	    if (!gridGap || Object.keys(gridGap).length === 0) {
	      return true
	    }

	    // skip rules that should not be inherited from
	    if (!shouldInheritGap(rule.selector, r.selector)) {
	      return true
	    }

	    let media = getParentMedia(r);
	    if (media) {
	      // if we are inside media, we need to check that media props match
	      // e.g ('min-width' === 'min-width')
	      let propToCompare = parseMediaParams(media.params)[0];
	      if (propToCompare === prop) {
	        closestRuleGap = gridGap;
	        return true
	      }
	    } else {
	      closestRuleGap = gridGap;
	      return true
	    }

	    return undefined
	  });

	  // if we find the closest gap object
	  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {
	    return closestRuleGap
	  }
	  return false
	}

	gridUtils.warnGridGap = warnGridGap;

	function warnGridGap({ decl, gap, hasColumns, result }) {
	  let hasBothGaps = gap.row && gap.column;
	  if (!hasColumns && (hasBothGaps || (gap.column && !gap.row))) {
	    delete gap.column;
	    decl.warn(
	      result,
	      'Can not implement grid-gap without grid-template-columns'
	    );
	  }
	}

	/**
	 * normalize the grid-template-rows/columns values
	 * @param  {String} str grid-template-rows/columns value
	 * @return {Array} normalized array with values
	 * @example
	 * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')
	 * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']
	 */
	function normalizeRowColumn(str) {
	  let normalized = parser(str).nodes.reduce((result, node) => {
	    if (node.type === 'function' && node.value === 'repeat') {
	      let key = 'count';

	      let [count, value] = node.nodes.reduce(
	        (acc, n) => {
	          if (n.type === 'word' && key === 'count') {
	            acc[0] = Math.abs(parseInt(n.value));
	            return acc
	          }
	          if (n.type === 'div' && n.value === ',') {
	            key = 'value';
	            return acc
	          }
	          if (key === 'value') {
	            acc[1] += parser.stringify(n);
	          }
	          return acc
	        },
	        [0, '']
	      );

	      if (count) {
	        for (let i = 0; i < count; i++) {
	          result.push(value);
	        }
	      }

	      return result
	    }
	    if (node.type === 'space') {
	      return result
	    }
	    return result.concat(parser.stringify(node))
	  }, []);

	  return normalized
	}

	gridUtils.autoplaceGridItems = autoplaceGridItems;

	/**
	 * Autoplace grid items
	 * @param {Declaration} decl
	 * @param {Result} result
	 * @param {Object} gap gap values
	 * @param {String} autoflowValue grid-auto-flow value
	 * @return {void}
	 * @see https://github.com/postcss/autoprefixer/issues/1148
	 */
	function autoplaceGridItems(decl, result, gap, autoflowValue = 'row') {
	  let { parent } = decl;

	  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows');
	  let rows = normalizeRowColumn(rowDecl.value);
	  let columns = normalizeRowColumn(decl.value);

	  // Build array of area names with dummy values. If we have 3 columns and
	  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']
	  let filledRows = rows.map((_, rowIndex) => {
	    return Array.from(
	      { length: columns.length },
	      (v, k) => k + rowIndex * columns.length + 1
	    ).join(' ')
	  });

	  let areas = parseGridAreas({ gap, rows: filledRows });
	  let keys = Object.keys(areas);
	  let items = keys.map(i => areas[i]);

	  // Change the order of cells if grid-auto-flow value is 'column'
	  if (autoflowValue.includes('column')) {
	    items = items.sort((a, b) => a.column.start - b.column.start);
	  }

	  // Insert new rules
	  items.reverse().forEach((item, index) => {
	    let { column, row } = item;
	    let nodeSelector = parent.selectors
	      .map(sel => sel + ` > *:nth-child(${keys.length - index})`)
	      .join(', ');

	    // create new rule
	    let node = parent.clone().removeAll();

	    // change rule selector
	    node.selector = nodeSelector;

	    // insert prefixed row/column values
	    node.append({ prop: '-ms-grid-row', value: row.start });
	    node.append({ prop: '-ms-grid-column', value: column.start });

	    // insert rule
	    parent.after(node);
	  });

	  return undefined
	}
	return gridUtils;
}

var gridArea;
var hasRequiredGridArea;

function requireGridArea () {
	if (hasRequiredGridArea) return gridArea;
	hasRequiredGridArea = 1;
	let Declaration = requireDeclaration();
	let utils = requireGridUtils();

	class GridArea extends Declaration {
	  /**
	   * Translate grid-area to separate -ms- prefixed properties
	   */
	  insert(decl, prefix, prefixes, result) {
	    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

	    let values = utils.parse(decl);

	    let [rowStart, rowSpan] = utils.translate(values, 0, 2);
	    let [columnStart, columnSpan] = utils.translate(values, 1, 3)

	    ;[
	      ['grid-row', rowStart],
	      ['grid-row-span', rowSpan],
	      ['grid-column', columnStart],
	      ['grid-column-span', columnSpan]
	    ].forEach(([prop, value]) => {
	      utils.insertDecl(decl, prop, value);
	    });

	    utils.warnTemplateSelectorNotFound(decl, result);
	    utils.warnIfGridRowColumnExists(decl, result);

	    return undefined
	  }
	}

	GridArea.names = ['grid-area'];

	gridArea = GridArea;
	return gridArea;
}

var gridColumnAlign;
var hasRequiredGridColumnAlign;

function requireGridColumnAlign () {
	if (hasRequiredGridColumnAlign) return gridColumnAlign;
	hasRequiredGridColumnAlign = 1;
	let Declaration = requireDeclaration();

	class GridColumnAlign extends Declaration {
	  /**
	   * Do not prefix flexbox values
	   */
	  check(decl) {
	    return !decl.value.includes('flex-') && decl.value !== 'baseline'
	  }

	  /**
	   * Change IE property back
	   */
	  normalize() {
	    return 'justify-self'
	  }

	  /**
	   * Change property name for IE
	   */
	  prefixed(prop, prefix) {
	    return prefix + 'grid-column-align'
	  }
	}

	GridColumnAlign.names = ['grid-column-align'];

	gridColumnAlign = GridColumnAlign;
	return gridColumnAlign;
}

var gridEnd;
var hasRequiredGridEnd;

function requireGridEnd () {
	if (hasRequiredGridEnd) return gridEnd;
	hasRequiredGridEnd = 1;
	let Declaration = requireDeclaration();
	let { isPureNumber } = requireUtils();

	class GridEnd extends Declaration {
	  /**
	   * Change repeating syntax for IE
	   */
	  insert(decl, prefix, prefixes, result) {
	    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

	    let clonedDecl = this.clone(decl);

	    let startProp = decl.prop.replace(/end$/, 'start');
	    let spanProp = prefix + decl.prop.replace(/end$/, 'span');

	    if (decl.parent.some(i => i.prop === spanProp)) {
	      return undefined
	    }

	    clonedDecl.prop = spanProp;

	    if (decl.value.includes('span')) {
	      clonedDecl.value = decl.value.replace(/span\s/i, '');
	    } else {
	      let startDecl;
	      decl.parent.walkDecls(startProp, d => {
	        startDecl = d;
	      });
	      if (startDecl) {
	        if (isPureNumber(startDecl.value)) {
	          let value = Number(decl.value) - Number(startDecl.value) + '';
	          clonedDecl.value = value;
	        } else {
	          return undefined
	        }
	      } else {
	        decl.warn(
	          result,
	          `Can not prefix ${decl.prop} (${startProp} is not found)`
	        );
	      }
	    }

	    decl.cloneBefore(clonedDecl);

	    return undefined
	  }
	}

	GridEnd.names = ['grid-row-end', 'grid-column-end'];

	gridEnd = GridEnd;
	return gridEnd;
}

var gridRowAlign;
var hasRequiredGridRowAlign;

function requireGridRowAlign () {
	if (hasRequiredGridRowAlign) return gridRowAlign;
	hasRequiredGridRowAlign = 1;
	let Declaration = requireDeclaration();

	class GridRowAlign extends Declaration {
	  /**
	   * Do not prefix flexbox values
	   */
	  check(decl) {
	    return !decl.value.includes('flex-') && decl.value !== 'baseline'
	  }

	  /**
	   * Change IE property back
	   */
	  normalize() {
	    return 'align-self'
	  }

	  /**
	   * Change property name for IE
	   */
	  prefixed(prop, prefix) {
	    return prefix + 'grid-row-align'
	  }
	}

	GridRowAlign.names = ['grid-row-align'];

	gridRowAlign = GridRowAlign;
	return gridRowAlign;
}

var gridRowColumn;
var hasRequiredGridRowColumn;

function requireGridRowColumn () {
	if (hasRequiredGridRowColumn) return gridRowColumn;
	hasRequiredGridRowColumn = 1;
	let Declaration = requireDeclaration();
	let utils = requireGridUtils();

	class GridRowColumn extends Declaration {
	  /**
	   * Translate grid-row / grid-column to separate -ms- prefixed properties
	   */
	  insert(decl, prefix, prefixes) {
	    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

	    let values = utils.parse(decl);
	    let [start, span] = utils.translate(values, 0, 1);

	    let hasStartValueSpan = values[0] && values[0].includes('span');

	    if (hasStartValueSpan) {
	      span = values[0].join('').replace(/\D/g, '');
	    }
[
	      [decl.prop, start],
	      [`${decl.prop}-span`, span]
	    ].forEach(([prop, value]) => {
	      utils.insertDecl(decl, prop, value);
	    });

	    return undefined
	  }
	}

	GridRowColumn.names = ['grid-row', 'grid-column'];

	gridRowColumn = GridRowColumn;
	return gridRowColumn;
}

var processor;
var hasRequiredProcessor;

function requireProcessor () {
	if (hasRequiredProcessor) return processor;
	hasRequiredProcessor = 1;
	let parser = requireLib();

	let Value = requireValue();
	let insertAreas = requireGridUtils().insertAreas;

	const OLD_LINEAR = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i;
	const OLD_RADIAL = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i;
	const IGNORE_NEXT = /(!\s*)?autoprefixer:\s*ignore\s+next/i;
	const GRID_REGEX = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i;

	const SIZES = [
	  'width',
	  'height',
	  'min-width',
	  'max-width',
	  'min-height',
	  'max-height',
	  'inline-size',
	  'min-inline-size',
	  'max-inline-size',
	  'block-size',
	  'min-block-size',
	  'max-block-size'
	];

	function hasGridTemplate(decl) {
	  return decl.parent.some(
	    i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'
	  )
	}

	function hasRowsAndColumns(decl) {
	  let hasRows = decl.parent.some(i => i.prop === 'grid-template-rows');
	  let hasColumns = decl.parent.some(i => i.prop === 'grid-template-columns');
	  return hasRows && hasColumns
	}

	class Processor {
	  constructor(prefixes) {
	    this.prefixes = prefixes;
	  }

	  /**
	   * Add necessary prefixes
	   */
	  add(css, result) {
	    // At-rules
	    let resolution = this.prefixes.add['@resolution'];
	    let keyframes = this.prefixes.add['@keyframes'];
	    let viewport = this.prefixes.add['@viewport'];
	    let supports = this.prefixes.add['@supports'];

	    css.walkAtRules(rule => {
	      if (rule.name === 'keyframes') {
	        if (!this.disabled(rule, result)) {
	          return keyframes && keyframes.process(rule)
	        }
	      } else if (rule.name === 'viewport') {
	        if (!this.disabled(rule, result)) {
	          return viewport && viewport.process(rule)
	        }
	      } else if (rule.name === 'supports') {
	        if (
	          this.prefixes.options.supports !== false &&
	          !this.disabled(rule, result)
	        ) {
	          return supports.process(rule)
	        }
	      } else if (rule.name === 'media' && rule.params.includes('-resolution')) {
	        if (!this.disabled(rule, result)) {
	          return resolution && resolution.process(rule)
	        }
	      }

	      return undefined
	    });

	    // Selectors
	    css.walkRules(rule => {
	      if (this.disabled(rule, result)) return undefined

	      return this.prefixes.add.selectors.map(selector => {
	        return selector.process(rule, result)
	      })
	    });

	    function insideGrid(decl) {
	      return decl.parent.nodes.some(node => {
	        if (node.type !== 'decl') return false
	        let displayGrid =
	          node.prop === 'display' && /(inline-)?grid/.test(node.value);
	        let gridTemplate = node.prop.startsWith('grid-template');
	        let gridGap = /^grid-([A-z]+-)?gap/.test(node.prop);
	        return displayGrid || gridTemplate || gridGap
	      })
	    }

	    let gridPrefixes =
	      this.gridStatus(css, result) &&
	      this.prefixes.add['grid-area'] &&
	      this.prefixes.add['grid-area'].prefixes;

	    css.walkDecls(decl => {
	      if (this.disabledDecl(decl, result)) return undefined

	      let parent = decl.parent;
	      let prop = decl.prop;
	      let value = decl.value;

	      if (prop === 'color-adjust') {
	        if (parent.every(i => i.prop !== 'print-color-adjust')) {
	          result.warn(
	            'Replace color-adjust to print-color-adjust. ' +
	              'The color-adjust shorthand is currently deprecated.',
	            { node: decl }
	          );
	        }
	      } else if (prop === 'grid-row-span') {
	        result.warn(
	          'grid-row-span is not part of final Grid Layout. Use grid-row.',
	          { node: decl }
	        );
	        return undefined
	      } else if (prop === 'grid-column-span') {
	        result.warn(
	          'grid-column-span is not part of final Grid Layout. Use grid-column.',
	          { node: decl }
	        );
	        return undefined
	      } else if (prop === 'display' && value === 'box') {
	        result.warn(
	          'You should write display: flex by final spec ' +
	            'instead of display: box',
	          { node: decl }
	        );
	        return undefined
	      } else if (prop === 'text-emphasis-position') {
	        if (value === 'under' || value === 'over') {
	          result.warn(
	            'You should use 2 values for text-emphasis-position ' +
	              'For example, `under left` instead of just `under`.',
	            { node: decl }
	          );
	        }
	      } else if (prop === 'text-decoration-skip' && value === 'ink') {
	        result.warn(
	          'Replace text-decoration-skip: ink to ' +
	            'text-decoration-skip-ink: auto, because spec had been changed',
	          { node: decl }
	        );
	      } else {
	        if (gridPrefixes && this.gridStatus(decl, result)) {
	          if (decl.value === 'subgrid') {
	            result.warn('IE does not support subgrid', { node: decl });
	          }
	          if (/^(align|justify|place)-items$/.test(prop) && insideGrid(decl)) {
	            let fixed = prop.replace('-items', '-self');
	            result.warn(
	              `IE does not support ${prop} on grid containers. ` +
	                `Try using ${fixed} on child elements instead: ` +
	                `${decl.parent.selector} > * { ${fixed}: ${decl.value} }`,
	              { node: decl }
	            );
	          } else if (
	            /^(align|justify|place)-content$/.test(prop) &&
	            insideGrid(decl)
	          ) {
	            result.warn(`IE does not support ${decl.prop} on grid containers`, {
	              node: decl
	            });
	          } else if (prop === 'display' && decl.value === 'contents') {
	            result.warn(
	              'Please do not use display: contents; ' +
	                'if you have grid setting enabled',
	              { node: decl }
	            );
	            return undefined
	          } else if (decl.prop === 'grid-gap') {
	            let status = this.gridStatus(decl, result);
	            if (
	              status === 'autoplace' &&
	              !hasRowsAndColumns(decl) &&
	              !hasGridTemplate(decl)
	            ) {
	              result.warn(
	                'grid-gap only works if grid-template(-areas) is being ' +
	                  'used or both rows and columns have been declared ' +
	                  'and cells have not been manually ' +
	                  'placed inside the explicit grid',
	                { node: decl }
	              );
	            } else if (
	              (status === true || status === 'no-autoplace') &&
	              !hasGridTemplate(decl)
	            ) {
	              result.warn(
	                'grid-gap only works if grid-template(-areas) is being used',
	                { node: decl }
	              );
	            }
	          } else if (prop === 'grid-auto-columns') {
	            result.warn('grid-auto-columns is not supported by IE', {
	              node: decl
	            });
	            return undefined
	          } else if (prop === 'grid-auto-rows') {
	            result.warn('grid-auto-rows is not supported by IE', { node: decl });
	            return undefined
	          } else if (prop === 'grid-auto-flow') {
	            let hasRows = parent.some(i => i.prop === 'grid-template-rows');
	            let hasCols = parent.some(i => i.prop === 'grid-template-columns');

	            if (hasGridTemplate(decl)) {
	              result.warn('grid-auto-flow is not supported by IE', {
	                node: decl
	              });
	            } else if (value.includes('dense')) {
	              result.warn('grid-auto-flow: dense is not supported by IE', {
	                node: decl
	              });
	            } else if (!hasRows && !hasCols) {
	              result.warn(
	                'grid-auto-flow works only if grid-template-rows and ' +
	                  'grid-template-columns are present in the same rule',
	                { node: decl }
	              );
	            }
	            return undefined
	          } else if (value.includes('auto-fit')) {
	            result.warn('auto-fit value is not supported by IE', {
	              node: decl,
	              word: 'auto-fit'
	            });
	            return undefined
	          } else if (value.includes('auto-fill')) {
	            result.warn('auto-fill value is not supported by IE', {
	              node: decl,
	              word: 'auto-fill'
	            });
	            return undefined
	          } else if (prop.startsWith('grid-template') && value.includes('[')) {
	            result.warn(
	              'Autoprefixer currently does not support line names. ' +
	                'Try using grid-template-areas instead.',
	              { node: decl, word: '[' }
	            );
	          }
	        }
	        if (value.includes('radial-gradient')) {
	          if (OLD_RADIAL.test(decl.value)) {
	            result.warn(
	              'Gradient has outdated direction syntax. ' +
	                'New syntax is like `closest-side at 0 0` ' +
	                'instead of `0 0, closest-side`.',
	              { node: decl }
	            );
	          } else {
	            let ast = parser(value);

	            for (let i of ast.nodes) {
	              if (i.type === 'function' && i.value === 'radial-gradient') {
	                for (let word of i.nodes) {
	                  if (word.type === 'word') {
	                    if (word.value === 'cover') {
	                      result.warn(
	                        'Gradient has outdated direction syntax. ' +
	                          'Replace `cover` to `farthest-corner`.',
	                        { node: decl }
	                      );
	                    } else if (word.value === 'contain') {
	                      result.warn(
	                        'Gradient has outdated direction syntax. ' +
	                          'Replace `contain` to `closest-side`.',
	                        { node: decl }
	                      );
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	        if (value.includes('linear-gradient')) {
	          if (OLD_LINEAR.test(value)) {
	            result.warn(
	              'Gradient has outdated direction syntax. ' +
	                'New syntax is like `to left` instead of `right`.',
	              { node: decl }
	            );
	          }
	        }
	      }

	      if (SIZES.includes(decl.prop)) {
	        if (!decl.value.includes('-fill-available')) {
	          if (decl.value.includes('fill-available')) {
	            result.warn(
	              'Replace fill-available to stretch, ' +
	                'because spec had been changed',
	              { node: decl }
	            );
	          } else if (decl.value.includes('fill')) {
	            let ast = parser(value);
	            if (ast.nodes.some(i => i.type === 'word' && i.value === 'fill')) {
	              result.warn(
	                'Replace fill to stretch, because spec had been changed',
	                { node: decl }
	              );
	            }
	          }
	        }
	      }

	      let prefixer;

	      if (decl.prop === 'transition' || decl.prop === 'transition-property') {
	        // Transition
	        return this.prefixes.transition.add(decl, result)
	      } else if (decl.prop === 'align-self') {
	        // align-self flexbox or grid
	        let display = this.displayType(decl);
	        if (display !== 'grid' && this.prefixes.options.flexbox !== false) {
	          prefixer = this.prefixes.add['align-self'];
	          if (prefixer && prefixer.prefixes) {
	            prefixer.process(decl);
	          }
	        }
	        if (this.gridStatus(decl, result) !== false) {
	          prefixer = this.prefixes.add['grid-row-align'];
	          if (prefixer && prefixer.prefixes) {
	            return prefixer.process(decl, result)
	          }
	        }
	      } else if (decl.prop === 'justify-self') {
	        // justify-self flexbox or grid
	        if (this.gridStatus(decl, result) !== false) {
	          prefixer = this.prefixes.add['grid-column-align'];
	          if (prefixer && prefixer.prefixes) {
	            return prefixer.process(decl, result)
	          }
	        }
	      } else if (decl.prop === 'place-self') {
	        prefixer = this.prefixes.add['place-self'];
	        if (
	          prefixer &&
	          prefixer.prefixes &&
	          this.gridStatus(decl, result) !== false
	        ) {
	          return prefixer.process(decl, result)
	        }
	      } else {
	        // Properties
	        prefixer = this.prefixes.add[decl.prop];
	        if (prefixer && prefixer.prefixes) {
	          return prefixer.process(decl, result)
	        }
	      }

	      return undefined
	    });

	    // Insert grid-area prefixes. We need to be able to store the different
	    // rules as a data and hack API is not enough for this
	    if (this.gridStatus(css, result)) {
	      insertAreas(css, this.disabled);
	    }

	    // Values
	    return css.walkDecls(decl => {
	      if (this.disabledValue(decl, result)) return

	      let unprefixed = this.prefixes.unprefixed(decl.prop);
	      let list = this.prefixes.values('add', unprefixed);
	      if (Array.isArray(list)) {
	        for (let value of list) {
	          if (value.process) value.process(decl, result);
	        }
	      }
	      Value.save(this.prefixes, decl);
	    })
	  }

	  /**
	   * Check for control comment and global options
	   */
	  disabled(node, result) {
	    if (!node) return false

	    if (node._autoprefixerDisabled !== undefined) {
	      return node._autoprefixerDisabled
	    }

	    if (node.parent) {
	      let p = node.prev();
	      if (p && p.type === 'comment' && IGNORE_NEXT.test(p.text)) {
	        node._autoprefixerDisabled = true;
	        node._autoprefixerSelfDisabled = true;
	        return true
	      }
	    }

	    let value = null;
	    if (node.nodes) {
	      let status;
	      node.each(i => {
	        if (i.type !== 'comment') return
	        if (/(!\s*)?autoprefixer:\s*(off|on)/i.test(i.text)) {
	          if (typeof status !== 'undefined') {
	            result.warn(
	              'Second Autoprefixer control comment ' +
	                'was ignored. Autoprefixer applies control ' +
	                'comment to whole block, not to next rules.',
	              { node: i }
	            );
	          } else {
	            status = /on/i.test(i.text);
	          }
	        }
	      });

	      if (status !== undefined) {
	        value = !status;
	      }
	    }
	    if (!node.nodes || value === null) {
	      if (node.parent) {
	        let isParentDisabled = this.disabled(node.parent, result);
	        if (node.parent._autoprefixerSelfDisabled === true) {
	          value = false;
	        } else {
	          value = isParentDisabled;
	        }
	      } else {
	        value = false;
	      }
	    }
	    node._autoprefixerDisabled = value;
	    return value
	  }

	  /**
	   * Check for grid/flexbox options.
	   */
	  disabledDecl(node, result) {
	    if (node.type === 'decl' && this.gridStatus(node, result) === false) {
	      if (node.prop.includes('grid') || node.prop === 'justify-items') {
	        return true
	      }
	    }
	    if (node.type === 'decl' && this.prefixes.options.flexbox === false) {
	      let other = ['order', 'justify-content', 'align-items', 'align-content'];
	      if (node.prop.includes('flex') || other.includes(node.prop)) {
	        return true
	      }
	    }

	    return this.disabled(node, result)
	  }

	  /**
	   * Check for grid/flexbox options.
	   */
	  disabledValue(node, result) {
	    if (this.gridStatus(node, result) === false && node.type === 'decl') {
	      if (node.prop === 'display' && node.value.includes('grid')) {
	        return true
	      }
	    }
	    if (this.prefixes.options.flexbox === false && node.type === 'decl') {
	      if (node.prop === 'display' && node.value.includes('flex')) {
	        return true
	      }
	    }
	    if (node.type === 'decl' && node.prop === 'content') {
	      return true
	    }

	    return this.disabled(node, result)
	  }

	  /**
	   * Is it flebox or grid rule
	   */
	  displayType(decl) {
	    for (let i of decl.parent.nodes) {
	      if (i.prop !== 'display') {
	        continue
	      }

	      if (i.value.includes('flex')) {
	        return 'flex'
	      }

	      if (i.value.includes('grid')) {
	        return 'grid'
	      }
	    }

	    return false
	  }

	  /**
	   * Set grid option via control comment
	   */
	  gridStatus(node, result) {
	    if (!node) return false

	    if (node._autoprefixerGridStatus !== undefined) {
	      return node._autoprefixerGridStatus
	    }

	    let value = null;
	    if (node.nodes) {
	      let status;
	      node.each(i => {
	        if (i.type !== 'comment') return
	        if (GRID_REGEX.test(i.text)) {
	          let hasAutoplace = /:\s*autoplace/i.test(i.text);
	          let noAutoplace = /no-autoplace/i.test(i.text);
	          if (typeof status !== 'undefined') {
	            result.warn(
	              'Second Autoprefixer grid control comment was ' +
	                'ignored. Autoprefixer applies control comments to the whole ' +
	                'block, not to the next rules.',
	              { node: i }
	            );
	          } else if (hasAutoplace) {
	            status = 'autoplace';
	          } else if (noAutoplace) {
	            status = true;
	          } else {
	            status = /on/i.test(i.text);
	          }
	        }
	      });

	      if (status !== undefined) {
	        value = status;
	      }
	    }

	    if (node.type === 'atrule' && node.name === 'supports') {
	      let params = node.params;
	      if (params.includes('grid') && params.includes('auto')) {
	        value = false;
	      }
	    }

	    if (!node.nodes || value === null) {
	      if (node.parent) {
	        let isParentGrid = this.gridStatus(node.parent, result);
	        if (node.parent._autoprefixerSelfDisabled === true) {
	          value = false;
	        } else {
	          value = isParentGrid;
	        }
	      } else if (typeof this.prefixes.options.grid !== 'undefined') {
	        value = this.prefixes.options.grid;
	      } else if (typeof process.env.AUTOPREFIXER_GRID !== 'undefined') {
	        if (process.env.AUTOPREFIXER_GRID === 'autoplace') {
	          value = 'autoplace';
	        } else {
	          value = true;
	        }
	      } else {
	        value = false;
	      }
	    }

	    node._autoprefixerGridStatus = value;
	    return value
	  }

	  /**
	   * Normalize spaces in cascade declaration group
	   */
	  reduceSpaces(decl) {
	    let stop = false;
	    this.prefixes.group(decl).up(() => {
	      stop = true;
	      return true
	    });
	    if (stop) {
	      return
	    }

	    let parts = decl.raw('before').split('\n');
	    let prevMin = parts[parts.length - 1].length;
	    let diff = false;

	    this.prefixes.group(decl).down(other => {
	      parts = other.raw('before').split('\n');
	      let last = parts.length - 1;

	      if (parts[last].length > prevMin) {
	        if (diff === false) {
	          diff = parts[last].length - prevMin;
	        }

	        parts[last] = parts[last].slice(0, -diff);
	        other.raws.before = parts.join('\n');
	      }
	    });
	  }

	  /**
	   * Remove unnecessary pefixes
	   */
	  remove(css, result) {
	    // At-rules
	    let resolution = this.prefixes.remove['@resolution'];

	    css.walkAtRules((rule, i) => {
	      if (this.prefixes.remove[`@${rule.name}`]) {
	        if (!this.disabled(rule, result)) {
	          rule.parent.removeChild(i);
	        }
	      } else if (
	        rule.name === 'media' &&
	        rule.params.includes('-resolution') &&
	        resolution
	      ) {
	        resolution.clean(rule);
	      }
	    });

	    // Selectors
	    css.walkRules((rule, i) => {
	      if (this.disabled(rule, result)) return

	      for (let checker of this.prefixes.remove.selectors) {
	        if (checker.check(rule)) {
	          rule.parent.removeChild(i);
	          return
	        }
	      }
	    });

	    return css.walkDecls((decl, i) => {
	      if (this.disabled(decl, result)) return

	      let rule = decl.parent;
	      let unprefixed = this.prefixes.unprefixed(decl.prop);

	      // Transition
	      if (decl.prop === 'transition' || decl.prop === 'transition-property') {
	        this.prefixes.transition.remove(decl);
	      }

	      // Properties
	      if (
	        this.prefixes.remove[decl.prop] &&
	        this.prefixes.remove[decl.prop].remove
	      ) {
	        let notHack = this.prefixes.group(decl).down(other => {
	          return this.prefixes.normalize(other.prop) === unprefixed
	        });

	        if (unprefixed === 'flex-flow') {
	          notHack = true;
	        }

	        if (decl.prop === '-webkit-box-orient') {
	          let hacks = { 'flex-direction': true, 'flex-flow': true };
	          if (!decl.parent.some(j => hacks[j.prop])) return
	        }

	        if (notHack && !this.withHackValue(decl)) {
	          if (decl.raw('before').includes('\n')) {
	            this.reduceSpaces(decl);
	          }
	          rule.removeChild(i);
	          return
	        }
	      }

	      // Values
	      for (let checker of this.prefixes.values('remove', unprefixed)) {
	        if (!checker.check) continue
	        if (!checker.check(decl.value)) continue

	        unprefixed = checker.unprefixed;
	        let notHack = this.prefixes.group(decl).down(other => {
	          return other.value.includes(unprefixed)
	        });

	        if (notHack) {
	          rule.removeChild(i);
	          return
	        }
	      }
	    })
	  }

	  /**
	   * Some rare old values, which is not in standard
	   */
	  withHackValue(decl) {
	    return (
	      (decl.prop === '-webkit-background-clip' && decl.value === 'text') ||
	      // Do not remove -webkit-box-orient when -webkit-line-clamp is present.
	      // https://github.com/postcss/autoprefixer/issues/1510
	      (decl.prop === '-webkit-box-orient' &&
	        decl.parent.some(d => d.prop === '-webkit-line-clamp'))
	    )
	  }
	}

	processor = Processor;
	return processor;
}

var gridRowsColumns;
var hasRequiredGridRowsColumns;

function requireGridRowsColumns () {
	if (hasRequiredGridRowsColumns) return gridRowsColumns;
	hasRequiredGridRowsColumns = 1;
	let Declaration = requireDeclaration();
	let Processor = requireProcessor();
	let {
	  autoplaceGridItems,
	  getGridGap,
	  inheritGridGap,
	  prefixTrackProp,
	  prefixTrackValue
	} = requireGridUtils();

	class GridRowsColumns extends Declaration {
	  insert(decl, prefix, prefixes, result) {
	    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

	    let { parent, prop, value } = decl;
	    let isRowProp = prop.includes('rows');
	    let isColumnProp = prop.includes('columns');

	    let hasGridTemplate = parent.some(
	      i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'
	    );

	    /**
	     * Not to prefix rows declaration if grid-template(-areas) is present
	     */
	    if (hasGridTemplate && isRowProp) {
	      return false
	    }

	    let processor = new Processor({ options: {} });
	    let status = processor.gridStatus(parent, result);
	    let gap = getGridGap(decl);
	    gap = inheritGridGap(decl, gap) || gap;

	    let gapValue = isRowProp ? gap.row : gap.column;

	    if ((status === 'no-autoplace' || status === true) && !hasGridTemplate) {
	      gapValue = null;
	    }

	    let prefixValue = prefixTrackValue({
	      gap: gapValue,
	      value
	    });

	    /**
	     * Insert prefixes
	     */
	    decl.cloneBefore({
	      prop: prefixTrackProp({ prefix, prop }),
	      value: prefixValue
	    });

	    let autoflow = parent.nodes.find(i => i.prop === 'grid-auto-flow');
	    let autoflowValue = 'row';

	    if (autoflow && !processor.disabled(autoflow, result)) {
	      autoflowValue = autoflow.value.trim();
	    }
	    if (status === 'autoplace') {
	      /**
	       * Show warning if grid-template-rows decl is not found
	       */
	      let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows');

	      if (!rowDecl && hasGridTemplate) {
	        return undefined
	      } else if (!rowDecl && !hasGridTemplate) {
	        decl.warn(
	          result,
	          'Autoplacement does not work without grid-template-rows property'
	        );
	        return undefined
	      }

	      /**
	       * Show warning if grid-template-columns decl is not found
	       */
	      let columnDecl = parent.nodes.find(i => {
	        return i.prop === 'grid-template-columns'
	      });
	      if (!columnDecl && !hasGridTemplate) {
	        decl.warn(
	          result,
	          'Autoplacement does not work without grid-template-columns property'
	        );
	      }

	      /**
	       * Autoplace grid items
	       */
	      if (isColumnProp && !hasGridTemplate) {
	        autoplaceGridItems(decl, result, gap, autoflowValue);
	      }
	    }

	    return undefined
	  }

	  /**
	   * Change IE property back
	   */
	  normalize(prop) {
	    return prop.replace(/^grid-(rows|columns)/, 'grid-template-$1')
	  }

	  /**
	   * Change property name for IE
	   */
	  prefixed(prop, prefix) {
	    if (prefix === '-ms-') {
	      return prefixTrackProp({ prefix, prop })
	    }
	    return super.prefixed(prop, prefix)
	  }
	}

	GridRowsColumns.names = [
	  'grid-template-rows',
	  'grid-template-columns',
	  'grid-rows',
	  'grid-columns'
	];

	gridRowsColumns = GridRowsColumns;
	return gridRowsColumns;
}

var gridStart;
var hasRequiredGridStart;

function requireGridStart () {
	if (hasRequiredGridStart) return gridStart;
	hasRequiredGridStart = 1;
	let Declaration = requireDeclaration();

	class GridStart extends Declaration {
	  /**
	   * Do not add prefix for unsupported value in IE
	   */
	  check(decl) {
	    let value = decl.value;
	    return !value.includes('/') && !value.includes('span')
	  }

	  /**
	   * Return a final spec property
	   */
	  normalize(prop) {
	    return prop.replace('-start', '')
	  }

	  /**
	   * Change property name for IE
	   */
	  prefixed(prop, prefix) {
	    let result = super.prefixed(prop, prefix);
	    if (prefix === '-ms-') {
	      result = result.replace('-start', '');
	    }
	    return result
	  }
	}

	GridStart.names = ['grid-row-start', 'grid-column-start'];

	gridStart = GridStart;
	return gridStart;
}

var gridTemplate;
var hasRequiredGridTemplate;

function requireGridTemplate () {
	if (hasRequiredGridTemplate) return gridTemplate;
	hasRequiredGridTemplate = 1;
	let Declaration = requireDeclaration();
	let {
	  getGridGap,
	  inheritGridGap,
	  parseTemplate,
	  warnGridGap,
	  warnMissedAreas
	} = requireGridUtils();

	class GridTemplate extends Declaration {
	  /**
	   * Translate grid-template to separate -ms- prefixed properties
	   */
	  insert(decl, prefix, prefixes, result) {
	    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

	    if (decl.parent.some(i => i.prop === '-ms-grid-rows')) {
	      return undefined
	    }

	    let gap = getGridGap(decl);

	    /**
	     * we must insert inherited gap values in some cases:
	     * if we are inside media query && if we have no grid-gap value
	     */
	    let inheritedGap = inheritGridGap(decl, gap);

	    let { areas, columns, rows } = parseTemplate({
	      decl,
	      gap: inheritedGap || gap
	    });

	    let hasAreas = Object.keys(areas).length > 0;
	    let hasRows = Boolean(rows);
	    let hasColumns = Boolean(columns);

	    warnGridGap({
	      decl,
	      gap,
	      hasColumns,
	      result
	    });

	    warnMissedAreas(areas, decl, result);

	    if ((hasRows && hasColumns) || hasAreas) {
	      decl.cloneBefore({
	        prop: '-ms-grid-rows',
	        raws: {},
	        value: rows
	      });
	    }

	    if (hasColumns) {
	      decl.cloneBefore({
	        prop: '-ms-grid-columns',
	        raws: {},
	        value: columns
	      });
	    }

	    return decl
	  }
	}

	GridTemplate.names = ['grid-template'];

	gridTemplate = GridTemplate;
	return gridTemplate;
}

var gridTemplateAreas;
var hasRequiredGridTemplateAreas;

function requireGridTemplateAreas () {
	if (hasRequiredGridTemplateAreas) return gridTemplateAreas;
	hasRequiredGridTemplateAreas = 1;
	let Declaration = requireDeclaration();
	let {
	  getGridGap,
	  inheritGridGap,
	  parseGridAreas,
	  prefixTrackProp,
	  prefixTrackValue,
	  warnGridGap,
	  warnMissedAreas
	} = requireGridUtils();

	function getGridRows(tpl) {
	  return tpl
	    .trim()
	    .slice(1, -1)
	    .split(/["']\s*["']?/g)
	}

	class GridTemplateAreas extends Declaration {
	  /**
	   * Translate grid-template-areas to separate -ms- prefixed properties
	   */
	  insert(decl, prefix, prefixes, result) {
	    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

	    let hasColumns = false;
	    let hasRows = false;
	    let parent = decl.parent;
	    let gap = getGridGap(decl);
	    gap = inheritGridGap(decl, gap) || gap;

	    // remove already prefixed rows
	    // to prevent doubling prefixes
	    parent.walkDecls(/-ms-grid-rows/, i => i.remove());

	    // add empty tracks to rows
	    parent.walkDecls(/grid-template-(rows|columns)/, trackDecl => {
	      if (trackDecl.prop === 'grid-template-rows') {
	        hasRows = true;
	        let { prop, value } = trackDecl;
	        trackDecl.cloneBefore({
	          prop: prefixTrackProp({ prefix, prop }),
	          value: prefixTrackValue({ gap: gap.row, value })
	        });
	      } else {
	        hasColumns = true;
	      }
	    });

	    let gridRows = getGridRows(decl.value);

	    if (hasColumns && !hasRows && gap.row && gridRows.length > 1) {
	      decl.cloneBefore({
	        prop: '-ms-grid-rows',
	        raws: {},
	        value: prefixTrackValue({
	          gap: gap.row,
	          value: `repeat(${gridRows.length}, auto)`
	        })
	      });
	    }

	    // warnings
	    warnGridGap({
	      decl,
	      gap,
	      hasColumns,
	      result
	    });

	    let areas = parseGridAreas({
	      gap,
	      rows: gridRows
	    });

	    warnMissedAreas(areas, decl, result);

	    return decl
	  }
	}

	GridTemplateAreas.names = ['grid-template-areas'];

	gridTemplateAreas = GridTemplateAreas;
	return gridTemplateAreas;
}

var imageRendering;
var hasRequiredImageRendering;

function requireImageRendering () {
	if (hasRequiredImageRendering) return imageRendering;
	hasRequiredImageRendering = 1;
	let Declaration = requireDeclaration();

	class ImageRendering extends Declaration {
	  /**
	   * Add hack only for crisp-edges
	   */
	  check(decl) {
	    return decl.value === 'pixelated'
	  }

	  /**
	   * Return property name by spec
	   */
	  normalize() {
	    return 'image-rendering'
	  }

	  /**
	   * Change property name for IE
	   */
	  prefixed(prop, prefix) {
	    if (prefix === '-ms-') {
	      return '-ms-interpolation-mode'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Warn on old value
	   */
	  process(node, result) {
	    return super.process(node, result)
	  }

	  /**
	   * Change property and value for IE
	   */
	  set(decl, prefix) {
	    if (prefix !== '-ms-') return super.set(decl, prefix)
	    decl.prop = '-ms-interpolation-mode';
	    decl.value = 'nearest-neighbor';
	    return decl
	  }
	}

	ImageRendering.names = ['image-rendering', 'interpolation-mode'];

	imageRendering = ImageRendering;
	return imageRendering;
}

var imageSet;
var hasRequiredImageSet;

function requireImageSet () {
	if (hasRequiredImageSet) return imageSet;
	hasRequiredImageSet = 1;
	let Value = requireValue();

	class ImageSet extends Value {
	  /**
	   * Use non-standard name for WebKit and Firefox
	   */
	  replace(string, prefix) {
	    let fixed = super.replace(string, prefix);
	    if (prefix === '-webkit-') {
	      fixed = fixed.replace(/("[^"]+"|'[^']+')(\s+\d+\w)/gi, 'url($1)$2');
	    }
	    return fixed
	  }
	}

	ImageSet.names = ['image-set'];

	imageSet = ImageSet;
	return imageSet;
}

var inlineLogical;
var hasRequiredInlineLogical;

function requireInlineLogical () {
	if (hasRequiredInlineLogical) return inlineLogical;
	hasRequiredInlineLogical = 1;
	let Declaration = requireDeclaration();

	class InlineLogical extends Declaration {
	  /**
	   * Return property name by spec
	   */
	  normalize(prop) {
	    return prop.replace(/(margin|padding|border)-(start|end)/, '$1-inline-$2')
	  }

	  /**
	   * Use old syntax for -moz- and -webkit-
	   */
	  prefixed(prop, prefix) {
	    return prefix + prop.replace('-inline', '')
	  }
	}

	InlineLogical.names = [
	  'border-inline-start',
	  'border-inline-end',
	  'margin-inline-start',
	  'margin-inline-end',
	  'padding-inline-start',
	  'padding-inline-end',
	  'border-start',
	  'border-end',
	  'margin-start',
	  'margin-end',
	  'padding-start',
	  'padding-end'
	];

	inlineLogical = InlineLogical;
	return inlineLogical;
}

var intrinsic;
var hasRequiredIntrinsic;

function requireIntrinsic () {
	if (hasRequiredIntrinsic) return intrinsic;
	hasRequiredIntrinsic = 1;
	let OldValue = requireOldValue();
	let Value = requireValue();

	function regexp(name) {
	  return new RegExp(`(^|[\\s,(])(${name}($|[\\s),]))`, 'gi')
	}

	class Intrinsic extends Value {
	  add(decl, prefix) {
	    if (decl.prop.includes('grid') && prefix !== '-webkit-') {
	      return undefined
	    }
	    return super.add(decl, prefix)
	  }

	  isStretch() {
	    return (
	      this.name === 'stretch' ||
	      this.name === 'fill' ||
	      this.name === 'fill-available'
	    )
	  }

	  old(prefix) {
	    let prefixed = prefix + this.name;
	    if (this.isStretch()) {
	      if (prefix === '-moz-') {
	        prefixed = '-moz-available';
	      } else if (prefix === '-webkit-') {
	        prefixed = '-webkit-fill-available';
	      }
	    }
	    return new OldValue(this.name, prefixed, prefixed, regexp(prefixed))
	  }

	  regexp() {
	    if (!this.regexpCache) this.regexpCache = regexp(this.name);
	    return this.regexpCache
	  }

	  replace(string, prefix) {
	    if (prefix === '-moz-' && this.isStretch()) {
	      return string.replace(this.regexp(), '$1-moz-available$3')
	    }
	    if (prefix === '-webkit-' && this.isStretch()) {
	      return string.replace(this.regexp(), '$1-webkit-fill-available$3')
	    }
	    return super.replace(string, prefix)
	  }
	}

	Intrinsic.names = [
	  'max-content',
	  'min-content',
	  'fit-content',
	  'fill',
	  'fill-available',
	  'stretch'
	];

	intrinsic = Intrinsic;
	return intrinsic;
}

var justifyContent;
var hasRequiredJustifyContent;

function requireJustifyContent () {
	if (hasRequiredJustifyContent) return justifyContent;
	hasRequiredJustifyContent = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class JustifyContent extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'justify-content'
	  }

	  /**
	   * Change property name for 2009 and 2012 specs
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2009) {
	      return prefix + 'box-pack'
	    }
	    if (spec === 2012) {
	      return prefix + 'flex-pack'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Change value for 2009 and 2012 specs
	   */
	  set(decl, prefix) {
	    let spec = flexSpec(prefix)[0];
	    if (spec === 2009 || spec === 2012) {
	      let value = JustifyContent.oldValues[decl.value] || decl.value;
	      decl.value = value;
	      if (spec !== 2009 || value !== 'distribute') {
	        return super.set(decl, prefix)
	      }
	    } else if (spec === 'final') {
	      return super.set(decl, prefix)
	    }
	    return undefined
	  }
	}

	JustifyContent.names = ['justify-content', 'flex-pack', 'box-pack'];

	JustifyContent.oldValues = {
	  'flex-end': 'end',
	  'flex-start': 'start',
	  'space-around': 'distribute',
	  'space-between': 'justify'
	};

	justifyContent = JustifyContent;
	return justifyContent;
}

var maskBorder;
var hasRequiredMaskBorder;

function requireMaskBorder () {
	if (hasRequiredMaskBorder) return maskBorder;
	hasRequiredMaskBorder = 1;
	let Declaration = requireDeclaration();

	class MaskBorder extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return this.name.replace('box-image', 'border')
	  }

	  /**
	   * Return flex property for 2012 spec
	   */
	  prefixed(prop, prefix) {
	    let result = super.prefixed(prop, prefix);
	    if (prefix === '-webkit-') {
	      result = result.replace('border', 'box-image');
	    }
	    return result
	  }
	}

	MaskBorder.names = [
	  'mask-border',
	  'mask-border-source',
	  'mask-border-slice',
	  'mask-border-width',
	  'mask-border-outset',
	  'mask-border-repeat',
	  'mask-box-image',
	  'mask-box-image-source',
	  'mask-box-image-slice',
	  'mask-box-image-width',
	  'mask-box-image-outset',
	  'mask-box-image-repeat'
	];

	maskBorder = MaskBorder;
	return maskBorder;
}

var maskComposite;
var hasRequiredMaskComposite;

function requireMaskComposite () {
	if (hasRequiredMaskComposite) return maskComposite;
	hasRequiredMaskComposite = 1;
	let Declaration = requireDeclaration();

	class MaskComposite extends Declaration {
	  /**
	   * Prefix mask-composite for webkit
	   */
	  insert(decl, prefix, prefixes) {
	    let isCompositeProp = decl.prop === 'mask-composite';

	    let compositeValues;

	    if (isCompositeProp) {
	      compositeValues = decl.value.split(',');
	    } else {
	      compositeValues = decl.value.match(MaskComposite.regexp) || [];
	    }

	    compositeValues = compositeValues.map(el => el.trim()).filter(el => el);
	    let hasCompositeValues = compositeValues.length;

	    let compositeDecl;

	    if (hasCompositeValues) {
	      compositeDecl = this.clone(decl);
	      compositeDecl.value = compositeValues
	        .map(value => MaskComposite.oldValues[value] || value)
	        .join(', ');

	      if (compositeValues.includes('intersect')) {
	        compositeDecl.value += ', xor';
	      }

	      compositeDecl.prop = prefix + 'mask-composite';
	    }

	    if (isCompositeProp) {
	      if (!hasCompositeValues) {
	        return undefined
	      }

	      if (this.needCascade(decl)) {
	        compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);
	      }

	      return decl.parent.insertBefore(decl, compositeDecl)
	    }

	    let cloned = this.clone(decl);
	    cloned.prop = prefix + cloned.prop;

	    if (hasCompositeValues) {
	      cloned.value = cloned.value.replace(MaskComposite.regexp, '');
	    }

	    if (this.needCascade(decl)) {
	      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
	    }

	    decl.parent.insertBefore(decl, cloned);

	    if (!hasCompositeValues) {
	      return decl
	    }

	    if (this.needCascade(decl)) {
	      compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);
	    }
	    return decl.parent.insertBefore(decl, compositeDecl)
	  }
	}

	MaskComposite.names = ['mask', 'mask-composite'];

	MaskComposite.oldValues = {
	  add: 'source-over',
	  exclude: 'xor',
	  intersect: 'source-in',
	  subtract: 'source-out'
	};

	MaskComposite.regexp = new RegExp(
	  `\\s+(${Object.keys(MaskComposite.oldValues).join(
	    '|'
	  )})\\b(?!\\))\\s*(?=[,])`,
	  'ig'
	);

	maskComposite = MaskComposite;
	return maskComposite;
}

var order;
var hasRequiredOrder;

function requireOrder () {
	if (hasRequiredOrder) return order;
	hasRequiredOrder = 1;
	let Declaration = requireDeclaration();
	let flexSpec = requireFlexSpec();

	class Order extends Declaration {
	  /**
	   * Return property name by final spec
	   */
	  normalize() {
	    return 'order'
	  }

	  /**
	   * Change property name for 2009 and 2012 specs
	   */
	  prefixed(prop, prefix) {
	    let spec
	    ;[spec, prefix] = flexSpec(prefix);
	    if (spec === 2009) {
	      return prefix + 'box-ordinal-group'
	    }
	    if (spec === 2012) {
	      return prefix + 'flex-order'
	    }
	    return super.prefixed(prop, prefix)
	  }

	  /**
	   * Fix value for 2009 spec
	   */
	  set(decl, prefix) {
	    let spec = flexSpec(prefix)[0];
	    if (spec === 2009 && /\d/.test(decl.value)) {
	      decl.value = (parseInt(decl.value) + 1).toString();
	      return super.set(decl, prefix)
	    }
	    return super.set(decl, prefix)
	  }
	}

	Order.names = ['order', 'flex-order', 'box-ordinal-group'];

	order = Order;
	return order;
}

var overscrollBehavior;
var hasRequiredOverscrollBehavior;

function requireOverscrollBehavior () {
	if (hasRequiredOverscrollBehavior) return overscrollBehavior;
	hasRequiredOverscrollBehavior = 1;
	let Declaration = requireDeclaration();

	class OverscrollBehavior extends Declaration {
	  /**
	   * Return property name by spec
	   */
	  normalize() {
	    return 'overscroll-behavior'
	  }

	  /**
	   * Change property name for IE
	   */
	  prefixed(prop, prefix) {
	    return prefix + 'scroll-chaining'
	  }

	  /**
	   * Change value for IE
	   */
	  set(decl, prefix) {
	    if (decl.value === 'auto') {
	      decl.value = 'chained';
	    } else if (decl.value === 'none' || decl.value === 'contain') {
	      decl.value = 'none';
	    }
	    return super.set(decl, prefix)
	  }
	}

	OverscrollBehavior.names = ['overscroll-behavior', 'scroll-chaining'];

	overscrollBehavior = OverscrollBehavior;
	return overscrollBehavior;
}

var pixelated;
var hasRequiredPixelated;

function requirePixelated () {
	if (hasRequiredPixelated) return pixelated;
	hasRequiredPixelated = 1;
	let OldValue = requireOldValue();
	let Value = requireValue();

	class Pixelated extends Value {
	  /**
	   * Different name for WebKit and Firefox
	   */
	  old(prefix) {
	    if (prefix === '-webkit-') {
	      return new OldValue(this.name, '-webkit-optimize-contrast')
	    }
	    if (prefix === '-moz-') {
	      return new OldValue(this.name, '-moz-crisp-edges')
	    }
	    return super.old(prefix)
	  }

	  /**
	   * Use non-standard name for WebKit and Firefox
	   */
	  replace(string, prefix) {
	    if (prefix === '-webkit-') {
	      return string.replace(this.regexp(), '$1-webkit-optimize-contrast')
	    }
	    if (prefix === '-moz-') {
	      return string.replace(this.regexp(), '$1-moz-crisp-edges')
	    }
	    return super.replace(string, prefix)
	  }
	}

	Pixelated.names = ['pixelated'];

	pixelated = Pixelated;
	return pixelated;
}

var placeSelf;
var hasRequiredPlaceSelf;

function requirePlaceSelf () {
	if (hasRequiredPlaceSelf) return placeSelf;
	hasRequiredPlaceSelf = 1;
	let Declaration = requireDeclaration();
	let utils = requireGridUtils();

	class PlaceSelf extends Declaration {
	  /**
	   * Translate place-self to separate -ms- prefixed properties
	   */
	  insert(decl, prefix, prefixes) {
	    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

	    // prevent doubling of prefixes
	    if (decl.parent.some(i => i.prop === '-ms-grid-row-align')) {
	      return undefined
	    }

	    let [[first, second]] = utils.parse(decl);

	    if (second) {
	      utils.insertDecl(decl, 'grid-row-align', first);
	      utils.insertDecl(decl, 'grid-column-align', second);
	    } else {
	      utils.insertDecl(decl, 'grid-row-align', first);
	      utils.insertDecl(decl, 'grid-column-align', first);
	    }

	    return undefined
	  }
	}

	PlaceSelf.names = ['place-self'];

	placeSelf = PlaceSelf;
	return placeSelf;
}

var placeholder;
var hasRequiredPlaceholder;

function requirePlaceholder () {
	if (hasRequiredPlaceholder) return placeholder;
	hasRequiredPlaceholder = 1;
	let Selector = requireSelector();

	class Placeholder extends Selector {
	  /**
	   * Add old mozilla to possible prefixes
	   */
	  possible() {
	    return super.possible().concat(['-moz- old', '-ms- old'])
	  }

	  /**
	   * Return different selectors depend on prefix
	   */
	  prefixed(prefix) {
	    if (prefix === '-webkit-') {
	      return '::-webkit-input-placeholder'
	    }
	    if (prefix === '-ms-') {
	      return '::-ms-input-placeholder'
	    }
	    if (prefix === '-ms- old') {
	      return ':-ms-input-placeholder'
	    }
	    if (prefix === '-moz- old') {
	      return ':-moz-placeholder'
	    }
	    return `::${prefix}placeholder`
	  }
	}

	Placeholder.names = ['::placeholder'];

	placeholder = Placeholder;
	return placeholder;
}

var placeholderShown;
var hasRequiredPlaceholderShown;

function requirePlaceholderShown () {
	if (hasRequiredPlaceholderShown) return placeholderShown;
	hasRequiredPlaceholderShown = 1;
	let Selector = requireSelector();

	class PlaceholderShown extends Selector {
	  /**
	   * Return different selectors depend on prefix
	   */
	  prefixed(prefix) {
	    if (prefix === '-moz-') {
	      return ':-moz-placeholder'
	    } else if (prefix === '-ms-') {
	      return ':-ms-input-placeholder'
	    }
	    return `:${prefix}placeholder-shown`
	  }
	}

	PlaceholderShown.names = [':placeholder-shown'];

	placeholderShown = PlaceholderShown;
	return placeholderShown;
}

var printColorAdjust;
var hasRequiredPrintColorAdjust;

function requirePrintColorAdjust () {
	if (hasRequiredPrintColorAdjust) return printColorAdjust;
	hasRequiredPrintColorAdjust = 1;
	let Declaration = requireDeclaration();

	class PrintColorAdjust extends Declaration {
	  /**
	   * Return property name by spec
	   */
	  normalize() {
	    return 'print-color-adjust'
	  }

	  /**
	   * Change property name for WebKit-based browsers
	   */
	  prefixed(prop, prefix) {
	    if (prefix === '-moz-') {
	      return 'color-adjust'
	    } else {
	      return prefix + 'print-color-adjust'
	    }
	  }
	}

	PrintColorAdjust.names = ['print-color-adjust', 'color-adjust'];

	printColorAdjust = PrintColorAdjust;
	return printColorAdjust;
}

var textDecoration;
var hasRequiredTextDecoration;

function requireTextDecoration () {
	if (hasRequiredTextDecoration) return textDecoration;
	hasRequiredTextDecoration = 1;
	let Declaration = requireDeclaration();

	const BASIC = [
	  'none',
	  'underline',
	  'overline',
	  'line-through',
	  'blink',
	  'inherit',
	  'initial',
	  'unset'
	];

	class TextDecoration extends Declaration {
	  /**
	   * Do not add prefixes for basic values.
	   */
	  check(decl) {
	    return decl.value.split(/\s+/).some(i => !BASIC.includes(i))
	  }
	}

	TextDecoration.names = ['text-decoration'];

	textDecoration = TextDecoration;
	return textDecoration;
}

var textDecorationSkipInk;
var hasRequiredTextDecorationSkipInk;

function requireTextDecorationSkipInk () {
	if (hasRequiredTextDecorationSkipInk) return textDecorationSkipInk;
	hasRequiredTextDecorationSkipInk = 1;
	let Declaration = requireDeclaration();

	class TextDecorationSkipInk extends Declaration {
	  /**
	   * Change prefix for ink value
	   */
	  set(decl, prefix) {
	    if (decl.prop === 'text-decoration-skip-ink' && decl.value === 'auto') {
	      decl.prop = prefix + 'text-decoration-skip';
	      decl.value = 'ink';
	      return decl
	    } else {
	      return super.set(decl, prefix)
	    }
	  }
	}

	TextDecorationSkipInk.names = [
	  'text-decoration-skip-ink',
	  'text-decoration-skip'
	];

	textDecorationSkipInk = TextDecorationSkipInk;
	return textDecorationSkipInk;
}

var textEmphasisPosition;
var hasRequiredTextEmphasisPosition;

function requireTextEmphasisPosition () {
	if (hasRequiredTextEmphasisPosition) return textEmphasisPosition;
	hasRequiredTextEmphasisPosition = 1;
	let Declaration = requireDeclaration();

	class TextEmphasisPosition extends Declaration {
	  set(decl, prefix) {
	    if (prefix === '-webkit-') {
	      decl.value = decl.value.replace(/\s*(right|left)\s*/i, '');
	    }
	    return super.set(decl, prefix)
	  }
	}

	TextEmphasisPosition.names = ['text-emphasis-position'];

	textEmphasisPosition = TextEmphasisPosition;
	return textEmphasisPosition;
}

var transformDecl;
var hasRequiredTransformDecl;

function requireTransformDecl () {
	if (hasRequiredTransformDecl) return transformDecl;
	hasRequiredTransformDecl = 1;
	let Declaration = requireDeclaration();

	class TransformDecl extends Declaration {
	  /**
	   * Is transform contain 3D commands
	   */
	  contain3d(decl) {
	    if (decl.prop === 'transform-origin') {
	      return false
	    }

	    for (let func of TransformDecl.functions3d) {
	      if (decl.value.includes(`${func}(`)) {
	        return true
	      }
	    }

	    return false
	  }

	  /**
	   * Don't add prefix for IE in keyframes
	   */
	  insert(decl, prefix, prefixes) {
	    if (prefix === '-ms-') {
	      if (!this.contain3d(decl) && !this.keyframeParents(decl)) {
	        return super.insert(decl, prefix, prefixes)
	      }
	    } else if (prefix === '-o-') {
	      if (!this.contain3d(decl)) {
	        return super.insert(decl, prefix, prefixes)
	      }
	    } else {
	      return super.insert(decl, prefix, prefixes)
	    }
	    return undefined
	  }

	  /**
	   * Recursively check all parents for @keyframes
	   */
	  keyframeParents(decl) {
	    let { parent } = decl;
	    while (parent) {
	      if (parent.type === 'atrule' && parent.name === 'keyframes') {
	        return true
	      }
({ parent } = parent);
	    }
	    return false
	  }

	  /**
	   * Replace rotateZ to rotate for IE 9
	   */
	  set(decl, prefix) {
	    decl = super.set(decl, prefix);
	    if (prefix === '-ms-') {
	      decl.value = decl.value.replace(/rotatez/gi, 'rotate');
	    }
	    return decl
	  }
	}

	TransformDecl.names = ['transform', 'transform-origin'];

	TransformDecl.functions3d = [
	  'matrix3d',
	  'translate3d',
	  'translateZ',
	  'scale3d',
	  'scaleZ',
	  'rotate3d',
	  'rotateX',
	  'rotateY',
	  'perspective'
	];

	transformDecl = TransformDecl;
	return transformDecl;
}

var userSelect;
var hasRequiredUserSelect;

function requireUserSelect () {
	if (hasRequiredUserSelect) return userSelect;
	hasRequiredUserSelect = 1;
	let Declaration = requireDeclaration();

	class UserSelect extends Declaration {
	  /**
	   * Avoid prefixing all in IE
	   */
	  insert(decl, prefix, prefixes) {
	    if (decl.value === 'all' && prefix === '-ms-') {
	      return undefined
	    } else if (
	      decl.value === 'contain' &&
	      (prefix === '-moz-' || prefix === '-webkit-')
	    ) {
	      return undefined
	    } else {
	      return super.insert(decl, prefix, prefixes)
	    }
	  }

	  /**
	   * Change prefixed value for IE
	   */
	  set(decl, prefix) {
	    if (prefix === '-ms-' && decl.value === 'contain') {
	      decl.value = 'element';
	    }
	    return super.set(decl, prefix)
	  }
	}

	UserSelect.names = ['user-select'];

	userSelect = UserSelect;
	return userSelect;
}

var writingMode;
var hasRequiredWritingMode;

function requireWritingMode () {
	if (hasRequiredWritingMode) return writingMode;
	hasRequiredWritingMode = 1;
	let Declaration = requireDeclaration();

	class WritingMode extends Declaration {
	  insert(decl, prefix, prefixes) {
	    if (prefix === '-ms-') {
	      let cloned = this.set(this.clone(decl), prefix);

	      if (this.needCascade(decl)) {
	        cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
	      }
	      let direction = 'ltr';

	      decl.parent.nodes.forEach(i => {
	        if (i.prop === 'direction') {
	          if (i.value === 'rtl' || i.value === 'ltr') direction = i.value;
	        }
	      });

	      cloned.value = WritingMode.msValues[direction][decl.value] || decl.value;
	      return decl.parent.insertBefore(decl, cloned)
	    }

	    return super.insert(decl, prefix, prefixes)
	  }
	}

	WritingMode.names = ['writing-mode'];

	WritingMode.msValues = {
	  ltr: {
	    'horizontal-tb': 'lr-tb',
	    'vertical-lr': 'tb-lr',
	    'vertical-rl': 'tb-rl'
	  },
	  rtl: {
	    'horizontal-tb': 'rl-tb',
	    'vertical-lr': 'bt-lr',
	    'vertical-rl': 'bt-rl'
	  }
	};

	writingMode = WritingMode;
	return writingMode;
}

var fraction = {exports: {}};

var hasRequiredFraction;

function requireFraction () {
	if (hasRequiredFraction) return fraction.exports;
	hasRequiredFraction = 1;
	(function (module) {

		/**
		 *
		 * This class offers the possibility to calculate fractions.
		 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
		 *
		 * Array/Object form
		 * [ 0 => <numerator>, 1 => <denominator> ]
		 * { n => <numerator>, d => <denominator> }
		 *
		 * Integer form
		 * - Single integer value as BigInt or Number
		 *
		 * Double form
		 * - Single double value as Number
		 *
		 * String form
		 * 123.456 - a simple double
		 * 123/456 - a string fraction
		 * 123.'456' - a double with repeating decimal places
		 * 123.(456) - synonym
		 * 123.45'6' - a double with repeating last place
		 * 123.45(6) - synonym
		 *
		 * Example:
		 * let f = new Fraction("9.4'31'");
		 * f.mul([-4, 3]).div(4.9);
		 *
		 */

		// Set Identity function to downgrade BigInt to Number if needed
		if (typeof BigInt === 'undefined') BigInt = function (n) { if (isNaN(n)) throw new Error(""); return n; };

		const C_ZERO = BigInt(0);
		const C_ONE = BigInt(1);
		const C_TWO = BigInt(2);
		const C_THREE = BigInt(3);
		const C_FIVE = BigInt(5);
		const C_TEN = BigInt(10);
		BigInt(Number.MAX_SAFE_INTEGER);

		// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
		// Example: 1/7 = 0.(142857) has 6 repeating decimal places.
		// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
		const MAX_CYCLE_LEN = 2000;

		// Parsed data to avoid calling "new" all the time
		const P = {
		  "s": C_ONE,
		  "n": C_ZERO,
		  "d": C_ONE
		};

		function assign(n, s) {

		  try {
		    n = BigInt(n);
		  } catch (e) {
		    throw InvalidParameter();
		  }
		  return n * s;
		}

		function ifloor(x) {
		  return typeof x === 'bigint' ? x : Math.floor(x);
		}

		// Creates a new Fraction internally without the need of the bulky constructor
		function newFraction(n, d) {

		  if (d === C_ZERO) {
		    throw DivisionByZero();
		  }

		  const f = Object.create(Fraction.prototype);
		  f["s"] = n < C_ZERO ? -C_ONE : C_ONE;

		  n = n < C_ZERO ? -n : n;

		  const a = gcd(n, d);

		  f["n"] = n / a;
		  f["d"] = d / a;
		  return f;
		}

		const FACTORSTEPS = [C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO * C_THREE, C_TWO, C_TWO * C_THREE]; // repeats
		function factorize(n) {

		  const factors = Object.create(null);
		  if (n <= C_ONE) {
		    factors[n] = C_ONE;
		    return factors;
		  }

		  const add = (p) => { factors[p] = (factors[p] || C_ZERO) + C_ONE; };

		  while (n % C_TWO === C_ZERO) { add(C_TWO); n /= C_TWO; }
		  while (n % C_THREE === C_ZERO) { add(C_THREE); n /= C_THREE; }
		  while (n % C_FIVE === C_ZERO) { add(C_FIVE); n /= C_FIVE; }

		  // 30-wheel trial division: test only residues coprime to 2*3*5
		  // Residue step pattern after 5: 7,11,13,17,19,23,29,31, ...
		  for (let si = 0, p = C_TWO + C_FIVE; p * p <= n;) {
		    while (n % p === C_ZERO) { add(p); n /= p; }
		    p += FACTORSTEPS[si];
		    si = (si + 1) & 7; // fast modulo 8
		  }
		  if (n > C_ONE) add(n);
		  return factors;
		}

		const parse = function (p1, p2) {

		  let n = C_ZERO, d = C_ONE, s = C_ONE;

		  if (p1 === undefined || p1 === null) ; else if (p2 !== undefined) { // Two arguments

		    if (typeof p1 === "bigint") {
		      n = p1;
		    } else if (isNaN(p1)) {
		      throw InvalidParameter();
		    } else if (p1 % 1 !== 0) {
		      throw NonIntegerParameter();
		    } else {
		      n = BigInt(p1);
		    }

		    if (typeof p2 === "bigint") {
		      d = p2;
		    } else if (isNaN(p2)) {
		      throw InvalidParameter();
		    } else if (p2 % 1 !== 0) {
		      throw NonIntegerParameter();
		    } else {
		      d = BigInt(p2);
		    }

		    s = n * d;

		  } else if (typeof p1 === "object") {
		    if ("d" in p1 && "n" in p1) {
		      n = BigInt(p1["n"]);
		      d = BigInt(p1["d"]);
		      if ("s" in p1)
		        n *= BigInt(p1["s"]);
		    } else if (0 in p1) {
		      n = BigInt(p1[0]);
		      if (1 in p1)
		        d = BigInt(p1[1]);
		    } else if (typeof p1 === "bigint") {
		      n = p1;
		    } else {
		      throw InvalidParameter();
		    }
		    s = n * d;
		  } else if (typeof p1 === "number") {

		    if (isNaN(p1)) {
		      throw InvalidParameter();
		    }

		    if (p1 < 0) {
		      s = -C_ONE;
		      p1 = -p1;
		    }

		    if (p1 % 1 === 0) {
		      n = BigInt(p1);
		    } else {

		      let z = 1;

		      let A = 0, B = 1;
		      let C = 1, D = 1;

		      let N = 10000000;

		      if (p1 >= 1) {
		        z = 10 ** Math.floor(1 + Math.log10(p1));
		        p1 /= z;
		      }

		      // Using Farey Sequences

		      while (B <= N && D <= N) {
		        let M = (A + C) / (B + D);

		        if (p1 === M) {
		          if (B + D <= N) {
		            n = A + C;
		            d = B + D;
		          } else if (D > B) {
		            n = C;
		            d = D;
		          } else {
		            n = A;
		            d = B;
		          }
		          break;

		        } else {

		          if (p1 > M) {
		            A += C;
		            B += D;
		          } else {
		            C += A;
		            D += B;
		          }

		          if (B > N) {
		            n = C;
		            d = D;
		          } else {
		            n = A;
		            d = B;
		          }
		        }
		      }
		      n = BigInt(n) * BigInt(z);
		      d = BigInt(d);
		    }

		  } else if (typeof p1 === "string") {

		    let ndx = 0;

		    let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;

		    let match = p1.replace(/_/g, '').match(/\d+|./g);

		    if (match === null)
		      throw InvalidParameter();

		    if (match[ndx] === '-') {// Check for minus sign at the beginning
		      s = -C_ONE;
		      ndx++;
		    } else if (match[ndx] === '+') {// Check for plus sign at the beginning
		      ndx++;
		    }

		    if (match.length === ndx + 1) { // Check if it's just a simple number "1234"
		      w = assign(match[ndx++], s);
		    } else if (match[ndx + 1] === '.' || match[ndx] === '.') { // Check if it's a decimal number

		      if (match[ndx] !== '.') { // Handle 0.5 and .5
		        v = assign(match[ndx++], s);
		      }
		      ndx++;

		      // Check for decimal places
		      if (ndx + 1 === match.length || match[ndx + 1] === '(' && match[ndx + 3] === ')' || match[ndx + 1] === "'" && match[ndx + 3] === "'") {
		        w = assign(match[ndx], s);
		        y = C_TEN ** BigInt(match[ndx].length);
		        ndx++;
		      }

		      // Check for repeating places
		      if (match[ndx] === '(' && match[ndx + 2] === ')' || match[ndx] === "'" && match[ndx + 2] === "'") {
		        x = assign(match[ndx + 1], s);
		        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;
		        ndx += 3;
		      }

		    } else if (match[ndx + 1] === '/' || match[ndx + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
		      w = assign(match[ndx], s);
		      y = assign(match[ndx + 2], C_ONE);
		      ndx += 3;
		    } else if (match[ndx + 3] === '/' && match[ndx + 1] === ' ') { // Check for a complex fraction "123 1/2"
		      v = assign(match[ndx], s);
		      w = assign(match[ndx + 2], s);
		      y = assign(match[ndx + 4], C_ONE);
		      ndx += 5;
		    }

		    if (match.length <= ndx) { // Check for more tokens on the stack
		      d = y * z;
		      s = /* void */
		        n = x + d * v + z * w;
		    } else {
		      throw InvalidParameter();
		    }

		  } else if (typeof p1 === "bigint") {
		    n = p1;
		    s = p1;
		    d = C_ONE;
		  } else {
		    throw InvalidParameter();
		  }

		  if (d === C_ZERO) {
		    throw DivisionByZero();
		  }

		  P["s"] = s < C_ZERO ? -C_ONE : C_ONE;
		  P["n"] = n < C_ZERO ? -n : n;
		  P["d"] = d < C_ZERO ? -d : d;
		};

		function modpow(b, e, m) {

		  let r = C_ONE;
		  for (; e > C_ZERO; b = (b * b) % m, e >>= C_ONE) {

		    if (e & C_ONE) {
		      r = (r * b) % m;
		    }
		  }
		  return r;
		}

		function cycleLen(n, d) {

		  for (; d % C_TWO === C_ZERO;
		    d /= C_TWO) {
		  }

		  for (; d % C_FIVE === C_ZERO;
		    d /= C_FIVE) {
		  }

		  if (d === C_ONE) // Catch non-cyclic numbers
		    return C_ZERO;

		  // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
		  // 10^(d-1) % d == 1
		  // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
		  // as we want to translate the numbers to strings.

		  let rem = C_TEN % d;
		  let t = 1;

		  for (; rem !== C_ONE; t++) {
		    rem = rem * C_TEN % d;

		    if (t > MAX_CYCLE_LEN)
		      return C_ZERO; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
		  }
		  return BigInt(t);
		}

		function cycleStart(n, d, len) {

		  let rem1 = C_ONE;
		  let rem2 = modpow(C_TEN, len, d);

		  for (let t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
		    // Solve 10^s == 10^(s+t) (mod d)

		    if (rem1 === rem2)
		      return BigInt(t);

		    rem1 = rem1 * C_TEN % d;
		    rem2 = rem2 * C_TEN % d;
		  }
		  return 0;
		}

		function gcd(a, b) {

		  if (!a)
		    return b;
		  if (!b)
		    return a;

		  while (1) {
		    a %= b;
		    if (!a)
		      return b;
		    b %= a;
		    if (!b)
		      return a;
		  }
		}

		/**
		 * Module constructor
		 *
		 * @constructor
		 * @param {number|Fraction=} a
		 * @param {number=} b
		 */
		function Fraction(a, b) {

		  parse(a, b);

		  if (this instanceof Fraction) {
		    a = gcd(P["d"], P["n"]); // Abuse a
		    this["s"] = P["s"];
		    this["n"] = P["n"] / a;
		    this["d"] = P["d"] / a;
		  } else {
		    return newFraction(P['s'] * P['n'], P['d']);
		  }
		}

		const DivisionByZero = function () { return new Error("Division by Zero"); };
		const InvalidParameter = function () { return new Error("Invalid argument"); };
		const NonIntegerParameter = function () { return new Error("Parameters must be integer"); };

		Fraction.prototype = {

		  "s": C_ONE,
		  "n": C_ZERO,
		  "d": C_ONE,

		  /**
		   * Calculates the absolute value
		   *
		   * Ex: new Fraction(-4).abs() => 4
		   **/
		  "abs": function () {

		    return newFraction(this["n"], this["d"]);
		  },

		  /**
		   * Inverts the sign of the current fraction
		   *
		   * Ex: new Fraction(-4).neg() => 4
		   **/
		  "neg": function () {

		    return newFraction(-this["s"] * this["n"], this["d"]);
		  },

		  /**
		   * Adds two rational numbers
		   *
		   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
		   **/
		  "add": function (a, b) {

		    parse(a, b);
		    return newFraction(
		      this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
		      this["d"] * P["d"]
		    );
		  },

		  /**
		   * Subtracts two rational numbers
		   *
		   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
		   **/
		  "sub": function (a, b) {

		    parse(a, b);
		    return newFraction(
		      this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
		      this["d"] * P["d"]
		    );
		  },

		  /**
		   * Multiplies two rational numbers
		   *
		   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
		   **/
		  "mul": function (a, b) {

		    parse(a, b);
		    return newFraction(
		      this["s"] * P["s"] * this["n"] * P["n"],
		      this["d"] * P["d"]
		    );
		  },

		  /**
		   * Divides two rational numbers
		   *
		   * Ex: new Fraction("-17.(345)").inverse().div(3)
		   **/
		  "div": function (a, b) {

		    parse(a, b);
		    return newFraction(
		      this["s"] * P["s"] * this["n"] * P["d"],
		      this["d"] * P["n"]
		    );
		  },

		  /**
		   * Clones the actual object
		   *
		   * Ex: new Fraction("-17.(345)").clone()
		   **/
		  "clone": function () {
		    return newFraction(this['s'] * this['n'], this['d']);
		  },

		  /**
		   * Calculates the modulo of two rational numbers - a more precise fmod
		   *
		   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
		   * Ex: new Fraction(20, 10).mod().equals(0) ? "is Integer"
		   **/
		  "mod": function (a, b) {

		    if (a === undefined) {
		      return newFraction(this["s"] * this["n"] % this["d"], C_ONE);
		    }

		    parse(a, b);
		    if (C_ZERO === P["n"] * this["d"]) {
		      throw DivisionByZero();
		    }

		    /**
		     * I derived the rational modulo similar to the modulo for integers
		     *
		     * https://raw.org/book/analysis/rational-numbers/
		     *
		     *    n1/d1 = (n2/d2) * q + r, where 0 ≤ r < n2/d2
		     * => d2 * n1 = n2 * d1 * q + d1 * d2 * r
		     * => r = (d2 * n1 - n2 * d1 * q) / (d1 * d2)
		     *      = (d2 * n1 - n2 * d1 * floor((d2 * n1) / (n2 * d1))) / (d1 * d2)
		     *      = ((d2 * n1) % (n2 * d1)) / (d1 * d2)
		     */
		    return newFraction(
		      this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
		      P["d"] * this["d"]);
		  },

		  /**
		   * Calculates the fractional gcd of two rational numbers
		   *
		   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
		   */
		  "gcd": function (a, b) {

		    parse(a, b);

		    // https://raw.org/book/analysis/rational-numbers/
		    // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

		    return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
		  },

		  /**
		   * Calculates the fractional lcm of two rational numbers
		   *
		   * Ex: new Fraction(5,8).lcm(3,7) => 15
		   */
		  "lcm": function (a, b) {

		    parse(a, b);

		    // https://raw.org/book/analysis/rational-numbers/
		    // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

		    if (P["n"] === C_ZERO && this["n"] === C_ZERO) {
		      return newFraction(C_ZERO, C_ONE);
		    }
		    return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
		  },

		  /**
		   * Gets the inverse of the fraction, means numerator and denominator are exchanged
		   *
		   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
		   **/
		  "inverse": function () {
		    return newFraction(this["s"] * this["d"], this["n"]);
		  },

		  /**
		   * Calculates the fraction to some integer exponent
		   *
		   * Ex: new Fraction(-1,2).pow(-3) => -8
		   */
		  "pow": function (a, b) {

		    parse(a, b);

		    // Trivial case when exp is an integer

		    if (P['d'] === C_ONE) {

		      if (P['s'] < C_ZERO) {
		        return newFraction((this['s'] * this["d"]) ** P['n'], this["n"] ** P['n']);
		      } else {
		        return newFraction((this['s'] * this["n"]) ** P['n'], this["d"] ** P['n']);
		      }
		    }

		    // Negative roots become complex
		    //     (-a/b)^(c/d) = x
		    // ⇔ (-1)^(c/d) * (a/b)^(c/d) = x
		    // ⇔ (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x
		    // ⇔ (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula
		    // From which follows that only for c=0 the root is non-complex
		    if (this['s'] < C_ZERO) return null;

		    // Now prime factor n and d
		    let N = factorize(this['n']);
		    let D = factorize(this['d']);

		    // Exponentiate and take root for n and d individually
		    let n = C_ONE;
		    let d = C_ONE;
		    for (let k in N) {
		      if (k === '1') continue;
		      if (k === '0') {
		        n = C_ZERO;
		        break;
		      }
		      N[k] *= P['n'];

		      if (N[k] % P['d'] === C_ZERO) {
		        N[k] /= P['d'];
		      } else return null;
		      n *= BigInt(k) ** N[k];
		    }

		    for (let k in D) {
		      if (k === '1') continue;
		      D[k] *= P['n'];

		      if (D[k] % P['d'] === C_ZERO) {
		        D[k] /= P['d'];
		      } else return null;
		      d *= BigInt(k) ** D[k];
		    }

		    if (P['s'] < C_ZERO) {
		      return newFraction(d, n);
		    }
		    return newFraction(n, d);
		  },

		  /**
		   * Calculates the logarithm of a fraction to a given rational base
		   *
		   * Ex: new Fraction(27, 8).log(9, 4) => 3/2
		   */
		  "log": function (a, b) {

		    parse(a, b);

		    if (this['s'] <= C_ZERO || P['s'] <= C_ZERO) return null;

		    const allPrimes = Object.create(null);

		    const baseFactors = factorize(P['n']);
		    const T1 = factorize(P['d']);

		    const numberFactors = factorize(this['n']);
		    const T2 = factorize(this['d']);

		    for (const prime in T1) {
		      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];
		    }
		    for (const prime in T2) {
		      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];
		    }

		    for (const prime in baseFactors) {
		      if (prime === '1') continue;
		      allPrimes[prime] = true;
		    }
		    for (const prime in numberFactors) {
		      if (prime === '1') continue;
		      allPrimes[prime] = true;
		    }

		    let retN = null;
		    let retD = null;

		    // Iterate over all unique primes to determine if a consistent ratio exists
		    for (const prime in allPrimes) {

		      const baseExponent = baseFactors[prime] || C_ZERO;
		      const numberExponent = numberFactors[prime] || C_ZERO;

		      if (baseExponent === C_ZERO) {
		        if (numberExponent !== C_ZERO) {
		          return null; // Logarithm cannot be expressed as a rational number
		        }
		        continue; // Skip this prime since both exponents are zero
		      }

		      // Calculate the ratio of exponents for this prime
		      let curN = numberExponent;
		      let curD = baseExponent;

		      // Simplify the current ratio
		      const gcdValue = gcd(curN, curD);
		      curN /= gcdValue;
		      curD /= gcdValue;

		      // Check if this is the first ratio; otherwise, ensure ratios are consistent
		      if (retN === null && retD === null) {
		        retN = curN;
		        retD = curD;
		      } else if (curN * retD !== retN * curD) {
		        return null; // Ratios do not match, logarithm cannot be rational
		      }
		    }

		    return retN !== null && retD !== null
		      ? newFraction(retN, retD)
		      : null;
		  },

		  /**
		   * Check if two rational numbers are the same
		   *
		   * Ex: new Fraction(19.6).equals([98, 5]);
		   **/
		  "equals": function (a, b) {

		    parse(a, b);
		    return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"];
		  },

		  /**
		   * Check if this rational number is less than another
		   *
		   * Ex: new Fraction(19.6).lt([98, 5]);
		   **/
		  "lt": function (a, b) {

		    parse(a, b);
		    return this["s"] * this["n"] * P["d"] < P["s"] * P["n"] * this["d"];
		  },

		  /**
		   * Check if this rational number is less than or equal another
		   *
		   * Ex: new Fraction(19.6).lt([98, 5]);
		   **/
		  "lte": function (a, b) {

		    parse(a, b);
		    return this["s"] * this["n"] * P["d"] <= P["s"] * P["n"] * this["d"];
		  },

		  /**
		   * Check if this rational number is greater than another
		   *
		   * Ex: new Fraction(19.6).lt([98, 5]);
		   **/
		  "gt": function (a, b) {

		    parse(a, b);
		    return this["s"] * this["n"] * P["d"] > P["s"] * P["n"] * this["d"];
		  },

		  /**
		   * Check if this rational number is greater than or equal another
		   *
		   * Ex: new Fraction(19.6).lt([98, 5]);
		   **/
		  "gte": function (a, b) {

		    parse(a, b);
		    return this["s"] * this["n"] * P["d"] >= P["s"] * P["n"] * this["d"];
		  },

		  /**
		   * Compare two rational numbers
		   * < 0 iff this < that
		   * > 0 iff this > that
		   * = 0 iff this = that
		   *
		   * Ex: new Fraction(19.6).compare([98, 5]);
		   **/
		  "compare": function (a, b) {

		    parse(a, b);
		    let t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];

		    return (C_ZERO < t) - (t < C_ZERO);
		  },

		  /**
		   * Calculates the ceil of a rational number
		   *
		   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
		   **/
		  "ceil": function (places) {

		    places = C_TEN ** BigInt(places || 0);

		    return newFraction(ifloor(this["s"] * places * this["n"] / this["d"]) +
		      (places * this["n"] % this["d"] > C_ZERO && this["s"] >= C_ZERO ? C_ONE : C_ZERO),
		      places);
		  },

		  /**
		   * Calculates the floor of a rational number
		   *
		   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
		   **/
		  "floor": function (places) {

		    places = C_TEN ** BigInt(places || 0);

		    return newFraction(ifloor(this["s"] * places * this["n"] / this["d"]) -
		      (places * this["n"] % this["d"] > C_ZERO && this["s"] < C_ZERO ? C_ONE : C_ZERO),
		      places);
		  },

		  /**
		   * Rounds a rational numbers
		   *
		   * Ex: new Fraction('4.(3)').round() => (4 / 1)
		   **/
		  "round": function (places) {

		    places = C_TEN ** BigInt(places || 0);

		    /* Derivation:

		    s >= 0:
		      round(n / d) = ifloor(n / d) + (n % d) / d >= 0.5 ? 1 : 0
		                   = ifloor(n / d) + 2(n % d) >= d ? 1 : 0
		    s < 0:
		      round(n / d) =-ifloor(n / d) - (n % d) / d > 0.5 ? 1 : 0
		                   =-ifloor(n / d) - 2(n % d) > d ? 1 : 0

		    =>:

		    round(s * n / d) = s * ifloor(n / d) + s * (C + 2(n % d) > d ? 1 : 0)
		        where C = s >= 0 ? 1 : 0, to fix the >= for the positve case.
		    */

		    return newFraction(ifloor(this["s"] * places * this["n"] / this["d"]) +
		      this["s"] * ((this["s"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this["n"] % this["d"]) > this["d"] ? C_ONE : C_ZERO),
		      places);
		  },

		  /**
		    * Rounds a rational number to a multiple of another rational number
		    *
		    * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
		    **/
		  "roundTo": function (a, b) {

		    /*
		    k * x/y ≤ a/b < (k+1) * x/y
		    ⇔ k ≤ a/b / (x/y) < (k+1)
		    ⇔ k = floor(a/b * y/x)
		    ⇔ k = floor((a * y) / (b * x))
		    */

		    parse(a, b);

		    const n = this['n'] * P['d'];
		    const d = this['d'] * P['n'];
		    const r = n % d;

		    // round(n / d) = ifloor(n / d) + 2(n % d) >= d ? 1 : 0
		    let k = ifloor(n / d);
		    if (r + r >= d) {
		      k++;
		    }
		    return newFraction(this['s'] * k * P['n'], P['d']);
		  },

		  /**
		   * Check if two rational numbers are divisible
		   *
		   * Ex: new Fraction(19.6).divisible(1.5);
		   */
		  "divisible": function (a, b) {

		    parse(a, b);
		    if (P['n'] === C_ZERO) return false;
		    return (this['n'] * P['d']) % (P['n'] * this['d']) === C_ZERO;
		  },

		  /**
		   * Returns a decimal representation of the fraction
		   *
		   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
		   **/
		  'valueOf': function () {
		    //if (this['n'] <= MAX_INTEGER && this['d'] <= MAX_INTEGER) {
		    return Number(this['s'] * this['n']) / Number(this['d']);
		    //}
		  },

		  /**
		   * Creates a string representation of a fraction with all digits
		   *
		   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
		   **/
		  'toString': function (dec = 15) {

		    let N = this["n"];
		    let D = this["d"];

		    let cycLen = cycleLen(N, D); // Cycle length
		    let cycOff = cycleStart(N, D, cycLen); // Cycle start

		    let str = this['s'] < C_ZERO ? "-" : "";

		    // Append integer part
		    str += ifloor(N / D);

		    N %= D;
		    N *= C_TEN;

		    if (N)
		      str += ".";

		    if (cycLen) {

		      for (let i = cycOff; i--;) {
		        str += ifloor(N / D);
		        N %= D;
		        N *= C_TEN;
		      }
		      str += "(";
		      for (let i = cycLen; i--;) {
		        str += ifloor(N / D);
		        N %= D;
		        N *= C_TEN;
		      }
		      str += ")";
		    } else {
		      for (let i = dec; N && i--;) {
		        str += ifloor(N / D);
		        N %= D;
		        N *= C_TEN;
		      }
		    }
		    return str;
		  },

		  /**
		   * Returns a string-fraction representation of a Fraction object
		   *
		   * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
		   **/
		  'toFraction': function (showMixed = false) {

		    let n = this["n"];
		    let d = this["d"];
		    let str = this['s'] < C_ZERO ? "-" : "";

		    if (d === C_ONE) {
		      str += n;
		    } else {
		      const whole = ifloor(n / d);
		      if (showMixed && whole > C_ZERO) {
		        str += whole;
		        str += " ";
		        n %= d;
		      }

		      str += n;
		      str += '/';
		      str += d;
		    }
		    return str;
		  },

		  /**
		   * Returns a latex representation of a Fraction object
		   *
		   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
		   **/
		  'toLatex': function (showMixed = false) {

		    let n = this["n"];
		    let d = this["d"];
		    let str = this['s'] < C_ZERO ? "-" : "";

		    if (d === C_ONE) {
		      str += n;
		    } else {
		      const whole = ifloor(n / d);
		      if (showMixed && whole > C_ZERO) {
		        str += whole;
		        n %= d;
		      }

		      str += "\\frac{";
		      str += n;
		      str += '}{';
		      str += d;
		      str += '}';
		    }
		    return str;
		  },

		  /**
		   * Returns an array of continued fraction elements
		   *
		   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
		   */
		  'toContinued': function () {

		    let a = this['n'];
		    let b = this['d'];
		    const res = [];

		    while (b) {
		      res.push(ifloor(a / b));
		      const t = a % b;
		      a = b;
		      b = t;
		    }
		    return res;
		  },

		  "simplify": function (eps = 1e-3) {

		    // Continued fractions give best approximations for a max denominator,
		    // generally outperforming mediants in denominator–accuracy trade-offs.
		    // Semiconvergents can further reduce the denominator within tolerance.

		    const ieps = BigInt(Math.ceil(1 / eps));

		    const thisABS = this['abs']();
		    const cont = thisABS['toContinued']();

		    for (let i = 1; i < cont.length; i++) {

		      let s = newFraction(cont[i - 1], C_ONE);
		      for (let k = i - 2; k >= 0; k--) {
		        s = s['inverse']()['add'](cont[k]);
		      }

		      let t = s['sub'](thisABS);
		      if (t['n'] * ieps < t['d']) { // More robust than Math.abs(t.valueOf()) < eps
		        return s['mul'](this['s']);
		      }
		    }
		    return this;
		  }
		};

		Object.defineProperty(Fraction, "__esModule", { 'value': true });
		Fraction['default'] = Fraction;
		Fraction['Fraction'] = Fraction;
		module['exports'] = Fraction; 
	} (fraction));
	return fraction.exports;
}

var resolution;
var hasRequiredResolution;

function requireResolution () {
	if (hasRequiredResolution) return resolution;
	hasRequiredResolution = 1;
	let FractionJs = /*@__PURE__*/ requireFraction();

	let Prefixer = requirePrefixer();
	let utils = requireUtils();

	const REGEXP = /(min|max)-resolution\s*:\s*\d*\.?\d+(dppx|dpcm|dpi|x)/gi;
	const SPLIT = /(min|max)-resolution(\s*:\s*)(\d*\.?\d+)(dppx|dpcm|dpi|x)/i;

	class Resolution extends Prefixer {
	  /**
	   * Remove prefixed queries
	   */
	  clean(rule) {
	    if (!this.bad) {
	      this.bad = [];
	      for (let prefix of this.prefixes) {
	        this.bad.push(this.prefixName(prefix, 'min'));
	        this.bad.push(this.prefixName(prefix, 'max'));
	      }
	    }

	    rule.params = utils.editList(rule.params, queries => {
	      return queries.filter(query => this.bad.every(i => !query.includes(i)))
	    });
	  }

	  /**
	   * Return prefixed query name
	   */
	  prefixName(prefix, name) {
	    if (prefix === '-moz-') {
	      return name + '--moz-device-pixel-ratio'
	    } else {
	      return prefix + name + '-device-pixel-ratio'
	    }
	  }

	  /**
	   * Return prefixed query
	   */
	  prefixQuery(prefix, name, colon, value, units) {
	    value = new FractionJs(value);

	    // 1dpcm = 2.54dpi
	    // 1dppx = 96dpi
	    if (units === 'dpi') {
	      value = value.div(96);
	    } else if (units === 'dpcm') {
	      value = value.mul(2.54).div(96);
	    }
	    value = value.simplify();

	    if (prefix === '-o-') {
	      value = value.n + '/' + value.d;
	    }
	    return this.prefixName(prefix, name) + colon + value
	  }

	  /**
	   * Add prefixed queries
	   */
	  process(rule) {
	    let parent = this.parentPrefix(rule);
	    let prefixes = parent ? [parent] : this.prefixes;

	    rule.params = utils.editList(rule.params, (origin, prefixed) => {
	      for (let query of origin) {
	        if (
	          !query.includes('min-resolution') &&
	          !query.includes('max-resolution')
	        ) {
	          prefixed.push(query);
	          continue
	        }

	        for (let prefix of prefixes) {
	          let processed = query.replace(REGEXP, str => {
	            let parts = str.match(SPLIT);
	            return this.prefixQuery(
	              prefix,
	              parts[1],
	              parts[2],
	              parts[3],
	              parts[4]
	            )
	          });
	          prefixed.push(processed);
	        }
	        prefixed.push(query);
	      }

	      return utils.uniq(prefixed)
	    });
	  }
	}

	resolution = Resolution;
	return resolution;
}

var cssFeaturequeries;
var hasRequiredCssFeaturequeries;

function requireCssFeaturequeries () {
	if (hasRequiredCssFeaturequeries) return cssFeaturequeries;
	hasRequiredCssFeaturequeries = 1;
	cssFeaturequeries={A:{A:{"2":"K D E F A B wC"},B:{"1":"0 1 2 3 4 5 C L M G N O P Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB"},C:{"1":"0 1 2 3 4 5 8 9 AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC yC zC","2":"6 7 xC UC J aB K D E F A B C L M G N O P bB 0C 1C"},D:{"1":"0 1 2 3 4 5 EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B VC 5B WC 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB I ZB NC YC ZC","2":"6 7 8 9 J aB K D E F A B C L M G N O P bB AB BB CB DB"},E:{"1":"F A B C L M G 6C bC OC PC 7C 8C 9C cC dC QC AD RC eC fC gC hC iC BD SC jC kC lC mC nC CD TC oC pC qC rC DD sC tC ED FD","2":"J aB K D E 2C aC 3C 4C 5C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G N O P bB AB BB CB DB EB FB cB dB eB fB gB hB iB jB kB lB mB nB oB pB qB rB sB tB uB vB wB xB yB zB 0B 1B 2B 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC LC MC Q H R XC S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z PC","2":"F B C GD HD ID JD OC uC KD"},G:{"1":"QD RD SD TD UD VD WD XD YD ZD aD bD cD dD eD cC dC QC fD RC eC fC gC hC iC gD SC jC kC lC mC nC hD TC oC pC qC rC iD sC tC","2":"E aC LD vC MD ND OD PD"},H:{"1":"jD"},I:{"1":"I oD pD","2":"UC J kD lD mD nD vC"},J:{"2":"D A"},K:{"1":"H","2":"A B C OC uC PC"},L:{"1":"I"},M:{"1":"NC"},N:{"2":"A B"},O:{"1":"QC"},P:{"1":"6 7 8 9 J AB BB CB DB EB FB qD rD sD tD uD bC vD wD xD yD zD RC SC TC 0D"},Q:{"1":"1D"},R:{"1":"2D"},S:{"1":"3D 4D"}},B:4,C:"CSS Feature Queries",D:true};
	return cssFeaturequeries;
}

var brackets_1;
var hasRequiredBrackets;

function requireBrackets () {
	if (hasRequiredBrackets) return brackets_1;
	hasRequiredBrackets = 1;
	function last(array) {
	  return array[array.length - 1]
	}

	let brackets = {
	  /**
	   * Parse string to nodes tree
	   */
	  parse(str) {
	    let current = [''];
	    let stack = [current];

	    for (let sym of str) {
	      if (sym === '(') {
	        current = [''];
	        last(stack).push(current);
	        stack.push(current);
	        continue
	      }

	      if (sym === ')') {
	        stack.pop();
	        current = last(stack);
	        current.push('');
	        continue
	      }

	      current[current.length - 1] += sym;
	    }

	    return stack[0]
	  },

	  /**
	   * Generate output string by nodes tree
	   */
	  stringify(ast) {
	    let result = '';
	    for (let i of ast) {
	      if (typeof i === 'object') {
	        result += `(${brackets.stringify(i)})`;
	        continue
	      }

	      result += i;
	    }
	    return result
	  }
	};

	brackets_1 = brackets;
	return brackets_1;
}

var supports;
var hasRequiredSupports;

function requireSupports () {
	if (hasRequiredSupports) return supports;
	hasRequiredSupports = 1;
	let featureQueries = requireCssFeaturequeries();
	let feature = requireFeature();
	let { parse } = requirePostcss();

	let brackets = requireBrackets();
	let Browsers = requireBrowsers();
	let utils = requireUtils();
	let Value = requireValue();

	let data = feature(featureQueries);

	let supported = [];
	for (let browser in data.stats) {
	  let versions = data.stats[browser];
	  for (let version in versions) {
	    let support = versions[version];
	    if (/y/.test(support)) {
	      supported.push(browser + ' ' + version);
	    }
	  }
	}

	class Supports {
	  constructor(Prefixes, all) {
	    this.Prefixes = Prefixes;
	    this.all = all;
	  }

	  /**
	   * Add prefixes
	   */
	  add(nodes, all) {
	    return nodes.map(i => {
	      if (this.isProp(i)) {
	        let prefixed = this.prefixed(i[0]);
	        if (prefixed.length > 1) {
	          return this.convert(prefixed)
	        }

	        return i
	      }

	      if (typeof i === 'object') {
	        return this.add(i, all)
	      }

	      return i
	    })
	  }

	  /**
	   * Clean brackets with one child
	   */
	  cleanBrackets(nodes) {
	    return nodes.map(i => {
	      if (typeof i !== 'object') {
	        return i
	      }

	      if (i.length === 1 && typeof i[0] === 'object') {
	        return this.cleanBrackets(i[0])
	      }

	      return this.cleanBrackets(i)
	    })
	  }

	  /**
	   * Add " or " between properties and convert it to brackets format
	   */
	  convert(progress) {
	    let result = [''];
	    for (let i of progress) {
	      result.push([`${i.prop}: ${i.value}`]);
	      result.push(' or ');
	    }
	    result[result.length - 1] = '';
	    return result
	  }

	  /**
	   * Check global options
	   */
	  disabled(node) {
	    if (!this.all.options.grid) {
	      if (node.prop === 'display' && node.value.includes('grid')) {
	        return true
	      }
	      if (node.prop.includes('grid') || node.prop === 'justify-items') {
	        return true
	      }
	    }

	    if (this.all.options.flexbox === false) {
	      if (node.prop === 'display' && node.value.includes('flex')) {
	        return true
	      }
	      let other = ['order', 'justify-content', 'align-items', 'align-content'];
	      if (node.prop.includes('flex') || other.includes(node.prop)) {
	        return true
	      }
	    }

	    return false
	  }

	  /**
	   * Return true if prefixed property has no unprefixed
	   */
	  isHack(all, unprefixed) {
	    let check = new RegExp(`(\\(|\\s)${utils.escapeRegexp(unprefixed)}:`);
	    return !check.test(all)
	  }

	  /**
	   * Return true if brackets node is "not" word
	   */
	  isNot(node) {
	    return typeof node === 'string' && /not\s*/i.test(node)
	  }

	  /**
	   * Return true if brackets node is "or" word
	   */
	  isOr(node) {
	    return typeof node === 'string' && /\s*or\s*/i.test(node)
	  }

	  /**
	   * Return true if brackets node is (prop: value)
	   */
	  isProp(node) {
	    return (
	      typeof node === 'object' &&
	      node.length === 1 &&
	      typeof node[0] === 'string'
	    )
	  }

	  /**
	   * Compress value functions into a string nodes
	   */
	  normalize(nodes) {
	    if (typeof nodes !== 'object') {
	      return nodes
	    }

	    nodes = nodes.filter(i => i !== '');

	    if (typeof nodes[0] === 'string') {
	      let firstNode = nodes[0].trim();

	      if (
	        firstNode.includes(':') ||
	        firstNode === 'selector' ||
	        firstNode === 'not selector'
	      ) {
	        return [brackets.stringify(nodes)]
	      }
	    }
	    return nodes.map(i => this.normalize(i))
	  }

	  /**
	   * Parse string into declaration property and value
	   */
	  parse(str) {
	    let parts = str.split(':');
	    let prop = parts[0];
	    let value = parts[1];
	    if (!value) value = '';
	    return [prop.trim(), value.trim()]
	  }

	  /**
	   * Return array of Declaration with all necessary prefixes
	   */
	  prefixed(str) {
	    let rule = this.virtual(str);
	    if (this.disabled(rule.first)) {
	      return rule.nodes
	    }

	    let result = { warn: () => null };

	    let prefixer = this.prefixer().add[rule.first.prop];
	    prefixer && prefixer.process && prefixer.process(rule.first, result);

	    for (let decl of rule.nodes) {
	      for (let value of this.prefixer().values('add', rule.first.prop)) {
	        value.process(decl);
	      }
	      Value.save(this.all, decl);
	    }

	    return rule.nodes
	  }

	  /**
	   * Return prefixer only with @supports supported browsers
	   */
	  prefixer() {
	    if (this.prefixerCache) {
	      return this.prefixerCache
	    }

	    let filtered = this.all.browsers.selected.filter(i => {
	      return supported.includes(i)
	    });

	    let browsers = new Browsers(
	      this.all.browsers.data,
	      filtered,
	      this.all.options
	    );
	    this.prefixerCache = new this.Prefixes(
	      this.all.data,
	      browsers,
	      this.all.options
	    );
	    return this.prefixerCache
	  }

	  /**
	   * Add prefixed declaration
	   */
	  process(rule) {
	    let ast = brackets.parse(rule.params);
	    ast = this.normalize(ast);
	    ast = this.remove(ast, rule.params);
	    ast = this.add(ast, rule.params);
	    ast = this.cleanBrackets(ast);
	    rule.params = brackets.stringify(ast);
	  }

	  /**
	   * Remove all unnecessary prefixes
	   */
	  remove(nodes, all) {
	    let i = 0;
	    while (i < nodes.length) {
	      if (
	        !this.isNot(nodes[i - 1]) &&
	        this.isProp(nodes[i]) &&
	        this.isOr(nodes[i + 1])
	      ) {
	        if (this.toRemove(nodes[i][0], all)) {
	          nodes.splice(i, 2);
	          continue
	        }

	        i += 2;
	        continue
	      }

	      if (typeof nodes[i] === 'object') {
	        nodes[i] = this.remove(nodes[i], all);
	      }

	      i += 1;
	    }
	    return nodes
	  }

	  /**
	   * Return true if we need to remove node
	   */
	  toRemove(str, all) {
	    let [prop, value] = this.parse(str);
	    let unprefixed = this.all.unprefixed(prop);

	    let cleaner = this.all.cleaner();

	    if (
	      cleaner.remove[prop] &&
	      cleaner.remove[prop].remove &&
	      !this.isHack(all, unprefixed)
	    ) {
	      return true
	    }

	    for (let checker of cleaner.values('remove', unprefixed)) {
	      if (checker.check(value)) {
	        return true
	      }
	    }

	    return false
	  }

	  /**
	   * Create virtual rule to process it by prefixer
	   */
	  virtual(str) {
	    let [prop, value] = this.parse(str);
	    let rule = parse('a{}').first;
	    rule.append({ prop, raws: { before: '' }, value });
	    return rule
	  }
	}

	supports = Supports;
	return supports;
}

var transition;
var hasRequiredTransition;

function requireTransition () {
	if (hasRequiredTransition) return transition;
	hasRequiredTransition = 1;
	let { list } = requirePostcss();
	let parser = requireLib();

	let Browsers = requireBrowsers();
	let vendor = requireVendor();

	class Transition {
	  constructor(prefixes) {
	    this.props = ['transition', 'transition-property'];
	    this.prefixes = prefixes;
	  }

	  /**
	   * Process transition and add prefixes for all necessary properties
	   */
	  add(decl, result) {
	    let prefix, prop;
	    let add = this.prefixes.add[decl.prop];
	    let vendorPrefixes = this.ruleVendorPrefixes(decl);
	    let declPrefixes = vendorPrefixes || (add && add.prefixes) || [];

	    let params = this.parse(decl.value);
	    let names = params.map(i => this.findProp(i));
	    let added = [];

	    if (names.some(i => i[0] === '-')) {
	      return
	    }

	    for (let param of params) {
	      prop = this.findProp(param);
	      if (prop[0] === '-') continue

	      let prefixer = this.prefixes.add[prop];
	      if (!prefixer || !prefixer.prefixes) continue

	      for (prefix of prefixer.prefixes) {
	        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {
	          continue
	        }

	        let prefixed = this.prefixes.prefixed(prop, prefix);
	        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {
	          if (!this.disabled(prop, prefix)) {
	            added.push(this.clone(prop, prefixed, param));
	          }
	        }
	      }
	    }

	    params = params.concat(added);
	    let value = this.stringify(params);

	    let webkitClean = this.stringify(
	      this.cleanFromUnprefixed(params, '-webkit-')
	    );
	    if (declPrefixes.includes('-webkit-')) {
	      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean);
	    }
	    this.cloneBefore(decl, decl.prop, webkitClean);
	    if (declPrefixes.includes('-o-')) {
	      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'));
	      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean);
	    }

	    for (prefix of declPrefixes) {
	      if (prefix !== '-webkit-' && prefix !== '-o-') {
	        let prefixValue = this.stringify(
	          this.cleanOtherPrefixes(params, prefix)
	        );
	        this.cloneBefore(decl, prefix + decl.prop, prefixValue);
	      }
	    }

	    if (value !== decl.value && !this.already(decl, decl.prop, value)) {
	      this.checkForWarning(result, decl);
	      decl.cloneBefore();
	      decl.value = value;
	    }
	  }

	  /**
	   * Does we already have this declaration
	   */
	  already(decl, prop, value) {
	    return decl.parent.some(i => i.prop === prop && i.value === value)
	  }

	  /**
	   * Show transition-property warning
	   */
	  checkForWarning(result, decl) {
	    if (decl.prop !== 'transition-property') {
	      return
	    }

	    let isPrefixed = false;
	    let hasAssociatedProp = false;

	    decl.parent.each(i => {
	      if (i.type !== 'decl') {
	        return undefined
	      }
	      if (i.prop.indexOf('transition-') !== 0) {
	        return undefined
	      }
	      let values = list.comma(i.value);
	      // check if current Rule's transition-property comma separated value list needs prefixes
	      if (i.prop === 'transition-property') {
	        values.forEach(value => {
	          let lookup = this.prefixes.add[value];
	          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {
	            isPrefixed = true;
	          }
	        });
	        return undefined
	      }
	      // check if another transition-* prop in current Rule has comma separated value list
	      hasAssociatedProp = hasAssociatedProp || values.length > 1;
	      return false
	    });

	    if (isPrefixed && hasAssociatedProp) {
	      decl.warn(
	        result,
	        'Replace transition-property to transition, ' +
	          'because Autoprefixer could not support ' +
	          'any cases of transition-property ' +
	          'and other transition-*'
	      );
	    }
	  }

	  /**
	   * Remove all non-webkit prefixes and unprefixed params if we have prefixed
	   */
	  cleanFromUnprefixed(params, prefix) {
	    let remove = params
	      .map(i => this.findProp(i))
	      .filter(i => i.slice(0, prefix.length) === prefix)
	      .map(i => this.prefixes.unprefixed(i));

	    let result = [];
	    for (let param of params) {
	      let prop = this.findProp(param);
	      let p = vendor.prefix(prop);
	      if (!remove.includes(prop) && (p === prefix || p === '')) {
	        result.push(param);
	      }
	    }
	    return result
	  }

	  cleanOtherPrefixes(params, prefix) {
	    return params.filter(param => {
	      let current = vendor.prefix(this.findProp(param));
	      return current === '' || current === prefix
	    })
	  }

	  /**
	   * Return new param array with different name
	   */
	  clone(origin, name, param) {
	    let result = [];
	    let changed = false;
	    for (let i of param) {
	      if (!changed && i.type === 'word' && i.value === origin) {
	        result.push({ type: 'word', value: name });
	        changed = true;
	      } else {
	        result.push(i);
	      }
	    }
	    return result
	  }

	  /**
	   * Add declaration if it is not exist
	   */
	  cloneBefore(decl, prop, value) {
	    if (!this.already(decl, prop, value)) {
	      decl.cloneBefore({ prop, value });
	    }
	  }

	  /**
	   * Check property for disabled by option
	   */
	  disabled(prop, prefix) {
	    let other = ['order', 'justify-content', 'align-self', 'align-content'];
	    if (prop.includes('flex') || other.includes(prop)) {
	      if (this.prefixes.options.flexbox === false) {
	        return true
	      }

	      if (this.prefixes.options.flexbox === 'no-2009') {
	        return prefix.includes('2009')
	      }
	    }
	    return undefined
	  }

	  /**
	   * Find or create separator
	   */
	  div(params) {
	    for (let param of params) {
	      for (let node of param) {
	        if (node.type === 'div' && node.value === ',') {
	          return node
	        }
	      }
	    }
	    return { after: ' ', type: 'div', value: ',' }
	  }

	  /**
	   * Find property name
	   */
	  findProp(param) {
	    let prop = param[0].value;
	    if (/^\d/.test(prop)) {
	      for (let [i, token] of param.entries()) {
	        if (i !== 0 && token.type === 'word') {
	          return token.value
	        }
	      }
	    }
	    return prop
	  }

	  /**
	   * Parse properties list to array
	   */
	  parse(value) {
	    let ast = parser(value);
	    let result = [];
	    let param = [];
	    for (let node of ast.nodes) {
	      param.push(node);
	      if (node.type === 'div' && node.value === ',') {
	        result.push(param);
	        param = [];
	      }
	    }
	    result.push(param);
	    return result.filter(i => i.length > 0)
	  }

	  /**
	   * Process transition and remove all unnecessary properties
	   */
	  remove(decl) {
	    let params = this.parse(decl.value);
	    params = params.filter(i => {
	      let prop = this.prefixes.remove[this.findProp(i)];
	      return !prop || !prop.remove
	    });
	    let value = this.stringify(params);

	    if (decl.value === value) {
	      return
	    }

	    if (params.length === 0) {
	      decl.remove();
	      return
	    }

	    let double = decl.parent.some(i => {
	      return i.prop === decl.prop && i.value === value
	    });
	    let smaller = decl.parent.some(i => {
	      return i !== decl && i.prop === decl.prop && i.value.length > value.length
	    });

	    if (double || smaller) {
	      decl.remove();
	      return
	    }

	    decl.value = value;
	  }

	  /**
	   * Check if transition prop is inside vendor specific rule
	   */
	  ruleVendorPrefixes(decl) {
	    let { parent } = decl;

	    if (parent.type !== 'rule') {
	      return false
	    } else if (!parent.selector.includes(':-')) {
	      return false
	    }

	    let selectors = Browsers.prefixes().filter(s =>
	      parent.selector.includes(':' + s)
	    );

	    return selectors.length > 0 ? selectors : false
	  }

	  /**
	   * Return properties string from array
	   */
	  stringify(params) {
	    if (params.length === 0) {
	      return ''
	    }
	    let nodes = [];
	    for (let param of params) {
	      if (param[param.length - 1].type !== 'div') {
	        param.push(this.div(params));
	      }
	      nodes = nodes.concat(param);
	    }
	    if (nodes[0].type === 'div') {
	      nodes = nodes.slice(1);
	    }
	    if (nodes[nodes.length - 1].type === 'div') {
	      nodes = nodes.slice(0, -2 + 1);
	    }
	    return parser.stringify({ nodes })
	  }
	}

	transition = Transition;
	return transition;
}

var prefixes;
var hasRequiredPrefixes;

function requirePrefixes () {
	if (hasRequiredPrefixes) return prefixes;
	hasRequiredPrefixes = 1;
	let AtRule = requireAtRule();
	let Browsers = requireBrowsers();
	let Declaration = requireDeclaration();
	let hackAlignContent = requireAlignContent();
	let hackAlignItems = requireAlignItems();
	let hackAlignSelf = requireAlignSelf();
	let hackAnimation = requireAnimation();
	let hackAppearance = requireAppearance();
	let hackAutofill = requireAutofill();
	let hackBackdropFilter = requireBackdropFilter();
	let hackBackgroundClip = requireBackgroundClip();
	let hackBackgroundSize = requireBackgroundSize();
	let hackBlockLogical = requireBlockLogical();
	let hackBorderImage = requireBorderImage();
	let hackBorderRadius = requireBorderRadius();
	let hackBreakProps = requireBreakProps();
	let hackCrossFade = requireCrossFade();
	let hackDisplayFlex = requireDisplayFlex();
	let hackDisplayGrid = requireDisplayGrid();
	let hackFileSelectorButton = requireFileSelectorButton();
	let hackFilter = requireFilter();
	let hackFilterValue = requireFilterValue();
	let hackFlex = requireFlex();
	let hackFlexBasis = requireFlexBasis();
	let hackFlexDirection = requireFlexDirection();
	let hackFlexFlow = requireFlexFlow();
	let hackFlexGrow = requireFlexGrow();
	let hackFlexShrink = requireFlexShrink();
	let hackFlexWrap = requireFlexWrap();
	let hackFullscreen = requireFullscreen();
	let hackGradient = requireGradient();
	let hackGridArea = requireGridArea();
	let hackGridColumnAlign = requireGridColumnAlign();
	let hackGridEnd = requireGridEnd();
	let hackGridRowAlign = requireGridRowAlign();
	let hackGridRowColumn = requireGridRowColumn();
	let hackGridRowsColumns = requireGridRowsColumns();
	let hackGridStart = requireGridStart();
	let hackGridTemplate = requireGridTemplate();
	let hackGridTemplateAreas = requireGridTemplateAreas();
	let hackImageRendering = requireImageRendering();
	let hackImageSet = requireImageSet();
	let hackInlineLogical = requireInlineLogical();
	let hackIntrinsic = requireIntrinsic();
	let hackJustifyContent = requireJustifyContent();
	let hackMaskBorder = requireMaskBorder();
	let hackMaskComposite = requireMaskComposite();
	let hackOrder = requireOrder();
	let hackOverscrollBehavior = requireOverscrollBehavior();
	let hackPixelated = requirePixelated();
	let hackPlaceSelf = requirePlaceSelf();
	let hackPlaceholder = requirePlaceholder();
	let hackPlaceholderShown = requirePlaceholderShown();
	let hackPrintColorAdjust = requirePrintColorAdjust();
	let hackTextDecoration = requireTextDecoration();
	let hackTextDecorationSkipInk = requireTextDecorationSkipInk();
	let hackTextEmphasisPosition = requireTextEmphasisPosition();
	let hackTransformDecl = requireTransformDecl();
	let hackUserSelect = requireUserSelect();
	let hackWritingMode = requireWritingMode();
	let Processor = requireProcessor();
	let Resolution = requireResolution();
	let Selector = requireSelector();
	let Supports = requireSupports();
	let Transition = requireTransition();
	let utils = requireUtils();
	let Value = requireValue();
	let vendor = requireVendor();

	Selector.hack(hackAutofill);
	Selector.hack(hackFullscreen);
	Selector.hack(hackPlaceholder);
	Selector.hack(hackPlaceholderShown);
	Selector.hack(hackFileSelectorButton);
	Declaration.hack(hackFlex);
	Declaration.hack(hackOrder);
	Declaration.hack(hackFilter);
	Declaration.hack(hackGridEnd);
	Declaration.hack(hackAnimation);
	Declaration.hack(hackFlexFlow);
	Declaration.hack(hackFlexGrow);
	Declaration.hack(hackFlexWrap);
	Declaration.hack(hackGridArea);
	Declaration.hack(hackPlaceSelf);
	Declaration.hack(hackGridStart);
	Declaration.hack(hackAlignSelf);
	Declaration.hack(hackAppearance);
	Declaration.hack(hackFlexBasis);
	Declaration.hack(hackMaskBorder);
	Declaration.hack(hackMaskComposite);
	Declaration.hack(hackAlignItems);
	Declaration.hack(hackUserSelect);
	Declaration.hack(hackFlexShrink);
	Declaration.hack(hackBreakProps);
	Declaration.hack(hackWritingMode);
	Declaration.hack(hackBorderImage);
	Declaration.hack(hackAlignContent);
	Declaration.hack(hackBorderRadius);
	Declaration.hack(hackBlockLogical);
	Declaration.hack(hackGridTemplate);
	Declaration.hack(hackInlineLogical);
	Declaration.hack(hackGridRowAlign);
	Declaration.hack(hackTransformDecl);
	Declaration.hack(hackFlexDirection);
	Declaration.hack(hackImageRendering);
	Declaration.hack(hackBackdropFilter);
	Declaration.hack(hackBackgroundClip);
	Declaration.hack(hackTextDecoration);
	Declaration.hack(hackJustifyContent);
	Declaration.hack(hackBackgroundSize);
	Declaration.hack(hackGridRowColumn);
	Declaration.hack(hackGridRowsColumns);
	Declaration.hack(hackGridColumnAlign);
	Declaration.hack(hackOverscrollBehavior);
	Declaration.hack(hackGridTemplateAreas);
	Declaration.hack(hackPrintColorAdjust);
	Declaration.hack(hackTextEmphasisPosition);
	Declaration.hack(hackTextDecorationSkipInk);
	Value.hack(hackGradient);
	Value.hack(hackIntrinsic);
	Value.hack(hackPixelated);
	Value.hack(hackImageSet);
	Value.hack(hackCrossFade);
	Value.hack(hackDisplayFlex);
	Value.hack(hackDisplayGrid);
	Value.hack(hackFilterValue);

	let declsCache = new Map();

	class Prefixes {
	  constructor(data, browsers, options = {}) {
	    this.data = data;
	    this.browsers = browsers;
	    this.options = options
	    ;[this.add, this.remove] = this.preprocess(this.select(this.data));
	    this.transition = new Transition(this);
	    this.processor = new Processor(this);
	  }

	  /**
	   * Return clone instance to remove all prefixes
	   */
	  cleaner() {
	    if (this.cleanerCache) {
	      return this.cleanerCache
	    }

	    if (this.browsers.selected.length) {
	      let empty = new Browsers(this.browsers.data, []);
	      this.cleanerCache = new Prefixes(this.data, empty, this.options);
	    } else {
	      return this
	    }

	    return this.cleanerCache
	  }

	  /**
	   * Declaration loader with caching
	   */
	  decl(prop) {
	    if (!declsCache.has(prop)) {
	      declsCache.set(prop, Declaration.load(prop));
	    }

	    return declsCache.get(prop)
	  }

	  /**
	   * Group declaration by unprefixed property to check them
	   */
	  group(decl) {
	    let rule = decl.parent;
	    let index = rule.index(decl);
	    let { length } = rule.nodes;
	    let unprefixed = this.unprefixed(decl.prop);

	    let checker = (step, callback) => {
	      index += step;
	      while (index >= 0 && index < length) {
	        let other = rule.nodes[index];
	        if (other.type === 'decl') {
	          if (step === -1 && other.prop === unprefixed) {
	            if (!Browsers.withPrefix(other.value)) {
	              break
	            }
	          }

	          if (this.unprefixed(other.prop) !== unprefixed) {
	            break
	          } else if (callback(other) === true) {
	            return true
	          }

	          if (step === 1 && other.prop === unprefixed) {
	            if (!Browsers.withPrefix(other.value)) {
	              break
	            }
	          }
	        }

	        index += step;
	      }
	      return false
	    };

	    return {
	      down(callback) {
	        return checker(1, callback)
	      },
	      up(callback) {
	        return checker(-1, callback)
	      }
	    }
	  }

	  /**
	   * Normalize prefix for remover
	   */
	  normalize(prop) {
	    return this.decl(prop).normalize(prop)
	  }

	  /**
	   * Return prefixed version of property
	   */
	  prefixed(prop, prefix) {
	    prop = vendor.unprefixed(prop);
	    return this.decl(prop).prefixed(prop, prefix)
	  }

	  /**
	   * Cache prefixes data to fast CSS processing
	   */
	  preprocess(selected) {
	    let add = {
	      '@supports': new Supports(Prefixes, this),
	      'selectors': []
	    };
	    for (let name in selected.add) {
	      let prefixes = selected.add[name];
	      if (name === '@keyframes' || name === '@viewport') {
	        add[name] = new AtRule(name, prefixes, this);
	      } else if (name === '@resolution') {
	        add[name] = new Resolution(name, prefixes, this);
	      } else if (this.data[name].selector) {
	        add.selectors.push(Selector.load(name, prefixes, this));
	      } else {
	        let props = this.data[name].props;

	        if (props) {
	          let value = Value.load(name, prefixes, this);
	          for (let prop of props) {
	            if (!add[prop]) {
	              add[prop] = { values: [] };
	            }
	            add[prop].values.push(value);
	          }
	        } else {
	          let values = (add[name] && add[name].values) || [];
	          add[name] = Declaration.load(name, prefixes, this);
	          add[name].values = values;
	        }
	      }
	    }

	    let remove = { selectors: [] };
	    for (let name in selected.remove) {
	      let prefixes = selected.remove[name];
	      if (this.data[name].selector) {
	        let selector = Selector.load(name, prefixes);
	        for (let prefix of prefixes) {
	          remove.selectors.push(selector.old(prefix));
	        }
	      } else if (name === '@keyframes' || name === '@viewport') {
	        for (let prefix of prefixes) {
	          let prefixed = `@${prefix}${name.slice(1)}`;
	          remove[prefixed] = { remove: true };
	        }
	      } else if (name === '@resolution') {
	        remove[name] = new Resolution(name, prefixes, this);
	      } else {
	        let props = this.data[name].props;
	        if (props) {
	          let value = Value.load(name, [], this);
	          for (let prefix of prefixes) {
	            let old = value.old(prefix);
	            if (old) {
	              for (let prop of props) {
	                if (!remove[prop]) {
	                  remove[prop] = {};
	                }
	                if (!remove[prop].values) {
	                  remove[prop].values = [];
	                }
	                remove[prop].values.push(old);
	              }
	            }
	          }
	        } else {
	          for (let p of prefixes) {
	            let olds = this.decl(name).old(name, p);
	            if (name === 'align-self') {
	              let a = add[name] && add[name].prefixes;
	              if (a) {
	                if (p === '-webkit- 2009' && a.includes('-webkit-')) {
	                  continue
	                } else if (p === '-webkit-' && a.includes('-webkit- 2009')) {
	                  continue
	                }
	              }
	            }
	            for (let prefixed of olds) {
	              if (!remove[prefixed]) {
	                remove[prefixed] = {};
	              }
	              remove[prefixed].remove = true;
	            }
	          }
	        }
	      }
	    }

	    return [add, remove]
	  }

	  /**
	   * Select prefixes from data, which is necessary for selected browsers
	   */
	  select(list) {
	    let selected = { add: {}, remove: {} };

	    for (let name in list) {
	      let data = list[name];
	      let add = data.browsers.map(i => {
	        let params = i.split(' ');
	        return {
	          browser: `${params[0]} ${params[1]}`,
	          note: params[2]
	        }
	      });

	      let notes = add
	        .filter(i => i.note)
	        .map(i => `${this.browsers.prefix(i.browser)} ${i.note}`);
	      notes = utils.uniq(notes);

	      add = add
	        .filter(i => this.browsers.isSelected(i.browser))
	        .map(i => {
	          let prefix = this.browsers.prefix(i.browser);
	          if (i.note) {
	            return `${prefix} ${i.note}`
	          } else {
	            return prefix
	          }
	        });
	      add = this.sort(utils.uniq(add));

	      if (this.options.flexbox === 'no-2009') {
	        add = add.filter(i => !i.includes('2009'));
	      }

	      let all = data.browsers.map(i => this.browsers.prefix(i));
	      if (data.mistakes) {
	        all = all.concat(data.mistakes);
	      }
	      all = all.concat(notes);
	      all = utils.uniq(all);

	      if (add.length) {
	        selected.add[name] = add;
	        if (add.length < all.length) {
	          selected.remove[name] = all.filter(i => !add.includes(i));
	        }
	      } else {
	        selected.remove[name] = all;
	      }
	    }

	    return selected
	  }

	  /**
	   * Sort vendor prefixes
	   */
	  sort(prefixes) {
	    return prefixes.sort((a, b) => {
	      let aLength = utils.removeNote(a).length;
	      let bLength = utils.removeNote(b).length;

	      if (aLength === bLength) {
	        return b.length - a.length
	      } else {
	        return bLength - aLength
	      }
	    })
	  }

	  /**
	   * Return unprefixed version of property
	   */
	  unprefixed(prop) {
	    let value = this.normalize(vendor.unprefixed(prop));
	    if (value === 'flex-direction') {
	      value = 'flex-flow';
	    }
	    return value
	  }

	  /**
	   * Return values, which must be prefixed in selected property
	   */
	  values(type, prop) {
	    let data = this[type];

	    let global = data['*'] && data['*'].values;
	    let values = data[prop] && data[prop].values;

	    if (global && values) {
	      return utils.uniq(global.concat(values))
	    } else {
	      return global || values || []
	    }
	  }
	}

	prefixes = Prefixes;
	return prefixes;
}

var autoprefixer;
var hasRequiredAutoprefixer;

function requireAutoprefixer () {
	if (hasRequiredAutoprefixer) return autoprefixer;
	hasRequiredAutoprefixer = 1;
	let browserslist = requireBrowserslist();
	let { agents } = requireAgents();
	let pico = /*@__PURE__*/ requirePicocolors();

	let dataPrefixes = requirePrefixes$1();
	let Browsers = requireBrowsers();
	let getInfo = requireInfo();
	let Prefixes = requirePrefixes();

	let autoprefixerData = { browsers: agents, prefixes: dataPrefixes };

	const WARNING =
	  '\n' +
	  '  Replace Autoprefixer `browsers` option to Browserslist config.\n' +
	  '  Use `browserslist` key in `package.json` or `.browserslistrc` file.\n' +
	  '\n' +
	  '  Using `browsers` option can cause errors. Browserslist config can\n' +
	  '  be used for Babel, Autoprefixer, postcss-normalize and other tools.\n' +
	  '\n' +
	  '  If you really need to use option, rename it to `overrideBrowserslist`.\n' +
	  '\n' +
	  '  Learn more at:\n' +
	  '  https://github.com/browserslist/browserslist#readme\n' +
	  '  https://twitter.com/browserslist\n' +
	  '\n';

	function isPlainObject(obj) {
	  return Object.prototype.toString.apply(obj) === '[object Object]'
	}

	let cache = new Map();

	function timeCapsule(result, prefixes) {
	  if (prefixes.browsers.selected.length === 0) {
	    return
	  }
	  if (prefixes.add.selectors.length > 0) {
	    return
	  }
	  if (Object.keys(prefixes.add).length > 2) {
	    return
	  }
	  /* c8 ignore next 11 */
	  result.warn(
	    'Autoprefixer target browsers do not need any prefixes.' +
	      'You do not need Autoprefixer anymore.\n' +
	      'Check your Browserslist config to be sure that your targets ' +
	      'are set up correctly.\n' +
	      '\n' +
	      '  Learn more at:\n' +
	      '  https://github.com/postcss/autoprefixer#readme\n' +
	      '  https://github.com/browserslist/browserslist#readme\n' +
	      '\n'
	  );
	}

	autoprefixer = plugin;

	function plugin(...reqs) {
	  let options;
	  if (reqs.length === 1 && isPlainObject(reqs[0])) {
	    options = reqs[0];
	    reqs = undefined;
	  } else if (reqs.length === 0 || (reqs.length === 1 && !reqs[0])) {
	    reqs = undefined;
	  } else if (reqs.length <= 2 && (Array.isArray(reqs[0]) || !reqs[0])) {
	    options = reqs[1];
	    reqs = reqs[0];
	  } else if (typeof reqs[reqs.length - 1] === 'object') {
	    options = reqs.pop();
	  }

	  if (!options) {
	    options = {};
	  }

	  if (options.browser) {
	    throw new Error(
	      'Change `browser` option to `overrideBrowserslist` in Autoprefixer'
	    )
	  } else if (options.browserslist) {
	    throw new Error(
	      'Change `browserslist` option to `overrideBrowserslist` in Autoprefixer'
	    )
	  }

	  if (options.overrideBrowserslist) {
	    reqs = options.overrideBrowserslist;
	  } else if (options.browsers) {
	    if (typeof console !== 'undefined' && console.warn) {
	      console.warn(
	        pico.red(WARNING.replace(/`[^`]+`/g, i => pico.yellow(i.slice(1, -1))))
	      );
	    }
	    reqs = options.browsers;
	  }

	  let brwlstOpts = {
	    env: options.env,
	    ignoreUnknownVersions: options.ignoreUnknownVersions,
	    stats: options.stats
	  };

	  function loadPrefixes(opts) {
	    let d = autoprefixerData;
	    let browsers = new Browsers(d.browsers, reqs, opts, brwlstOpts);
	    let key = browsers.selected.join(', ') + JSON.stringify(options);

	    if (!cache.has(key)) {
	      cache.set(key, new Prefixes(d.prefixes, browsers, options));
	    }

	    return cache.get(key)
	  }

	  return {
	    browsers: reqs,

	    info(opts) {
	      opts = opts || {};
	      opts.from = opts.from || process.cwd();
	      return getInfo(loadPrefixes(opts))
	    },

	    options,

	    postcssPlugin: 'autoprefixer',
	    prepare(result) {
	      let prefixes = loadPrefixes({
	        env: options.env,
	        from: result.opts.from
	      });

	      return {
	        OnceExit(root) {
	          timeCapsule(result, prefixes);
	          if (options.remove !== false) {
	            prefixes.processor.remove(root, result);
	          }
	          if (options.add !== false) {
	            prefixes.processor.add(root, result);
	          }
	        }
	      }
	    }
	  }
	}

	plugin.postcss = true;

	/**
	 * Autoprefixer data
	 */
	plugin.data = autoprefixerData;

	/**
	 * Autoprefixer default browsers
	 */
	plugin.defaults = browserslist.defaults;

	/**
	 * Inspect with default Autoprefixer
	 */
	plugin.info = () => plugin().info();
	return autoprefixer;
}

var autoprefixerExports = requireAutoprefixer();
const autoprefixerPlugin = /*@__PURE__*/getDefaultExportFromCjs$1(autoprefixerExports);

async function getPostCssConfig(root, postcssInlineOptions) {
  let postcssConfigResult;
  if (!(typeof postcssInlineOptions === "object" && postcssInlineOptions !== null)) {
    let { default: postcssrc } = await import('./index_gLSLwfaX.mjs').then(n => n.i);
    const searchPath = typeof postcssInlineOptions === "string" ? postcssInlineOptions : root;
    try {
      postcssConfigResult = await postcssrc({}, searchPath);
    } catch {
      postcssConfigResult = null;
    }
  }
  return postcssConfigResult;
}
async function getViteConfiguration(tailwindConfigPath, nesting, root, postcssInlineOptions) {
  const postcssConfigResult = await getPostCssConfig(root, postcssInlineOptions);
  const postcssOptions = postcssConfigResult?.options ?? {};
  const postcssPlugins = postcssConfigResult?.plugins?.slice() ?? [];
  postcssPlugins.push(tailwindPlugin(tailwindConfigPath));
  postcssPlugins.push(autoprefixerPlugin());
  return {
    css: {
      postcss: {
        ...postcssOptions,
        plugins: postcssPlugins
      }
    }
  };
}
function tailwindIntegration(options) {
  const customConfigPath = options?.configFile;
  const nesting = false;
  return {
    name: "@astrojs/tailwind",
    hooks: {
      "astro:config:setup": async ({ config, updateConfig, injectScript }) => {
        updateConfig({
          vite: await getViteConfiguration(
            customConfigPath,
            nesting,
            fileURLToPath$1(config.root),
            config.vite.css?.postcss
          )
        });
        {
          injectScript("page-ssr", `import '@astrojs/tailwind/base.css';`);
        }
      }
    }
  };
}

const __dirname$1 = require$$0$2$1.dirname(fileURLToPath$2(import.meta.url));
const config = defineConfig({
  base: "/",
  integrations: [svelteIntegration(), tailwindIntegration()],
  vite: {
    // 1. 预构建阶段排除fsevents
    optimizeDeps: {
      exclude: ["fsevents"]
    },
    // 2. 别名替换为空白模块
    resolve: {
      alias: {
        "fsevents": require$$0$2$1.resolve(__dirname$1, "empty-module.js")
      }
    },
    // 3. Rollup打包时标记为外部依赖
    build: {
      rollupOptions: {
        external: ["fsevents"]
      }
    }
  }
});
const siteConfig = {
  title: "LeeSin",
  subtitle: "光荣进化",
  lang: "zh_CN",
  themeColor: {
    hue: 250},
  banner: {
    enable: true,
    src: "assets/images/demo-banner.png",
    position: "center",
    credit: {
      enable: false}
  },
  toc: {
    depth: 2
  },
  favicon: []
};
const navBarConfig = {
  links: [
    LinkPreset.Home,
    LinkPreset.Archive,
    {
      name: "GitHub",
      url: "https://github.com/LeeSin77",
      external: true
    }
  ]
};
const profileConfig = {
  avatar: "assets/images/leesin.jpeg",
  name: "Lee Sin",
  bio: "加入光荣的进化吧",
  links: [
    {
      name: "Twitter",
      icon: "fa6-brands:twitter",
      url: "https://twitter.com"
    },
    {
      name: "Steam",
      icon: "fa6-brands:steam",
      url: "https://store.steampowered.com"
    },
    {
      name: "GitHub",
      icon: "fa6-brands:github",
      url: "https://github.com/LeeSin77"
      // 补全空URL，避免点击跳转异常
    }
  ]
};
const licenseConfig = {
  name: "CC BY-NC-SA 4.0",
  url: "https://creativecommons.org/licenses/by-nc-sa/4.0/"
};

const config$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: config,
  licenseConfig,
  navBarConfig,
  profileConfig,
  siteConfig
}, Symbol.toStringTag, { value: 'Module' }));

const en = {
  [I18nKey.home]: "Home",
  [I18nKey.about]: "About",
  [I18nKey.archive]: "Archive",
  [I18nKey.search]: "Search",
  [I18nKey.tags]: "Tags",
  [I18nKey.categories]: "Categories",
  [I18nKey.recentPosts]: "Recent Posts",
  [I18nKey.comments]: "Comments",
  [I18nKey.untitled]: "Untitled",
  [I18nKey.uncategorized]: "Uncategorized",
  [I18nKey.noTags]: "No Tags",
  [I18nKey.wordCount]: "word",
  [I18nKey.wordsCount]: "words",
  [I18nKey.minuteCount]: "minute",
  [I18nKey.minutesCount]: "minutes",
  [I18nKey.postCount]: "post",
  [I18nKey.postsCount]: "posts",
  [I18nKey.themeColor]: "Theme Color",
  [I18nKey.lightMode]: "Light",
  [I18nKey.darkMode]: "Dark",
  [I18nKey.systemMode]: "System",
  [I18nKey.more]: "More",
  [I18nKey.author]: "Author",
  [I18nKey.publishedAt]: "Published at",
  [I18nKey.license]: "License"
};

const en$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  en
}, Symbol.toStringTag, { value: 'Module' }));

const es = {
  [I18nKey.home]: "Inicio",
  [I18nKey.about]: "Sobre mí",
  [I18nKey.archive]: "Archivo",
  [I18nKey.search]: "Buscar",
  [I18nKey.tags]: "Etiquetas",
  [I18nKey.categories]: "Categorías",
  [I18nKey.recentPosts]: "Publicaciones recientes",
  [I18nKey.comments]: "Comentarios",
  [I18nKey.untitled]: "Sin título",
  [I18nKey.uncategorized]: "Sin categoría",
  [I18nKey.noTags]: "Sin etiquetas",
  [I18nKey.wordCount]: "palabra",
  [I18nKey.wordsCount]: "palabras",
  [I18nKey.minuteCount]: "minuto",
  [I18nKey.minutesCount]: "minutos",
  [I18nKey.postCount]: "publicación",
  [I18nKey.postsCount]: "publicaciones",
  [I18nKey.themeColor]: "Color del tema",
  [I18nKey.lightMode]: "Claro",
  [I18nKey.darkMode]: "Oscuro",
  [I18nKey.systemMode]: "Sistema",
  [I18nKey.more]: "Más",
  [I18nKey.author]: "Autor",
  [I18nKey.publishedAt]: "Publicado el",
  [I18nKey.license]: "Licencia"
};

const es$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  es
}, Symbol.toStringTag, { value: 'Module' }));

const id = {
  [I18nKey.home]: "Beranda",
  [I18nKey.about]: "Tentang",
  [I18nKey.archive]: "Arsip",
  [I18nKey.search]: "Cari",
  [I18nKey.tags]: "Tag",
  [I18nKey.categories]: "Kategori",
  [I18nKey.recentPosts]: "Postingan Terbaru",
  [I18nKey.comments]: "Komentar",
  [I18nKey.untitled]: "Tanpa Judul",
  [I18nKey.uncategorized]: "Tanpa Kategori",
  [I18nKey.noTags]: "Tanpa Tag",
  [I18nKey.wordCount]: "kata",
  [I18nKey.wordsCount]: "kata",
  [I18nKey.minuteCount]: "menit",
  [I18nKey.minutesCount]: "menit",
  [I18nKey.postCount]: "postingan",
  [I18nKey.postsCount]: "postingan",
  [I18nKey.themeColor]: "Warna Tema",
  [I18nKey.lightMode]: "Terang",
  [I18nKey.darkMode]: "Gelap",
  [I18nKey.systemMode]: "Sistem",
  [I18nKey.more]: "Lainnya",
  [I18nKey.author]: "Penulis",
  [I18nKey.publishedAt]: "Diterbitkan pada",
  [I18nKey.license]: "Lisensi"
};

const id$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  id
}, Symbol.toStringTag, { value: 'Module' }));

const ja = {
  [I18nKey.home]: "Home",
  [I18nKey.about]: "About",
  [I18nKey.archive]: "Archive",
  [I18nKey.search]: "検索",
  [I18nKey.tags]: "タグ",
  [I18nKey.categories]: "カテゴリ",
  [I18nKey.recentPosts]: "最近の投稿",
  [I18nKey.comments]: "コメント",
  [I18nKey.untitled]: "タイトルなし",
  [I18nKey.uncategorized]: "カテゴリなし",
  [I18nKey.noTags]: "タグなし",
  [I18nKey.wordCount]: "文字",
  [I18nKey.wordsCount]: "文字",
  [I18nKey.minuteCount]: "分",
  [I18nKey.minutesCount]: "分",
  [I18nKey.postCount]: "件の投稿",
  [I18nKey.postsCount]: "件の投稿",
  [I18nKey.themeColor]: "テーマカラー",
  [I18nKey.lightMode]: "ライト",
  [I18nKey.darkMode]: "ダーク",
  [I18nKey.systemMode]: "システム",
  [I18nKey.more]: "もっと",
  [I18nKey.author]: "作者",
  [I18nKey.publishedAt]: "公開日",
  [I18nKey.license]: "ライセンス"
};

const ja$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  ja
}, Symbol.toStringTag, { value: 'Module' }));

const ko = {
  [I18nKey.home]: "홈",
  [I18nKey.about]: "소개",
  [I18nKey.archive]: "아카이브",
  [I18nKey.search]: "검색",
  [I18nKey.tags]: "태그",
  [I18nKey.categories]: "카테고리",
  [I18nKey.recentPosts]: "최근 게시물",
  [I18nKey.comments]: "댓글",
  [I18nKey.untitled]: "제목 없음",
  [I18nKey.uncategorized]: "분류되지 않음",
  [I18nKey.noTags]: "태그 없음",
  [I18nKey.wordCount]: "단어",
  [I18nKey.wordsCount]: "단어",
  [I18nKey.minuteCount]: "분",
  [I18nKey.minutesCount]: "분",
  [I18nKey.postCount]: "게시물",
  [I18nKey.postsCount]: "게시물",
  [I18nKey.themeColor]: "테마 색상",
  [I18nKey.lightMode]: "밝은 모드",
  [I18nKey.darkMode]: "어두운 모드",
  [I18nKey.systemMode]: "시스템 모드",
  [I18nKey.more]: "더 보기",
  [I18nKey.author]: "저자",
  [I18nKey.publishedAt]: "게시일",
  [I18nKey.license]: "라이선스"
};

const ko$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  ko
}, Symbol.toStringTag, { value: 'Module' }));

const th = {
  [I18nKey.home]: "หน้าแรก",
  [I18nKey.about]: "เกี่ยวกับ",
  [I18nKey.archive]: "คลัง",
  [I18nKey.search]: "ค้นหา",
  [I18nKey.tags]: "ป้ายกำกับ",
  [I18nKey.categories]: "หมวดหมู่",
  [I18nKey.recentPosts]: "โพสต์ล่าสุด",
  [I18nKey.comments]: "ความคิดเห็น",
  [I18nKey.untitled]: "ไม่ได้ตั้งชื่อ",
  [I18nKey.uncategorized]: "ไม่ได้จัดหมวดหมู่",
  [I18nKey.noTags]: "ไม่มีป้ายกำกับ",
  [I18nKey.wordCount]: "คำ",
  [I18nKey.wordsCount]: "คำ",
  [I18nKey.minuteCount]: "นาที",
  [I18nKey.minutesCount]: "นาที",
  [I18nKey.postCount]: "โพสต์",
  [I18nKey.postsCount]: "โพสต์",
  [I18nKey.themeColor]: "สีของธีม",
  [I18nKey.lightMode]: "สว่าง",
  [I18nKey.darkMode]: "มืด",
  [I18nKey.systemMode]: "ตามระบบ",
  [I18nKey.more]: "ดูเพิ่ม",
  [I18nKey.author]: "ผู้เขียน",
  [I18nKey.publishedAt]: "เผยแพร่เมื่อ",
  [I18nKey.license]: "สัญญาอนุญาต"
};

const th$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  th
}, Symbol.toStringTag, { value: 'Module' }));

const tr = {
  [I18nKey.home]: "Anasayfa",
  [I18nKey.about]: "Hakkında",
  [I18nKey.archive]: "Arşiv",
  [I18nKey.search]: "Ara",
  [I18nKey.tags]: "Taglar",
  [I18nKey.categories]: "Katagoriler",
  [I18nKey.recentPosts]: "Son Paylaşımlar",
  [I18nKey.comments]: "Yorumlar",
  [I18nKey.untitled]: "Başlıksız",
  [I18nKey.uncategorized]: "Katagorisiz",
  [I18nKey.noTags]: "Tag Bulunamadı",
  [I18nKey.wordCount]: "kelime",
  [I18nKey.wordsCount]: "kelime",
  [I18nKey.minuteCount]: "dakika",
  [I18nKey.minutesCount]: "dakika",
  [I18nKey.postCount]: "gönderi",
  [I18nKey.postsCount]: "gönderiler",
  [I18nKey.themeColor]: "Tema Rengi",
  [I18nKey.lightMode]: "Aydınlık",
  [I18nKey.darkMode]: "Koyu",
  [I18nKey.systemMode]: "Sistem",
  [I18nKey.more]: "Daha Fazla",
  [I18nKey.author]: "Yazar",
  [I18nKey.publishedAt]: "Yayınlanma:",
  [I18nKey.license]: "Lisans"
};

const tr$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  tr
}, Symbol.toStringTag, { value: 'Module' }));

const vi = {
  [I18nKey.home]: "Trang chủ",
  [I18nKey.about]: "Giới thiệu",
  [I18nKey.archive]: "Kho bài",
  [I18nKey.search]: "Tìm kiếm",
  [I18nKey.tags]: "Thẻ",
  [I18nKey.categories]: "Danh mục",
  [I18nKey.recentPosts]: "Bài viết mới nhất",
  [I18nKey.comments]: "Bình luận",
  [I18nKey.untitled]: "Không tiêu đề",
  [I18nKey.uncategorized]: "Chưa phân loại",
  [I18nKey.noTags]: "Chưa có thẻ",
  [I18nKey.wordCount]: "từ",
  [I18nKey.wordsCount]: "từ",
  [I18nKey.minuteCount]: "phút đọc",
  [I18nKey.minutesCount]: "phút đọc",
  [I18nKey.postCount]: "bài viết",
  [I18nKey.postsCount]: "bài viết",
  [I18nKey.themeColor]: "Màu giao diện",
  [I18nKey.lightMode]: "Sáng",
  [I18nKey.darkMode]: "Tối",
  [I18nKey.systemMode]: "Hệ thống",
  [I18nKey.more]: "Thêm",
  [I18nKey.author]: "Tác giả",
  [I18nKey.publishedAt]: "Đăng vào lúc",
  [I18nKey.license]: "Giấy phép bản quyền"
};

const vi$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  vi
}, Symbol.toStringTag, { value: 'Module' }));

const zh_CN = {
  [I18nKey.home]: "主页",
  [I18nKey.about]: "关于",
  [I18nKey.archive]: "归档",
  [I18nKey.search]: "搜索",
  [I18nKey.tags]: "标签",
  [I18nKey.categories]: "分类",
  [I18nKey.recentPosts]: "最新文章",
  [I18nKey.comments]: "评论",
  [I18nKey.untitled]: "无标题",
  [I18nKey.uncategorized]: "未分类",
  [I18nKey.noTags]: "无标签",
  [I18nKey.wordCount]: "字",
  [I18nKey.wordsCount]: "字",
  [I18nKey.minuteCount]: "分钟",
  [I18nKey.minutesCount]: "分钟",
  [I18nKey.postCount]: "篇文章",
  [I18nKey.postsCount]: "篇文章",
  [I18nKey.themeColor]: "主题色",
  [I18nKey.lightMode]: "亮色",
  [I18nKey.darkMode]: "暗色",
  [I18nKey.systemMode]: "跟随系统",
  [I18nKey.more]: "更多",
  [I18nKey.author]: "作者",
  [I18nKey.publishedAt]: "发布于",
  [I18nKey.license]: "许可协议"
};

const zh_CN$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  zh_CN
}, Symbol.toStringTag, { value: 'Module' }));

const zh_TW = {
  [I18nKey.home]: "首頁",
  [I18nKey.about]: "關於",
  [I18nKey.archive]: "彙整",
  [I18nKey.search]: "搜尋",
  [I18nKey.tags]: "標籤",
  [I18nKey.categories]: "分類",
  [I18nKey.recentPosts]: "最新文章",
  [I18nKey.comments]: "評論",
  [I18nKey.untitled]: "無標題",
  [I18nKey.uncategorized]: "未分類",
  [I18nKey.noTags]: "無標籤",
  [I18nKey.wordCount]: "字",
  [I18nKey.wordsCount]: "字",
  [I18nKey.minuteCount]: "分鐘",
  [I18nKey.minutesCount]: "分鐘",
  [I18nKey.postCount]: "篇文章",
  [I18nKey.postsCount]: "篇文章",
  [I18nKey.themeColor]: "主題色",
  [I18nKey.lightMode]: "亮色",
  [I18nKey.darkMode]: "暗色",
  [I18nKey.systemMode]: "跟隨系統",
  [I18nKey.more]: "更多",
  [I18nKey.author]: "作者",
  [I18nKey.publishedAt]: "發佈於",
  [I18nKey.license]: "許可協議"
};

const zh_TW$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  zh_TW
}, Symbol.toStringTag, { value: 'Module' }));

const defaultTranslation = en;
const map = {
  es,
  en,
  en_us: en,
  en_gb: en,
  en_au: en,
  zh_cn: zh_CN,
  zh_tw: zh_TW,
  ja,
  ja_jp: ja,
  ko,
  ko_kr: ko,
  th,
  th_th: th,
  vi,
  vi_vn: vi,
  id,
  tr,
  tr_tr: tr
};
function getTranslation(lang) {
  return map[lang.toLowerCase()] || defaultTranslation;
}
function i18n(key) {
  const lang = siteConfig.lang;
  return getTranslation(lang)[key];
}

const translation = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  getTranslation,
  i18n
}, Symbol.toStringTag, { value: 'Module' }));

function pathsEqual(path1, path2) {
  const normalizedPath1 = path1.replace(/^\/|\/$/g, "").toLowerCase();
  const normalizedPath2 = path2.replace(/^\/|\/$/g, "").toLowerCase();
  return normalizedPath1 === normalizedPath2;
}
function joinUrl(...parts) {
  const joined = parts.join("/");
  return joined.replace(/\/+/g, "/");
}
function getPostUrlBySlug(slug) {
  return url(`/posts/${slug}/`);
}
function getTagUrl(tag) {
  if (!tag) return url("/archive/");
  return url(`/archive/?tag=${encodeURIComponent(tag.trim())}`);
}
function getCategoryUrl(category) {
  if (!category || category.trim() === "" || category.trim().toLowerCase() === i18n(I18nKey.uncategorized).toLowerCase())
    return url("/archive/?uncategorized=true");
  return url(`/archive/?category=${encodeURIComponent(category.trim())}`);
}
function getDir(path) {
  const lastSlashIndex = path.lastIndexOf("/");
  if (lastSlashIndex < 0) {
    return "/";
  }
  return path.substring(0, lastSlashIndex + 1);
}
function url(path) {
  return joinUrl("", "/", path);
}

const urlUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  getCategoryUrl,
  getDir,
  getPostUrlBySlug,
  getTagUrl,
  pathsEqual,
  url
}, Symbol.toStringTag, { value: 'Module' }));

async function getRawSortedPosts() {
  const allBlogPosts = await getCollection("posts", ({ data }) => {
    return data.draft !== true ;
  });
  const sorted = allBlogPosts.sort((a, b) => {
    const dateA = new Date(a.data.published);
    const dateB = new Date(b.data.published);
    return dateA > dateB ? -1 : 1;
  });
  return sorted;
}
async function getSortedPosts() {
  const sorted = await getRawSortedPosts();
  for (let i = 1; i < sorted.length; i++) {
    sorted[i].data.nextSlug = sorted[i - 1].slug;
    sorted[i].data.nextTitle = sorted[i - 1].data.title;
  }
  for (let i = 0; i < sorted.length - 1; i++) {
    sorted[i].data.prevSlug = sorted[i + 1].slug;
    sorted[i].data.prevTitle = sorted[i + 1].data.title;
  }
  return sorted;
}
async function getSortedPostsList() {
  const sortedFullPosts = await getRawSortedPosts();
  const sortedPostsList = sortedFullPosts.map((post) => ({
    slug: post.slug,
    data: post.data
  }));
  return sortedPostsList;
}
async function getTagList() {
  const allBlogPosts = await getCollection("posts", ({ data }) => {
    return data.draft !== true ;
  });
  const countMap = {};
  allBlogPosts.forEach((post) => {
    post.data.tags.forEach((tag) => {
      if (!countMap[tag]) countMap[tag] = 0;
      countMap[tag]++;
    });
  });
  const keys = Object.keys(countMap).sort((a, b) => {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  });
  return keys.map((key) => ({ name: key, count: countMap[key] }));
}
async function getCategoryList() {
  const allBlogPosts = await getCollection("posts", ({ data }) => {
    return data.draft !== true ;
  });
  const count = {};
  allBlogPosts.forEach((post) => {
    if (!post.data.category) {
      const ucKey = i18n(I18nKey.uncategorized);
      count[ucKey] = count[ucKey] ? count[ucKey] + 1 : 1;
      return;
    }
    const categoryName = typeof post.data.category === "string" ? post.data.category.trim() : String(post.data.category).trim();
    count[categoryName] = count[categoryName] ? count[categoryName] + 1 : 1;
  });
  const lst = Object.keys(count).sort((a, b) => {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  });
  const ret = [];
  for (const c of lst) {
    ret.push({
      name: c,
      count: count[c],
      url: getCategoryUrl(c)
    });
  }
  return ret;
}

const contentUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  getCategoryList,
  getSortedPosts,
  getSortedPostsList,
  getTagList
}, Symbol.toStringTag, { value: 'Module' }));

export { config$1 as A, en$1 as B, es$1 as C, DEFAULT_OUTPUT_FORMAT as D, id$1 as E, ja$1 as F, ko$1 as G, th$1 as H, I18nKey as I, tr$1 as J, vi$1 as K, LinkPreset as L, zh_CN$1 as M, zh_TW$1 as N, translation as O, urlUtils as P, contentUtils as Q, VALID_SUPPORTED_FORMATS as V, getSortedPostsList as a, getSortedPosts as b, getDir as c, getPostUrlBySlug as d, getCategoryUrl as e, getTagUrl as f, getEntry as g, defineCollection as h, i18n as i, types$2 as j, joinPaths as k, licenseConfig as l, isRemotePath as m, DEFAULT_HASH_PROPS as n, navBarConfig as o, profileConfig as p, getCategoryList as q, renderEntry as r, siteConfig as s, typeHandlers as t, url as u, getTagList as v, pathsEqual as w, commonjsRequire as x, i18nKey as y, config$3 as z };
